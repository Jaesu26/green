

 ###### 수정본(망함)
 
  #### 2이상 50사이의 서로 다른 자연수가 두개 있다.
  #### A는 서로 다른 두 자연수의 곱을 알고 B는 서로 다른 두 자연수의 합을 안다.
  #### C가 A에게 두 자연수를 알겠냐고 물었다.
  #### A : 모르겠습니다.
  #### B : 전 당신이 모를걸 알고 있었어요.
  #### A : 아! 알겠습니다.
  #### B : 저도 알겠습니다!
  #### 이때 두 자연수는 무엇인가?



secret_number <- function(x, y){
  
  ## mul = multiple
  ## mul1은 서로 다른 두 자연수 곱의 조합
  
  
  
  mul1 = c()
  
  n = 1
  
  for(i in x:y){
    for(j in x:y){
      if(i != j){
        mul1[n] = i * j
        
        n = n + 1
      }
    }
  }
  
  ## mul1에서 두 번만 등장한 수를 제거한다.
  ## 왜냐하면 A가 바로 답을 맞출 수 있기 때문임.
  ## 만약 6이라면 2*3=3*2 임으로 6이 2번 등장하는데
  ## A가 받은 수 가 6이라면 A는 바로 답을 맞춤
  
  ## mul2은 두 번만 등장한 수의 집합
  
  mul2 = c()
  n1 = 1
  
  for(i in 1:length(mul1)){
    count = 0
    
    for(j in 1:length(mul1)){
      
      if(mul1[i] == mul1[j]){
        count = count + 1
      }
    }
    
    if(count == 2){
      mul2[n1] = mul1[i]
      n1 = n1 + 1
    }
  }
  
  mul2 = unique(mul2)
  
  ## mul3는 합을 a+b꼴로 나타냈을 때 a*b값이 유일한 경우의 조합이다.
  
  mul3 = c()
    n2 = 1
    
  for(i in x:y){
    for(j in x:y){
      
      if(i != j){
        m = i * j
        
        if(length(intersect(m, mul2)) > 0){
          mul3[n2] = i + j
          n2 = n2 + 1
        }
      }
    }
  }
    
  
  ## mul은 6=2*3, 21=7*3 과 같이 A가 바로 답을 알 수 있는 수를 
  ## 제외한 두 자연수 곱의 조합
  
  mul = setdiff(mul1, mul2)
        
  
  mul = unique(mul)
  
  ## mul은 두 자연수 곱의 조합에서 두 소수 곱의 조합을 뺀 차집합이다.
  #### A : 모르겠습니다. clear
   

  #### B : 전 당신이 모를걸 알고 있었어요.
  ## B가 알고있는 내용은 두 자연수의 합
  ## 두 자연수의 합을 보고 A가 모를걸 알고 있었다.
  ## 즉 합을 두 자연수로 쪼갰을 때 소수+소수의 형태가 존재하지 않아야 한다.
  ## 만약 소수+소수라면 A는 답을 알 수 있으므로 B는 A가 모를걸 알고 있었다고 말을 못한다.
  ## 골드바흐 추측에 따라 짝수는 소수+소수 꼴로 나타나므로 제외
  ## 짝수인 소수는 2밖에 없다.
  ## 그러므로 어떤 합A - 2가 소수라면 A는 제외
  ## add는 서로 다른 두 자연수 합의 조합
  
  
  add = c()
  n = 1
  for(i in x:y){
    for(j in x:y){
      if(i != j){
        add[n] = i + j
        n = n + 1
      }
    }
  }
  
  add = unique(add)
  
  
  ## 짝수 = 소수 +소수 이므로 짝수 제거
  ## 6 = 3+3 이지만 중복해서 수를 사용할 수 없으므로
  ## 6 = 2+4이며 조합이 하나 뿐이므로 어자피 제거된다.
  
  add = add[add %% 2 == 1]
  add_2 = add - 2
  
  ## X - 2 가 소수이면 2가 소수이므로 X도 소수, 그러므로 X 제거
  
  prime1 = c()
  m = 1
  for(i in add_2){
    check = 0
      for(j in 1:i){
        if(i %% j == 0){
          check = check + 1
        }
      }
    if(check == 2){
      prime1[m] = i
      m = m + 1
    }
  }
  
  prime2 = prime1 + 2

  ## B1은 두 자연수의 합 중에서 두 소수의 합으로 이루어지지 않는 조합
  ## 만약 합이 83이라면 50+33을 포함하고 50*33은 유일한 값이므로
  ## A가 답을 바로 맞출 수 있다.
  ## 83도 B1에서 제외되야 하는데 이를 고려를 못했다.

  B1 = setdiff(add, prime2)
  
  B1 = setdiff(B1, mul3)

  #### B : 전 당신이 모를걸 알고 있었어요. clear
  #### A : 아! 알겠습니다.
  ## A는 X를 안다. 이때 X는 서로 다른 두 자연수의 곱이다.
  ## A는 X를 두 곱의 조합으로 나타낸다.
  ## ex) X가 18이라면 (2,9) 와 (3,6)
  ## A는 18이란 숫자를 알 때 B는 11 또는 9라는 사실을 알고 있다.
  ## B는 9 or 11 인데  B : 전 당신이 모를걸 알고 있었어요. 라고 말했다.
  ## 이는 B가 알고있는 숫자가
  ## 두 자연수의 합 중에서 두 소수의 합으로 이루어지지 않는 조합
  ## 임을 나타낸다. 그런데 9 = 2+7이므로 제외하면 11이 남는다.
  ## 그렇다면 A는 알겠다고 대답할 수 있다.
  ## 즉 X를 a*b 조합으로 나타낸 후 a+b로 가능한 조합을 찾는다.
  ## 이때 a+b의 조합에서 B : 전 당신이 모를걸 알고 있었어요. 라고 말했으므로
  ## a+b의 조합중에서 두 소수의 합으로 이루어지지 않은 쌍이 있다는 것이다.
  ## 만약 이러한 쌍이 단 하나뿐이라면 A는 알겠다고 대답할 수 있다.
  
  ## mul_comb은 mul에서 표현가능한 (mul, 상수a, 상수b, a+b)의 행렬
  
  mul_comb = data.frame("두 수의 곱" = 0, "상수a"=  0, "상수b" = 0, "두 수의 합" = 0)
  
  for (i in mul){
    for(j in x:y){
      for(k in x:y){
        if(j * k == i){
          q = j + k
          vec = c(i, j, k, q)
          
          mul_comb = rbind(mul_comb, vec)
          
        }
      }
    }
  }
  
  ## 첫 번째 행(0,0,0,0)은 필요없어서 없앰
  
  mul_comb = mul_comb[-1,]
  
  
  ## 같은 조합이 반복됨 ex) 8, 2, 4 & 8, 4,2
  ## 상수a > 상수b 인 경우만 추출
  
  ## pro = product
  
  pro1 = c()
  for(i in 1:nrow(mul_comb)){
    if(mul_comb[i,2] > mul_comb[i,3]){
      pro1 = rbind(pro1 , mul_comb[i,])
    }
  }
      
  ##  "B : 전 당신이 모를걸 알고 있었어요." 이 내용을 충족시키기 위해 두 수의 합이 
  ## 두 소수의 합으로 표현되는 수를 제외한다.
  ## pro2는 두 수의 합이 짝수인 행을 제거한다.
  
  pro2 = c()
  
  for (i in 1:nrow(pro1)){
    if(pro1[i,4] %% 2 != 0){
      pro2 = rbind(pro2, pro1[i,])
    }
  }

  ## 두 수의 합이 소수 + 소수인 경우를 B1을 이용해 제거한다
  ## pro3는 두 수의 합이 두 소수의 합으로 표현되는 수를 제거한 행렬이다.
  
  pro3 = c()
  
  for(i in 1:nrow(pro2)){
    for(j in B1){
      if(pro2[i,4] == j){
        pro3 = rbind(pro3, pro2[i,])
      }
    }
  }
  
  
  ## pro4는 두수의 곱을 X라 할 때 X=a*b에서
  ## a+b로 가능한 모든 조합을 찾고 그 중에서 두 수의합으로
  ## 불가능한 경우를 
  ## B : 전 당신이 모를걸 알고 있었어요. 라는 내용에 따라
  ## 다 제거하니 단 하나만 남은 X를 저장한다.
  
  pro4 = c()
  
  for(i in 1:nrow(pro3)){
    count = 0
    
    for(j in 1:nrow(pro3)){
      if(pro3[i,1] == pro3[j,1]){
        count = count + 1
      }
    }
    if(count == 1){
      pro4 = rbind(pro4, pro3[i,])
    }
  }
  
  
  #### A : 아! 알겠습니다. clear
  
  #### B : 저도 알겠습니다! start
  
  ## B가 두 수의 합을 알고있다. 두 수의 합을 X라 할 때
  ## X를 a+b꼴로 즉, 가능한 모든 (a,b)의 조합으로 표현할 떄
  ## ex) X=17, (a,b)의 조합으로는 (2,15), (3,14)......등이 있다.
  ## (a,b)조합을 모두 찾은후 개별 (a,b)에 대하여 
  ## a*b를 계산한다. 그리고 나온 값을 Y라 할 때
  ## Y를 m*n꼴로 즉, 가능한 모든 (m,n)의 조합으로 표현할 떄
  ## ex)Y=30, (m,n)의 조합으로는 (2,15), (3,10), (5,6)이다.
  ## 그리고 Y에 대한 (m,n)조합에서 m+n을 계산한다
  ## Y=30 이면 m+n으로 17, 13, 11이 나온다.
  ## 이때 B : 전 당신이 모를걸 알고 있었어요.라고 했으므로 
  ## 두 수의 합이 두 소수의 합으로 표현되는 경우를 모두 제거한다,
  ## Y=30 이면 13 = 2 + 11이므로 제거된다.
  ## 그리고 남은 m+n은 11과 17이다.
  ## 이때 A : 아! 알겠습니다. 라고 했으므로
  ## 남은 경우의 수가 단 하나뿐이여된다.
  ## Y=30 인 경우 11과 17, 두 가지 경우가 남으므로
  ## A는 알겠다고 답할 수 없다.
  ## 즉 m+n으로 가능한 수가 단 하나만 남는 경우를 찾으면 된다.
  ## m+n은 두수의 합이고 두수의 합은 pro4에서
  ## 찾을 수 있고 '두 수의 합' 열에서 단 한번만
  ## 나온 숫자가 답이다.
  ## 단 한번만 나온 숫자가 단 하나뿐이여야 한다
  ## 만약 한번만 나온 숫자가 여러개라면
  ## 문제의 조건을 충족시키지 못한다.
  
  
  ## two_number는 모든 조건을 충족시키는 두 자연수이다.
  
  two_number = c()
  
  for(i in 1:nrow(pro4)){
    count = 0
    
    for(j in 1:nrow(pro4)){
      if(pro4[i,4] == pro4[j,4]){
        count = count + 1
      }
    }
    if(count == 1){
      two_number = rbind(two_number, pro4[i,])
    }
  }
  
  return(pro4)
  
}

 ### 자연수의 범위가 2부터 50인 경우
 ### pro4에서 두 수의 합으로 단 한번만
 ### 등장한 수가 단 하나 4와13이므로
 ### 문제의 해는 4와13이다.

 ### 자연수의 범위가 50부터 100인 경우
 ### 문제의 해는 50과51이다.
  
 ####### 오류 있당 ㅎ헤ㅔ헤 뭐가 잘못됐을가 헤헤헤
  
  
  
  
  ########원본

#### 2이상 50사이의 서로 다른 자연수가 두개 있다.
#### A는 서로 다른 두 자연수의 곱을 알고 B는 서로 다른 두 자연수의 합을 안다.
#### C가 A에게 두 자연수를 알겠냐고 물었다.
#### A : 모르겠습니다.
#### B : 전 당신이 모를걸 알고 있었어요.
#### A : 아! 알겠습니다.
#### B : 저도 알겠습니다!
#### 이때 두 자연수는 무엇인가?



secret_number <- function(x, y){
  
  ## mul = multiple
  ## mul은 서로 다른 두 자연수 곱의 조합
  
  mul = c()
  n = 1
  for(i in x:y){
    for(j in x:y){
      if(i != j){
        mul[n] = i * j
        n = n + 1
      }
    }
  }
  
  mul = unique(mul)
  
  ## prime = prime number
  ## prime은 x와 y 사이에 있는 소수 , unique(x) => x에서 중복되는 원소 제거
  
  prime = c()
  k = 1
  
  for(i in x:y){
    check = 0
    for(j in 1:i){
      if(i %% j == 0){
        check = check + 1
      }
    }
    if(check == 2){
      prime[k] = i
      k = k + 1
    }
  }
  
  ## prime_num 은 서로 다른 두 소수 곱의 조합
  
  prime_num = c()
  n = 1
  for(i in prime){
    for(j in prime){
      if(i != j){
        prime_num[n] = i * j
        n = n + 1
      }
    }
  }
  
  prime_num = unique(prime_num)
  
  
  ## A1은 두 자연수 곱의 조합에서 두 소수 곱의 조합을 뺀 차집합이다.
  #### A : 모르겠습니다. clear
  
  
  A1 = setdiff(mul, prime_num)
  
  
  
  ## mul은 두 자연수 곱의 조합에서 두 소수 곱의 조합을 뺀 차집합이다.
  #### A : 모르겠습니다. clear
  
  
  #### B : 전 당신이 모를걸 알고 있었어요.
  ## B가 알고있는 내용은 두 자연수의 합
  ## 두 자연수의 합을 보고 A가 모를걸 알고 있었다.
  ## 즉 합을 두 자연수로 쪼갰을 때 소수+소수의 형태가 존재하지 않아야 한다.
  ## 만약 소수+소수라면 A는 답을 알 수 있으므로 B는 A가 모를걸 알고 있었다고 말을 못한다.
  ## 골드바흐 추측에 따라 짝수는 소수+소수 꼴로 나타나므로 제외
  ## 짝수인 소수는 2밖에 없다.
  ## 그러므로 어떤 합A - 2가 소수라면 A는 제외
  ## add는 서로 다른 두 자연수 합의 조합
  
  
  add = c()
  n = 1
  for(i in x:y){
    for(j in x:y){
      if(i != j){
        add[n] = i + j
        n = n + 1
      }
    }
  }
  
  add = unique(add)
  
  
  ## 짝수 = 소수 +소수 이므로 짝수 제거
  ## 6 = 3+3 이지만 중복해서 수를 사용할 수 없으므로
  ## 6 = 2+4이며 조합이 하나 뿐이므로 어자피 제거된다.
  
  add = add[add %% 2 == 1]
  add_2 = add - 2
  
  ## X - 2 가 소수이면 2가 소수이므로 X도 소수, 그러므로 X 제거
  
  prime1 = c()
  m = 1
  for(i in add_2){
    check = 0
    for(j in 1:i){
      if(i %% j == 0){
        check = check + 1
      }
    }
    if(check == 2){
      prime1[m] = i
      m = m + 1
    }
  }
  
  prime2 = prime1 + 2
  
  ## B1은 두 자연수의 합 중에서 두 소수의 합으로 이루어지지 않는 조합
  
  B1 = setdiff(add, prime2)
  
  #### B : 전 당신이 모를걸 알고 있었어요. clear
  #### A : 아! 알겠습니다.
  ## A는 X를 안다. 이때 X는 서로 다른 두 자연수의 곱이다.
  ## A는 X를 두 곱의 조합으로 나타낸다.
  ## ex) X가 18이라면 (2,9) 와 (3,6)
  ## A는 18이란 숫자를 알 때 B는 11 또는 9라는 사실을 알고 있다.
  ## B는 9 or 11 인데  B : 전 당신이 모를걸 알고 있었어요. 라고 말했다.
  ## 이는 B가 알고있는 숫자가
  ## 두 자연수의 합 중에서 두 소수의 합으로 이루어지지 않는 조합
  ## 임을 나타낸다. 그런데 9 = 2+7이므로 제외하면 11이 남는다.
  ## 그렇다면 A는 알겠다고 대답할 수 있다.
  ## 즉 X를 a*b 조합으로 나타낸 후 a+b로 가능한 조합을 찾는다.
  ## 이때 a+b의 조합에서 B : 전 당신이 모를걸 알고 있었어요. 라고 말했으므로
  ## a+b의 조합중에서 두 소수의 합으로 이루어지지 않은 쌍이 있다는 것이다.
  ## 만약 이러한 쌍이 단 하나뿐이라면 A는 알겠다고 대답할 수 있다.
  
  ## mul_comb은 A1에서 표현가능한 (A1, 상수a, 상수b, a+b)의 행렬
  
  mul_comb = data.frame("두 수의 곱" = 0, "상수a"=  0, "상수b" = 0, "두 수의 합" = 0)
  
  for (i in A1){
    for(j in x:y){
      for(k in x:y){
        if(j * k == i){
          q = j + k
          vec = c(i, j, k, q)
          
          mul_comb = rbind(mul_comb, vec)
          
        }
      }
    }
  }
  
  ## 첫 번째 행(0,0,0,0)은 필요없어서 없앰
  
  mul_comb = mul_comb[-1,]
  
  
  ## 같은 조합이 반복됨 ex) 8, 2, 4 & 8, 4,2
  ## 상수a > 상수b 인 경우만 추출
  
  ## pro = product
  
  pro1 = c()
  for(i in 1:nrow(mul_comb)){
    if(mul_comb[i,2] > mul_comb[i,3]){
      pro1 = rbind(pro1 , mul_comb[i,])
    }
  }
  
  ##  "B : 전 당신이 모를걸 알고 있었어요." 이 내용을 충족시키기 위해 두 수의 합이 
  ## 두 소수의 합으로 표현되는 수를 제외한다.
  ## pro2는 두 수의 합이 짝수인 행을 제거한다.
  
  pro2 = c()
  
  for (i in 1:nrow(pro1)){
    if(pro1[i,4] %% 2 != 0){
      pro2 = rbind(pro2, pro1[i,])
    }
  }
  
  ## 두 수의 합이 소수 + 소수인 경우를 B1을 이용해 제거한다
  ## pro3는 두 수의 합이 두 소수의 합으로 표현되는 수를 제거한 행렬이다.
  
  pro3 = c()
  
  for(i in 1:nrow(pro2)){
    for(j in B1){
      if(pro2[i,4] == j){
        pro3 = rbind(pro3, pro2[i,])
      }
    }
  }
  
  
  ## pro4는 두수의 곱을 X라 할 때 X=a*b에서
  ## a+b로 가능한 모든 조합을 찾고 그 중에서 두수의합으로
  ## 불가능한 경우를 
  ## B : 전 당신이 모를걸 알고 있었어요. 라는 내용에 따라
  ## 다 제거하니 단 하나만 남은 X를 저장한다.
  
  pro4 = c()
  
  for(i in 1:nrow(pro3)){
    count = 0
    
    for(j in 1:nrow(pro3)){
      if(pro3[i,1] == pro3[j,1]){
        count = count + 1
      }
    }
    if(count == 1){
      pro4 = rbind(pro4, pro3[i,])
    }
  }
  
  
  #### A : 아! 알겠습니다. clear
  
  #### B : 저도 알겠습니다! start
  
  ## B가 두 수의 합을 알고있다. 두 수의 합을 X라 할 때
  ## X를 a+b꼴로 즉, 가능한 모든 (a,b)의 조합으로 표현할 떄
  ## ex) X=17, (a,b)의 조합으로는 (2,15), (3,14)......등이 있다.
  ## (a,b)조합을 모두 찾은후 개별 (a,b)에 대하여 
  ## a*b를 계산한다. 그리고 나온 값을 Y라 할 때
  ## Y를 m*n꼴로 즉, 가능한 모든 (m,n)의 조합으로 표현할 떄
  ## ex)Y=30, (m,n)의 조합으로는 (2,15), (3,10), (5,6)이다.
  ## 그리고 Y에 대한 (m,n)조합에서 m+n을 계산한다
  ## Y=30 이면 m+n으로 17, 13, 11이 나온다.
  ## 이때 B : 전 당신이 모를걸 알고 있었어요.라고 했으므로 
  ## 두 수의 합이 두 소수의 합으로 표현되는 경우를 모두 제거한다,
  ## Y=30 이면 13 = 2 + 11이므로 제거된다.
  ## 그리고 남은 m+n은 11과 17이다.
  ## 이때 A : 아! 알겠습니다. 라고 했으므로
  ## 남은 경우의 수가 단 하나뿐이여된다.
  ## Y=30 인 경우 11과 17, 두 가지 경우가 남으므로
  ## A는 알겠다고 답할 수 없다.
  ## 즉 m+n으로 가능한 수가 단 하나만 남는 경우를 찾으면 된다.
  ## m+n은 두수의 합이고 두수의 합은 pro4에서
  ## 찾을 수 있고 '두 수의 합' 열에서 단 한번만
  ## 나온 숫자가 답이다.
  ## 단 한번만 나온 숫자가 단 하나뿐이여야 한다
  ## 만약 한번만 나온 숫자가 여러개라면
  ## 문제의 조건을 충족시키지 못한다.
  
  
  ## two_number는 모든 조건을 충족시키는 두 자연수이다.
  
  two_number = c()
  
  for(i in 1:nrow(pro4)){
    count = 0
    
    for(j in 1:nrow(pro4)){
      if(pro4[i,4] == pro4[j,4]){
        count = count + 1
      }
    }
    if(count == 1){
      two_number = rbind(two_number, pro4[i,])
    }
  }
  
  return(two_number)
  
}

### 자연수의 범위가 2부터 50인 경우
### pro4에서 두 수의 합으로 단 한번만
### 등장한 수가 단 하나 4와13이므로
### 문제의 해는 4와13이다.

### 자연수의 범위가 50부터 100인 경우
### 문제의 해는 50과51이다.



  
  
  




  