{
  
    
        "post0": {
            "title": "자료구조 큐(queue)",
            "content": "&#53328;(queue) . - 큐(queue)는 기본적인 자료 구조 + 스택(stack)과 반대되는 개념 . - 큐는 먼저 집어 넣은(push) 데이터가 먼저 나오는(pop) FIFO(First In First Out)구조로 되어 있음 &gt; 식당에서 줄 기다리기 &gt; 먼저 줄을 선 사람이 먼저 줄에서 나감( =식당으로 들어감) . - 참고: 자료구조 큐 . &#53328;(queue) &#49324;&#50857; . - 파이썬에서 queue은 from collections import deque를 실행한 후 deque()통해 구현할 수 있다 . - queue.append(x)를 통해 큐에 x를 push한다 . - queue.popleft()를 통해 큐에서 앞의 원소를 pop한다 . &#50696;&#51228; . from collections import deque ## 큐(queue)를 사용하기 위해 deque라이브러리 import queue = deque() ## 큐(queue) 자료구조 생성 &gt; deque([]) queue.append(1) ## 큐에 1 추가 &gt; deque([1]) queue.append(2) ## 큐에 2 추가 &gt; deque([1, 2]) queue.popleft() ## 큐에서 앞의 원소를 추출함 &gt; 선입선출 구조 &gt; deque([2]) . 1 .",
            "url": "https://gkswotn12345.github.io/green/python/data%20structure/2021/09/05/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%81%90.html",
            "relUrl": "/python/data%20structure/2021/09/05/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%81%90.html",
            "date": " • Sep 5, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "수리통계학",
            "content": "- 2학기 수업에서 배우는 수리통계학에 대해 정리할 것임 . - 중요한 내용은 따로 정리하여 다른 주피터 노트북 파일로 만들 수 도 있음 . 1&#51109; - &#54869;&#47456;&#51060;&#47200; . - 확률모형 &gt; 동전 던지기와 같이 가능성(chance)에 의존 . &#54364;&#48376;&#44277;&#44036;&#44284; &#49324;&#44148; . - 표본공간(sample space) : 모든 관찰 가능한 결과들의 집합 &gt; $S$ 또는 $ Omega$ . - 사건(event) : 표본공간의 일부분(부분집합) &gt; $A, B$ 등 영어 알파벳 대문자 . - 실험(experiment) 또는 시행 (trial) : 어떤 현상의 관찰결과를 얻기위한 과정 . 예시 | . - 동전의 앞면을 H, 뒷면을 T라 할 때 동전을 2회 던지는 실험을 시행하자 . - 표본공간 $S = {HH, HT, TH, TT }$ . - 1회 앞면이 나오는 사건 $A = {HT, TH }$ . - 2회 뒷면이 나오는 사건 $B = {TT }$ . 정의 | . - 사건 $A$와 $B$가 동시에 속하는 사건 &gt; $A$와 $B$의 공통부분(intersection) &gt; $A cap B$ . - 사건 $A$ 또는 $B$에 속하는 사건 &gt; $A$와 $B$의 합(union) &gt; $A cup B$ . - $A cap B$ = $ phi$ &gt; 두 사건 $A$와 $B$는 상호배반(mutually exclusive) . - 사건 $A$에 포함되지 않은 모든 $S$의 원소의 집합 &gt; $A$의 여사건(complement) &gt; $A^c$ . 사건에 대한 분배법칙과 드 모르간 법칙 | . - $(A cup B)^c = A^c cap B^c$ &gt; 드 모르간(De Morgan) 법칙 . - $(A cap B)^c = A^c cup B^c$ &gt; 드 모르간 법칙 . - $A cup (B cap C) = (A cup B) cap (A cup C)$ &gt; 분배법칙 . - $A cap (B cup C) = (A cap B) cup (A cap C)$ &gt; 분배법칙 . &#54869;&#47456;&#51032; &#51221;&#51032; . 고전적 정의 | . - 표본공간이 유한 개($N$)의 결과로 구성되고 모든 가능한 실험결과들이 일어날 가능성이 동일한경우 $M$개의 실험결과로 이루어진 사건 $A$의 확률 $P(A) = frac{M}{N}$ . 상대도수의 극한 | . - 실험을 독립적으로 n회 반복했을 때 사건 $A$의 발생횟수를 m이라 하면 실험이 무한히 반복되면 $P(A) = frac{m}{n}$ . &#54869;&#47456;&#44277;&#47532; . 1. 임의의 사건 $A$에 대해 $P(A) geq 0$ . 2. $P(S)=1$ . 3. 표본공간 $S$에 정의된 사건열 $A_1, A_2, cdots$가 있다고 할 때 모든 $i neq j$에 대하여 $A_i cap A_j = phi$이면 $P( bigcup limits_{i=1}^{ infty} A_i) = P(A_1 cup A_2 cup A_3 cup cdots) = sum limits_{i=1}^{ infty} P(A_i)$ . - 3번째 공리는 쉽게 말하자면 서로소인 두 사건 $A$와 $B$에 대해 $P(A) + P(B) = p(A cup B)$이다 + 집합열 이해 안되면 통계수학 책 참고하셈 . - 확률 &gt; 표본공간의 부분집합의 모임(특별한 성질 만족)을 정의역으로 하면서 확률공리를 만족하는 함수 . - 아니 특별한 성질이 뭐임??? &gt; 교수님 - (노트) 확률, 확률변수, 시계열, 정상성 파일에 나와있긴 한데...... . 정리 | . - 증명은 교재 참고 . 1. $P(A^c) = 1- P(A)$ . 2. $P( phi) = 0$ . 3. $A subset B$이면 $P(A) leq P(B)$ . 4. $P(A cup B)=P(A)+P(B)-P(A cap B)$ . - 정리 4번 사건 3개 버전 . - $P(A cup B cup C) = P(A) + P(B) + P(C) - P(A cap B) - P(B cap C) - P(C cap A) + P(A cap B cap C)$ &gt; 벤 다이어그램을 그려보면 간단히 알 수 있음 .",
            "url": "https://gkswotn12345.github.io/green/statistics/2021/09/03/%EC%88%98%EB%A6%AC%ED%86%B5%EA%B3%84%ED%95%99.html",
            "relUrl": "/statistics/2021/09/03/%EC%88%98%EB%A6%AC%ED%86%B5%EA%B3%84%ED%95%99.html",
            "date": " • Sep 3, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "회귀 분석",
            "content": "- 2학기 수업에서 배우는 회귀 분석 내용에 대해 간단히 정리할 거임 . - SAS 와 R을 활용한 선형 회귀분석 참고 . 1&#51109; - &#54924;&#44480; &#48516;&#49437;&#51032; &#44060;&#45392; . &#49345;&#44288; &#48516;&#49437;(correlation analysis) . - 변수들이 얼마만큼의 선형적인 관계가 있는지 분석 . - 종속변수와 독립변수 고려 X . - 측정은 상관계수 . &#54924;&#44480; &#48516;&#49437;(regression analysis) . - 서로 인과관계가 있는 두 변수들 간의 관계식을 분석 . - 독립변수와 종속변수 고려 O . &#48320;&#49688; &#54805;&#53468; . 1. 연속형(continuous)변수 &gt; 키, 몸무게, 수입 등 . 2. 이산형(discrete)변수 &gt; 사고 횟수 등 . 3. 범주형(classified)변수 &gt; 성별, 교육 수준 등 . &#53685;&#44228;&#51201; &#47784;&#54805;&#51032; &#51333;&#47448; . 1. 단순 선형회귀 $y=a+bx+ epsilon$ . 2. 다중 선형회귀 $y=a+b_1x_1+b_2x_2+ cdots+b_kx_k+ epsilon$ . 3. 다항 회귀 $y=a+b_1x+b_2x^2+ cdots+b_nx^k+ epsilon$ . 4. 비선형 회귀 $y= frac{c}{a-b}(e^{-ax_1}+e^{-bx_2}-e^{-cx_3})+ epsilon$ . 5. 일반화 선형모형 &gt; 로지스틱 y: 이항변수, 포아송 회귀 y: 계수변수 . - 참고 $y=e^{a+bx}$ : 비선형 $ to$ $ln(y) = a+bx$ : 선형 . &#54924;&#44480; &#48516;&#49437;&#51032; &#51208;&#52264; . 1. 연구목적 &gt; 설명변수 선택 . 2. 산점도 &gt; 다중공선성, 이상점, 영향점 파악 . 3. 회귀모형 추정 &gt; 회귀계수 추정 . - 이분산 &gt; 가중회귀, 다중공선성 &gt; Ridge Regression . 4. 유의한 변수 선택 &gt; 회귀 계수 t검정, 변수 선택방법 이용, 수정 결정계수 . 5. 다중공선성 진단 &gt; 산점도, VIF, 문제 변수 제거, 주성분 회귀 이용 . 6. 영향점 진단 &gt; RSTUDENT, LEVERAGE, DFFITS, COVARTIO, 이상점 제거, 다중회귀에선 영향점도 제거 . 7. 잔차 분석 &gt; 잔차와 예측치의 산점도, 잔차의 정규성 검정 . - 정규성 가정 이탈: 종속변수를 변환, 등분산 가정 이탈: 가중회귀 방법 . 8. 최종 회귀모형 &gt; 추정된 모형 해석, 표준화 회귀계수에 의해 각 설명변수의 영향력 비교 .",
            "url": "https://gkswotn12345.github.io/green/r/statistics/2021/09/01/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D.html",
            "relUrl": "/r/statistics/2021/09/01/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D.html",
            "date": " • Sep 1, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "이진 탐색(Binary search)",
            "content": "&#51060;&#51652; &#53456;&#49353;(Binary search) . - 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘 . - 처음 중간의 값을 임의의 값으로 선택하고 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 사용 . - 처음 선택한 중앙값이 만약 찾는 값보다 크면 그 값은 새로운 최댓값이 되며 작으면 그 값은 새로운 최솟값이 됨 . - 검색 원리상 정렬된 리스트에만 사용할 수 있다는 단점이 있지만 검색이 반복될 때마다 목표값을 찾을 확률은 두 배가 되므로 속도가 빠르다는 장점 &gt; $O(logN)$ . - 참고: 이진 탐색 . &#51060;&#51652; &#53456;&#49353; &#44396;&#54788; . - 정렬된 array에서 target의 위치를 이진 탐색으로 찾는 코드를 구현하자 . - 이 코드를 통해 1~100 숫자(arr)에서 88(target)을 찾는 과정을 살펴보자 . def binary_search(arr, target): arr.sort() ## 리스트를 오름차순으로 정렬 low = 0 high = len(arr) - 1 ## arr의 첫번째 인덱스(low)부터 마지막 인덱스(high)까지 탐색 while low &lt;= high: mid = (high + low) // 2 print(&#39;low: {} nhigh: {} nmid: {}&#39;.format(low, high, mid)) if arr[mid] == target: ## 원하는 값을 찾으면 mid(인덱스)를 반환 return mid elif arr[mid] &gt; target: ## 원하는 값이 중간점보다 작은 경우 왼쪽 부분 탐색 high = mid - 1 else: low = mid + 1 ## 원하는 값이 중간점보다 큰 경우 오른쪽 부분 탐색 return False ## 원하는 값이 arr에 없는 경우 . arr = list(range(1, 101)) target = 88 binary_search(arr, target) . low: 0 high: 99 mid: 49 low: 50 high: 99 mid: 74 low: 75 high: 99 mid: 87 . 87 . - 우리가 찾는 target인 88은 arr의 87번째 인덱스 값이라고 한다 . arr[87] . 88 . - 진짜임 . - 어떤 과정을 거쳐서 87번째 인덱스라는 것을 알려준 것일까? . - arr은 1부터 100까지의 값임 . 1. 1 2 3 $ cdots$ 98 99 100 &gt; low는 0이고 high는 99이므로 mid는 49임 . 2. arr[mid(49)] = 50는 target(88)보다 작으므로 arr[mid(49)+1] ~ arr[high(99)] 를 탐색하면 target(88)이 존재할 것임 . 3. 51 52 53 $ cdots$ 98 99 100 &gt; low는 50이고 high는 99이므로 mid는 74임 . 4. arr[mid(74)]는 target(88)보다 작으므로 arr[mid(74)+1] ~ arr[high(99)] 를 탐색하면 target(88)이 존재할 것임 . 5. 76 77 78 $ cdots$ 98 99 100 &gt; low는 75이고 high는 99이므로 mid는 87임 . 6. arr[mid(87)]는 target(88)과 동일하므로 mid(87)를 return한다 . &#51060;&#51652; &#53456;&#49353; &#49884;&#44036; &#48373;&#51105;&#46020; . - 시간 복잡도는 $O(logN)$이다 . - 위에서 1~100사이에서 target을 찾는 과정을 살펴봤음 . - 탐색 범위를 $N$이라고 한다면 처음에는 $N$만큼 탐색함 . - 그 다음에는 $ frac{N}{2}$만큼 탐색함 . - 또 그 다음에는 $ frac{N}{4}$만큼 탐색함 . - 이를 살펴보면 탐색 범위는 $N, frac{N}{2}, frac{N}{4}, cdots , 1$ . - 시간 복잡도는 알고리즘의 의해 수행되는 기본 연산의 개수를 보면 알 수 있음 . - 연산 횟수(탐색 반복 횟수)를 $k$라고 하면 처음 탐색($k=1$)때의 탐색 범위는 $N$, 두번째 탐색($k=2$)때의 탐색 범위는 $ frac{N}{2}$이며 이를 계속하면 탐색 범위는 $1$이 됨 . - 위의 관계식을 통해 $N times( frac{1}{2})^{k} = 1$임을 알 수 있고 이를 정리하면 $k=log_{2}N$임 . - Big O 표기법에서 로그의 밑은 영향이 없으므로 이진 탐색의 시간 복잡도는 $O(logN)$이라고 할 수 있음 &gt; 이해 안되면 통계수학 big O 표기법 다시 보기 .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/08/31/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89.html",
            "relUrl": "/python/algorithm/2021/08/31/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "자료구조 스택(Stack)",
            "content": "&#49828;&#53469;(Stack) . - 스택(stack)은 기본적인 자료 구조 . - 스택은 자료를 넣고(push) 자료를 빼는(pop) 입구가 같은 선형 구조(LIFO - Last In First Out)으로 되어 있음 . - 참고: 자료구조 스택 . &#49828;&#53469;(Stack) &#49324;&#50857; . - 파이썬에서 stack은 list를 통해 구현할 수 있다 . - stack.append(x)를 통해 스택에 x를 push한다 . - stack.pop()을 통해 스택의 마지막 원소를 pop한다 . &#50696;&#51228; - &#51228;&#47196; . 문제 출처: 백준 10773번 | . - 스택(stack)의 기본적인 push와 pop을 이요하면 된다 . - 0이 입력되면 pop하고 그 외에 수가 입력되면 push한다 . K = int(input()) stack = list() ## stack = []와 동일 for _ in range(K): num = int(input()) if num == 0: stack.pop() else: stack.append(num) print(sum(stack)) . 0 .",
            "url": "https://gkswotn12345.github.io/green/python/data%20structure/2021/08/30/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8A%A4%ED%83%9D.html",
            "relUrl": "/python/data%20structure/2021/08/30/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8A%A4%ED%83%9D.html",
            "date": " • Aug 30, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "자료구조 힙(Heap)",
            "content": "&#55193;(Heap) . - 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리 자료구조 . - 힙 속성 &gt; A가 B의 부모노드(parent node) 이면 A의 키(key)값과 B의 키값 사이에는 대소관계가 성립 . - 최대 힙: 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙 . - 최소 힙: 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙 . - 키(key)값의 대소관계는 오로지 부모노드와 자식노드 간에만 성립하며 특히 형제 사이에는 대소관계가 정해지지 않음 . - 대개 자식노드 개수가 최대 2개인 이진 힙(binary heap)을 사용함 . - 데이터의 최대값(최대 힙) or 최소값(최소 힙)을 찾는데 $O(1)$이 소요됨 &gt; 루트노드에 저장되어 있으므로 . - 데이터의 삽입과 삭제는 $O(logN)$이 소요됨 . - 참고: 자료구조 힙 . &#55193;(Heap) &#49324;&#50857; . - 파이썬의 heapq 모듈은 최소 힙이다 . - 힙(Heap) 구조 그림으로 보기 &gt; 힙 구조 &gt; 이거 보면 무조건 이해 가능 . - 힙을 코드로 구현하기 전에 필요한 함수를 공부하자 . - heapq.heappush(heap, item) &gt; item을 heap에 추가함 . - heapq.heappop(heap) &gt; heap에서 가장 작은 원소(루트 노드)를 pop(추출)하고 비어 있으면 IndexError . - heapq.heapify(x) &gt; 리스트 x를 heap 자료 구조로 변환함 . - 참고: heapq . &#50696;&#51228;: &#52852;&#46300; &#54633;&#52404; &#45440;&#51060; . 문제 출처: 백준 15903번 | . - 카드 더미의 최소값 2개를 뽑은다음 두 숫자를 두 수의 합으로 바꿔주는 것을 반복하면 됨 . - 최소값 2개를 뽑으면 되니 Heap을 사용하자 . - Heap에서 최소값 추출은 $O(1)$ 삽입과 삭제는 $O(logN)$이므로 다른 구조보다 효율적으로 문제를 해결할 수 있음 . import heapq n, m = map(int, input().split()) cards = list(map(int, input().split())) heapq.heapify(cards) ## list인 cards를 Heap구조로 변홤함 for _ in range(m): two_card_sum = heapq.heappop(cards) + heapq.heappop(cards) ## 최소값 2개(제일 작은 값과 두 번째로 작은 값)를 뽑음 heapq.heappush(cards, two_card_sum) ## 두 수를 두 수의 합으로 바꿔줌 heapq.heappush(cards, two_card_sum) ## 그리고 cards 에 push한다 print(sum(cards)) . 19 .",
            "url": "https://gkswotn12345.github.io/green/python/data%20structure/2021/08/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%9E%99.html",
            "relUrl": "/python/data%20structure/2021/08/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%9E%99.html",
            "date": " • Aug 26, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "R 프로그래밍",
            "content": "참고: R 프로그래밍 - 허명회 지음 . - R 프로그래밍에 대해 복습할 겸 간단히 정리 . 2&#51109; - &#48289;&#53552;(vector) . - 데이터 컨테이너의 기본형 . &#48289;&#53552; . import rpy2 %load_ext rpy2.ipython . C: anaconda3 envs py38r40 lib site-packages rpy2 robjects packages.py:366: UserWarning: The symbol &#39;quartz&#39; is not in this R namespace/package. warnings.warn( . %%R x &lt;- 1 is.vector(x) . [1] TRUE . - x는 길이가 1인 벡터 = 스칼라 . %%R print(pi) print(pi, 16) . [1] 3.141593 [1] 3.141592653589793 . - π는 숫자가 예약되어 있는 스칼라 . %%R M &lt;- matrix(1:12, nrow = 4, ncol = 3, byrow = T) M . [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 [3,] 7 8 9 [4,] 10 11 12 . - M은 행렬 &gt; 벡터의 2차원 배열 . &#51064;&#45937;&#49905; . %%R f &lt;- c(1, 1, 2, 3, 5, 8, 13, 21) f[5] . [1] 5 . %%R f[1:5] . [1] 1 1 2 3 5 . %%R f[-c(1,4)] . [1] 1 2 5 8 13 21 . %%R f[c(1,2,4)] . [1] 1 1 3 . seq()&#50752; rep() &#54632;&#49688; . - seq(a, b, by = c)는 a부터 b까지 c간격으로 등차수열 생성 . %%R seq(0, 10, 2.5) . [1] 0.0 2.5 5.0 7.5 10.0 . - seq(a, b, length = n)는 a부터 b까지 길이가 n인 일정 간격 수열을 생성 . %%R seq(0, 10, length = 11) . [1] 0 1 2 3 4 5 6 7 8 9 10 . - rep(x, times = k)는 x의 각 요소가 k의 각 요소씩 반복된 벡터 . %%R rep(NA, 5) . [1] NA NA NA NA NA . %%R rep(c(1, 2), 3) . [1] 1 2 1 2 1 2 . %%R rep(c(1, 2, 3), c(3, 2, 1)) . [1] 1 1 1 2 2 3 . - rep(x, each = k)는 x의 각 요소가 각각 k번 반복된 벡터 . %%R rep(c(1, 2), each = 3) . [1] 1 1 1 2 2 2 . &#54596;&#53552;&#47553; . - 조건에 부합하는 데이터 값만 추출 . %%R x &lt;- 1:10 x[x %% 2 == 1] . [1] 1 3 5 7 9 . %%R subset(x, x %% 2 == 0) . [1] 2 4 6 8 10 . ifelse() &#54632;&#49688; . - ifelse(x, yes, no)는 x가 True이면 yes를 값으로 하고 False이면 no를 값으로 배출 . %%R x &lt;- 1:10 x1 &lt;- ifelse(x %% 2 == 0, x, 2*x) cbind(x, x1) . x x1 [1,] 1 2 [2,] 2 2 [3,] 3 6 [4,] 4 4 [5,] 5 10 [6,] 6 6 [7,] 7 14 [8,] 8 8 [9,] 9 18 [10,] 10 10 . names() &#54632;&#49688; . - names(x)는 벡터x의 개별 요소에 이름을 부여함 . %%R era &lt;- c(5, 4 ,3, 4 ,5, 6) era . [1] 5 4 3 4 5 6 . - paste()함수는 2개의 문자열 벡터를 sep인수로 붙인다 . %%R names(era) &lt;- paste(&quot;y&quot;, 2001:2006, sep = &quot;-&quot;) era . y-2001 y-2002 y-2003 y-2004 y-2005 y-2006 5 4 3 4 5 6 . 3&#51109; - &#54665;&#47148;(matrix) . - $p$개의 길이 $n$인 벡터를 열에 배치함 . &#54665;&#47148; . %%R n &lt;- 100 p &lt;- 3 x &lt;- rnorm(n*p) A &lt;- matrix(x, nrow = n, ncol = p) A[1:6, ] . [,1] [,2] [,3] [1,] -0.5272115 -0.09766999 0.9157430 [2,] -0.4910666 0.27630674 -0.4863826 [3,] -0.7199871 -1.37864849 -0.1378880 [4,] -0.2978141 1.21144373 -1.1352895 [5,] -0.9412001 -1.05635910 1.0677189 [6,] -0.4909131 0.92592424 -1.8697058 . - 콤마(,)앞은 행, 콤마(,)뒤는 열 . %%R A[1:6, 1:2] . [,1] [,2] [1,] -0.5272115 -0.09766999 [2,] -0.4910666 0.27630674 [3,] -0.7199871 -1.37864849 [4,] -0.2978141 1.21144373 [5,] -0.9412001 -1.05635910 [6,] -0.4909131 0.92592424 . - 필터링을 통해 인덱싱도 가능 . %%R A[A[,3] &gt; 0 &amp; A[,2] &gt; 0, ] . [,1] [,2] [,3] [1,] -1.632001082 0.95386709 0.34696994 [2,] -0.388047387 0.75046872 0.61005479 [3,] -1.325637032 0.85805657 0.48388600 [4,] 1.027718630 1.93877622 0.04144039 [5,] -0.926911907 0.57212123 1.66361085 [6,] 2.120355231 0.25362934 0.64836355 [7,] 1.038120371 0.01903657 0.04071902 [8,] -0.973632914 0.35330337 0.35594054 [9,] 1.799568590 1.98855528 0.50952846 [10,] 0.633299053 1.03079130 0.23844919 [11,] -0.178793903 0.66631102 1.11482316 [12,] 1.307643075 0.14501150 0.41404295 [13,] 0.005313813 2.02583488 0.33820766 [14,] -0.280283865 1.04242405 1.33195196 [15,] 0.270559357 0.05230981 0.35938639 [16,] -1.485066480 0.41976340 0.59734787 [17,] -0.076204339 0.97655368 1.99341983 [18,] 2.316420281 0.05287762 0.27840240 [19,] -0.661999001 0.28495938 1.43514281 [20,] -0.713879760 0.15816804 0.71605743 [21,] -0.095003851 1.13276296 0.74928887 [22,] 0.087418924 1.66296778 0.47576952 [23,] -1.055728878 0.56180370 1.26128539 [24,] 1.153290080 0.27938929 0.58182072 [25,] 1.348495993 0.30003159 1.17131650 [26,] -0.815336296 0.74215461 0.03795627 . - t(A) 함수는 행렬 A의 전치행렬을 구해줌 . %%R B &lt;- matrix(1:9, 3, 3) B . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . %%R t(B) . [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 [3,] 7 8 9 . - solve()함수는 역행렬을 구해줌 . %%R C &lt;- matrix(c(16 ,4, 1, 4, 4, 1, 1, 1, 1), 3, 3) C . [,1] [,2] [,3] [1,] 16 4 1 [2,] 4 4 1 [3,] 1 1 1 . %%R solve(C) . [,1] [,2] [,3] [1,] 0.08333333 -0.08333333 0.0000000 [2,] -0.08333333 0.41666667 -0.3333333 [3,] 0.00000000 -0.33333333 1.3333333 . - %*%는 행렬곱 . %%R solve(C) %*% C . [,1] [,2] [,3] [1,] 1.000000e+00 -5.551115e-17 -1.387779e-17 [2,] 1.665335e-16 1.000000e+00 5.551115e-17 [3,] 0.000000e+00 0.000000e+00 1.000000e+00 . - 참고로 $AA^{-1} = I$ . - $I$는 단위행렬 . apply() &#54632;&#49688; . - apply(A, 1 or 2, f) &gt; 행렬A의 행(1) or 열(2)에 함수 f를 적용 . - c(1, 2)는 행과 열에 적용 &gt; 각 원소 . %%R M &lt;- matrix(1:12, 3, 4) M . [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 . - apply에서 옵션을 1(행)로 하니 전치된 행렬을 반환함 . %%R max_ = apply(M, 2, max) apply(M, 1, &quot;-&quot;, max_) . [,1] [,2] [,3] [1,] -2 -1 0 [2,] -2 -1 0 [3,] -2 -1 0 [4,] -2 -1 0 . %%R max_ = apply(M, 2, max) t(apply(M, 1, &quot;-&quot;, max_)) . [,1] [,2] [,3] [,4] [1,] -2 -2 -2 -2 [2,] -1 -1 -1 -1 [3,] 0 0 0 0 . - apply에서 옵션을 2(열)로 하니 문제 없어보임 . %%R max_ = apply(M, 1, max) apply(M, 2, &quot;-&quot;, max_) . [,1] [,2] [,3] [,4] [1,] -9 -6 -3 0 [2,] -9 -6 -3 0 [3,] -9 -6 -3 0 . - 옵션을 c(1, 2)로 하니 각 원소에서 -1을 수행함 . %%R apply(M, 1:2, &quot;-&quot;, 1) . [,1] [,2] [,3] [,4] [1,] 0 3 6 9 [2,] 1 4 7 10 [3,] 2 5 8 11 . - 행렬의 각 열에 대해 최소값 0과 최대값 1이 되도록 변환 . %%R n &lt;- 5 p &lt;- 4 M &lt;- matrix(rnorm(n*p), n, p) M . [,1] [,2] [,3] [,4] [1,] 0.39140070 0.41656975 0.3387848 0.15505716 [2,] 1.82931560 -1.25805693 -1.3580300 0.08618929 [3,] -0.07224563 -0.01837199 1.1249997 0.16007225 [4,] 1.05756759 -0.33926353 0.8730712 -0.51535640 [5,] 1.35992572 0.06295887 0.2480695 -2.54631691 . %%R min_ &lt;- apply(M, 2, min) max_ &lt;- apply(M, 2, max) M.1 &lt;- t(apply(M, 1, &quot;-&quot;, min_)) M.2 &lt;- t(apply(M.1, 1, &quot;/&quot;, max_-min_)) M.2 . [,1] [,2] [,3] [,4] [1,] 0.2438240 1.0000000 0.6833647 0.9981469 [2,] 1.0000000 0.0000000 0.0000000 0.9727005 [3,] 0.0000000 0.7402754 1.0000000 1.0000000 [4,] 0.5941503 0.5486557 0.8985399 0.7504318 [5,] 0.7531555 0.7888420 0.6468306 0.0000000 . rownames()&#50752; colnames() &#54632;&#49688; . - 행렬의 행과 열에 이름을 붙임 . %%R n &lt;- 10 x &lt;- matrix(round(rnorm(n*4, 50, 10)), n, 4) ## 평균이 50, 표준편차가 10인 정규분포에서 난수 40개 추출 rownames(x) &lt;- paste(&quot;S&quot;, 1:n, sep = &quot;&quot;) colnames(x) &lt;- c(&quot;math&quot;, &quot;engl&quot;, &quot;science&quot;, &quot;arts&quot;) x . math engl science arts S1 48 63 48 42 S2 40 46 45 60 S3 48 47 65 54 S4 29 53 56 35 S5 42 63 42 46 S6 30 67 57 55 S7 59 44 41 47 S8 44 48 40 60 S9 45 67 43 58 S10 66 54 72 73 . 4&#51109; - &#47532;&#49828;&#53944;(list) . - R에서 가장 일반적인 데이터 형태 . %%R members &lt;- list(leaders = c(&quot;gang&quot;, &quot;iu&quot;), assisstants = &quot;kang&quot;) members . $leaders [1] &#34;gang&#34; &#34;iu&#34; $assisstants [1] &#34;kang&#34; . - class(X) 함수는 X의 type을 알려줌 . %%R class(members) . [1] &#34;list&#34; . - names()함수로 요소의 라벨을 확인 + 변경 가능 . %%R print(names(members)) names(members)[2] &lt;- &quot;workers&quot; print(names(members)) . [1] &#34;leaders&#34; &#34;assisstants&#34; [1] &#34;leaders&#34; &#34;workers&#34; . &#47532;&#49828;&#53944;&#50640; &#51217;&#44540;&#54616;&#44592; . - [[ ]] 사용 . %%R members[[1]] . [1] &#34;gang&#34; &#34;iu&#34; . - [ ]은 sublist . - [[ ]]은 벡터이고 [ ]은 리스트임 . %%R members[1] . $leaders [1] &#34;gang&#34; &#34;iu&#34; . - 요소 이름 사용 . %%R members[[&quot;leaders&quot;]] . [1] &#34;gang&#34; &#34;iu&#34; . - $ 기호 사용 &gt; 개인적으로 제일 편함 . %%R members$leaders . [1] &#34;gang&#34; &#34;iu&#34; . - 리스트 내 자료 값 변경도 가능 . %%R members$leaders[1] &lt;- &quot;park&quot; members . $leaders [1] &#34;park&#34; &#34;iu&#34; $workers [1] &#34;kang&#34; . lapply()&#50752; sapply() &#54632;&#49688; . - matrix에서 apply() 함수를 사용하듯이 리스트에선 lapply()와 sapply() 함수를 사용 . - lapply(list, fun)는 list 내 요소들에 함수 fun을 적용하여 결과를 리스트로 출력 &gt; sapply() 는 벡터로 출력 . %%R salaries &lt;- list(leaders = c(250, 200), assistant = 100, members = c(300, 200, 180, 120 ,100)) salaries . $leaders [1] 250 200 $assistant [1] 100 $members [1] 300 200 180 120 100 . - lapply() 사용 . %%R lapply(salaries, mean) . $leaders [1] 225 $assistant [1] 100 $members [1] 180 . - sapply() 사용 . - 벡터로 출력이 불가능할 때는 lapply() 처럼 list로 출력함 . %%R sapply(salaries, mean) . leaders assistant members 225 100 180 . 5&#51109; - &#45936;&#51060;&#53552; &#54532;&#47112;&#51076;(data frame) . - matrix는 요소가 숫자만 가능했다면 data frame은 문자열과 같은 다른 type도 가능함 . - 데이터 프레임은 리스트의 일종 . - 리스트는 각 변수마다 길이가 달라도 되지만 데이터 프레임은 각 변수마다 길이가 같아야 함(열의 길이가 동일) . %%R course.id &lt;- c(1, 2, 3, 4 ,5, 6 ,7, 8, 9 ,10) mid &lt;- c(8, 22, 25, 25 ,21, 12, 12, 29, 40, 25) final &lt;- c(11, 24, 31, 13 ,34 ,26, NA ,36, 34 ,38) exams &lt;- data.frame(course.id, mid, final) exams . course.id mid final 1 1 8 11 2 2 22 24 3 3 25 31 4 4 25 13 5 5 21 34 6 6 12 26 7 7 12 NA 8 8 29 36 9 9 40 34 10 10 25 38 . %%R is.list(exams) . [1] TRUE . %%R colnames(exams) . [1] &#34;course.id&#34; &#34;mid&#34; &#34;final&#34; . %%R names(exams) . [1] &#34;course.id&#34; &#34;mid&#34; &#34;final&#34; . %%R length(exams) . [1] 3 . - [row, column]으로 인덱싱 . %%R exams[exams$mid &gt; 20, ] . course.id mid final 2 2 22 24 3 3 25 31 4 4 25 13 5 5 21 34 8 8 29 36 9 9 40 34 10 10 25 38 . %%R exams[exams$mid &gt; 20, &#39;final&#39;] ## exams[exams$mid &gt; 20, 3] 과 동일함 . [1] 24 31 13 34 36 34 38 . - 데이터 프레임의 각 열은 수치 벡터이므로 연산 가능 . %%R mean(exams[, &quot;mid&quot;]) . [1] 21.9 . %%R mean(exams$final) . [1] NA . - 값이 NA로 나옴 &gt; 7번 학생이 기말시험을 결시함 . - 그럼 어떻게 평균을 구하지? &gt; na.rm = T 옵션을 통해 NA를 제외한 데이터만 사용할 수 있음 . %%R mean(exams$final, na.rm = T) . [1] 27.44444 . - 만약 시험을 결시한 경우 0점 처리 한다면? &gt; is.na() 함수를 통해 NA인 경우 True를 아닌 경우 False를 생성하여 처리 가능 . %%R is.na(exams$final) . [1] FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE . %%R exams$final[is.na(exams$final)] &lt;- 0 ## is.na가 True인 경우만 0으로 변경 exams . course.id mid final 1 1 8 11 2 2 22 24 3 3 25 31 4 4 25 13 5 5 21 34 6 6 12 26 7 7 12 0 8 8 29 36 9 9 40 34 10 10 25 38 . %%R mean(exams$final) . [1] 24.7 . &#46160; &#45936;&#51060;&#53552; &#54532;&#47112;&#51076;&#51032; &#48337;&#54633; . - exams 변수는 중간 기말 성적이 기록되어 있음 . - 새로운 변수 book은 과제와 프로젝트 점수가 student_name의 순서로 정렬되어 있음 . - 이 둘을 합쳐보자 . %%R student_name &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;) homework &lt;- c(22, 34, 31, 24, 37, 36, 37, 28, 37, 34) project &lt;- c(NA, 7, NA, NA, 17 ,10, 8, NA ,4, NA) course.id &lt;- c(8, 10, 5, 1, 4, 2, 3 ,9 ,7 ,6) book &lt;- data.frame(student_name, homework, project, course.id) book . student_name homework project course.id 1 a 22 NA 8 2 b 34 7 10 3 c 31 NA 5 4 d 24 NA 1 5 e 37 17 4 6 f 36 10 2 7 g 37 8 3 8 h 28 NA 9 9 i 37 4 7 10 j 34 NA 6 . - NA는 자료의 수치 연산을 불가능하게 하므로 앞서 했던것처럼 is.na()를 통해 0점 처리하자 . %%R book$project[is.na(book$project)] &lt;- 0 book . student_name homework project course.id 1 a 22 0 8 2 b 34 7 10 3 c 31 0 5 4 d 24 0 1 5 e 37 17 4 6 f 36 10 2 7 g 37 8 3 8 h 28 0 9 9 i 37 4 7 10 j 34 0 6 . - 2개의 데이터 프레임을 통합하고자 할 때 확인할 것은 각 데이터 프레임에서 개체들의 정렬순서 . 1. 2개의 프레임에서 순서가 같은 경우 열 묶음(cbind)를 한다 &gt; cbind(exams, book) . - 하지만 course.id의 순서가 다르므로 불가능 . 2. 2개의 프레임에서 그 순서가 다른 경우 공통 개체 식별자(key)를 찾아 정의 &gt; merge() 함수가 key 변수를 찾아줌 . %%R class_record &lt;- merge(exams, book, by = &#39;course.id&#39;) class_record . course.id mid final student_name homework project 1 1 8 11 d 24 0 2 2 22 24 f 36 10 3 3 25 31 g 37 8 4 4 25 13 e 37 17 5 5 21 34 c 31 0 6 6 12 26 j 34 0 7 7 12 0 i 37 4 8 8 29 36 a 22 0 9 9 40 34 h 28 0 10 10 25 38 b 34 7 . - 위와 같이 key 변수의 이름(위에서는 course.id)이 두 데이터 프레임에서 동일한 경우 by를 사용 &gt; 그렇지 않은 경우에는 by.x와 by.y를 사용 . - 학생들의 총 점수 합계를 구하여 데이터 프레임에 새 변수로 추가해보자 . %%R class_record$total &lt;- apply(class_record[ ,c(2, 3, 5, 6)], 1, sum) class_record . course.id mid final student_name homework project total 1 1 8 11 d 24 0 43 2 2 22 24 f 36 10 92 3 3 25 31 g 37 8 101 4 4 25 13 e 37 17 92 5 5 21 34 c 31 0 86 6 6 12 26 j 34 0 72 7 7 12 0 i 37 4 53 8 8 29 36 a 22 0 87 9 9 40 34 h 28 0 102 10 10 25 38 b 34 7 104 . 6&#51109; - &#51064;&#51088;&#50752; &#45936;&#51060;&#53552; &#50836;&#50557;(factors and summaries) . - R에서 factor는 범주형 변수(벡터) 또는 비연속적 변수(벡터)를 지칭 . &#51064;&#51088;&#50752; &#53580;&#51060;&#48660; . %%R set.seed(1) ## 시드 넘버 설정 alpha &lt;- sample(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 25, replace = T) ## &#39;A&#39;, &#39;B&#39;, &#39;C&#39; 중에서 무작위로 25개를 중복을 허용하여 뽑는다 f &lt;- factor(alpha) ## alpha를 범주형 변수로 바꿈 . %%R alpha . [1] &#34;A&#34; &#34;C&#34; &#34;A&#34; &#34;B&#34; &#34;A&#34; &#34;C&#34; &#34;C&#34; &#34;B&#34; &#34;B&#34; &#34;C&#34; &#34;C&#34; &#34;A&#34; &#34;A&#34; &#34;A&#34; &#34;B&#34; &#34;B&#34; &#34;B&#34; &#34;B&#34; &#34;C&#34; [20] &#34;A&#34; &#34;C&#34; &#34;A&#34; &#34;A&#34; &#34;A&#34; &#34;A&#34; . %%R f . [1] A C A B A C C B B C C A A A B B B B C A C A A A A Levels: A B C . - 문자열인 alpha와 인자 벡터인 f가 같아 보이지만 다름 . - factor는 Levels이 존재하여 데이터 분류에 용이함 . - str() 함수는 데이터를 요약하여 보여줌 . %%R z &lt;- sample(1:5, 25, replace = T) g &lt;- factor(z) str(data.frame(f = f, g = g)) . &#39;data.frame&#39;: 25 obs. of 2 variables: $ f: Factor w/ 3 levels &#34;A&#34;,&#34;B&#34;,&#34;C&#34;: 1 3 1 2 1 3 3 2 2 3 ... $ g: Factor w/ 5 levels &#34;1&#34;,&#34;2&#34;,&#34;3&#34;,&#34;4&#34;,..: 2 1 3 3 4 3 1 4 5 1 ... . - table()은 빈도표를 만듦 . - addmargins()는 빈도표의 주변 합을 테이블에 추가함 . %%R table(f) . f A B C 11 7 7 . %%R table(f, g) ## f와 g의 인덱스를 보고 만듦 ex) f[x] = &#39;A&#39;이고 g[x] = 3이라면 (&#39;A&#39;, 3)위치의 값을 +1하는 식으로 만듦 . g f 1 2 3 4 5 A 2 2 2 2 3 B 0 0 1 4 2 C 5 0 1 0 1 . %%R addmargins(table(f)) . f A B C Sum 11 7 7 25 . %%R addmargins(table(f, g)) . g f 1 2 3 4 5 Sum A 2 2 2 2 3 11 B 0 0 1 4 2 7 C 5 0 1 0 1 7 Sum 7 2 4 6 6 25 . tapply()&#50752; aggregate()&#47196; &#45936;&#51060;&#53552; &#50836;&#50557; . - tapply(x, f, fun)는 x를 f의 수준 별로 쪼개서 fun을 적용함 . %%R set.seed(2) x &lt;- round(rnorm(25, 50, 10)) data.frame(x = x, f = f) . x f 1 41 A 2 52 C 3 66 A 4 39 B 5 49 A 6 51 C 7 57 C 8 48 B 9 70 B 10 49 C 11 54 C 12 60 A 13 46 A 14 40 A 15 68 B 16 27 B 17 59 B 18 50 B 19 60 C 20 54 A 21 71 C 22 38 A 23 66 A 24 70 A 25 50 A . %%R tapply(x, f, mean) . A B C 52.72727 51.57143 56.28571 . %%R tapply(x, f, function(t){max(t)-min(t)}) . A B C 32 43 22 . - function()은 사용자 정의 함수임 . - 한 줄일 경우 { }생략 가능 . - 쪼갬의 대상이 벡터가 아니라 데이터 프레임인 경우에는 split()과 sapply()를 함께 이용 . %%R split(data.frame(x = x, z = z), f) . $A x z 1 41 2 3 66 3 5 49 4 12 60 4 13 46 5 14 40 5 20 54 5 22 38 1 23 66 1 24 70 3 25 50 2 $B x z 4 39 3 8 48 4 9 70 5 15 68 4 16 27 5 17 59 4 18 50 4 $C x z 2 52 1 6 51 3 7 57 1 10 49 1 11 54 1 19 60 1 21 71 5 . %%R s &lt;- split(data.frame(x = x, z = z), f) class(s) . [1] &#34;list&#34; . %%R sapply(s, apply, 2, mean) . A B C x 52.727273 51.571429 56.285714 z 3.181818 4.142857 1.857143 . - aggregate(x, list(f, g), fun)은 x를 f와 g의 조합으로 쪼개서 fun을 적용함 . %%R aggregate(data.frame(x = x, z = z)$x, list(f, g), sum) . Group.1 Group.2 x 1 A 1 104 2 C 1 272 3 A 2 91 4 A 3 136 5 B 3 39 6 C 3 51 7 A 4 109 8 B 4 225 9 A 5 140 10 B 5 97 11 C 5 71 . - tapply()는 쪼갤 기준이 하나 . - aggregate()는 쪼갤 기준이 여러개(list) . cut() &#54632;&#49688; . - cut(x, breaks)는 수치형 벡터 x를 breaks로 쪼개서 factor 변수로 만듦(구간화) . - 만약 기준 변수가 factor가 아니라면 factor로 만듦 . %%R set.seed(21) x &lt;- runif(100, 0, 10) y &lt;- 5 + 0.5*(x-5) + rnorm(100) ## x와 y는 선형관계 ## rnorm(100)은 오차항 ## y = 0.5x + 2.5 + ϵ, ϵ ~ (0, σ^2) &gt; 이 예제에서 σ = 1 chr_ &lt;- c(&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;) x_cut &lt;- cut(x, chr_) class(x_cut) . [1] &#34;factor&#34; . %%R cbind(x, x_cut, y) . x x_cut y [1,] 7.8611493 8 5.8484239 [2,] 2.5244560 3 5.5363467 [3,] 6.9925230 7 5.7855895 [4,] 1.8446075 2 3.0701969 [5,] 9.5961383 10 7.8832415 [6,] 9.1868340 10 8.1071017 [7,] 1.0180455 2 2.9864533 [8,] 1.7219168 2 2.4578035 [9,] 9.8600368 10 8.3377913 [10,] 8.4939610 9 7.9089234 [11,] 6.6754012 7 5.3797472 [12,] 9.3521022 10 8.1040078 [13,] 0.5818433 1 0.6879865 [14,] 6.1861583 7 3.9159120 [15,] 1.7491846 2 5.1402481 [16,] 0.3767539 1 3.4828244 [17,] 5.2531317 6 4.6426963 [18,] 2.8218425 3 5.8392804 [19,] 4.9904520 5 4.6111098 [20,] 6.3382510 7 4.0824480 [21,] 0.1139965 1 2.7712999 [22,] 6.0785656 7 4.4010011 [23,] 7.7559853 8 6.8674062 [24,] 9.2397118 10 5.3672191 [25,] 2.9170673 3 4.4595508 [26,] 7.8907624 8 6.5321374 [27,] 5.6849721 6 5.5335596 [28,] 7.7843508 8 7.2240144 [29,] 7.1323253 8 5.3871303 [30,] 6.6904867 7 6.1411056 [31,] 9.3470991 10 8.2857154 [32,] 5.0646019 6 5.3948908 [33,] 7.4506019 8 5.9543859 [34,] 8.3835263 9 6.4948175 [35,] 8.6907475 9 6.9123283 [36,] 1.9311168 2 2.5977567 [37,] 2.1633194 3 3.2196540 [38,] 6.5042346 7 4.6125672 [39,] 3.3516604 4 3.3604589 [40,] 5.0765589 6 6.3485251 [41,] 6.5283937 7 5.5058359 [42,] 9.6557667 10 7.9341482 [43,] 5.1466067 6 5.3867516 [44,] 0.6165677 1 2.8618869 [45,] 1.5101646 2 4.3833361 [46,] 6.3556589 7 5.1196960 [47,] 1.0296050 2 4.5507614 [48,] 7.7269430 8 6.3010251 [49,] 4.1022537 5 4.5727020 [50,] 8.7023337 9 4.7613394 [51,] 7.7204222 8 5.5493224 [52,] 6.4981737 7 2.8052970 [53,] 6.3036461 7 5.6330273 [54,] 8.3020059 9 6.2963228 [55,] 1.3049793 2 3.1880598 [56,] 8.8185301 9 7.4033842 [57,] 2.4005341 3 3.0404586 [58,] 6.4817896 7 6.7420367 [59,] 2.3344643 3 4.7393166 [60,] 0.6940427 1 3.6027870 [61,] 0.3330366 1 1.2110536 [62,] 9.2247471 10 8.0552446 [63,] 3.4175140 4 2.3384819 [64,] 9.3834557 10 6.9384556 [65,] 5.1071478 6 4.7610120 [66,] 1.3198211 2 3.3786786 [67,] 8.1901787 9 5.2400199 [68,] 9.2262677 10 6.9904067 [69,] 9.4890694 10 6.7926696 [70,] 5.5827285 6 5.3886124 [71,] 5.2419521 6 4.8028737 [72,] 5.3472914 6 4.5898834 [73,] 9.6766790 10 7.4056243 [74,] 5.2833101 6 5.4971212 [75,] 5.3193106 6 5.1386437 [76,] 6.2043358 7 6.8507949 [77,] 9.2198573 10 6.2252412 [78,] 2.2786153 3 2.7543007 [79,] 9.2766458 10 6.6875929 [80,] 9.2997805 10 8.4412031 [81,] 5.2228023 6 5.4902407 [82,] 9.9086911 10 8.9550287 [83,] 0.6460298 1 2.5542380 [84,] 8.6259344 9 8.0880172 [85,] 4.8062732 5 5.2246315 [86,] 5.3615727 6 6.8357290 [87,] 4.1513448 5 3.3840167 [88,] 2.2846328 3 3.5953298 [89,] 9.8195084 10 5.8097139 [90,] 6.5597644 7 4.6645165 [91,] 5.8016786 6 6.2954982 [92,] 1.4083867 2 2.4986595 [93,] 6.9767447 7 5.0349142 [94,] 7.4802064 8 7.2367931 [95,] 9.5334043 10 6.6016713 [96,] 1.3104292 2 1.5242489 [97,] 6.4997197 7 6.4960776 [98,] 7.0777577 8 5.0707520 [99,] 0.9994111 1 2.6955059 [100,] 0.6916488 1 3.5104340 . - (x, y)의 산점도에 x의 구간별 평균을 막대로 넣어 구간별 평균의 이동을 산출해보자 . %%R y_local &lt;- aggregate(y, list(x_cut), mean) ## x_cut은 1~10까지 존재 &gt; 1부터 10까지 x_cut별로 따로 모아 그에 해당하는 y 데이터의 평균을 구함 y_local . Group.1 x 1 (0,1] 2.597557 2 (1,2] 3.252382 3 (2,3] 4.148030 4 (3,4] 2.849470 5 (4,5] 4.448115 6 (5,6] 5.436146 7 (6,7] 5.198160 8 (7,8] 6.197139 9 (8,9] 6.638144 10 (9,10] 7.384560 . %%R plot(x, y, ylim = c(0, 10), main = &quot;x vs y&quot; ) segments(0:9, y_local$x, 1:10, y_local$x, lwd = 2) ## segments 함수는 x좌표와 y좌표를 입력받아 line을 그려줌 abline(v = 1:9, lty = &quot;dotted&quot;) ## abline 함수는 line을 그려줌, v는 수직선의 위치 . - 참고: abline 함수 . - 참고: segments 함수 . &#51025;&#50857; . - 나중에 + R입문 중간고사 내용도 . 8&#51109; - &#51077;&#52636;&#47141;(input and output) . - read.table read.csv(&#39;파일 위치&#39;) &gt; 텍스트 파일 or csv 파일을 읽어 내부 저장소에 dataframe으로 만듦 . - getwd() &gt; 현재의 작업 디렉토리를 알려줌 . - setwd(&#39;위치&#39;) &gt; 작업 디렉토리를 입력한 위치로 변경 . - dir() &gt; 현재 작업 디렉토리에 있는 파일들의 리스트를 보여줌 . - write.table write.csv()은 특정 데이터 프레임을 작업 디렉토리에 텍스트 파일 or csv 파일로 입력함 . - 파일을 읽을 때 stringAdFactors = F 옵션을 적용하면 문자열 변수가 자동으로 factor 형이 되는 것을 막아줌 . - sink()함수를 통해 결과값을 텍스트 파일로 저장할 수 있음 &gt; sink function . scan()&#54632;&#49688; . - scan() &gt; 비정형의 문자열 데이터를 읽을 때 유용 . - what 은 읽어 들일 데이터 값 형식 numeric, logical, character . - 책 따라 하는데 scan함수가 제대로 작동되지 않아 찾아보니 quote = &quot;&quot; 로 하지 않아서라고 함 &gt; 참고: https://pythonq.com/so/r/29317 . - quote = &quot;&quot; 옵션을 적용하지 않으면 Read 1 item을 반환 &gt; 빈칸을 기준으로 문자열을 쪼개지 않았다는 뜻 &gt; 그런데 sep = &quot; n&quot; 으로 하면 Read 20 item임 . - 원인을 알았는데 내가 yesterday노래 가사 텍스트 파일을 만들 때 맨 앞에 &quot; 기호를 실수로 추가했었음 &gt; &quot; 기호를 없애니 잘 동작함 . %%R lyrics &lt;- scan(&quot;yesterday.txt&quot;, what = &quot;character&quot;) ## quote = &quot;&quot; 옵션을 적용 안해도 잘 동작함 . R[write to console]: Read 126 items . %%R str(lyrics) . chr [1:126] &#34;Yesterday,&#34; &#34;all&#34; &#34;my&#34; &#34;troubles&#34; &#34;seemed&#34; &#34;so&#34; &#34;far&#34; &#34;away.&#34; ... . %%R head(lyrics, 10) . [1] &#34;Yesterday,&#34; &#34;all&#34; &#34;my&#34; &#34;troubles&#34; &#34;seemed&#34; [6] &#34;so&#34; &#34;far&#34; &#34;away.&#34; &#34;Now&#34; &#34;it&#34; . - 빈칸을 구분자로 인식하여 문자열을 쪼개어 읽어옴 + 줄 단위로 읽고 싶다면 sep = &quot; n&quot; . %%R lyrics_2 &lt;- scan(&quot;yesterday.txt&quot;, what = &quot;character&quot;, sep = &quot; n&quot;) . R[write to console]: Read 20 items . %%R str(lyrics_2) . chr [1:20] &#34;Yesterday, all my troubles seemed so far away.&#34; ... . %%R head(lyrics_2, 5) . [1] &#34;Yesterday, all my troubles seemed so far away.&#34; [2] &#34;Now it looks as though they&#39;re here to stay.&#34; [3] &#34;oh, I believe in yesterday.&#34; [4] &#34;Suddenly, I&#39;m not half the man I used to be.&#34; [5] &#34;There&#39;s a shadow hanging over me.&#34; . cat() &#54632;&#49688; . - print함수와 비슷하나 여러개의 출력이 가능하고 출력이 공백 없이 이어짐 . %%R print(&quot;a&quot;) print(&quot;b&quot;) . [1] &#34;a&#34; [1] &#34;b&#34; . %%R cat(&quot;a&quot;) cat(&quot;b&quot;) . ab . 9&#51109; - &#47928;&#51088;&#50676; &#51089;&#50629; . grep() &#54632;&#49688; . - grep(pattern, x)는 x에서 pattern이 있는 곳을 알려줌 . %%R grep(&quot;Yesterday&quot;, lyrics) . [1] 1 63 105 . %%R grep(&quot;yesterday&quot;, lyrics) . [1] 22 40 62 84 104 126 . - &quot;Yesterday&quot;는 1 ,63 ,105번째 요소에 있고 &quot;yesterday&quot;는 22, 40 ,62, 84, 104, 126번째 요소에 있음을 알려줌 . - 이번에는 &quot;?&quot;를 찾아보자 . - grep(&quot;?&quot;, lyrics)를 하면 될 것 같지만 아님 . %%R # collapse-output grep(&quot;?&quot;, lyrics) # %%R 셀에서는 collapse-output이 안됨...... . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 [91] 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 [109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 . - &quot;?&quot;는 정규표현식 기호로 사용되게 원래의 물음표 기호를 사용하고자 하면 &quot; &quot;을 앞에 넣어줘야함 &gt; 나중에 정규표현식 공부하자 . %%R grep(&quot; ?&quot;, lyrics) . [1] 47 89 . nchar() &#54632;&#49688; . - nchar(x)는 문자열 x의 길이를 알려줌(빈칸 포함) . %%R nchar(&quot;yesterday&quot;) . [1] 9 . - 문자열 벡터에도 적용 가능함 . %%R nchar(lyrics) . [1] 10 3 2 8 6 2 3 5 3 2 5 2 6 7 4 2 5 3 1 7 2 10 9 3 3 [26] 4 3 3 1 4 2 3 7 1 6 7 4 3 3 9 4 9 3 3 3 2 3 1 5 5 [51] 3 8 4 1 4 9 6 3 1 4 3 10 9 4 3 4 2 4 4 2 5 3 1 4 1 [76] 5 2 4 5 3 1 7 2 10 3 3 3 2 3 1 5 5 3 8 4 1 4 9 6 3 [101] 1 4 3 10 9 4 3 4 2 4 4 2 5 3 1 4 1 5 2 4 5 3 1 7 2 [126] 12 .",
            "url": "https://gkswotn12345.github.io/green/r/2021/08/20/R%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html",
            "relUrl": "/r/2021/08/20/R%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html",
            "date": " • Aug 20, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "파이썬 scipy.stats",
            "content": "- 확률분포를 scipy.stats를 통해 그리는데 익숙하지 않아 기본 사용에 대해 알아볼 거임 . - 참고: scipy.stats . - 참고: scipy 확률분포 . &#54869;&#47456;&#48516;&#54252; &#53364;&#47000;&#49828; . - scipy.stats를 통해 확률분포를 그려보자 . - 우선 확률분포에 대한 클래스 객체를 생성해야 함 . - 각 확률분포의 파라미터는 scipy.stats.이름을 통해 확인하자 . 종류 이름 확률분포 . 이산 | bernoulli | 베르누이 분포 | . 이산 | binom | 이항 분포 | . 이산 | poisson | 포아송 분포 | . 이산 | geom | 기하 분포 | . 이산 | nbinom | 음이항 분포 | . 이산 | hypergeom | 초기하 분포 | . 이산 | multinomial | 다항 분포 | . 연속 | norm | 정규 분포 | . 연속 | uniform | 균일 분포 | . 연속 | expon | 지수 분포 | . 연속 | gamma | 감마 분포 | . 연속 | t | t 분포 | . 연속 | chi2 | 카이제곱 분포 | . 연속 | f | f 분포 | . 연속 | beta | 베타 분포 | . &#47784;&#49688; &#51648;&#51221; . - 확률분포의 모수는 종류별로 다르므로 문서를 참고하자 . - 하지만 대부분 확률분포가 공통적으로 가지는 모수가 있음 . 모수 이름 의미 . loc | 기댓값 | . scale | 표준편차 | . &#54869;&#47456;&#48516;&#54252; methods . - 확률분포 클래스 객체가 가지는 method가 있음 . - 정규분포를 예로 들어 ppf에 대한 설명을 해보면 norm.ppf(0.5)는 정규분포에서 $50$분위수에 해당하는 $x$값으로 $0$이다 . 메서드 기능 . pmf | 확률질량함수 | . pdf | 확률밀도함수 | . cdf | 누적분포함수 | . ppf | 누적분포함수의 역함수(백분위 함수) | . sf | 생존함수 = 1 $-$ 누적분포함수 | . isf | 생존함수의 역함수 | . rvs | 무작위 표본 생성 | . &#54869;&#47456;&#48516;&#54252; plot . &#51221;&#44508; &#48516;&#54252; pdf . - 정규 분포 pdf를 그려보자 . import numpy as np import matplotlib.pyplot as plt from scipy.stats import norm xx = np.linspace(-5, 5, 1000) for scale in (0.5, 1.0, 2.0): plt.plot(xx, norm(0, scale).pdf(xx), label = &#39;μ = 0, σ = &#39; + str(scale), lw = 2, alpha = 0.8) plt.plot(xx, norm(-2, 0.5).pdf(xx), label = &#39;μ = -2, σ = 0.5&#39;, lw = 2, alpha = 0.8) plt.xticks(np.arange(-5, 6)) plt.yticks(np.arange(0.0, 1.2, 0.2)) plt.title(&quot;normal distribution pdf&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$f(x)$&quot;) plt.grid() plt.legend() plt.show() . &#51221;&#44508; &#48516;&#54252; cdf . - 정규 분포 cdf를 그려보자 . - cdf에 대한 내용 정리 예정 . import numpy as np import matplotlib.pyplot as plt from scipy.stats import norm xx = np.linspace(-5, 5, 1000) for scale in (0.5, 1.0, 2.0): plt.plot(xx, norm(0, scale).cdf(xx), label = &#39;μ = 0, σ = &#39; + str(scale), lw = 2, alpha = 0.8) plt.plot(xx, norm(-2, 0.5).cdf(xx), label = &#39;μ = -2, σ = 0.5&#39;, lw = 2, alpha = 0.8) plt.xticks(np.arange(-5, 6)) plt.yticks(np.arange(0.0, 1.2, 0.2)) plt.title(&quot;normal distribution cdf&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$f(x)$&quot;) plt.grid() plt.legend() plt.show() .",
            "url": "https://gkswotn12345.github.io/green/python/statistics/2021/08/10/scipy-stats.html",
            "relUrl": "/python/statistics/2021/08/10/scipy-stats.html",
            "date": " • Aug 10, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "가설검정",
            "content": "- 대표적인 확률분포에 대한 간단한 정리를 마친 후 작성할 예정임 &gt; 시작 . - 참고: Statistics: Unlocking the power of data, Robin Lock 외 4인 . &#51473;&#49900;&#44537;&#54620;&#51221;&#47532;(central limit theorem) . - 동일한 확률분포를 가진 독립확률변수 $n$개의 평균의 분포는 충분히 크다면($n geq 30$이면) 정규분포에 가까워짐 . - 앞으로 많은 가설검정에서 사용될 예정 . - 나중에 증명 추가 . &#54217;&#44512;&#50640; &#45824;&#54620; &#52628;&#47200; . - 양적 자료에서 관심 있는 모수는 종종 모집단 평균 $ mu$이다 . - ex) 우리나라 사람들의 평균 맥박수가 어느정도 되는지 궁금함 &gt; 평균에 대한 가설검증 . &#54364;&#48376; &#54217;&#44512;&#50640; &#45824;&#54620; &#51473;&#49900;&#44537;&#54620;&#51221;&#47532; . - 평균이 $ mu$이고 표준편차가 $ alpha$인 모집단에서 표본 크기 $n$이 충분히 클 때 표본 평균의 분포는 근사적으로 평균이 $ mu$이고 표준편차는 $ frac{ alpha}{ sqrt{n}}$인 정규분포를 따름 . - 하지만 위의 내용을 그대로 사용할 수 없음 . 모집단의 표준편차 $ alpha$를 모른다 &gt; 표본의 표준편차 $s$를 $ alpha$대신 사용 . | 추정된 표준오차 $ frac{s}{ sqrt{n}}$에 기반하여 표준화한 통계량의 분포는 표준정규분포를 따르지 않음 &gt; t 분포를 따름(t 분포 참고) . | &#54364;&#48376;&#51032; &#54364;&#51456;&#54200;&#52264;&#47484; &#49324;&#50857;&#54624; &#46412; &#54364;&#48376; &#54217;&#44512;&#51032; &#48516;&#54252; . - 평균이 $ mu$인 모집단에서 표본 크기 $n$인 무작위 표본을 뽑을 때 표본 평균의 분포는 중심이 $ mu$이고 표준오차는 $ frac{s}{ sqrt{n}}$으로 추정 . - 표본 평균을 표준화하면 자유도 $n-1$인 t 분포를 근사적으로 따름 . - 표본 크기 $n$이 커질수록 t분포는 표준정규분포와 가까워짐 . import scipy as sp . import scipy.stats . import matplotlib.pyplot as plt . import numpy as np . x = np.linspace(-5, 5, 100) rv_norm = sp.stats.norm(loc=0, scale=1) rv_t10 = sp.stats.t(df=10) rv_t5 = sp.stats.t(df=5) rv_t1 = sp.stats.t(df=1) norm_pdf = rv_norm.pdf(x) t10_pdf = rv_t10.pdf(x) t5_pdf = rv_t5.pdf(x) t1_pdf = rv_t1.pdf(x) legend = [&#39;z-dist&#39;, &#39;t(df=1)&#39;, &#39;t(df=5)&#39;, &#39;t(df=10)&#39;] plt.figure(figsize = (10, 6)) plt.plot(x, norm_pdf) plt.plot(x, t1_pdf) plt.plot(x, t5_pdf) plt.plot(x, t10_pdf) plt.title(&quot;z-dist, t-dist(df=1, 5, 10)&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$p(x)$&quot;) plt.grid() plt.legend(legend) plt.show() . - 위의 plot을 보면 자유도가 커질수록 t분포가 표준정규분포에 가까워짐을 알 수 있음 . - 나중에 plot그리는데 사용되는 lib와 사용법 추가 예정 . t &#48516;&#54252; &#49324;&#50857; &#51312;&#44148; . - 표본 크기 $n geq30$이면 문제 없음 . - 만약 표본 크기 $n$이 작다면? &gt; 모집단이 정규분포를 따라야 함 . - 근데 모집단이 정규분포 따르는지 모른다 &gt; 대신에 표본이 정규분포를 따르는지 확인하자 &gt; shapiro.test 실시 . - 표본에 이상점이 있거나 비대칭이면 t 분포 사용$ times$ . - 표본이 정규분포를 따르는 것 같다 &gt; $ bar{x}$의 분포는 정규분포를 따른다 &gt; t-test 실시해도 괜찮다 . &#54217;&#44512;&#50640; &#45824;&#54620; t&#44160;&#51221; . - 영가설 $H_0: mu= mu_0$를 검정하는 t-통계량은 다음과 같음 . - $t= frac{ bar{x}- mu_0}{ frac{s}{ sqrt{n}}}$ . - $ bar{x}$는 표본 평균, $s$는 표본에서 계산한 표준편차 . - p-값을 통해 영가설을 기각할지 기각하지 못하는지를 결정 &gt; 가설검정 용어(영가설, p-값 등등)에 대해 나중에 정리 예정 . - 검증의 p-값은 자유도가 $n-1$인 t분포에서 대안가설에 적절한 꼬리쪽의 비율을 계산 . &#54217;&#44512;&#50640; &#45824;&#54620; t&#44160;&#51221; &#50696;&#51228; . 문제 | . - 사람의 평균 체온이 $36.5^{°} mathrm{C}$인지 검정하기 위해 건강한 사람 50명의 체온을 재었다 . - 임의로 데이터를 설정하여 평균 체온 데이터는 평균이 36.3, 표준편차는 0.5인 정규분포에서 추출했음 . - 임의로 뽑은 표본을 살펴보니 $ bar{x} = 36.35, ;s=0.5$이다 . - 위의 데이터는 사람의 평균 체온이 $36.5^{°} mathrm{C}$와는 다르다는 증거인지 유의수준 $ alpha=0.05$ 에서 검정하자 . 해결 과정 | . - $H_0: mu=36.5, ;H_a: mu neq36.5$ . - 표본 크기가 충분하고 표본에 대한 히스토그램을 보면 정규분포를 따르는 것으로 보인다 . import rpy2 import os os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; %load_ext rpy2.ipython . The rpy2.ipython extension is already loaded. To reload it, use: %reload_ext rpy2.ipython . import matplotlib.pyplot as plt import numpy as np ## 예시 샘플 np.random.seed(2021) sample = np.random.normal(loc = 36.3, scale = 0.5, size = 50) plt.hist(sample) plt.title(&#39;body heat data&#39;) plt.show() %R -i sample . - 샤피로 윌크 검정을 통해 정규성을 정확히 확인하자 . %%R shapiro.test(sample) . Shapiro-Wilk normality test data: sample W = 0.98456, p-value = 0.7524 . - p-값이 크므로 영가설(표본은 정규분포를 따름)을 기각할 수 없으므로 표본의 정규성을 가정 . - t통계량을 직접 구해도 됨 &gt; $t= frac{ bar{x}- mu_0}{ frac{s}{ sqrt{n}}} = frac{36.35-36.5}{ frac{0.5}{ sqrt{50}}}=-2.12$ . - 하지만 매번 직접 구하기 귀찮으므로 R을 통해 구해보도록 하자 + p-값도 구해줌 . - 사실 파이썬으로도 가능하지만 내가 모르는 관계로 R로 하고 나중에 따로 공부하자 . %%R print(mean(sample)) ## 평균 print(sd(sample)) ## 분산 . [1] 36.35498 [1] 0.5006206 . %%R t.test(sample, mu = 36.5, alternative = &#39;two.sided&#39;, conf.level = 0.95) . One Sample t-test data: sample t = -2.0483, df = 49, p-value = 0.04591 alternative hypothesis: true mean is not equal to 36.5 95 percent confidence interval: 36.21271 36.49726 sample estimates: mean of x 36.35498 . - p-값을 보면 0.04591로 유의수준인 0.05보다 작음 &gt; 영가설을 기각한다 . - 따라서 표본에 따르면 사람의 평균 체온은 $36.5^{°} mathrm{C}$와 다르다고 할 수 있다 . - 임의로 만든 표본은 평균이 36.3인 정규분포에서 추출한 것이므로 올바르게 추론한 것을 알 수 있음 . &#54217;&#44512; &#52264;&#51060; &#48516;&#54252; . - 단일 평균에 대한 t검정과 차이점은 표본이 하나인가 둘인가이다 . - 평균 차이에 대한 t검정에서 관심있는 모수는 $ mu_1 - mu_2$이다 . - 평균이 $ mu_1$과 $ mu_2$인 모집단에서 표본크기가 $n_1$과 $n_2$인 무작위 표본을 얻었을 때 표본 평균 차이 $ bar{x_1}- bar{x_2}$의 분포는 중심이 모집단 평균 차이$ mu_1- mu_2$이고 표준오차는 $ sqrt{ frac{{s_1}^{2}}{n_1}+ frac{{s_2}^2}{n_2}}$이다 . - 표본 평균 차이를 표준화한 값은 t분포를 따르며 자유도는 근사적으로 $n_1+n_2-2$ . - $n_1 &lt;30$ or $n_2&lt;30$인 경우 표본 크기가 작으며 이 경우에는 모집단이 정규분포를 따라야 함 . - 평균 차이를 검정할 땐 두 집단이 서로 독립인지 아닌지가 중요함 &gt; 독립여부에 따라 검정 방법이 달라짐 . - 여기서는 독립표본에 대해 얘기할 것 임 . - 두 집단의 분산의 동질성이 중요함 &gt; 평균 차이 검정을 하기 전에 분산의 동질성 검정을 수행함 . - 분산이 같은 경우 student&#39;s t-test를 사용하고 분산이 다른 경우 Welch&#39;s t test사용함 . &#54217;&#44512; &#52264;&#51060;&#50640; &#45824;&#54620; t&#44160;&#51221; . - 영가설 $H_0: mu_1- mu_2=0$를 검정하는 t-통계량은 다음과 같음 . - $t= frac{( bar{x_1}- bar{x_2})-0}{ sqrt{ frac{{s_1}^2}{n_1}+ frac{{s_2}^2}{n_2}}}$ . - $ bar{x_1}$과 $ bar{x_2}$는 표본 평균, $s_1$과 $s_2$는 표본의 표준편차 . &#54217;&#44512; &#52264;&#51060;&#50640; &#45824;&#54620; t&#44160;&#51221; &#50696;&#51228; . 문제 | . - 남자의 평균 체온$( bar{x_1})$과 여자의 평균 체온$( bar{x_2})$이 다른지 검정하기 위해 각각 건강한 사람 50명의 체온을 재었다 . - 임의로 데이터를 설정하여 남자의 평균 체온 데이터는 평균이 36.5, 표준편차는 0.4인 정규분포에서 추출했음 . - 임의로 데이터를 설정하여 여자의 평균 체온 데이터는 평균이 36.45, 표준편차는 0.5인 정규분포에서 추출했음 . - 임의로 뽑은 표본을 보니 $ bar{x_1} = 36.54, ; bar{x_2} = 36.5, ; s_1=0.4, ;s_2=0.53$이다 . - 위의 데이터는 남자와 여자의 평균 체온이 서로 다르다는 증거인지 유의수준 $ alpha=0.05$ 에서 검정하자 . 해결 과정 | . - $H_0: mu_1- mu_2 = 0, ;H_a: mu_1 neq mu_2$ . - 표본 크기가 충분하고 표본에 대한 히스토그램을 보면 정규분포를 따르는 것으로 보인다 . - 남자 모집단과 여자 모집단에서 표본을 추출했으므로 두 표본은 서로 독립이다 . import rpy2 import os os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; %load_ext rpy2.ipython . C: anaconda3 envs py38r40 lib site-packages rpy2 robjects packages.py:366: UserWarning: The symbol &#39;quartz&#39; is not in this R namespace/package. warnings.warn( . import matplotlib.pyplot as plt import numpy as np ## 예시 샘플 np.random.seed(2021) man_heat = np.random.normal(loc = 36.5, scale = 0.4, size = 50) woman_heat = np.random.normal(loc = 36.45, scale = 0.5, size = 50) fig, ax = plt.subplots(1, 2, figsize = (10, 4)) ax[0].hist(man_heat) ax[1].hist(woman_heat) ax[0].set_title(&#39;man body heat data&#39;) ax[1].set_title(&#39;woman body heat data&#39;) plt.show() %R -i man_heat,woman_heat . - 두 표본이 정규성을 따르는지 정확히 확인하자 . %%R shapiro.test(man_heat) . Shapiro-Wilk normality test data: man_heat W = 0.98456, p-value = 0.7524 . %%R shapiro.test(woman_heat) . Shapiro-Wilk normality test data: woman_heat W = 0.96223, p-value = 0.1102 . - 둘다 p-값이 크므로 정규성을 가정하자 . - 평균 차이 검정을 하기전에 우선 두 표본의 분산이 동일한지 검정하자 . - var.test는 두 집단의 분산이 동일한지 비교함 ratio(두 집단 분산의 비율)이 1이 아니라면 두 집단의 분산이 다르다는 증거임 . %%R print(mean(man_heat)) print(sd(man_heat)) print(mean(woman_heat)) print(sd(woman_heat)) . [1] 36.54399 [1] 0.4004965 [1] 36.52622 [1] 0.5260057 . %%R var.test(man_heat, woman_heat, ratio = 1, alternative = &quot;two.sided&quot;, conf.level = 0.95) . F test to compare two variances data: man_heat and woman_heat F = 0.57972, num df = 49, denom df = 49, p-value = 0.05916 alternative hypothesis: true ratio of variances is not equal to 1 95 percent confidence interval: 0.3289758 1.0215715 sample estimates: ratio of variances 0.5797175 . - 두 집단의 분산이 같은지 검정하니 p-값이 0.05보다 크기 때문에 다르다고 할만한 충분한 증거가 없으므로 동일하다 가정함 . - 분산이 각각 0.4와 0.5인 집단에서 표본을 추출하여 원래는 분산이 다르지만 표본크기가 작기 때문에 0.1의 차이를 판단하지 못하였음 . - 아무튼 var.test 결과는 분산이 동일하다 나왔으므로 두 집단의 분산이 동일하다 생각하고 평균 차이를 검정하자 . %%R t.test(man_heat, woman_heat, alternative = &#39;two.sided&#39;, var.equal = T, conf.level = 0.95) . Two Sample t-test data: man_heat and woman_heat t = 0.19001, df = 98, p-value = 0.8497 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: -0.1677758 0.2033056 sample estimates: mean of x mean of y 36.54399 36.52622 . - 검정결과를 보면 p-값이 0.05보다 크므로 영가설을 기각하지 못함 &gt; 남자와 여자의 평균체온을 다르다고 할 수 없음 . - 실제 데이터는 평균이 36.5와 36.45로 다르지만 표본의 크기가 충분하지 않아 이를 잡아내지 못함 . - 표본 크기가 50이 아니라 더욱 커진다면 위의 차이를 알아낼 수 있음 . &#45824;&#51025;&#54364;&#48376;&#50640; &#45824;&#54620; &#54217;&#44512; &#52264;&#51060; t&#44160;&#51221; . - 위에서 두 개의 개별 표본일 때 평균 차이 검정을 했음 . - 하지만 자료가 짝으로 주어졌다면 위와 동일한 방법으로 검정을 수행하면 안됨 . - 짝 자료 &gt; 동일한 피실험체를 두 가지 다른 조건에서 측정한 데이터 ex) 개별 사람의 왼손과 오른손 악력, 약을 복용하기 전과 후의 혈압 . - 조건이 동일하다면 동일한 피실험체가 아니어도 가능함 &gt; ex) 일란성 쌍둥이의 IQ . - 짝 자료에 대한 평균 차이 검정은 우선 각 짝 자료의 차이를 계산한 후 차이에 대한 평균 $ bar{x_d}$, 표준편차 $s_d$, 표본 크기 $n_d$를 계산 . - $t = frac{ bar{x_d} - 0}{ frac{s_d}{ sqrt{n_d}}}$를 자유도가 $n_d-1$인 t분포에서 검정함 . &#45824;&#51025; &#54364;&#48376;&#50640; &#45824;&#54620; &#54217;&#44512; &#52264;&#51060; t&#44160;&#51221; &#50696;&#51228; . 문제 | . - 소설을 읽을 때 스토리 스포일러를 포함한 경우와 그렇지 않은 경우에 대해 즐거움의 등급(점수)차이가 있는지 유의수준 $ alpha=0.05$ 에서 검정하자 . - 등급이 높을 수록 스토리가 더 재밌었다는 것을 의미함 . - 12개 스토리의 각 버전은 최소 30명이 읽고 1~10등급으로 등급을 매겼음 . - 스포일러 유 &gt; 4.7, 5.1, 7.9, 7.0, 7.1, 7.2, 7.1, 7.2, 4.8, 5.2, 4.6, 6.7 . - 스포일러 무 &gt; 3.8, 4.9, 7.4, 7.1, 6.2, 6.1, 6.7, 7.0, 4.3, 5.0, 4.1, 6.1 . 해결 과정 | . - 12개의 스토리를 동일한 조건(무작위 샘플링)을 지닌 사람이 두 가지 처리(스포일러 유무)를 받아 읽고 등급을 평가함 &gt; 대응 표본 . import rpy2 import os os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; %load_ext rpy2.ipython . C: anaconda3 envs py38r40 lib site-packages rpy2 robjects packages.py:366: UserWarning: The symbol &#39;quartz&#39; is not in this R namespace/package. warnings.warn( . %%R install.packages(&#39;ggplot2&#39;) library(ggplot2) . Please select a CRAN mirror for use in this session . R[write to console]: trying URL &#39;https://cran.seoul.go.kr/bin/windows/contrib/4.0/ggplot2_3.3.5.zip&#39; R[write to console]: Content type &#39;application/zip&#39; R[write to console]: length 4129414 bytes (3.9 MB) R[write to console]: downloaded 3.9 MB . package &#39;ggplot2&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: tmp Rtmp0OKRvu downloaded_packages . %%R with_spoiler &lt;- c(4.7, 5.1, 7.9, 7.0, 7.1, 7.2, 7.1, 7.2, 4.8, 5.2, 4.6, 6.7) original &lt;- c(3.8, 4.9, 7.4, 7.1, 6.2, 6.1, 6.7, 7.0, 4.3, 5.0, 4.1, 6.1) diff &lt;- with_spoiler - original diff_df &lt;- as.data.frame(diff) ggplot(diff_df, aes(x = diff)) + xlab(&#39;Difference&#39;) + geom_dotplot(binwidth = 0.1) . - 짝 자료 차이에 대한 점도표를 보면 정규분포를 부정할 만한 비대칭이나 이상점은 없어보임 . %%R shapiro.test(diff) . Shapiro-Wilk normality test data: diff W = 0.95506, p-value = 0.7116 . - 샤피로 윌크 검정도 해보니 정규분포임을 가정해도 괜찮아 보임 . %%R t.test(with_spoiler, original, paired = T, alternative = &#39;two.sided&#39;, conf.level = 0.95) . Paired t-test data: with_spoiler and original t = 4.8997, df = 11, p-value = 0.0004719 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 0.2708052 0.7125281 sample estimates: mean of the differences 0.4916667 . - R에서 대응 표본에 대한 검정을 하려면 paried = T 옵션을 적용한다 . - p-값이 0.0004719로 매우 작으므로 영가설을 기각하자 &gt; 스포일러 유무에 따른 재미의 등급은 차이가 있다! .",
            "url": "https://gkswotn12345.github.io/green/python/statistics/2021/07/27/%EA%B0%80%EC%84%A4%EA%B2%80%EC%A0%95.html",
            "relUrl": "/python/statistics/2021/07/27/%EA%B0%80%EC%84%A4%EA%B2%80%EC%A0%95.html",
            "date": " • Jul 27, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "matplotlib 기본 사용법",
            "content": "- 파이썬으로 그래프를 그리는데 matplotlib에 대해 너무 무지하단 생각이 들어 작성함 . - 참고 자료: https://wikidocs.net/92071 . - 위에 참고 자료를 보면서 공부할 예정 . - 실행이 안된다면 모듈 import 했는지 확인 . 01. matplotlib &#44592;&#48376; &#49324;&#50857; . - matplotlib 라이브러리를 이용해서 그래프를 그려보자 . - 그 중에서도 pyplot 사용할 것 임 . &#44592;&#48376; &#44536;&#47000;&#54532; . - pyplot을 이용해서 간단하게 시각화 가능 . - plt.plot() 에 하나의 숫자 리스트를 입력함으로써 아래와 같은 그래프가 그려짐 . - plt.plot()은 하나의 리스트만 입력되면 리스트의 값들이 y 값들이라고 가정하고, x 값 [0, 1, 2, 3] (default)을 자동으로 만듦 . import matplotlib.pyplot as plt plt.plot([1, 2, 3, 4]) plt.show() . - plot() 함수는 다양한 기능을 포함하고 있어서, 임의의 개수의 인자를 받을 수 있음 . - 아래와 같이 두 개의 리스트를 입력하면 순서대로 x, y값으로 생각하고 그래프를 나타냄 . plt.plot([1, 2, 3, 4], [10, 20, 30, 40]) . [&lt;matplotlib.lines.Line2D at 0x20767bee700&gt;] . - plt.show() 는 화면에 표시하는 기능을 하는데 Jupyter를 사용할 때는 자동으로 표시되기 때문에 호출할 필요가 없음 . &#49828;&#53440;&#51068; &#51648;&#51221;&#54616;&#44592; . - x, y 값 인자에 대해 선의 색상과 형태를 지정하는 포맷 문자열을 세번째 인자에 입력할 수 있음 &gt; 후에 더 자세히 알아보자 . - axis()를 이용해서 축의 범위 [xmin, xmax, ymin, ymax]를 지정함 . - linewidth를 통해 선 두께 조절 . - markersize를 통해 마커 사이즈 조절 . import matplotlib.pyplot as plt plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;ro--&#39;, linewidth = 3, markersize = 9) plt.axis([0, 6, 0, 20]) plt.show() ## plt.show()를 사용하지 않으면 그래프는 똑같이 출력되나 plt.axis()의 값인 [0, 6, 0, 20]이 출력되므로 깔끔한 plot을 원한다면 plt.show()를 하자 ## plt.axis()없이 plt.plot()만 해도 위의 그래프와 같이 type이 출력되므로 plt.show()를 하자 . &#50668;&#47084; &#44060;&#51032; &#44536;&#47000;&#54532; &#44536;&#47532;&#44592; . - matplotlib는 대개 numpy array를 이용 . - plt.plot()에서 (x, y, 스타일)을 여러쌍 입력하면 한 화면에 여러 개의 그래프가 그려짐 . import numpy as np x = np.arange(0, 5, 0.2) ## 0부터 5까지 0.2간격으로 객체 생성 # 빨간 대쉬, 파란 사각형, 녹색 삼각형 plt.plot(x, x, &#39;r--&#39;) plt.plot(x, x**2, &#39;bs&#39;) plt.plot(x, x**3, &#39;g^&#39;) ## plt.plot(x, x, &#39;r--&#39;, x, x**2, &#39;bs&#39;, x, x**3, &#39;g^&#39;) 도 동일한 결과를 나타냄 plt.show() . - plt.plot(x, x, &#39;r--&#39;, x, x**2, &#39;bs&#39;, x, x**3, &#39;g^&#39;) 도 동일한 결과를 나타냄 . 02. matplotlib &#52629; &#47112;&#51060;&#48660; &#49444;&#51221; . - plt.xlabel(), plt.ylabel()을 통해 그래프의 x, y축에 대한 label(레이블)을 표시할 수 있음 . plt.plot([1, 2, 3, 4], [1, 4, 9, 16]) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.show() . 03. matplotlib &#49828;&#53440;&#51068; &#51648;&#51221; . - 특별한 입력이 없으면 그래프가 실선으로 그려짐 . - 색깔, 선 타입, 마커를 지정하여 그래프를 그릴 수 있음 . - &#39;ro--&#39;는 red circle dashed, &#39;ro--&#39;에서 r, o, --의 순서는 상관없음 &#39;o--r&#39;도 가능 . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;ro--&#39;) ## `r`는 red, &#39;o&#39;는 circle, `--`는 dashed, `r--`는 red dashed, &#39;ro--&#39;에서 r, o, --의 순서는 상관없음 &#39;o--r&#39;도 가능 ## 레이블 설정 plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) ## x, y축 범위 설정 plt.axis([0, 5, 0, 20]) plt.show() . &#49353;&#44628;, &#49440;, &#47560;&#52964; &#54364;&#49884; &#54805;&#49885; . - color, linestyle, marker 인자를 통해 색깔, 선, 마커 선택 가능 . Colors . - 색깔 종류 정리 . character color . &#39;b&#39; | blue | . &#39;g&#39; | green | . &#39;r&#39; | red | . &#39;c&#39; | cyan | . &#39;m&#39; | megenta | . &#39;y&#39; | yellow | . &#39;k&#39; | black | . &#39;w&#39; | white | . Line Styles . - 선 타입 종류 정리 . character line style . &#39;-&#39; | soild | . &#39;--&#39; | dashed | . &#39;-.&#39; | dash-dot | . &#39;:&#39; | dotted | . Markers . - 마커 종류 정리 . character marker . &#39;.&#39; | point | . &#39;,&#39; | pixel | . &#39;o&#39; | circle | . &#39;v&#39; | triangle_down | . &#39;^&#39; | triangle_up | . &#39;&lt;&#39; | triangle_left | . &#39;&gt;&#39; | triangle_right | . &#39;1&#39; | tir_down | . &#39;2&#39; | tri_up | . &#39;3&#39; | tri_left | . &#39;4&#39; | tri_right | . &#39;s&#39; | square | . &#39;p&#39; | pentagon | . &#39;*&#39; | star | . &#39;h&#39; | hexagon1 | . &#39;H&#39; | hexagon2 | . &#39;+&#39; | plus | . &#39;X&#39; | X marker | . &#39;D&#39; | diamond | . &#39;d&#39; | thin_diamond | . &#39;|&#39; | vline | . &#39;_&#39; | hline | . 04. matplotlib &#49353;&#49345; &#51648;&#51221; . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], color = &#39;springgreen&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.axis([0, 5, 0, 20]) plt.show() . - 위와 같이 color 인자를 통해 더욱 다양한 색상의 이름을 지정 가능 . - 사용 가능 색상 확인: plt colors . Hex code &#49324;&#50857; . - 16진수 코드 (Hex code) 로 더욱 다양한 색상을 지정 가능 . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], color = &#39;#e35f62&#39;, marker = &#39;o&#39;, linestyle = &#39;--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.axis([0, 5, 0, 20]) plt.show() . - marker 인자로 마커 지정 가능 . - linestyle 인자로 선 타입 지정 가능 . - 색상 참고: HTML Color Codes . 05. matplotlib &#44536;&#47000;&#54532; &#50689;&#50669; &#52292;&#50864;&#44592; . - 그래프의 특정 영역을 색상으로 채워서 강조 가능 . - 3가지 함수가 존재: fill_between(), fill_betweenx(), fill() . - [$ star$] x, y의 인덱스를 다르게 해도 되지만 범위가 맞지 않아 그래프와 무관한 사각형을 그린다 [$ star$] . &#44592;&#48376; &#49324;&#50857; . - alpha는 투명도, color는 색상 . import matplotlib.pyplot as plt x = [1, 2, 3, 4] y = [1, 4, 9, 16] plt.plot(x, y, &#39;ko--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.fill_between(x[1:3], y[1:3], color = &#39;red&#39;, alpha = 0.5) ## fill_between() 사용 plt.show() . - fill_between() 함수에 x[1:3], y[1:3]를 순서대로 입력하면, 네 점 (x[1], y[1]), (x[2], y[2]), (x[1], 0), (x[2], 0)을 잇는 영역이 채워짐 . - 일반화 해보면? . - fill_between() 함수에 x[a:a+2], y[b:b+2]를 순서대로 입력하면, 네 점 (x[a], y[a]), (x[a+1], y[a+1]), (x[a], 0), (x[a+1], 0)을 잇는 영역이 채워짐 . - x축에 대한 적분이라 생각하자 . x = [1, 2, 3, 4] y = [1, 4, 9, 16] plt.plot(x, y, &#39;g*:&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.fill_betweenx(y[1:3], x[1:3], color =&#39;cyan&#39;, alpha = 0.5) ## fill_betweenx() 사용 plt.show() . - fill_betweenx() 함수에 x[1:3], y[1:3]를 순서대로 입력하면, 네 점 (x[1], y[1]), (x[2], y[2]), (0, y[1]), (0, y[2])을 잇는 영역이 채워짐 . - 일반화 해보면? . - fill_betweenx() 함수에 x[a:a+2], y[a:a+2]를 순서대로 입력하면, 네 점 (x[a], y[a]), (x[a+1], y[a+1]), (0, y[a]), (0, y[a+1])을 잇는 영역이 채워짐 . - y축에 대한 적분이라 생각하자 . &#46160; &#44536;&#47000;&#54532; &#49324;&#51060; &#50689;&#50669; &#52292;&#50864;&#44592; . - fill_between()을 사용하면 x축에 대한 적분, fill_betweenx()를 사용하면 y축에 대한 적분과 같이 두 그래프 사이 영역을 채울 수 있음 . fill_between() . x1 = [1, 2, 3, 4] y1 = [1, 4, 9, 16] y2 = [1, 2, 1, 8] plt.plot(x1, y1, &#39;rd--&#39;) plt.plot(x1, y2, &#39;bd--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.fill_between(x1[1:3], y1[1:3], y2[1:3], color = &#39;gray&#39;, alpha = 0.5) ## x1, y1, y2순서 매우 중요 plt.show() . - x축 기준으로 두 개의 그래프 커브 사이 영역을 채우기 위해서는 하나의 값 x1과 두 개의 y 값 시퀀스 y1, y2를 입력 . - 네 점 (x1[1], y1[1]), (x1[1], y2[1]), (x1[2], y1[2]), (x1[2], y2[2]) 사이 영역이 채워짐 . - 일반화하면 네 점 (x1[a], y1[a]), (x1[a], y2[a]), (x1[a+1], y1[a+1]), (x1[a+1], y2[a+1]) 사이 영역이 채워짐 . - x1, y1, y2순서 매우 중요 &gt; 한 개의 값 x1을 앞에 배치 . fill_betweenx() . x1 = [1, 4, 9, 16] x2 = [1, 2, 4, 8] y1 = [1, 2, 3, 4] plt.plot(x1, y, &#39;rd--&#39;) plt.plot(x2, y, &#39;bd--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.fill_betweenx(y[1:3], x1[1:3], x2[1:3], color = &#39;gray&#39;, alpha = 0.5) ## x1, x2, y1순서 매우 중요 plt.show() . - y축 기준으로 두 개의 그래프 커브 사이 영역을 채우기 위해서는 하나의 값 y1와 두 개의 x 값 시퀀스 x1, x2를 입력 . - 네 점 (x1[1], y1[1]), (x2[1], y1[1]), (x1[2], y1[2]), (x2[2], y1[2]) 사이 영역이 채워짐 . - 일반화하면 네 점 (x1[a], y1[a]), (x2[a], y1[a]), (x1[a+1], y1[a+1]), (x2[a+1], y1[a+1]) 사이 영역이 채워짐 . - y1, x1, x2순서 매우 중요 &gt; 한 개의 값 y1을 앞에 배치 . &#51076;&#51032;&#51032; &#50689;&#50669; &#52292;&#50864;&#44592; . - fill() 함수에 x, y 값의 리스트를 입력해주면, 각 x, y 점들로 정의되는 다각형 영역을 자유롭게 지정해서 채운다 . x1 = [1, 2, 3, 4] y1 = [1, 4, 9, 16] y2 = [1, 2, 4, 8] plt.plot(x1, y1, &#39;go--&#39;) plt.plot(x1, y2, &#39;bo--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.fill([1.9, 1.9, 3.1, 3.1], [2, 5, 11, 8], color = &#39;lightgray&#39;, alpha = 0.5) plt.show() . 06. matplotlib &#44536;&#47532;&#46300; &#49444;&#51221; . - 데이터의 위치를 더 명확하게 하기 위해 그래프에 grid() 함수를 이용해서 그리드(격자)를 표시할 수 있음 . - plt.grid(True, axis = &#39;type)와 같이 설정하면, 그래프의 x, y축에 대해 그리드가 표시 . - type은 &#39;x&#39;, &#39;y&#39;, &#39;both&#39;(default) 존재 . - grid()도 선의 스타일 설정 가능 . - which 파라미터를 &#39;major&#39;, &#39;minor&#39;, &#39;both&#39; 등으로 사용하면 주눈금, 보조눈금에 각각 그리드를 표시할 수 있음 &gt; 나중에 더 자세히 . x = np.arange(0, 2, 0.2) plt.plot(x, x, &#39;bo--&#39;) plt.plot(x, x**2, &#39;ro--&#39;, linewidth = 2) plt.plot(x, x**3, &#39;go--&#39;, markersize = 5) plt.grid(True, axis = &#39;both&#39;, color = &#39;k&#39;, alpha = 0.5, linestyle = &#39;--&#39;, which = &#39;major&#39;) plt.show() . 07. matplotlib &#45576;&#44552; &#54364;&#49884; . - tick은 그래프의 축에 간격을 구분하기 위해 표시하는 눈금 . &#44592;&#48376; &#49324;&#50857; . - xticks(), yticks() 함수는 각각 x축, y축에 눈금을 표시 . - 리스트 또는 numpy array를 입력하면, 해당하는 위치에 눈금과 숫자 레이블이 표시 . a = np.arange(0, 2, 0.2) plt.plot(a, a, &#39;b^&#39;) plt.plot(a, a**2, &#39;r^&#39;, linewidth = 2) plt.plot(a, a**3, &#39;g^&#39;, markersize = 7) plt.xticks([0, 1, 2]) plt.yticks(np.arange(1, 6)) plt.show() . &#45576;&#44552; &#47112;&#51060;&#48660; &#51648;&#51221; . - labels 파라미터를 사용하면 눈금 레이블을 명시적으로 지정 . x = np.arange(0, 2.4, 0.2) plt.plot(x, x, &#39;b*--&#39;) plt.plot(x, x**2, &#39;r*--&#39;, linewidth = 2) plt.plot(x, x**3, &#39;g*--&#39;, markersize = 7) plt.xticks(x, labels = [&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;]) plt.yticks(np.arange(0,12), (&#39;1M&#39;, &#39;2M&#39;, &#39;3M&#39;, &#39;4M&#39;, &#39;5M&#39;, &#39;6M&#39;, &#39;7M&#39;, &#39;8M&#39;, &#39;9M&#39;, &#39;10M&#39;, &#39;11M&#39;, &#39;12M&#39;)) ## labels 없어도 적용됨 plt.show() . &#45576;&#44552; &#49828;&#53440;&#51068; &#49444;&#51221; . tick_params() 함수를 사용하면 눈금의 스타일을 다양하게 설정 &gt; R의 ggplot2의 axe()와 비슷 | . - axis는 설정이 적용될 축을 지정 &gt; &#39;x&#39;, &#39;y&#39;, &#39;both&#39; 중 선택 . - direction은 눈금을 안/밖으로 표시 &gt; &#39;in&#39;, &#39;out&#39;, &#39;inout&#39; 중 선택 . - length는 눈금의 길이를 지정 . - pad는 눈금과 레이블과의 거리를 지정 . - labelsize는 레이블의 크기를 지정 . - labelcolor는 레이블의 색상을 지정 . - top/bottom/left/right를 True/False로 지정하면 눈금이 표시될 위치를 선택 &gt; default: left, bottom . - width는 눈금의 너비를 지정 . - color는 눈금의 색상을 지정 . x = np.arange(0, 2.4, 0.2) plt.plot(x, x, &#39;b*--&#39;) plt.plot(x, x**2, color = &#39;#e35f62&#39;, marker = &#39;*&#39;, linestyle = &#39;--&#39;, linewidth=2) plt.plot(x, x**3, color = &#39;springgreen&#39;, marker = &#39;*&#39;, linestyle = &#39;--&#39;, markersize = 7) plt.xticks(x, labels = [&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;]) plt.yticks(np.arange(0,12), (&#39;1M&#39;, &#39;2M&#39;, &#39;3M&#39;, &#39;4M&#39;, &#39;5M&#39;, &#39;6M&#39;, &#39;7M&#39;, &#39;8M&#39;, &#39;9M&#39;, &#39;10M&#39;, &#39;11M&#39;, &#39;12M&#39;)) ## labels 없어도 적용됨 plt.tick_params(axis = &#39;y&#39;, direction = &#39;in&#39;, length = 3, pad = 6, labelsize = 11, labelcolor = &#39;red&#39;, right = True) plt.tick_params(axis = &#39;x&#39;, direction = &#39;inout&#39;, length = 10, pad = 15, labelsize = 12, width = 2, color = &#39;b&#39;, top = True) plt.show() . 08. matplotlib &#53440;&#51060;&#53952; &#49444;&#51221; . - title() 함수를 이용해서 그래프의 제목을 설정 . &#44592;&#48376; &#49324;&#50857; . - loc를 통해 상단 중 제목의 위치를 지정 가능 &gt; left, right, center(default) . - pad는 title과 그래프와의 간격(오프셋)을 포인트 단위로 설정 . import matplotlib.pyplot as plt import numpy as np plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;ro--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.title(&#39;$x^2$ plot&#39;, loc = &#39;right&#39;, pad = 10) ## pad는 title과 그래프와의 간격을 포인트 단위로 설정 plt.show() . &#54256;&#53944; &#51648;&#51221; . - fontdict에 딕셔너리 형태로 폰트에 대한 설정을 입력 . - 참고1: matplotlib default font . - 참고2: matplotlib writing mathematical expressions . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;ro--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.grid(True) plt.title(&#39;$x^2$ plot&#39;, fontdict = title_font, loc = &#39;center&#39;, pad = 10) ## pad는 title과 그래프와의 간격을 포인트 단위로 설정 title_font = { &#39;fontsize&#39;: 16, &#39;fontweight&#39;: &#39;bold&#39; } plt.show() . 09. matplotlib &#49688;&#51649;&#49440;/&#49688;&#54217;&#49440; &#54364;&#49884; . - 그래프의 특정 값에 해당하는 위치에 수직선/수평선을 표시하기 위해서 axhline(), axvline(), hlines(), vlines() 사용 . &#44592;&#48376; &#49324;&#50857; - axhline()/axvline() . - axhline() 함수의 1번째 인자는 y 값 으로서 수평선의 위치 . - 2, 3번째 인자는 xmin, xmax 값 으로서 0에서 1 사이의 값 . - 0은 왼쪽 끝(y축), 1은 오른쪽 끝을 의미 . - axvline() 함수의 1번째 인자는 x 값 으로서 수직선의 위치 . - 2, 3번째 인자는 ymin, ymax 값 으로서 0에서 1 사이의 값 . - 0은 아래쪽 끝(x축), 1은 위쪽 끝을 의미 . - 2, 3번째 인자를 생략하면 직선을 그려줌(default) + 0~1사이의 값은 비율임 &gt; ex) 0.5는 중간 . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;ro--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.title(&#39;$x^2$ plot&#39;, loc = &#39;center&#39;, pad = 15) plt.axhline(4, 0, 0.35, color = &#39;gray&#39;, linestyle = &#39;--&#39;, linewidth = 2) plt.axvline(2, 0, 0.23, color = &#39;gray&#39;, linestyle = &#39;--&#39;, linewidth = 2) plt.show() . &#44592;&#48376; &#49324;&#50857; - hlines()/vlines() . - axhline()/axvline()는 수직선/수평선을 비율로 그리는 반면 hlines()/vlines() 는 좌표를 지정해서 그림 . - hlines() 함수에 y, xmin, xmax를 순서대로 입력하면 점 (xmin, y)에서 점 (xmax, y)를 따라 수평선을 표시 . - vlines() 함수에 x, ymin, ymax를 순서대로 입력하면 점 (x, ymin)에서 점 (x, ymax)를 따라 수직선을 표시 . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;bo--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.title(&#39;$x^2$ plot&#39;, loc = &#39;center&#39;, pad = 15) plt.hlines(9, 2, 3, color = &#39;k&#39;, linestyle = &#39;--&#39;, linewidth = 2) plt.vlines(2, 4, 9, color = &#39;k&#39;, linestyle = &#39;--&#39;, linewidth = 2) plt.show() . 10. matplotlib &#47561;&#45824; &#44536;&#47000;&#54532; . - bar() 함수를 이용해서 막대 그래프를 표현 . &#44592;&#48376; &#49324;&#50857; . - np.arange()는 주어진 범위와 간격에 따라 균일한 값을 갖는 배열을 생성하는 함수 . import matplotlib.pyplot as plt import numpy as np x = np.arange(3) years = [&#39;2019&#39;, &#39;2020&#39;, &#39;2021&#39;] values = [100, 400, 900] plt.bar(x, values) plt.xticks(x, years) plt.show() . &#49828;&#53440;&#51068; &#44984;&#48120;&#44592; . - width는 막대의 너비(default는 0.8) . - align은 tick과 막대의 위치를 조절 . - color는 막대의 색 . - edgecolor는 막대의 테두리 색 . - linewidth는 테두리의 두께 . - tick_label을 array 형태로 지정하면 tick에 array의 문자열을 나타냄 . - log = True로 설정하면, y축이 로그 스케일로 표시 . x = np.arange(3) years = [&#39;2019&#39;, &#39;2020&#39;, &#39;2021&#39;] values = [100, 400, 900] plt.bar(x, values, width = 0.6, align = &#39;edge&#39;, color = &#39;k&#39;, edgecolor = &#39;b&#39;, linewidth = 1.5, tick_label = years, log = True) plt.show() . 11. matplotlib &#49688;&#54217; &#47561;&#45824; &#44536;&#47000;&#54532; . - barh() 함수를 이용하면 수평 막대 그래프를 그림 . &#44592;&#48376; &#49324;&#50857; . - height는 막대의 높이(default는 0.8) . - 나머지는 bar() 함수와 동일 . import matplotlib.pyplot as plt import numpy as np x = np.arange(3) years = [&#39;2019&#39;, &#39;2020&#39;, &#39;2021&#39;] values = [100, 400, 900] plt.barh(x, values, height = 0.6, align = &#39;edge&#39;, color = &#39;k&#39;, edgecolor = &#39;b&#39;, linewidth = 1.5, tick_label = years, log = False) plt.show() . 12. matplotlib &#49328;&#51216;&#46020; . - 산점도 (scatter plot)는 두 변수의 상관 관계를 직교 좌표계의 평면에 데이터를 점으로 표현하는 그래프 . - scatter() 함수를 이용하여 산점도를 그림 . - np.random.rand(N) &gt; 0~1사이의 난수 N개 생성 . - scatter()에 x, y 위치를 입력 . - s는 마커의 면적을 c는 마커의 색을 지정 . np.random.seed(2021) # Reproducible random state N = 50 x = np.random.rand(N) y = np.random.rand(N) colors = np.random.rand(N) area = (30 * np.random.rand(N))**2 plt.scatter(x, y, s = area, c = colors, alpha = 0.5) plt.show() . 13. matplotlib 3&#52264;&#50896; &#49328;&#51216;&#46020; . - scatter() 함수를 이용해서 3차원 산점도 (3D Scatter plot)를 그릴 수 있음 . &#45212;&#49688; &#49373;&#49457; . - random.random_sample() 함수는 [0.0, 1.0) 범위에서 임의의 실수를 반환 . - 괄호안에 파라미터는 배열의 크기를 지정 &gt; ex) random.random_sample(5, 2) : 5$ times$2배열에 [0.0, 1.0) 범위에서 임의의 실수를 채워넣음 . - [a, b) 범위의 난수를 생성하려면??? &gt; (b-a) * random_sample() + a . - np.random.rand() 함수는 0부터 1사이의 균일 분포에서 난수 matrix array 생성 . - np.random.randn() 함수는 표준 정규 분포에서 난수 matrix array를 생성 . - np.random.standard_normal() 함수는 표준 정규 분포에서 난수 matrix array를 생성 + tuple을 인자로 받음 . &#52264;&#53944; &#44592;&#48376; &#53356;&#44592; &#49444;&#51221; . - plt.rcParams()는 차트의 기본 크기를 지정 . - plt.figure(figsize=(10, 3))과 같이 차트의 기본 크기를 지정할 수 있지만 매번 지정해줘야 함 . figure &#49373;&#49457; . - plt.figure() 함수는 새로운 figure를 생성 . - plt.show() 함수를 통해 생성된 모든 figure를 보여줌 . axes &#49373;&#49457; . - axes는 figure 내에서 축을 가지는 하나의 좌표평면과 같은 개념임 . - axes 는 실제로 데이터가 그려지는 곳 . sub plot &#49373;&#49457; . - fig = plt.figure() . add_subplot() | . - 한 화면에 여러 개의 그래프를 그리려면 plt.figure() 함수를 통해 객체를 먼저 만들고 add_subplot() 함수를 통해 그리려는 그래프 개수만큼 subplot을 만듦 . - fig.add_subplot(1,1,1)은 그림의 1 X 1 그리드에 첫 번째 위치에 서브 플롯을 추가 $ longrightarrow$ fig.add_subplot(111)와 동일 . plt.subplot() | . - fig, ax = plt.subplots(2,1)와 같이 사용 . - 행과 열의 수를 함수에 인수로 전달하고 함수는 plot을 조정하는 데 사용할 수있는 figure 객체와 axes 객체를 반환 . - 서브plot들은 ax를 통해 조작함 . - 참고: matplotlib의 그림에 서브 플롯 추가 . 예시1 | . import matplotlib.pyplot as plt fig,ax = plt.subplots(2, 1) ax[0].text(0.3, 0.5, &quot;1st Subplot&quot;) ax[0].set_xticks([]) ax[0].set_yticks([]) ax[1].text(0.3, 0.5, &quot;2nd Subplot&quot;) ax[1].set_xticks([]) ax[1].set_yticks([]) fig.suptitle(&#39;Figure with 2 subplots&#39;, fontsize = 16) plt.show() . 예시2 | . import matplotlib.pyplot as plt x = [1, 2, 3, 4, 5] y1 = [i**2 for i in x ] y2 = [4*i+1 for i in x] fig, ax = plt.subplots(2, 1) ax[0].plot(x, y1) ax[0].set_xlabel(&quot;X&quot;) ax[0].set_ylabel(&quot;Y&quot;) ax[1].plot(x, y2) ax[1].set_xlabel(&quot;X&quot;) ax[1].set_ylabel(&quot;Y&quot;) plt.tight_layout() plt.show() . 3차원 산점도 | . - 3D axes를 만들기 위해 add_subplot()에 projection = &#39;3d&#39;를 입력 . - scatter() 함수에 x, y, z 위치를 array 형태로 입력 . - cmap = &#39;Greens&#39;를 통해 colormap을 녹색 계열로 설정 . import matplotlib.pyplot as plt import numpy as np n = 100 xmin, xmax, ymin, ymax, zmin, zmax = 0, 20, 0, 20, 0, 50 cmin, cmax = 0, 2 x = np.array([(xmax - xmin) * np.random.random_sample() + xmin for __ in range(n)]) y = np.array([(ymax - ymin) * np.random.random_sample() + ymin for __ in range(n)]) z = np.array([(zmax - zmin) * np.random.random_sample() + zmin for __ in range(n)]) color = (cmax - cmin) * np.random.rand(n) + cmin plt.rcParams[&quot;figure.figsize&quot;] = (6, 6) fig = plt.figure() ax = fig.add_subplot(111, projection = &#39;3d&#39;) ax.scatter(x, y, z, c = color, marker = &#39;o&#39;, s = 15, cmap = &#39;Greens&#39;) plt.show() . 14. matplotlib &#55176;&#49828;&#53664;&#44536;&#47016; . - hist() 함수를 이용해서 히스토그램을 그림 . &#44592;&#48376; &#49324;&#50857; . import matplotlib.pyplot as plt weight = [68, 81, 64, 56, 78, 74, 61, 77, 66, 68, 59, 71, 80, 59, 67, 81, 69, 73, 69, 74, 70, 65] plt.hist(weight) plt.show() . &#50668;&#47084;&#44060;&#51032; &#55176;&#49828;&#53664;&#44536;&#47016; &#44536;&#47532;&#44592; . - bins는 몇 개의 영역으로 쪼갤지를 설정 . - density = True로 설정하면 밀도함수가 되어서 막대의 아래 면적이 1이 됨 . - histtype을 &#39;step&#39;으로 설정하면 막대 내부가 비어있고 &#39;stepfilled&#39;로 설정하면 막대 내부가 채워짐 . import matplotlib.pyplot as plt import numpy as np a = 2.0 * np.random.randn(10000) + 1.0 b = np.random.standard_normal(10000) c = 20.0 * np.random.rand(5000) - 10.0 plt.hist(a, bins = 100, density = True, alpha = 0.7, histtype = &#39;step&#39;, color = &#39;red&#39;) plt.hist(b, bins = 50, density = True, alpha = 0.5, histtype = &#39;stepfilled&#39;, color = &#39;blue&#39;) plt.hist(c, bins = 100, density = True, alpha = 0.9, histtype = &#39;step&#39;, color = &#39;green&#39;) plt.show() . 15. matplotlib &#54028;&#51060; &#52264;&#53944; . - pie() 함수를 이용해서 파이 차트를 그림 . &#44592;&#48376; &#49324;&#50857; . - 각 영역의 비율과 이름을 ratio와 labels로 지정 . - autopct는 부채꼴 안에 표시될 숫자의 형식을 지정 . - autopct에서 문자열로 사용할 땐 &#39;%&#39; 앞에 백분율을 표시하고 &#39;%&#39; 뒤에 백분율을 표시할 형식을 지정 . - &#39;%&#39; 문자 자체를 출력하고 싶다면 &#39;%%&#39;와 같이 입력 . import matplotlib.pyplot as plt ratio = [34, 32, 16, 18] labels = [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Melon&#39;, &#39;Grapes&#39;] fig = plt.figure() ## 캔버스 생성 fig.set_facecolor(&#39;white&#39;) ## 캔버스 색상 하얀색 plt.pie(ratio, labels = labels, autopct = &#39;%.1f%%&#39;) ## autopct 문자열로 입력 plt.show() . &#47588;&#44060; &#48320;&#49688; &#49324;&#50857; . - explode는 부채꼴이 파이 차트의 중심에서 벗어나는 정도를 설정 . - startangle는 부채꼴이 그려지는 시작 각도를 설정(디폴트는 0도) . - counterclock = False로 설정하면 시계 방향 순서로 부채꼴 영역이 표시 . - shadow = True로 설정하면 파이 차트에 그림자가 표시 . - colors를 사용하면 각 영역의 색상을 지정 &gt; Hex code를 이용해서 더욱 다양한 색상을 지정 . - wedgeprops는 부채꼴 영역의 스타일을 설정 . import matplotlib.pyplot as plt ratio = [34, 32, 16, 18] labels = [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Melon&#39;, &#39;Grapes&#39;] explode = [0, 0.10, 0, 0.10] colors = [&#39;#ff9999&#39;, &#39;#ffc000&#39;, &#39;green&#39;, &#39;lightgray&#39;] wedgeprops = {&#39;width&#39;: 0.7, &#39;edgecolor&#39;: &#39;w&#39;, &#39;linewidth&#39;: 5} fig = plt.figure() fig.set_facecolor(&#39;white&#39;) plt.pie(ratio, labels = labels, autopct = lambda x: &#39;{:.1f}%&#39;.format(x), startangle = 260, counterclock = False, explode = explode, colors = colors, wedgeprops = wedgeprops, shadow = True) ## autopct 함수로 입력 plt.show() .",
            "url": "https://gkswotn12345.github.io/green/python/visualization/2021/07/27/matplotlib.html",
            "relUrl": "/python/visualization/2021/07/27/matplotlib.html",
            "date": " • Jul 27, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "파이썬에서 R실행",
            "content": "&#54028;&#51060;&#50028;&#50640;&#49436; R&#49892;&#54665;&#54616;&#44592; . 1. 아나콘다에 접속한 후 Anaconda Installers에서 64-Bit Graphical Installer(477MB)설치 . 2. Anaconda Prompt (anaconda3) 실행 . 3. 아래와 같이 입력 . (base) C: Users 한재수&gt; conda create -n py38r40 python=3.8 . (base) C: Users 한재수&gt; conda activate py38r40 . (py38r40) C: Users 한재수&gt; conda install jupyter lab . (py38r40) C: Users 한재수&gt; pip install rpy2 . (py38r40) C: Users 한재수&gt; R . 4. R에서 아래와 같이 입력 . &gt; install.packages(&quot;IRcernel&quot;) . &gt; IRcernel::installspec() . &gt; R.home() ## 나오는 경로 복사 . &gt; q() ## R 종료 . 5. 다시 프롬프트로 돌아와서 주피터랩 실행 . (py38r40) C: Users 한재수&gt; jupyter lab . 6. R세팅은 끝났고 파이썬에서 R을 사용하려면 아래와 같이 입력(주피터랩 킬 때마다 한 번씩만 입력) . import os . os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; ## R.HOME 에서 복사한 경로 . import rpy2 . %load_ext rpy2.ipython . 7. R사용 . 셀 마다 %R or %%R 입력하여 사용 . import os . os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; ## R.HOME 에서 복사한 경로 . import rpy2 . %load_ext rpy2.ipython . C: anaconda3 envs py38r40 lib site-packages rpy2 robjects packages.py:366: UserWarning: The symbol &#39;quartz&#39; is not in this R namespace/package. warnings.warn( . %R q &lt;- c(1, 2, 3) %R print(q) Q = [1, 2, 3] print(Q) . [1] 1 2 3 [1, 2, 3] . %%R x &lt;- c(1, 2, 3, 4, 5, 8, 9, 11) y &lt;- c(5, 1, 7, 12, 11, 5, 7, 21) model &lt;- lm(y ~ x) summary(model) . Call: lm(formula = y ~ x) Residuals: Min 1Q Median 3Q Max -6.3741 -4.4232 0.9096 3.2796 6.4840 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 2.9958 3.4644 0.865 0.420 x 1.0473 0.5469 1.915 0.104 Residual standard error: 5.185 on 6 degrees of freedom Multiple R-squared: 0.3793, Adjusted R-squared: 0.2759 F-statistic: 3.667 on 1 and 6 DF, p-value: 0.104 . - %R -i 을 통해 파이썬에서 정의한 변수를 R에서 사용할 수 있음 . import numpy as np data = np.random.rand(50) %R -i data . %%R hist(data) .",
            "url": "https://gkswotn12345.github.io/green/python/r/2021/07/26/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EC%84%9C-R%EC%8B%A4%ED%96%89.html",
            "relUrl": "/python/r/2021/07/26/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EC%84%9C-R%EC%8B%A4%ED%96%89.html",
            "date": " • Jul 26, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "변수 줄임말",
            "content": "&#48320;&#49688; &#51460;&#51076;&#47568; . - 변수를 줄임말로 쓸 때가 있는데 뭐인지 헷갈리는 변수를 정리할 거임 . - 나중에 변수 줄임말 말고도 변수명을 어떻게 정할지에 대한 내용도 정리할 수 도 있음 . - rtn &gt; return . - tmp &gt; temporary variable . - num &gt; number . - lib &gt; library . - lin &gt; linear . - rv &gt; random variable . - aes &gt; aesthetic . - axes &gt; axis(축)의 복수형 . - param(s) &gt; parameter . - loc &gt; location . - pch &gt; point character . - fig &gt; figure . - ax &gt; axes . &#48320;&#49688; &#51460;&#51076;&#47568;&#51008; &#50500;&#45768;&#51648;&#47564; &#50500;&#47924;&#53948; &#51460;&#51076;&#47568;&#51076; . - WLLN &gt; Weak Law of Large Numbers(큰 수의 약한 법칙) . - MLE &gt; maximum likelihood estimate(최대우도추정량) .",
            "url": "https://gkswotn12345.github.io/green/python/2021/07/26/%EB%B3%80%EC%88%98-%EC%A4%84%EC%9E%84%EB%A7%90.html",
            "relUrl": "/python/2021/07/26/%EB%B3%80%EC%88%98-%EC%A4%84%EC%9E%84%EB%A7%90.html",
            "date": " • Jul 26, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "적률생성함수",
            "content": "&#51201;&#47456;&#51060;&#46976; . - 확률변수의 특징을 설명 . - 확률변수 $X$의 $k$차 중심적률(central moment)을 $ mu_{k}$라 하면 $ mu_{k} = E[(X- mu)^{k}]$ . - $ mu_{1} = E(X) - mu = 0$ &gt; 확률변수 $X$의 $1$차 중심적률은 $0$ . - $ mu_{2} = E[(X- mu)^{2}]$ &gt; 확률변수 $X$의 $2$차 중심적률은 분산 . - $ mu_{3} = E[(X- mu)^{3}]$ &gt; 확률변수 $X$의 $3$차 중심적률은 왜도 . - $ mu_{4} = E[(X- mu)^{4}]$ &gt; 확률변수 $X$의 $4$차 중심적률은 첨도 . - 일반적인 확률 변수 $X$의 적률(moment)은 비중심(non-central)적률을 나타냄 $ longrightarrow$ $ mu&#39;_{k} = E[X^k]$ . - $ mu&#39;_{k} = E[X^k] = begin{cases} text{이산확률변수 : } sum limits_{x}x^{k}f(x) text{연속확률변수 : } int_{- infty}^{ infty}x^{k}f(x)dx end{cases}$ . - $ mu&#39;_{1} = mu$ . - $ sigma^{2} = mu_{2} = mu&#39;_{2} - ( mu&#39;_{1})^{2}$ . - 모평균$ mu$는 확률변수 $X$의 1차 비중심적률 . - 모분산$ sigma^{2}$은 확률변수 $X$의 2차 비중심적률에서 1차 비중심적률의 제곱을 뺀 값 . - 참고 자료: 통계수학 강의 . &#51201;&#47456;&#49373;&#49457;&#54632;&#49688;(moment generating function, mgf) . - 특정 확률 분포의 적률을 생성하는 함수 . - 적률을 계산하려면 연속확률변수의 경우 적분을 하게 되는데 어렵거나 불가능한 경우도 있음 &gt; 적률생성함수를 통해 계산 가능 . - 임의의 확률변수 $X$의 기댓값이 존재한다면 $X$의 적률생성함수 $M_{X}(t) = E(e^{tX}), ; t in mathbb{R}$ . - $M_{X}(t) = E(e^{tX}) = begin{cases} text{이산확률변수 : } sum limits_{x}e^{tx}f(x) text{연속확률변수 : } int_{- infty}^{ infty}e^{tx}f(x)dx end{cases}$ . - 만약 확률변수 $X$의 기댓값을 구하는데 $X$가 아니라 $x$가 사용되네??라고 생각하면 구글창에 확률변수의 기댓값 검색해서 공부하세요 . - 사실 $x$말고 $k$라고 하든지 $a$라고 하든지 다른 변수를 사용해도 됨 &gt; 마치 적분할 때 $ int x ,dx = int t , dt = int a ,da$ 인 것 처럼 . - 참고: $X$는 확률변수, $x$는 확률변수 $X$가 가지는 값 &gt; 이산확률변수는 $P(X=x)$, 연속확률변수는 $P(A leq X leq B)$ . - 적률생성함수는 항상 존재하는 것이 아님 &gt; 1. $e^{tX}$가 $t=0$근방에서 적분이 가능해야 함 $ ; ;$ 2. $ forall , t in mathbb{R}, ; ;E(e^{tX}) &lt; infty $ . &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; &#53945;&#51669; . - 두 확률변수의 mgf가 일치하면 두 확률변수는 같은 분포를 가짐 . - 적률생성함수를 $k$번 미분하고 $t=0$을 대입하면 확률변수 $X$의 $k$차 비중심 적률이다 &gt; 왜??? . &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; k&#48264; &#48120;&#48516; $ longrightarrow$ k&#52264; &#48708;&#51473;&#49900; &#51201;&#47456; . - $M_{X}(t) = E(e^{tX})$ . - $ frac{d^{k}M_{X}(0)}{dt^{k}} = E(X^{k})$ . - 매클로린 급수를 사용하자 . - $e^{tX} = sum limits_{k = 0}^{ infty} frac{X^k}{k!}(e^{tX})^{(k)}(0) = frac{t^{0}}{0!}X^{0}+ frac{t^1}{1!}X^1+ frac{t^2}{2!}X^2+ frac{t^3}{3!}X^3+ dots$ . - 양변에 기댓값을 취하면... . - $M_X(t)=E(e^{tX}) = 1 + tE(X) + frac{t^2}{2!}E(X^2) + frac{t^3}{3!}E(X^3)+ dots$ . - 이제 양변을 t에 대해 미분하자 . - $ frac{dM_X(t)}{dt} = 0 + E(X) + tE(X^2) + frac{t^2}{2}E(X^3)+ dots$ . - 이제 $t=0$을 대입하면... . - $ frac{dM_X(0)}{dt} = E(X)$ --&gt; 1번 미분하니 1차 적률이 구해짐 . - 그럼 한 번 더 미분하면 2차 적률? --&gt; ㅇㅇ . - $ frac{d^2M_X(t)}{dt^2} = 0 + 0 + E(X^2) + tE(X^3)+ dots$ . - 참고: $E(X)$는 $t$에 대하여 상수임 . - 이제 $t=0$을 대입하면 . - $ frac{d^2M_X(0)}{dt^2} = E(X^2)$ . - 정말로 2번 미분하니 2차 적률이 구해졌다.. . 확률 분포에 대해 정리할 때 기댓값과 분산을 과정없이 결과만 적었었음 . | 적률생성함수를 통해 여러가지 확률 분포의 기댓값과 분산을 구해보자 . | . &#44512;&#51068; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 균일 분포의 확률 밀도 함수: $f(x) = frac{1}{b-a}$ . - 균일 분포의 적률생성함수 . $M_X(t) = E(e^{tX}) = int_{a}^{b}e^{tx} frac{1}{b-a}dx longrightarrow text{확률변수$X$가 $a$부터 $b$까지의 값을 가진다는 뜻} = frac{1}{b-a} left[ frac{1}{t}e^{tx} right]_{a}^{b} = frac{e^{t}(e^{b}-e^{a})}{t(b-a)}$ | . - 균일 분포의 기댓값 &gt; 적률생성함수를 통해 구하는 것보다 1차 적률의 정의를 통해 구하는 것이 더 쉬움 . $E(X) = int_{a}^{b} frac{1}{b-a}x ;dx = frac{1}{b-a} left[ frac{x^2}{2} right]_{a}^{b} = frac{b^{2}-a^{2}}{2(b-a)} = frac{a+b}{2}$ | . - 균일 분포의 분산 &gt; 적률의 정의를 통해 구하자 &gt; 우선 2차 비중심 적률을 구하자 . $E(X^2) = int_{a}^{b} frac{1}{b-a}x^2 ;dx = frac{1}{b-a} left[ frac{x^3}{3} right]_{a}^{b} = frac{b^{3}-a^{3}}{3(b-a)} = frac{a^2+ab+b^2}{3}$ . | $Var(X) = E(X^2) - [E(X)]^2 = frac{a^2+ab+b^2}{3} - ( frac{a+b}{2})^2 = frac{4(a^2+ab+b^2) ,- 3(a^2+2ab+b^2)}{12} = frac{(b-a)^2}{12}$ . | . &#44592;&#54616; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 기하 분포의 확률 질량 함수: $f(x) = q^{x-1}p, ; q=1-p, ; x = 1, 2, 3, dots$ . - 첫째항이 $a$, 공비가 $r$인 무한등비수열의 합: $ frac{a}{1-r}, ; |r|&lt;1$ . - 기하 분포의 적률생성함수 . $M_X(t) = E(e^{tX}) = sum limits_{x=1}^{ infty}e^{tx}q^{x-1}p = frac{p}{q} sum limits_{x=1}^{ infty}(qe^{t})^{x} = frac{pqe^t}{q(1-qe^t)} , ; 0 leq qe^t &lt; 1 = frac{pe^t}{1-qe^t}$ | . - 기하 분포의 기댓값 . - 몫의 미분: $[ frac{f(x)}{g(x)}]&#39; = frac{f&#39;(x)g(x)-f(x)g&#39;(x)}{(g(x))^2}$ . $E(X) = frac{dM_X(t)}{dt} = frac{pe^{t}(1-qe^t)-pe^{t}(-qe^t)}{(1-qe^t)^2} = frac{pe^t}{(1-qe^t)^2} , ; text{$t=0$ 대입} = frac{p}{(1-q)^2} = frac{1}{p}$ | . - 기하 분포의 분산 . $E(X^2) = frac{d^2M_X(t)}{dt^2} = frac{pe^{t}(1-qe^t)^2- 2pe^{t}(1-qe^{t})(-qe^t)}{(1-qe^t)^4} = frac{pe^{t}(1-qe^t)((1-qe^t)+2qe^t)}{(1-qe^t)^4} = frac{pe^{t}(1+qe^t)}{(1-qe^t)^3}, ; text{$t=0$ 대입} = frac{p(1+q)}{(1-q)^3} = frac{1+q}{p^2}$ . | $Var(X) = E(X^2) - [E(X)]^2 = frac{1+q}{p^2} - ( frac{1}{p})^2 = frac{q}{p^2}$ . | . &#51060;&#54637; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 이항 분포의 확률 질량 함수: $f(x) ,= , _{n} rm C_{x} ,p^{x} ,(1-p)^{n-x}$ . - 이항 분포는 서로 독립이고 동일한 베르누이 분포를 따르는 확률변수들을 n개 합한 것임 . - 베르누이 분포의 확률 질량 함수 $f(x) = p^{x}(1-p)^{1-x}, ; x = 0, 1$ . - 베르누이 분포의 기댓값 . $E(X) = sum limits_{x=0}^{1}xp^{x}(1-p)^{1-x} = 0 cdot (1-p) + 1 cdot p = p$ | . - 베르누이 분포의 분산 . $E(X^2) = sum limits_{x=0}^{1}x^2p^x(1-p)^{1-x} = 0 cdot (1-p) + 1 cdot p = p$ . | $Var(X) = E(X^2)-[E(X)]^2 = p - p^2 = p(1-p)$ . | . - 확률변수 $X, Y$에 대해 $E(X + Y)= E(X) + E(Y)$ . - 확률변수 $X, Y$가 독립이면 $Var(X + Y) = Var(X) + Var(Y)$ . - 참고: 확률변수의 합 특징 . - 이항 분포의 기댓값 &gt; 이항 분포의 정의를 통해 구함: 베르누이 분포를 따르는 확률변수들의 합 . $E(X) = E( sum limits_{i=1}^{n}X_i) = sum limits_{i=1}^{n}E(X_i) = E(X_1) + E(X_2) + dots+E(X_{n-1})+E(X_n) = overbrace{p + dots + p}^{n rm times} = np$ | . - 이항 분포의 분산 --&gt; 기댓값과 마찬가지 . $Var(X) = Var( sum limits_{i=1}^{n}X_i) = sum limits_{i=1}^{n}Var(X_i) = Var(X_1)+Var(X_2)+ dots+Var(X_{n-1})+Var(X_n) = overbrace{p(1-p)+ dots+p(1-p)}^{n rm times} = np(1-p)$ | . - 이항 정리 . $(x+y)^n = sum limits_{k=0}^{n} binom{n}{k}x^{n-k}y^{k}$ | . - 이항 분포의 적률생성함수 . $M_{X}(t) = E(e^{tX}) = sum limits_{x=0}^{n} binom{n}{x}e^{tx}p^{x} ,(1-p)^{n-x} = sum limits_{x=0}^{n} binom{n}{x}(pe^{t})^{x} ,(1-p)^{n-x} = (1-p+pe^{t})^n$ | . - 이항 분포의 기댓값 &gt; 적률생성함수 미분해서 구하기 . - 합성함수의 미분 . $[f(g(x))]&#39; = g&#39;(x)f&#39;(g(x))$ | . $E(X) = frac{dM_X(t)}{dt} = npe^t(1-p+pe^t)^{n-1}, ; text{$t=0$ 대입} = np$ | . - 곱의 미분 . $[f(x)g(x)]&#39;=f&#39;(x)g(x)+f(x)g&#39;(x)$ | . - 이항 분포의 분산 &gt; 적률생성함수 미분해서 구하기 . $E(X^2) = frac{d^2M_X(t)}{dt^2} = npe^{t} cdot(1-p+pe^t)^{n-1}+npe^{t} cdot (n-1)pe^{t}(1-p+pe^{t})^{n-2}, ; text{$t=0$ 대입} =np+np^{2}(n-1) = np-np^2+n^2p^2$ . | $Var(X) = E(X^2)-[E(X)]^2 = np-np^2+n^2p^2-(np)^2 = np-np^2 =np(1-p)$ . | . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 테일러 급수 공부해라 구더기야 + 극좌표계도(희망) 하기 싫어............................................... . - 테일러 급수: 초월함수를 특정 값의 근방에서 멱함수로 근사시킴 &gt; 개사기임 . - $a$에서 $f$의 테일러 급수 . $f(x) = sum limits_{n=0}^{ infty} frac{f^{(n)}(a)}{n!}(x-a)^{n} = f(a) + frac{f&#39;(a)}{1!}(x-a)+ frac{f&#39;&#39;(a)}{2!}(x-a)^2+ frac{f&#39;&#39;&#39;(a)}{3!}(x-a)^3+ cdots$ | . - $a=0$인 특별한 경우 매클로린 급수라고 함 . $f(x) = sum limits_{n=0}^{ infty} frac{f^{(n)}(0)}{n!}x^n = f(0) + frac{f&#39;(0)}{1!}x+ frac{f&#39;&#39;(0)}{2!}x^2+ frac{f&#39;&#39;&#39;(0)}{3!}x^3+ cdots$ | . - $e^x$의 매클로린 급수 . $e^x = sum limits^{ infty}_{n=0} frac{x^n}{n!}$ | . - 포아송 분포의 확률 질량 함수: $f(x) = frac{e^{- lambda} lambda^{x}}{x!}$ . - 포아송 분포의 적률생성함수 . $M_X(t) = E(e^{tX}) = sum limits_{x=0}^{ infty}e^{tx} frac{e^{- lambda} lambda^{x}}{x!} =e^{- lambda} sum limits_{x=0}^{ infty} frac{( lambda e^{t})^{x}}{x!} quad text{$ therefore lambda e^t to x, ;x to n$ 으로 바꾸면 $e^x$의 매클로린 급수이다} = e^{- lambda} cdot e^{ lambda e^{t}} = e^{ lambda(e^{t}-1)} $ | . - 포아송 분포의 기댓값 . - $e^{- lambda}$ 는 변수가 아니므로 $e^{ lambda e^{t}}$ 에 대해서만 미분하면 된다 . - $y =e^{t}, ; frac{d}{dy}(y) = e^{t}$ . $E(X) = frac{dM_X(t)}{dt} =e^{- lambda} cdot(e^{ lambda y})&#39; = e^{- lambda} cdot lambda e^{ lambda y} cdot frac{d}{dy}(y) = e^{- lambda} cdot lambda e^{ lambda e^{t}} cdot e^{t}, ; text{$t=0$ 대입} = lambda cdot e^{- lambda} cdot e^{ lambda} = lambda$ | . - 포아송 분포의 분산 . $E(X^2) = frac{d^2M_X(t)}{dt^2} = lambda e^{- lambda} cdot([ lambda e^{ lambda e^{t}} cdot e^{t}] cdot [e^{t}] + [e^{ lambda e^{t}}] cdot[e^{t}]), ; text{$t=0$ 대입} = lambda e^{- lambda}( lambda e^{ lambda}+e^{ lambda}) = lambda^{2}+ lambda$ . | $Var(X) = E(X^2)-[E(X)]^{2} = lambda^{2}+ lambda - lambda^{2} = lambda$ . | . &#51648;&#49688; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 지수 분포의 확률 밀도 함수: $f(x) = lambda e^{- lambda x}, ; x&gt;0$ . - $ lambda$는 포아송 분포의 모수로 단위 시간당 사건의 평균 발생 횟수 . - 지수 분포의 적률생성함수 . $M_{X}(t) = E(e^{tX}) = int_{0}^{ infty}e^{tx} cdot lambda e^{- lambda x} ,dx = lambda int_{0}^{ infty}e^{tx} cdot e^{- lambda x} ,dx = lambda int_{0}^{ infty}e^{(t- lambda)x} ,dx = frac{ lambda}{t- lambda} cdot left[e^{(t- lambda) x} right]_{0}^{ infty}, ; ; ;(t&lt; lambda) = frac{ lambda}{ lambda - t} $ | . - 지수 분포의 기댓값 . $E(X) = frac{dM_X(t)}{dt} = frac{ lambda}{( lambda - t)^2}, ; text{$t=0$ 대입} = frac{1}{ lambda}$ | . - 지수 분포의 분산 . $E(X^2) = frac{d^2M_X(t)}{dt^2} = - frac{-2 lambda( lambda-t) }{( lambda-t)^4} = frac{2 lambda}{( lambda - t)^3}, ; text{$t=0$ 대입} = frac{2}{ lambda^2}$ . | $Var(X) = E(X^2) - [E(X)]^2 = frac{2}{ lambda^2} - ( frac{1}{ lambda})^2 = frac{1}{ lambda^2}$ . | . &#48288;&#53440; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 베타 분포의 확률 밀도 함수: $f(x)= frac{1}{B( alpha, beta)}x^{ alpha-1}(1-x)^{ beta-1}, quad 0 leq x leq1, ;( alpha , beta&gt;0)$ . - 베타 분포의 적률생성함수 . 어려워서 나중에 수리통계학에서 배우면 하는걸로 합시다 | . - 베타 분포의 기댓값 &gt; 적률생성함수를 통해 구하는 것보다 1차 적률의 정의를 통해 구하는 것이 더 쉬움 . - 베타 분포의 $f(x)$를 적분하면 $1$이다 . - 그런데 $f(x)$가 아닌 $xf(x)$를 적분함 &gt; $x^{ alpha-1} to x^{ alpha}$ . - 원래는 성공횟수가 ${ alpha-1}$, 실패횟수가${ beta-1}$인 베타분포인데 성공횟수가 ${ alpha}$, 실패횟수가${ beta-1}$로 바뀌었음 . - 그런데 어자피 베타분포는 확률 밀도 함수이므로 정의역구간을 적분하면 $1$이므로 상관없다 &gt; 하지만 바뀐 베타분포의 상수(베타 함수)가 아닌 기존 베타분포의 상수가 곱해져있는데??? . - 어자피 상수는 적분에 영향을 주지 못하니까 상수항은 임의로 맞춰주면 된다 . $E(X) = int_{0}^{1}x frac{1}{B( alpha, beta)}x^{ alpha-1}(1-x)^{ beta-1} ;dx = frac{1}{B( alpha, beta)} int_{0}^{1}x^{ alpha}(1-x)^{ beta-1} ;dx quad text{$ therefore frac{1}{B( alpha+1, beta)}$을 곱해주어 베타 분포를 만들자} = frac{B( alpha+1, beta)}{B( alpha, beta)} int_{0}^{1} frac{1}{B( alpha+1, beta)}x^{ alpha}(1-x)^{ beta-1} ;dx = frac{B( alpha+1, beta)}{B( alpha, beta)} cdot 1 = frac{ Gamma( alpha + beta)}{ Gamma( alpha) Gamma( beta)} cdot frac{ Gamma( alpha+1) Gamma( beta)}{ Gamma( alpha + beta+1)} quad text{$ therefore$ 감마함수의 성질: $ Gamma( alpha+1) = alpha Gamma( alpha)$} = frac{ Gamma( alpha + beta)}{ Gamma( alpha) Gamma( beta)} cdot frac{ alpha Gamma( alpha) Gamma( beta)}{( alpha+ beta) Gamma( alpha + beta)} = frac{ alpha}{ alpha+ beta}$ | . - 베타 분포의 분산 &gt; 적률의 정의를 통해 구하자 &gt; 우선 2차 비중심 적률을 구하자 . - 베타 분포의 기댓값을 구할 때와 같은 방법을 사용하자 . $E(X^2) = int_{0}^{1}x^{2} frac{1}{B( alpha, beta)}x^{ alpha-1}(1-x)^{ beta-1} ;dx = frac{1}{B( alpha, beta)} int_{0}^{1}x^{ alpha+1}(1-x)^{ beta-1} ;dx quad text{$ therefore frac{1}{B( alpha+2, beta)}$을 곱해주어 베타 분포를 만들자} = frac{B( alpha+2, beta)}{B( alpha, beta)} int_{0}^{1} frac{1}{B( alpha+2, beta)}x^{ alpha+1}(1-x)^{ beta-1} ;dx = frac{B( alpha+2, beta)}{B( alpha, beta)} cdot 1 = frac{ Gamma( alpha + beta)}{ Gamma( alpha) Gamma( beta)} cdot frac{ Gamma( alpha+2) Gamma( beta)}{ Gamma( alpha + beta+2)} quad text{$ therefore Gamma( alpha+1) = alpha Gamma( alpha)$} = frac{ Gamma( alpha + beta)}{ Gamma( alpha) Gamma( beta)} cdot frac{ alpha( alpha+1) Gamma( alpha) Gamma( beta)}{( alpha+ beta+1)( alpha+ beta) Gamma( alpha + beta)} = frac{ alpha( alpha+1)}{( alpha+ beta)( alpha+ beta+1)}$ . | $Var(X) = E(X^2) - [E(X)]^2 = frac{ alpha( alpha+1)}{( alpha+ beta)( alpha+ beta+1)} - ( frac{ alpha}{ alpha+ beta})^{2} = frac{ alpha}{ alpha+ beta}( frac{ alpha+1}{ alpha+ beta+1}- frac{ alpha}{ alpha+ beta}) = frac{ alpha}{ alpha+ beta}( frac{( alpha+1)( alpha+ beta)}{( alpha+ beta)( alpha+ beta+1)}- frac{ alpha( alpha+ beta+1)}{( alpha+ beta)( alpha+ beta+1)}) = frac{ alpha}{ alpha+ beta} cdot frac{ beta}{( alpha+ beta)( alpha+ beta+1)} = frac{ alpha beta}{( alpha+ beta)^{2}( alpha+ beta+1)}$ . | . &#44048;&#47560; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 감마 분포의 확률 밀도 함수: $f(x) = frac{1}{ beta^{ alpha} Gamma( alpha)}x^{ alpha - 1}e^{- frac{x}{ beta}},(x, alpha, beta geq 0)$ . - 감마 함수: $ Gamma( alpha) = int_{0}^{ infty}x^{ alpha-1}e^{-x}dx, , alpha geq 0$ . - 감마 함수를 살짝 변형하면 $ int_{0}^{ infty} frac{1}{ Gamma( alpha)}x^{ alpha-1}e^{-x}dx = 1$ . - 위의 식을 감마 분포의 적률생성함수를 구하는데 사용할 것임 . - 감마 분포의 적률생성함수 &gt; $t=0$ 근방임을 잊지말자 . $M_X(t) = E(e^{tX}) = int_{0}^{ infty} frac{1}{ beta^{ alpha} Gamma( alpha)}x^{ alpha - 1}e^{- frac{x}{ beta}}e^{tx} ;dx quad text{$ therefore$ 감마함수의 적분을 이용하기 위해 치환} = frac{1}{ beta^ alpha} int_{0}^{ infty} frac{1}{ Gamma( alpha)}x^{ alpha - 1}e^{(t- frac{1}{ beta})x} ;dx quad text{$ therefore(t- frac{1}{ beta})x=-y, ; dx= frac{ beta}{1- beta t}dy$} = frac{1}{ beta^ alpha} int_{0}^{ infty} frac{1}{ Gamma( alpha)}( frac{ beta}{1- beta t}y)^{ alpha - 1}e^{-y} frac{ beta}{1- beta t} ;dy quad text{$ therefore x= frac{ beta}{1- beta t}y, ;x=0 to y=0, ;x= infty to y= infty, ;(t&lt; frac{1}{ beta})$} = frac{1}{ beta^ alpha}( frac{ beta}{1- beta t})^{ alpha} int_{0}^{ infty} frac{1}{ Gamma( alpha)}y^{ alpha - 1}e^{-y} ;dy quad text{$ therefore int_{0}^{ infty} frac{1}{ Gamma( alpha)}y^{ alpha-1}e^{-y}dy = 1$, 위에 참고} =( frac{1}{1- beta t})^{ alpha}, quad t&lt; frac{1}{ beta} $ | . - 감마 분포의 기댓값 . $E(X) = frac{dM_X(t)}{dt} = alpha( frac{1}{1- beta t})^{ alpha-1} cdot frac{d}{dt}( frac{1}{1- beta t}) = alpha( frac{1}{1- beta t})^{ alpha-1} cdot frac{ beta}{(1- beta t)^2} = frac{ alpha beta}{(1- beta t)^{ alpha+1}}, ; text{$t=0$ 대입} = alpha beta $ | . - 감마 분포의 분산 . $E(X^2) = frac{d^2M_X(t)}{dt^2} = alpha beta frac{ beta( alpha+1)(1- beta t)^{ alpha}}{(1- beta t)^{2 alpha+2}} = frac{ alpha beta^{2}( alpha+1)}{(1- beta t)^{ alpha+2}}, ; text{$t=0$ 대입} = alpha beta^{2}( alpha+1)$ . | $Var(X) = E(X^2) - [E(X)]^2 = alpha beta^{2}( alpha+1) - ( alpha beta)^{2} = alpha beta^{2}( alpha+1)- alpha^2 beta^2 = alpha beta^2$ . | . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 카이제곱 분포의 확률 밀도 함수: $f(x) = frac{1}{2^ frac{k}{2} Gamma( frac{k}{2})}x^{ frac{k}{2}-1}e^{- frac{x}{2}}$ . - $k$는 자유도 . - 감마 분포에서 $ alpha= frac{k}{2}, beta = 2$인 경우 카이제곱 분포라고 했음 . - 그렇기에 감마분포의 평균, 분산, 적률생성함수에 $ alpha= frac{k}{2}, beta = 2$를 대입하여 카이제곱 분포의 평균, 분산, 적률생섬함수를 구할 수 있음(내 생각) . - 카이제곱 분포의 적률생성함수 . $M_X(t) = ( frac{1}{1- beta t})^{ alpha}, quad t&lt; frac{1}{ beta}, quad text{$ alpha= frac{k}{2}, beta = 2$ 대입} =( frac{1}{1-2t})^ frac{k}{2}$ | . - 카이제곱 분포의 기댓값 . $E(X) = alpha beta= k, quad text{$ alpha= frac{k}{2}, beta = 2$ 대입} $ | . - 카이제곱 분포의 분산 . $Var(X) = alpha beta^2=2k, quad text{$ alpha= frac{k}{2}, beta = 2$ 대입} $ | . - 이렇게 적고보니 너무 양심이 없는 것 같아 나중에 감마분포를 통해 구하지 않는 방법 추가 예정 . &#51221;&#44508; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 정규 분포의 확률 밀도 함수: $f(x) = frac{1}{ sqrt{2 pi sigma^{2}}}e^{- frac{(x- mu)^{2}}{2 sigma^{2}}}$ . - 완전제곱식 생성: $x^2-ax=(x- frac{a}{2})^2- frac{a^2}{4}$ . - 정규 분포의 적률생성함수 . $M_X(t) = E(e^{tX}) = int_{- infty}^{ infty}e^{tx} frac{1}{ sqrt{2 pi sigma^{2}}}e^{- frac{(x- mu)^{2}}{2 sigma^{2}}} ;dx = int_{- infty}^{ infty} frac{1}{ sqrt{2 pi sigma^{2}}}e^{- frac{x^2-2( mu+ sigma^{2}t)x+ mu^2}{2 sigma^{2}}} ;dx = int_{- infty}^{ infty} frac{1}{ sqrt{2 pi sigma^{2}}}e^{- frac{(x- mu- sigma^{2}t)^2-( mu+ sigma^2t)^2+ mu^2}{2 sigma^{2}}} ;dx =e^{ mu t+ frac{ sigma^2 t^2}{2}} int_{- infty}^{ infty} frac{1}{ sqrt{2 pi sigma^{2}}}e^{- frac{(x- mu- sigma^{2}t)^2}{2 sigma^2}} ;dx qquad text{$ therefore$ 평균이 $ mu+ sigma^{2}t$이고 표준편차가 $ sigma$인 정규분포이므로 적분값은 $1$} =e^{ mu t+ frac{ sigma^2 t^2}{2}}$ | . - 정규 분포의 기댓값 . $E(X) = frac{dM_X(t)}{dt} = ( mu + sigma^2 t)e^{ mu t+ frac{ sigma^2 t^2}{2}}, ; text{$t=0$ 대입} = mu$ | . - 정규 분포의 분산 . $E(X^2) = frac{d^2M_X(t)}{dt^2} = sigma^{2}e^{ mu t+ frac{ sigma^2 t^2}{2}}+( mu+ sigma^2 t)^2e^{ mu t+ frac{ sigma^2 t^2}{2}}, ; text{$t=0$ 대입} = sigma^2+ mu^2$ . | $Var(X)=E(X^2)-[E(X)]^2 = sigma^2+ mu^2-( mu)^2 = sigma^2$ . | .",
            "url": "https://gkswotn12345.github.io/green/python/statistics/2021/07/23/%EC%A0%81%EB%A5%A0%EC%83%9D%EC%84%B1%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/statistics/2021/07/23/%EC%A0%81%EB%A5%A0%EC%83%9D%EC%84%B1%ED%95%A8%EC%88%98.html",
            "date": " • Jul 23, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "동적 계획법",
            "content": "&#46041;&#51201; &#44228;&#54925;&#48277; . - 다이나믹 프로그래밍 참고: 동적 계획법 . - 다이나믹 프로그래밍((Dynamic Programming)으로도 불림 . - 큰 문제를 작은 문제로 나눠서 푸는 방법 . - 분할 정복과 유사하지만.. . 동적 계획법 분할 정복 . 공통점 | 큰 문제를 작은 문제로 나눠서 해결 | 큰 문제를 작은 문제로 나눠서 해결 | . 차이점 | 작은 문제가 반복됨 | 작은 문제가 반복되지 않음 | . - 나중에 분할 정복에 대해서도 다뤄보자 . &#45796;&#51060;&#45208;&#48121; &#54532;&#47196;&#44536;&#47000;&#48141; &#51312;&#44148; . 작은 문제들의 반복 . | 같은 문제는 구할 때마다 정답이 같음 . | &#45796;&#51060;&#45208;&#48121; &#54532;&#47196;&#44536;&#47000;&#48141; &#44396;&#54788; . - 모든 작은 문제는 단 한번만 풀어야 함 . - 정답을 구한 작은 문제는 어딘가에 저장 . - 큰 문제를 해결할 때 미리 구한 작은 문제의 정답을 사용 . 피보나치 수열을 다이나믹 프로그래밍으로 구현해보자 | . Top-down . - 큰 문제를 해결할 때 작은 문제가 해결되지 않았으면 작은 문제를 해결하여 큰 문제를 해결 . - 재귀 함수로 구현하는 경우가 대부분 Top-down 방법 . - 메모이제이션 기법 사용 --&gt; 미리 구한 작은 문제의 정답을 어딘가에 저장 . fibonacci = {0:0, 1:1} ## 메모이제이션을 위한 딕셔러니 선언 ## 리스트도 가능 def fibo_top_down(n): if n in fibonacci: return fibonacci[n] fibonacci[n] = fibo_top_down(n-1) + fibo_top_down(n-2) return fibonacci[n] . fibo_top_down(10) . 55 . Bottom-up . - 작은 문제부터 차근차근 해결하여 큰 문제를 해결 . - 반복문 사용 . def fibo_bottom_up1(n): if n &lt;= 1: return n fir_fibo = 0 sec_fibo = 1 for _ in range(n-1): next_fibo = fir_fibo + sec_fibo ## 2번째 피보나치 값 = 0번째 피보나치 값 + 1번째 피보나치 값(n번째 피보나치 값 = n-2번째 피보나치 값 + n-1번째 피보나치 값) fir_fibo = sec_fibo ## 0번째 피보나치 값을 1번째 피보나치 값으로 업데이트 sec_fibo = next_fibo ## 1번째 피보나치 값을 2번째 피보나치 값으로 업데이트 ## 다시 for문 시작으로 돌아가서 1번째 피보나치 값과 2번째 피보나치 값을 통해 3번째 피보나치 값을 구함(이를 n-1번 반복) ## for 문의 역할은 점화식을 통해 0번째와 1번째의 피보나치 값을 가지고 n번째의 피보나치 값을 구한다 return next_fibo . fibo_bottom_up1(10) . 55 . - 또 다른 방법 . - 미리 dp라는 list를 생성 . x = 100 ## 문제 조건에 맞춰서 dp = [-1] * x ## 리스트 초기화 def fibo_bottom_up2(n): ## 굳이 함수를 사용하지 않아도 상관 없음 dp[0] = 0 dp[1] = 1 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] . fibo_bottom_up2(10) . 55 . - bottom-up 방식으로 구현한 위의 두개 코드의 차이점은? . - fibo(9)와 fibo(10)을 구할 때 처음 코드는 fibo_bottom_up1(9)과 fibo_bottom_up1(10) 총 함수를 2번 사용 . - 사실 fibo_bottom_up1(10)을 구했다면 fibo_bottom_up1(9)도 당연히 알지만 각각을 따로 두 번 구했다 . - 첫번째 코드의 경우 다이나믹 프로그래밍은 이미 구한 작은 문제 정답은 또 구하지 않기로 했지만 그렇지 않은 모습 . - 하지만 두번째 코드는 fibo_bottom_up2(10)을 구했다면 dp[0] ~ dp[10]까지 값이 채워져 있기에 fibo_bottom_up2(9)를 하지 않고 dp[9]를 통해 fibo(9)를 구할 수 있음 . - 결론: 두번째 코드 쓰세요 .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/19/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html",
            "relUrl": "/python/algorithm/2021/07/19/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html",
            "date": " • Jul 19, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "파이썬 기본 연산 시간 복잡도(Big O)",
            "content": "&#49884;&#44036; &#48373;&#51105;&#46020; . - 컴퓨터 프로그램의 입력값과 연산 수행 시간의 함수 관계 . - 보통 Big O 표기법으로 나타냄 . Big O &#54364;&#44592;&#48277; . - 알고리즘의 시간 복잡도를 나타내는 척도 . - 두 함수 $f$와 $g ,(g&gt;0)$에 대해 상수 $k&lt; infty$가 존재해서 $x in A subset mathbb{R}$인 $x$에 대하여 $| frac{f(x)}{g(x)}|&lt;K$이면 $f(x)=O(g(x))$임 . - 쉽게 말하면 $f$나 $g$나 고만고만하다는 뜻 . - $f(x) = 2x, ,g(x) = x$이면 $| frac{f(x)}{g(x)}| = 2&lt; infty$이므로 $f(x) = O(g(x))$임 &gt; $f$나 $g$나 비슷함 . - 만약 $h(x) = x^2$이면 $| frac{h(x)}{g(x)}| = |x|$이고 $x to infty$이면 $| frac{h(x)}{g(x)}| to infty$이므로 $h(x) neq O(g(x))$임 &gt; $h$와 $g$는 급이 다름 . &#50672;&#49328; &#49884;&#44036; &#48373;&#51105;&#46020; . - 자료형별 연산의 시간 복잡도를 나타내자 . &#47532;&#49828;&#53944;(list) . - l은 리스트(list) . - k는 상수 . - 참고: 파이썬 자료형별 연산 시간 복잡도 . Operation Example Complexity Class Notes . index | l[n] | $O(1)$ | | . store | l[n] = 0 | $O(1)$ | store는 변수 저장 | . length | len(l) | $O(1)$ | | . append | l.append(5) | $O(1)$ | | . pop | l.pop() | $O(1)$ | same as l.pop(-1) | . clear | l.clear() | $O(1)$ | similar to l = [] | . slice | l[a:b] | $O(b-a)$ | $l[1:5] to O(l)$, $l[ ; ; : ; ; ] to O(len(l)-0)=O(N)$ | . extend | l.extend(...) | $O(len( dots))$ | depends only on len of extension | . construction | list(...) | $O(len( dots))$ | depends on length of ... iterable | . check ==, != | l1 == l2 | $O(N)$ | | . insert | l[a:b] = ... | $O(N)$ | | . delete | del l[n] | $O(N)$ | depends on n; $O(N)$ in worst case | . containment | x in/not in l | $O(N)$ | linearly searches list | . copy | l.copy() | $O(N)$ | Same as $l[ ; ;: ; ;]$ which is $O(N)$ | . remove | l.remove(...) | $O(N)$ | | . pop | l.pop(n) | $O(N)$ | $O(N-i)$: l.pop(0): $O(N)$ (see above) | . extreme value | min(l)/max(l) | $O(N)$ | linearly searches list for value | . reverse | l.reverse() | $O(N)$ | | . iteration | for v in l: | $O(N)$ | Worst: no return/break in loop | . sort | l.sort() | $O(N Log N)$ | key/reverse mostly does not change | . multiply | $k times l$ | $O(kN)$ | $5 times l$ is $O(N)$: $len(l) times l$ is $O(N^2)$ | . &#51665;&#54633;(set) . - 리스트에 비해 시간 복잡도가 작음 . Operation Example Complexity Class Notes . Length | len(s) | $O(1)$ | | . Add | s.add(5) | $O(1)$ | | . Containment | x in/not in s | $O(1)$ | compare to list/tuple - $O(N)$ | . Remove | s.remove(..) | $O(1)$ | compare to list/tuple - $O(N)$ | . Discard | s.discard(..) | $O(1)$ | | . Pop | s.pop() | $O(1)$ | popped value &quot;randomly&quot; selected | . Clear | s.clear() | $O(1)$ | similar to s = set() | . Construction | set(...) | $O(len(...))$ | depends on length of ... iterable | . check ==, != | s != t | $O(len(s))$ | same as len(t); False in O(1) if the lengths are different | . &lt;=/&lt; | s &lt;= t | $O(len(s))$ | issubset | . &gt;=/&gt; | s &gt;= t | $O(len(t))$ | issuperset s &lt;= t == t &gt;= s | . Union | s | t | $O(len(s)$+$len(t))$ | | . Intersection | s &amp; t | $O(len(s)$+$len(t))$ | | . Difference | s - t | $O(len(s)$+$len(t))$ | | . Symmetric Diff | s ^ t | $O(len(s)$+$len(t))$ | | . Iteration | for v in s: | $O(N)$ | Worst: no return/break in loop | . Copy | s.copy() | $O(N)$ | | . &#54644;&#49884;(dictionary) . - 시간 복잡도가 대부분 $O(1)$이다 . - 같은 함수라면 리스트 대신 딕셔너리를 사용하는 것이 시간 복잡도 면에서 우월함 . Operation Example Complexity Class Notes . Index | d[k] | $O(1)$ | | . Store | d[k] = v | $O(1)$ | | . Length | len(d) | $O(1)$ | | . Delete | del d[k] | $O(1)$ | | . get/setdefault | d.get(k) | $O(1)$ | | . Pop | d.pop(k) | $O(1)$ | | . Pop item | d.popitem() | $O(1)$ | popped item &quot;randomly&quot; selected | . Clear | d.clear() | $O(1)$ | similar to s = {} or = dict() | . View | d.keys() | $O(1)$ | same for d.values() | . Construction | dict(...) | $O(len(...))$ | depends # (key,value) 2-tuples | . Iteration | for k in d: | $O(N)$ | all forms: keys, values, items, Worst: no return/break in loop | .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/15/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B8%B0%EB%B3%B8%EC%97%B0%EC%82%B0-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84.html",
            "relUrl": "/python/algorithm/2021/07/15/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B8%B0%EB%B3%B8%EC%97%B0%EC%82%B0-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84.html",
            "date": " • Jul 15, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "문자열 함수",
            "content": "format &#54632;&#49688; . - 문자열을 포매팅(formatting)하는데 사용 . - 포매팅: 문자열의 원하는 위치에 특정 변수를 삽입 . - 아래 예제를 보자 . &#39;이름:{},나이:{},성별:{}&#39;.format(&#39;홍길동&#39;,&#39;21&#39;,&#39;남&#39;) . &#39;이름:홍길동,나이:21,성별:남&#39; . - 순서대로 홍길동, 21, 남이 {}에 삽입됨 . - 구구단도 쉽게 출력할 수 있음 . i = 2 for j in range(1, 10): print(&#39;{} X {} = {}&#39;.format(i, j, i*j)) . 2 X 1 = 2 2 X 2 = 4 2 X 3 = 6 2 X 4 = 8 2 X 5 = 10 2 X 6 = 12 2 X 7 = 14 2 X 8 = 16 2 X 9 = 18 . [$ star$]&#49548;&#49688;&#51216; &#51088;&#47551;&#49688; &#54364;&#54788;[$ star$] . - 알고리즘 문제를 풀다보면 특정 소수점 자릿수까지 출력을 요구할 때가 있음 . - 계산 결과를 소수점 셋째 자리 까지 표현하려면? . a = 10 b = 3 a / b . 3.3333333333333335 . - 소수점 셋째 짜리 까지 표현하고 싶음 . - format 함수 사용! . a = 10 b = 3 print(&#39;{:.3f}&#39;.format(a / b)) . 3.333 . - round 함수도 되는데? . - round(x, a) --&gt; x를 소수점 a번째 까지 나타냄 . a = 10 b = 3 round(a / b, 3) . 3.333 . - 아래와 같은 경우는? . a = 10 b = 2 a / b . 5.0 . - format 함수 . a = 10 b = 2 print(&#39;{:.3f}&#39;.format(a / b)) . 5.000 . - round 함수 . a = 10 b = 2 round(a / b, 3) . 5.0 . - format 함수는 소수점 셋째 자리까지 나타낸 반면 round 함수는 첫째 자리까지 나타냄 . round 함수를 사용할 때 주의할 점 | . - 파이썬에서는 사사오입의 원칙을 따라 반올림할 자리가 5이면 반올림을 할 때 짝수면 내림, 홀수면 올림 한다 . round(2.5) . 2 . round(-1.5) . -2 . - 오사오입의 원칙으로 반올림 하려면? --&gt; 함수를 따로 만들자 . def round2(number): if number &gt;= 0: if number - int(number) &gt;= 0.5: a = 1 else: a = 0 return int(number) + a else: if int(number) - number &gt; 0.5: a = -1 else: a = 0 return int(number) + a . round2(2.5) . 3 . round2(-1.5) . -1 . - 사사오입의 원칙으로 반올림을 하는 이유는 데이터의 대부분이 .5로 끝나는 자료라면 이를 반올림하면 0.5만큼의 오차가 생기기 때문 . 결론: 원하는 자릿수 까지 나타내려면 round 함수 대신 format 함수를 쓰자 | . join &#54632;&#49688; . - 문자열로 이루어진 리스트를 기준 문자열로 합쳐 문자열로 만듦 . - &#39;구분자&#39;.join(list) . - 구분자에는 문자열, list에는 문자열을 원소로 가지는 리스트가 들어감 . a = [&#39;12&#39;, &#39;45&#39;, &#39;48&#39;] . &#39;-&#39;.join(a) . &#39;12-45-48&#39; . &#39;&#39;.join(a) . &#39;124548&#39; . replace &#54632;&#49688; . - 특정 문자를 다른 문자로 대체 . - &#39;문자열&#39;.replace(&#39;기존 문자&#39;, &#39;바꿀 문자&#39;) . a = &#39;hello world&#39; . a.replace(&#39;h&#39;, &#39;H&#39;) . &#39;Hello world&#39; . a.replace(&#39;&#39;, &#39;!&#39;) . &#39;!h!e!l!l!o! !w!o!r!l!d!&#39; . - 문자열에서는 빈칸도 하나의 문자로 취급 . split &#54632;&#49688; . - 문자열을 구분자를 기준으로 쪼갬 . - &#39;문자열&#39;.split(&#39;구분자&#39;) . a = &#39;!h!e!l!l!o! !w!o!r!l!d!&#39; . a.split(&#39;!&#39;) . [&#39;&#39;, &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;&#39;] . upper &#54632;&#49688; . - 문자열에서 모든 소문자를 대문자로 바꿈 . - &#39;문자열&#39;.upper(&#39;구분자&#39;) . a = &#39;hello world&#39; . a.upper() . &#39;HELLO WORLD&#39; . lower &#54632;&#49688; . - 문자열에서 모든 대문자를 소문자로 바꿈 . - &#39;문자열&#39;.lower(&#39;구분자&#39;) . a = &#39;HELLO WORLD&#39; . a.lower() . &#39;hello world&#39; . count &#54632;&#49688; . - 문자열에서 특정 문자 or 문자열의 개수를 반환함 . - &#39;문자열&#39;.count(&#39;찾는 문자&#39;, 시작 인덱스, 끝 인덱스) . - 시작 인덱스 $ leq$ 문자열 $&lt;$ 끝 인덱스 . a = &#39;HELLO WORLD&#39; . a.count(&#39;L&#39;) . 3 . a.count(&#39;L&#39;, 0, 9) . 2 . a.count(&#39;L&#39;, 0, 10) . 3 . chr &#54632;&#49688; . - 아스키 코드를 문자로 변환함 . - chr(아스키코드) . - 아스키 코드 참고: https://ko.wikipedia.org/wiki/ASCII . chr(65) . &#39;A&#39; . ord &#54632;&#49688; . - 문자를 아스키 코드로 변환함 . - ord(&#39;문자&#39;) . ord(&#39;A&#39;) . 65 .",
            "url": "https://gkswotn12345.github.io/green/python/2021/07/09/%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/2021/07/09/%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%95%A8%EC%88%98.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "그리디 알고리즘",
            "content": "&#44536;&#47532;&#46356; &#50508;&#44256;&#47532;&#51608;(&#50837;&#49900;&#51137;&#51060; &#50508;&#44256;&#47532;&#51608;, Greedy Algorithm)&#51060;&#46976;? . - 다이나믹 프로그래밍이 모든 경우를 확인 한다는 점에서 고안된 알고리즘 . - 매 선택마다 가장 최적인 답을 선택하여 결론을 도출 --&gt; 알파고: 자신 차례마다 가장 승률이 높은 수를 선택 . - but, 매 선택마다 최적이지만 결과가 최적이라는 보장 없음 . - 마시멜로 실험: 당장은 1개, 기다리면 2개 --&gt; 최적해: 기다리고 2개 먹기 . - 하지만 그리디 알고리즘은 지금 최적의 선택인 1개를 선택 --&gt; 최적해 아님 . &#44536;&#47084;&#47732; &#50612;&#46500; &#44221;&#50864;&#50640; &#51096; &#46041;&#51089;&#54616;&#45716;&#44032;? . - 탐욕 선택 속성(greedy choice property): 한번의 선택이 다음 선택과는 무관 . - 최적 부분 구조(optimal substructure): 매 순간의 최적해 --&gt; 문제에 대한 최적해 . &#44536;&#47532;&#46356; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . - 백준 - 설탕 배달: https://www.acmicpc.net/problem/2839 . - 설탕 N kg을 3kg, 5kg봉지에 담아야 하는데 봉지의 수를 최소화 . 최적 부분 구조: 매 순간 봉지의 수를 최소화하려는 행위(3kg 봉지 보다 5kg 봉지 사용)는 문제에 대한 최적해(봉지의 수 최소화) . | 탐욕 선택 속성: 전에 5kg 봉지를 선택하든 3kg 봉지를 선택하든 상관없이 현재 남아있는 무게를 가지고만 판단하여 선택 . | - 그리디 알고리즘: 5kg 봉지로만 담는 것이 최선 . - 만약 5kg 봉지로만 담는 것이 불가능하면? . - 5kg 봉지를 하나 줄이고 3kg 봉지를 사용함 . - 이를 반복함 --&gt; 만약 담는 것이 불가능하면 -1 return . 설탕 배달(그리디 알고리즘) | . - 설탕의 무게는 N kg . 5kg 봉지 선택(최적 판단) . | 5kg 봉지 선택(최적 판단) . | 5kg 봉지만 계속 선택 --&gt; total: k 번 선택(최적 판단) . | 만약 남은 무게가 예컨데 4kg 이라 5kg 봉지에 담지 못한다면 3kg 선택(최적 판단) . | 3kg 에 담고나면 1kg 이 남음 --&gt; 어느 봉지에도 담지 못함 . | 5kg 봉지를 k - 1번 선택하고 3kg 봉지를 선택 . | 5kg 봉지를 0번 선택할 때 까지 반복 --&gt; 이 경우에도 답이 없다면 해가 존재하지 않음 . | N = int(input()) def sugar(n): k = n // 5 l = n % 5 for i in range(k+1): if l == 0: return k break elif l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 21 . - 설탕 무게가 101kg 일시 5kg 19개, 3kg 2개를 선택 .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/09/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "relUrl": "/python/algorithm/2021/07/09/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "DFS와 BFS 알고리즘",
            "content": "&#44618;&#51060; &#50864;&#49440; &#53456;&#49353;(Depth First Search, DFS) . - 모든 정점을 한번만 방문 . - 시작 노드에서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색 . - 방문할 노드와 방문한 노드를 기준으로 탐색 . - 특정 노드가 방문할 노드 --&gt; 탐색, 방문한 노드 --&gt; 지나감 . - 그래프나 트리는 dictionary로 생성 . - stack 구조 와 재귀 함수로 구현 가능 . DFS &#51109;&#51216; . - 단지 현 경로상의 노드들만을 기억하면 되므로 저장공간의 수요가 비교적 적음 . - 목표노드가 깊은 단계에 있을 경우 해를 빨리 구함 . DFS &#45800;&#51216; . - 해가 없는 경로에 깊이 빠질 가능성 존재 . - 얻어진 해가 최단 경로가 된다는 보장이 없음 --&gt; 목표에 이르는 경로가 다수일 때 해에 다다르면 탐색을 끝내버림 --&gt; 이때 얻어진 해는 최적이 아닐 수 있음 . DFS 참고: 깊이 우선 탐색 | . DFS &#53076;&#46300; &#44396;&#54788; . - tree 구조 . - stack 자료 구조 활용: 후입선출(한쪽면이 막힌 원통) . - 노드: [A], [B], [C], [D], [E], [F], [G], [H], [I], [J] . - 분기: [A, B, E], [A, B, F, I], [A, C, G], [A, D, H, I] . tree = {&#39;A&#39;: [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;], ## A는 B, C, D와 연결됨 &#39;B&#39;: [&#39;A&#39;, &#39;E&#39;, &#39;F&#39;], ## B는 A, E, F와 연결됨 &#39;C&#39;: [&#39;A&#39;, &#39;G&#39;], ## C는 A, G와 연결됨 &#39;D&#39;: [&#39;A&#39;, &#39;H&#39;], ## D는 A, H와 연결됨 &#39;E&#39;: [&#39;B&#39;], ## E는 B와 연결됨 &#39;F&#39;: [&#39;B&#39;, &#39;I&#39;], ## F는 B, I와 연결됨 &#39;G&#39;: [&#39;C&#39;], ## G는 C와 연결됨 &#39;H&#39;: [&#39;D&#39;, &#39;J&#39;], ## H는 D, J와 연결됨 &#39;I&#39;: [&#39;F&#39;], ## I는 F와 연결됨 &#39;J&#39;: [&#39;H&#39;]} ## J는 H와 연결됨 . &#47532;&#49828;&#53944; &#54876;&#50857; . - 파이썬에서 리스트는 stack구조여서 DFS에 활용 가능 . - list.pop(i)은 성능이 떨어짐, i번째 이후 원소들을 한 칸씩 앞으로 땡겨야하기 때문 --&gt; $O(N)$ . - 비고: $O(N-i) to O(N)$ 최악의 경우(0번째 인덱스) . - list.pop()은 마지막 원소만 pop하므로 $O(1)$ . - list.pop()--&gt; 맨 마지막에 넣었던 노드를 가져옴: stack구조와 동일(후입선출) . def DFS_list(graph, start_node): visited = [] ## 방문한 노드 stack = [] ## 방문할 노드 stack.append(start_node) ## 방문할 노드에 시작 노드 추가 while stack: ## 방문할 노드가 있다면(리스트에 원소가 있으면 True) node = stack.pop() ## 마지막 노드 추가(스택 구조 사용) if node not in visited: ## 만약 아직 방문한 노드가 아니라면 visited.append(node) ## 이제 방문했으니까 방문한 노드에 추가 stack.extend(reversed(graph[node])) ## 방문한 노드에 연결된 노드를 탐색해보자 print(visited) print(stack) print(&#39;-&#39;) ## 방문과정 확인 return visited ## 방문한 노드를 반환 DFS_list(tree, &#39;A&#39;) ## 마지막은 return 값 . [&#39;A&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;E&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;E&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;I&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;I&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;] [&#39;D&#39;, &#39;C&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;] [&#39;D&#39;, &#39;G&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;] [&#39;D&#39;, &#39;G&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;] [&#39;D&#39;, &#39;C&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;] [&#39;D&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;] [&#39;H&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;] [&#39;H&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;] [&#39;J&#39;, &#39;D&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;] [&#39;J&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] [&#39;H&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] [] - . [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] . - return 결과를 보면 DFS 방식임을 알 수 있다 . &#54644;&#49884; &#53580;&#51060;&#48660; &#54876;&#50857; . - if node not in visited: --&gt; visited가 list인 경우 $O(N)$의 시간복잡도를 가짐 . - visited도 해시 테이블(key: value 관계인 자료형: 파이썬의 dictionary)로 구현하면 $O(1)$로 효율$ uparrow$ . - 해시 테이블에 관한 좋은 영상 &gt; 해시 테이블 . def DFS_Hash_Table(graph, start_node): visited = {} ## 방문한 노드 stack = [] ## 방문할 노드 stack.append(start_node) ## 방문할 노드에 시작 노드 추가 while stack: ## 방문할 노드가 있다면(리스트에 원소가 있으면 True) node = stack.pop() ## 마지막 노드 추가(스택 구조 사용) if node not in visited: ## 만약 아직 방문한 노드가 아니라면 visited[node] = True ## 이제 방문했으니까 방문한 노드에 추가 stack.extend(reversed(graph[node])) ## 방문한 노드에 연결된 노드를 탐색해보자 return list(visited.keys()) ## 방문한 노드를 반환 DFS_list(tree, &#39;A&#39;) ## 마지막은 return 값 . [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] . - list를 활용한 코드와 return 결과는 동일하다 . - 시간복잡도면에서 list를 활용한 것 보다 Hash Table을 사용한 것이 성능이 우월하다 . - return 결과를 보면 DFS 방식임을 알 수 있다 . &#51116;&#44480;&#54632;&#49688; &#54876;&#50857; . def DFS_recursive(graph, start_node, visited = {}): visited[start_node] = True for node in graph[start_node]: if node not in visited: DFS_recursive(graph, node, visited) ## 간단히 설명 -&gt; 처음 시작 노드는 &#39;A&#39; -&gt; &#39;A&#39;를 visited에 추가 &#39;A&#39;의 node는 [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;] ## -&gt; &#39;B&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;B&#39;를 start_node로 하여 visited에 추가 -&gt;&#39;B&#39;의 node는 [&#39;A&#39;, E&#39;, &#39;F&#39;] ## -&gt; &#39;A&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;E&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;E&#39;를 start_node로 하여 visited에 추가 -&gt; &#39;E&#39;의 node는 [&#39;B&#39;] ## -&gt; &#39;B&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;B&#39;의 node로 &#39;A&#39;, &#39;E&#39; 방문 했고 이제 &#39;F&#39;만 남았음 ## -&gt; &#39;F&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;F&#39;를 start_node로 하여 visited에 추가 -&gt; &#39;F&#39;의 node는 [&#39;B&#39;, &#39;I&#39;] ## -&gt; &#39;B&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;I&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;I&#39;를 start_node로 하여 visited에 추가 -&gt; &#39;I&#39;의 node는 [F] ## -&gt; &#39;F&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;A&#39;의 node인 [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]중 &#39;B&#39;를 방문 끝냈으므로 &#39;B&#39;를 탐색했던 것처럼 나머지 &#39;C&#39;와 &#39;D&#39;도 탐색하면 끝임 return list(visited.keys()) DFS_recursive(tree, &#39;A&#39;) . [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] . - 재귀함수를 사용하여 방문한 노드를 visited에 추가한다 . - return 결과를 보면 DFS 방식임을 알 수 있다 . &#45320;&#48708; &#50864;&#49440; &#53456;&#49353;(Breadth First Search, BFS) . - 모든 정점을 한번만 방문 . - 시작 노드에서 인접한 다음 분기로 넘어가면서 탐색 . - 넘어갈 분기가 없으면 하위 노드를 탐색 . - 방문할 노드와 방문한 노드를 기준으로 탐색 . - 특정 노드가 방문할 노드 --&gt; 탐색, 방문한 노드 --&gt; 지나감 . - 그래프나 트리는 dictionary로 생성 . - queue 구조로 구현 가능 . BFS &#51109;&#51216; . - 출발노드에서 목표노드까지의 최단 길이 경로를 보장 . BFS &#45800;&#51216; . - 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요 . - 해가 존재하지 않는다면 유한 그래프(finite graph)의 경우에는 모든 그래프를 탐색한 후에 실패로 끝남 . - 무한 그래프(infinite graph)의 경우에는 결코 해를 찾지도 못하고, 끝내지도 못함 . BFS 참고: 너비 우선 탐색 | . BFS &#53076;&#46300; &#44396;&#54788; . - tree 구조 . - queue 자료 구조 활용: 선입선출(양쪽 면이 뚫린 원통) . - 노드: [A], [B], [C], [D], [E], [F], [G], [H], [I], [J] . - 분기: [A, B, E], [A, B, F, I], [A, C, G], [A, D, H, I] . deque &#54876;&#50857; . - 성능이 좋음 --&gt; $O(1)$ . - 사용: from collections import deque . - 만약 queue = list()라면 queue.pop(0)을 해야함 --&gt; $O(N)$ . - deque를 사용하여 queue.pop(0)대신 queue.popleft( ) 사용 --&gt; $O(1)$ . - DFS와 마찬가지로 visited는 해시 테이블로 구현 . def BFS_queue(graph, start_node): from collections import deque ## deque패키지 import visited = {} ## 방문한 노드 queue = deque() ## 방문할 노드 queue.append(start_node) ## 방문할 노드에 시작 노드 추가 while queue: ## 방문할 노드가 있다면(리스트에 원소가 있으면 True) node = queue.popleft() ## 첫번째 노드 추가(큐 구조 사용) if node not in visited: ## 만약 아직 방문한 노드가 아니라면 visited[node] = True ## 이제 방문했으니까 방문한 노드에 추가 queue.extend(graph[node]) ## 방문한 노드에 연결된 노드를 탐색해보자 print(list(visited.keys())) print(queue) print(&#39;-&#39;) ## 방문과정 확인 return list(visited.keys()) ## 방문한 노드를 반환 BFS_queue(tree, &#39;A&#39;) . [&#39;A&#39;] deque([&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]) - [&#39;A&#39;, &#39;B&#39;] deque([&#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;E&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] deque([&#39;D&#39;, &#39;A&#39;, &#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] deque([&#39;A&#39;, &#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] deque([&#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] deque([&#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] deque([&#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] deque([&#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] deque([&#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] deque([&#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;B&#39;, &#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;C&#39;, &#39;D&#39;, &#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;D&#39;, &#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([&#39;F&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([&#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([]) - . [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] . - return 결과를 보면 BFS 방식임을 알 수 있다 .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/09/DFS-BFS.html",
            "relUrl": "/python/algorithm/2021/07/09/DFS-BFS.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "정렬 알고리즘",
            "content": "- 데이터를 오름차순으로 정렬해보자! . $O(N^2)$ &#51221;&#47148; . &#49440;&#53469; &#51221;&#47148; . - 가장 작은 수를 첫 번째 인덱스로 선택 그 다음으로 작은 수를 두 번째 인덱스로 선택 . - 이런식으로 가장 큰 수까지 마지막 인덱스로 선택하면 정렬 끝 . &#49440;&#53469; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2] . 2 첫 번째 인덱스와 나머지 $n - 1$개의 수를 비교하여 가장 작은 수와 위치를 바꾼다 . 3 5와 비교하여 1이 가장 작으므로 5와 1의 위치를 바꾼다 . List = [1, 8, 7, 5, 2] . 4 이제 두 번째 인덱스와 나머지$n - 2$개의 수를 비교하여 남은 수 중 가장 작은 수와 위치를 바꾼다 . 5 8과 비교하여 2가 가장 작으므로 8과 2의 위치를 바꾼다 . List = [1, 2, 7, 5, 8] . 6 이런 식으로 $n-1$번째 인덱스와 나머지 1개의 수를 비교하여 오름차순 정렬을 마친다 . List = [1, 2, 5, 7, 8] . &#49440;&#53469; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(n - 1): min_idx = i for j in range(i + 1, n): if List[j] &lt; List[min_idx]: min_idx = j List[i], List[min_idx] = List[min_idx], List[i] print(List) . [1, 8, 7, 5, 2] [1, 2, 7, 5, 8] [1, 2, 5, 7, 8] [1, 2, 5, 7, 8] . &#48260;&#48660; &#51221;&#47148; . - 연속된 인덱스를 비교하여 더 큰 값을 오른쪽으로 보냄 . - 한 사이클을 돌면 가장 큰 값이 맨 뒤에 위치 . - 사이클마다 남은 수 중 가장 큰 값이 뒤에 위치함 . &#48260;&#48660; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2] . 2 첫 번째 인덱스와 두 번째 인덱스를 비교하여 더 큰값을 오른쪽에 위치시킨다 . 3 5와 8을 비교하면 8이 더 크므로 8을 오른쪽을 보낸다 . List = [5, 8, 7, 1, 2] . 4 이제 두 번째 인덱스와 세 번째 인덱스를 비교한다 . 5 8과 7을 비교하면 8이 더 크므로 8을 오른쪽으로 보낸다 . List = [5, 7, 8, 1, 2] . 6 이런식으로 한 사이클을 돌면 8이 마지막에 위치한다 . List = [5, 7, 1, 2, 8] . 7 다시 사이클을 돌면 7이 8 왼쪽에 위치한다 . List = [5, 1, 2, 7, 8] . 8 이런식으로 $n - 1$ 번의 사이클을 돌면 자료가 오름차순으로 정렬된다 . List = [1, 2, 5, 7 ,8] . &#48260;&#48660; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(n - 1, 0, -1): for j in range(i): if List[j + 1] &lt; List[j]: List[j + 1], List[j] = List[j], List[j + 1] print(List) . [5, 7, 1, 2, 8] [5, 1, 2, 7, 8] [1, 2, 5, 7, 8] [1, 2, 5, 7, 8] . &#49341;&#51077; &#51221;&#47148; . - 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교함 . - 자신의 위치를 찾아 삽입함 . - 일반적으로 선택 정렬, 버블 정렬 보다 빠름 . &#49341;&#51077; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2] . 2 두 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . List = [5, 8, 7, 1, 2] . 3 5와 8을 비교하면 8이 더 크므로 8을 오른쪽을 보낸다 . List = [5, 8, 7, 1, 2] . 4 세 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . 5 7과 8을 비교하면 8이 더 크고 5와 7을 비교하면 7이 더 크므로 5와 8사이에 위치한다 . List = [5, 7, 8, 1, 2] . 6 네 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . 7 1이 부분 리스트 중 가장 작으므로 맨 앞에 삽입 . List = [1, 5, 7, 8, 2] . 8 마지막 원소를 부분 리스트에서 적절한 위치에 삽입 . 9 2는 부분 리스트 중 1 다음으로 작으므로 1 오른쪽에 삽입 . List = [1, 2, 5, 7, 8] . &#49341;&#51077; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(1, n): j = i - 1 key = List[i] while List[j] &gt; key and j &gt;= 0: List[j+1] = List[j] j = j - 1 List[j+1] = key print(List) . [5, 8, 7, 1, 2] [5, 7, 8, 1, 2] [1, 5, 7, 8, 2] [1, 2, 5, 7, 8] . $O(NlogN)$ &#51221;&#47148; . &#48337;&#54633; &#51221;&#47148; . - 리스트 안에 있는 요소들을 왼쪽, 오른쪽 두 그룹으로 나눔 . - 각 그룹을 또 왼쪽, 오른쪽 두 그룹으로 나눔, 이를 요소가 1개 남을 때까지 반복함 . - 나누어진 두 개의 리스트를 병합함 . - 이를 정렬될 때까지 반복함 . &#48337;&#54633; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2, 3, 9, 4] . 2 그룹을 두 그룹으로 나눈다 . [5, 8, 7, 1], [2, 3, 9, 4] . 3 각 그룹을 두 그룹으로 나눈다 . [5, 8], [7, 1], [2, 3], [9, 4] . 4 이를 요소가 1개 남을 때까지 반복한다 . [5], [8], [7], [1], [2], [3], [9], [4] . 5 이제 나눈 순서의 역순으로 두 그룹씩 오름차순으로 병합한다 . [5, 8], [1, 7], [2, 3], [4, 9] . 6 이를 정렬이 끝날 때까지 반복한다 . [1, 5, 7, 8], [2, 3, 4, 9] . List = [1, 2, 3, 4, 5, 7, 8, 9] . &#48337;&#54633; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . - 위의 병합 정렬 알고리즘을 보면 두 그룹으로 나누고 병합하는 과정을 반복한다 . - 그렇기에 재귀 함수를 사용하여 구현했음 --&gt; 리스트의 길이가 클 경우 많은 재귀 함수 호출이 이루어지기에 시간이 매우 오래걸림(내 생각) . - 먼저 left, right로 나눈 후 나눠진 left를 가지고 또 left, right로 나눈다 . - left를 나누는 것이 끝나면 이제서야 right를 가지고 left, right로 나눈다 . 이 코드는 아래 코드보다 느림 | . - list타입.pop(0)은 $O(N)$임 . List = [5, 8, 7, 1, 2, 3, 9, 4] def mergeSort(x): if len(x) &lt;= 1: return x mid = len(x) // 2 left = x[:mid] right = x[mid:] next_left = mergeSort(left) next_right = mergeSort(right) return merge(next_left, next_right) def merge(left, right): sorted_list = [] while left and right: if left[0] &lt; right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) while left: sorted_list.append(left.pop(0)) while right: sorted_list.append(right.pop(0)) return sorted_list mergeSort(List) . - 그래서 pop(0)함수를 사용하지 않음 . - 아래의 코드가 이해가 잘 안될 수 있다 . - 그래서 어떻게 split하고 merge가 되는지 알아보기로 하자 . - 밑의 출력을 보니 처음으로 merge()에 대입된 left와 right는 [5]와 [8]임을 알 수 있다 . - 처음으로 넣은 값은 [5, 8, 7, 1, 2, 3, 9, 4]인데 신기하다 . - 자세히 살펴보자 . List = [5, 8, 7, 1, 2, 3, 9, 4] k = 0 def mergeSort(x): ## 나누기 n = len(x) if n &lt;= 1: return x mid = n // 2 left = x[:mid] ## mid를 기준으로 왼쪽 right = x[mid:] ## mid를 기준으로 오른쪽 next_left = mergeSort(left) ## 재귀적으로 나누기 next_right = mergeSort(right) ## 재귀적으로 나누기 global k k += 1 print(&#39;return 횟수 %s&#39; %k) return merge(next_left, next_right) def merge(left, right): ## 병합하기 i = 0 j = 0 sorted_list = list() print(left) print(right) while i &lt; len(left) and j &lt; len(right): ## left와 right중 더 작은 값 넣기 if left[i] &lt; right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 ## left와 right 중 남은 값을 넣어주기 while i &lt; len(left): sorted_list.append(left[i]) i += 1 while j &lt; len(right): sorted_list.append(right[j]) j += 1 return sorted_list print(mergeSort(List)) . return 횟수 1 [5] [8] return 횟수 2 [7] [1] return 횟수 3 [5, 8] [1, 7] return 횟수 4 [2] [3] return 횟수 5 [9] [4] return 횟수 6 [2, 3] [4, 9] return 횟수 7 [1, 5, 7, 8] [2, 3, 4, 9] [1, 2, 3, 4, 5, 7, 8, 9] . - 우선 mergeSort 함수에서 return은 총 7번 일어남을 알 수 있다 . - 각 상황에서 어떤일이 일어나는지 알아보자 . 우리는 print(mergeSort(List))를 통해 mergeSort 함수에 List라는 input을 넣었다 . | mergeSort에는 [5, 8, 7, 1, 2, 3, 9, 4]이 대입됐다 . | left는 [5, 8, 7, 1], right는 [2, 3, 9, 4]이다 . | next_left는 mergeSort([5, 8, 7, 1]), next_right는 mergeSort([2, 3, 9, 4])이다 . | merge(next_left, next_right)값을 return한다 . | 근데 merge(next_left, next_right)를 return하려고 보니까 next_left, next_right 값을 알아야한다 . | 4번으로 돌아가서 보면 mergeSort([5, 8, 7, 1])와 mergeSort([2, 3, 9, 4])를 구해야 한다 --&gt; 그럼 구하면 되지 . | mergeSort()에 [5, 8, 7, 1]이 대입된다 . | 그러면 mergeSort()는 merge(mergeSort([5, 8]), mergeSort([7, 1]))를 return한다 . | 근데 mergeSort([5, 8]), mergeSort([7, 1])값은 뭐지?? --&gt; 이것도 구해야 한다 . | mergeSort([5, 8])을 구하면 next_left = [5], next_right = [8]이다 . | merge(next_left, next_right)는 merge([5], [8])이 되고 드디어 merge()함수에 left와 right가 대입된다 --&gt; 그래서 처음 left와 right로 출력된 값이 [5]와 [8]이었던 것: return1 . | merge([5], [8])은 [5,8]인 sorted_list를 return한다 --&gt; mergeSort([5, 8])은 [5,8]을 return한다 즉, mergeSort([5, 8])= [5, 8] . | 이제 mergeSort([5, 8])를 구했으니 mergeSort([7, 1])값을 구할 차례이다 . | mergeSort([7, 1])은 merge([7], [1])이고 [1, 7]을 return한다 --&gt; mergeSort([7, 1]) = [1, 7]: return2 . | 이제 8번을 보자. 8번은 merge([5, 8, 7, 1])이고 merge(mergeSort([5, 8]), mergeSort([7, 1]))를 return한다 . | 이때는 mergeSort([5, 8])와 mergeSort([7, 1])를 모르는 상태였지만 이제는 구해서 알고 있다 . | merge([5, 8], [1, 7])을 구해보면 sorted_list로 [1, 5, 7, 8]을 return한다: return3 . | 이제 mergeSort([2, 3, 9, 4])을 구할 차례이다. 이는 위에서 한 방식대로 따라하면 된다 . | 결과적으로 print(mergeSort(List))는 [1, 2, 3, 4, 5, 7, 8, 9]을 출력하게 된다 . | - 메모리 아끼는 병합 정렬 참고: https://www.daleseo.com/sort-merge/ . $O(N)$ &#51221;&#47148; . &#44228;&#49688; &#51221;&#47148; . - 카운팅 정렬이라고도 한다 . - 양수만 가능, 값의 범위가 크면 안됨(메모리 크기를 넘기면 안됨) . - 수의 범위가 작다면(입력으로 주어지는 값들의 개수: 0 ~ 1이라고 수의 범위가 작은 것이 아님... 0 ~ 1사이의 수는 무한개이다) 카운팅 정렬을 통해 빠르게 정렬할 수 있음 . - 비교 정렬이 아님 --&gt; 위의 코드들은 다른 요소값과 비교하는데 카운팅 정렬은 비교없이 데이터를 정렬함 . - 입력으로 주어지는 input의 개수는 큰데 주어지는 값의 개수가 적다면 메모리 관점에서 효율적이다 . - 예로 input이 최대1억개인데 값이 1 ~ 10까지라면 위에서 다룬 정렬은 1억크기의 배열이 필요하지만 카운팅 정렬에 경우는 크기가 10인 배열을 만들면 된다 . - 하지만, 최대 수를 기준으로 배열을 만든다(최대값이 100인 경우 크기가 100인 리스트 생성) . - 그렇기에 [0, 1, 1, 1, 100]인 리스트를 정렬한다고 보면 숫자는 3개 뿐이지만 최대값이 100이므로 크기가 100인 리스트를 만들어야 한다 --&gt; 심한 메모리 낭비 . &#44228;&#49688; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 최대 값이 k인 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 1, 3, 9] . 2 k = 10 이라고 가정하자. [0] * (k+1) 리스트를 만든다 --&gt; 파이썬에서 인덱스는 0부터 시작하기 때문 . count = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] . 3 List 요소의 값을 x라 하면 count[x]의 값을 +1 해준다 . count = [0, 2, 0, 1, 0, 1, 0, 1, 1, 1, 0] . 4 count 리스트에서 자기(x) 앞에 몇개의 숫자가 있는지를 바탕으로 x의 위치를 결정하여 정렬한다. 예로 3의 경우 자기 앞에 숫자 2개가 있으므로 3번째이다 . List = [1, 1, 3, 5, 7, 8, 9] . &#44228;&#49688; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 1, 3, 9] def counting_sort(arr): count = [0] * (max(arr) + 1) sorted_list = [0] * len(arr) for i in arr: count[i] += 1 ## arr에 있는 수를 몇개인지 카운팅함 for j in range(1, max(arr) + 1): count[j] += count[j - 1] ## count[j] 앞에 몇 개의 숫자가 있는지 저장 ## count[5] = 10이라면 5가 x번 등장했다고 할 때 5앞에 10-x개의 숫자가 있다는 의미이므로 sorted_list[10-x : x]에 5가 위치한다. (x 번째 포함 no, x-1번째 까지) for k in range(len(arr)): sorted_list[count[arr[k]] - 1] = arr[k] ## 인덱스는 0부터 시작하므로 -1을 해줌 count[arr[k]] -= 1 return sorted_list print(counting_sort(List)) . [1, 1, 3, 5, 7, 8, 9] .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/04/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "relUrl": "/python/algorithm/2021/07/04/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "date": " • Jul 4, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "확률 분포",
            "content": "- 2학기에 수리통계학 배움 . - 내용 추가 + 확률 밀도 함수 유도 과정 추가 + 증명 안하고 넘어갔던 부분 추가 예정 . - 만약 수리통계학에 없는 내용이라면? &gt; . . . . . . . &#54869;&#47456; &#48516;&#54252;&#46976;? . - 확률 분포(probability distribution)는 확률 변수가 특정한 값을 가질 확률을 나타내는 함수를 의미한다 &gt; 참고: 확률 분포 . &#44536;&#47111;&#45796;&#47732; &#54869;&#47456; &#48320;&#49688;&#46976;? . - 확률변수(Random Variable)란 무작위 실험을 했을 때, 특정 확률로 발생하는 각각의 결과를 수치로 표현한 변수 . - 무작위 실험 &gt; 동전 던지기 . - 특정 확률 &gt; 앞면이 나올 확률 $ frac{1}{2}$, 뒷면이 나올 확률 $ frac{1}{2}$ . - 수치 &gt; 앞면 = $1$, 뒷면 = $2$ . &#50672;&#49549; &#54869;&#47456; &#48516;&#54252; . - 연속 확률 변수가 가지는 확률 분포 . - 이산 확률 변수는 확률을 $[ star]P(X=x)[ star]$와 같이 표현 가능, 연속 확률 변수는 불가능 . - 연속 확률 변수는 확률을 $[ star]P(A leq X leq B)[ star]$로 표현 가능 . &#51221;&#44508; &#48516;&#54252; . - 정규 분포는 수집된 자료의 분포를 근사하는 데에 자주 사용됨 . - 중심극한정리에 의하여 독립적인 확률변수들의 평균은 정규 분포에 가까워지는 성질이 있기 때문임 . - 신뢰구간이나 가설검정 등의 모델에서 사용 . - 기호로는 $N sim ( mu, sigma^{2})$ . - 정규 분포의 기댓값, 중앙값, 최빈값은 $ mu$, 분산은 $ sigma^{2}$ . - 표준정규분포는 평균이 0, 표준편차가 1인 경우임 &gt; $N sim (0, 1)$ . - 정규 분포에서 $ mu pm2 sigma$에 전체 데이터 중 $95 %$가 존재 . &#54364;&#51456;&#54868; . - 정규 분포 밀도 함수에서 $Z =$ $ frac{X - mu}{ sigma}$ 를 통해 $X$(원점수)를 $Z$($z$점수) 표준화하여 표준정규분포(z-분포)를 얻을 수 있다 . &#51221;&#44508; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688;(PDF) . $f(x) = frac{1}{ sqrt{2 pi sigma^{2}}}e^{- frac{(x- mu)^{2}}{2 sigma^{2}}}$ . &#51221;&#44508; &#48516;&#54252; plot . import numpy as np np.random.normal(loc, scale, size) . - loc는 평균, scale은 표준편차, size는 표본의 수 . np.random.normal(loc = 0, scale = 1, size = 1000) . - np.random.normal(loc = 0, scale = 1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.normal(loc = 0, scale = 1, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.normal(loc = 0, scale = 1, size = 1000)&#39;) plt.show() . &#44512;&#51068; &#48516;&#54252; . - 모든 확률 변수에 대하여 구간 내에서 균일한 확률을 가짐 . - 임의의 구간 내에서 균일한 확률을 가지기에 난수 생성기로 쓰임 . - 이산 확률 변수에서도 가능 . &#44512;&#51068; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x) = begin{cases} frac{1}{b-a} &amp; text{for $x in [a,b]$} 0 &amp; text{otherwise} end{cases} $ . - $f(x)$는 구간 $[a,b]$에서 균등한 확률을 가짐 . &#44512;&#51068; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = frac{a+b}{2}$ . - $Var(X) = frac{(b-a)^{2}}{12}$ . &#44512;&#51068; &#48516;&#54252; plot . import numpy as np np.random.uniform(low, high, size) . - low는 출력값의 최소 경계, high은 출력값의 최대 경계, size는 표본의 수 . np.random.uniform(low = 0, high = 1, size = 1000) . - np.random.uniform(low = 0, high = 1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.uniform(low = 0, high = 1, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.normal(loc = 0, scale = 1, size = 1000)&#39;) plt.show() . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;($x^2$&#48516;&#54252;) . - $k$개의 서로 독립인 표준 정규 확률변수를 각각 제곱하여 합해 얻어진 분포 . - 이때 $k$는 자유도이며 카이제곱 분포의 매개변수 . - 분산의 퍼진 정도를 분포로 보여줌 . - 모분산을 구하거나 적합도 검정, 독립성/동질성 검정 등의 모델에서 사용 . - $k$개의 독립적이고 표준정규분포를 따르는 확률변수 $Z_1, dots,Z_k$가 있을 때 자유도 $k$의 카이제곱 분포는 . - 확률변수 $Q = sum^{k}_{i=1}Z{_i}{^2}$의 분포임 . - 따라서 $Q sim X{_k}{^i}$ . - 참고: 카이제곱 분포 . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x; k) = frac{1}{2^ frac{k}{2} Gamma( frac{k}{2})}x^{ frac{k}{2}-1}e^{- frac{x}{2}}$ . - $ Gamma( frac{k}{2})$는 감마함수이다 . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = k$ . - $Var(X) = 2k$ . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252; plot . import numpy as np np.random.chisquare(df, size) . - df는 자유도, size는 표본의 수 . np.random.chisquare(df = 10, size = 1000) . - np.random.chisquare(df = 10, size = 1000)를 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.chisquare(df = 10, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.chisquare(df = 10, size = 1000)&#39;) plt.show() . - 자유도(df)를 바꿔볼까? . - df = 5 . np.random.seed(1) sample = np.random.chisquare(df = 5, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.chisquare(df = 5 , size = 1000)&#39;) plt.show() . - df = 1 . - 표준정규분포의 제곱은 자유도가 1인 카이제곱 분포를 따름 . - $V = ( frac{X- mu}{ sigma})^{2} sim X^{2}(1)$ . - 표본을 10000개 뽑아 둘을 비교해보자! . np.random.seed(2) sample = np.random.chisquare(df = 1, size = 10000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.chisquare(df = 1 , size = 10000)&#39;) plt.show() . np.random.seed(2) sample = np.random.normal(loc = 0, scale = 1, size = 10000) sample = sample**2 plt.hist(sample, bins = 30) plt.title(&#39;square of a standard normal distribution&#39;) plt.show() . - 두 분포가 거의 동일하다 . - 표준정규분포의 제곱은 자유도가 1인 카이제곱 분포를 따른다는 것을 확인할 수 있다 . &#51648;&#49688; &#48516;&#54252; . - 사건이 서로 독립적일 때, 일정 시간동안 발생하는 사건의 횟수가 포아송 분포를 따른다면, 다음 사건이 일어날 때까지 대기 시간은 지수분포를 따른다(지수 분포) . - 기하 분포에서 베르누이 시행 횟수$n$이 많아지고 성공 확률 $p$가 작아지면 지수 분포로 수렴 . - 감마 분포에서 $ alpha = 1$일 때의 특수한 경우임(감마 분포 참고) . &#51648;&#49688; &#48516;&#54252;&#51032; &#47924;&#44592;&#50613;&#49457; . - 기하 분포의 무기억성과 같은 내용임 . - $P(A|B)$ &gt; 사건 B가 발생한 상황에서 사건 A가 발생할 확률 . - $P(X&gt;s+t|X&gt;t) = P(X&gt;s)$ . - 핸드폰의 고장률이 지수 분포를 따른다면 내가 핸드폰을 처음 구매하고 1년안에 고장날 확률 = 핸드폰을 5년 사용한 시점에서 1년 안에 고장날 확률 . - 물론 현실은 핸드폰을 5년 사용한 후에 고장날 확률이 더 크다 . - 지수 분포는 무기억 성질을 갖는 유일한 연속 확률 분포 . &#51648;&#49688; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x; beta) = frac{1}{ beta}e^{- frac{x}{ beta}}, ; x &gt; 0$ . - 위의 확률 밀도 함수는 감마 분포의 확률 밀도 함수에서 $ alpha = 1$을 대입한 결과이다 . - 여기서 $ beta$는 사건 사이의 평균 시간인데 포아송 분포의 모수인 $ lambda$는 단위 시간당 사건의 평균 발생 횟수이다 . - 위의 지수 분포 설명에서 사건의 횟수가 포아송 분포를 따를 때를 전제로 대기 시간은 지수 분포를 따른다고 했다 . - 그렇기에 여기서는 위의 확률 밀도 함수 대신 포아송 분포의 모수인 $ lambda = frac{1}{ beta}$ 를 통해 지수 분포의 확률 밀도 함수를 나타내기로 함 . - 위아래 확률 밀도 함수 둘 다 맞는 표현임, 그런데 numpy.random.exponential이 위의 확률 밀도 함수를 사용하므로 위의 확률 밀도 함수를 기억하는 것이 좋을 것 같음 . $f(x; lambda) = lambda e^{- lambda x}, ; x&gt;0$ . &#51648;&#49688; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = frac{1}{ lambda}$ . - $Var(X) = frac{1}{ lambda^{2}}$ . - 기댓값은 어찌보면 당연한데 단위 시간 동안 사건이 $ lambda$번 발생한다면 대기 시간은 $ frac{1}{ lambda}$여야 $ lambda times frac{1}{ lambda} = 1 text{(단위 시간)}$이 성립한다 . &#51648;&#49688; &#48516;&#54252; plot . - 사건이 발생하고 다음 사건이 발생하기 까지의 대기 시간에 대한 확률 분포 . - numpy.random.exponential의 확률 밀도 함수는 $f(x; beta) = frac{1}{ beta}e^{- frac{x}{ beta}}, ; x &gt; 0$임 (numpy 지수 함수) . import numpy as np np.random.exponential(scale, size) . - scale은 $ beta$ = 대기 시간, size는 표본의 수 . np.random.exponential(scale = 2, size = 1000) . - 우리 집 앞에서 1시간당 평균 0.5명이 넘어진다 &gt; $ lambda text{(사건의 빈도)} = 0.5$이므로 대기 시간 $ beta text{(대기 시간)} = 2$ . - 다시말하면 우리 집 앞에서 한 명이 넘어지고 다음 사람이 넘어지기 까지 2시간이 걸린다 . - 이때 한 사람이 넘어지고 다음 사람이 넘어지기 까지 걸리는 대기 시간에 대한 분포를 그려보자 . - np.random.exponential(scale = 2, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.exponential(scale = 2, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.exponential(scale = 2, size = 1000)&#39;) plt.show() . &#44048;&#47560; &#48516;&#54252; . - 감마 분포는 지수 분포나 푸아송 분포 등의 매개변수에 대한 켤레 사전 확률 분포 . - 이에 따라 베이즈 확률론에서 사전 확률 분포로 사용 . - $ alpha$개의 사건이 일어날 때까지 걸리는 대기 시간에 대한 분포 . - 지수 분포를 한 번의 사건이 아닌 여러 개의 사건으로 확장 . - 지수 분포의 모수가$ beta$ &gt; $ beta$ = 사건 사이의 평균 시간 . - 모수가 $ beta$인 지수 분포를 따르는 확률 변수 X가 $ alpha$개가 있고 각 확률 변수 X는 i.i.d를 따름 &gt; 이 확률 변수의 합은 모수가 $ alpha, beta$인 감마 분포를 따름 . - 참고: 감마 분포 . &#44048;&#47560;&#54632;&#49688;(Gamma Function) . - 복소수 범위까지 일반화 된 팩토리얼(!) . $ Gamma( alpha) = int_{0}^{ infty}x^{ alpha-1}e^{-x}dx, , alpha geq 0$ . &#44048;&#47560;&#54632;&#49688; &#49457;&#51656; . - $ Gamma( alpha+1) = alpha Gamma( alpha)$ . - $ Gamma(n) = (n-1)!, , n in mathbb{N}$ . - $ Gamma( frac{1}{2}) = sqrt{ pi}$ . &#44048;&#47560; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x; alpha, beta) = frac{1}{ beta^{ alpha} Gamma( alpha)}x^{ alpha - 1}e^{- frac{x}{ beta}},(x, alpha, beta geq 0)$ . - 확률 변수 $X$가 감마 분포를 따른 다면 $X sim Gamma( alpha, beta)$ . - 발생하기 까지의 평균$ beta = frac{1}{ lambda}$의 시간이 소요되는 어떤 사건이 $ alpha$번 발생하는데 걸리는 시간 $X$에 대한 확률 분포 . - $ lambda$는 포아송 분포의 모수로 단위 시간당 사건의 평균 발생 횟수 . - $ alpha = 1$일 때 $ lambda = frac{1}{ beta}$인 지수 분포를 따름 . - $X sim Gamma(1, beta) Leftrightarrow exp( frac{1}{ beta})$ . &#44048;&#47560; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = alpha beta$ . - $Var(X) = alpha beta^{2}$ . &#44048;&#47560; &#48516;&#54252; plot . - $ alpha$는 형태 모수(shape parameter), $ beta$는 척도 모수(scale parameter) . - 사건이 발생하고 다음 사건이 발생하기 까지의 평균 대기 시간이 $ beta$일 때 $ alpha$번의 사건이 발생하는데 걸리는 시간에 대한 확률 분포 . import numpy as np np.random.gamma(shape, scale, size) . - shape는 $ alpha$, scale은$ beta$, size는 표본의 수 . np.random.gamma(shape = 2, scale = 2, size = 1000) . - 우리 집 앞에서 1시간당 평균 0.5명이 넘어진다 &gt; $ lambda = 0.5$이므로 $ beta = 2$ . - 다시말하면 우리 집 앞에서 한 명이 넘어지고 다음 사람이 넘어지기 까지 평균 2시간이 걸린다 . - 이때 2명의 사람이 넘어지기 까지 걸리는 시간에 대한 분포를 그려보자 . - np.random.gamma(shape = 2, scale = 2, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.gamma(shape = 2, scale = 2, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.gamma(shape = 2, scale = 2, size = 1000)&#39;) plt.show() . - 위에서 지수 분포는 감마 분포에서 $ alpha = 1$인 특수한 경우라고 했음 . - 진짜로 동일한지 $ beta = 4$인 지수 분포와 $ alpha = 1, beta = 4$인 감마 분포를 히스토그램을 그려 비교하자 . np.random.seed(1) sample1 = np.random.gamma(shape = 1, scale = 4, size = 1000) sample2 = np.random.exponential(scale = 4, size = 1000) fig, ax = plt.subplots(1, 2, figsize = (14, 4)) ax[0].hist(sample1, bins = 30) ax[1].hist(sample2, bins = 30) ax[0].set_title(&#39;np.random.gamma(shape = 2, scale = 4, size = 1000)&#39;) ax[1].set_title(&#39;np.random.exponential(scale = 4, size = 1000)&#39;) plt.show() . - 히스토그램을 통해 비교하니 $ alpha = 1$인 감마 분포는 지수 분포와 동일함을 알 수 있다 . $ alpha$&#50752;$ beta$&#50640; &#46384;&#47480; &#44048;&#47560; &#48516;&#54252; &#47784;&#50577; . - $ alpha$는 형태 모수로 $ alpha$가 커질수록 그래프의 모양이 종모양에 가까워짐 . - $ beta$는 척도 모수로 $ beta$가 커질수록 그래프가 퍼짐 . - shape는 $ alpha$, scale은 $ beta$, loc은 위치 매개변수 . - scipy.stats.gamma 참고 . $ alpha$ &#48320;&#54868; $ beta$ &#44256;&#51221; . - $ alpha$(사건 발생 횟수)가 커질수록 그래프가 종모양에 가까워짐 . import numpy as np import matplotlib.pyplot as plt from scipy.stats import gamma loc = 0 scale = 0.5 x = np.linspace(0, 12, 1000) plt.figure(figsize = (14, 7)) for shape in np.arange(2, 11, 2): plt.plot(x, gamma(shape, loc, scale).pdf(x), label = &#39;α = &#39; + str(shape)) plt.title(&quot;Gamma distribution(α = 2, 4, 6, 8, 10, β = 0.5)&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$f(x)$&quot;) plt.grid() plt.legend() plt.show() . $ alpha$ &#44256;&#51221; $ beta$ &#48320;&#54868; . - $ beta$(대기 시간)가 커질수록 그래프가 넓게 퍼짐 . loc = 0 shape = 3 x = np.linspace(0, 16, 1000) plt.figure(figsize = (14, 7)) for scale in np.arange(0.4, 2.1, 0.4): plt.plot(x, gamma(shape, loc, scale).pdf(x), label = &#39;β = &#39; + str(round(scale, 1))) plt.title(&quot;Gamma distribution(α = 3, β = 0.4, 0.8, 1.2, 1.6, 2.0)&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$f(x)$&quot;) plt.grid() plt.legend() plt.show() . t &#48516;&#54252; . - 표본평균$ bar{X}$을 이용해 정규분포의 평균을 해석 &gt; 모집단이 정규분포를 따를 때 . - 표준화한 표본평균의 분포: 모표준편차를 알고 있음($ frac{x- mu}{ sqrt{ frac{ sigma}{n}}}$) --&gt; 정규분포, 모표준편차를 모르고 표본표준편차를 알고 있음($ frac{x- bar{x}}{ sqrt{ frac{s}{n}}}$) &gt; t분포 . - 다음의 확률 분포로 정의 &gt; $ frac{Z}{ sqrt{ frac{V}{ nu}}}$ . - $Z$는 표준정규분포, $V$는 자유도$ nu$인 카이제곱 분포 . - 자유도가 커질수록 표준정규분포에 가까워짐 (중심극한정리와 무관) &gt; 보통 표본 크기 $n geq30$이면 표준정규분포와 가깝다고 한다 . - [$ star$]표본크기가 커지면 표준정규분포에 가까워짐[$ star$] &gt; 표본 크기가 커진다는 것은 모집단에 가까워진다는 의미이므로 표본표준편차도 모표준편차에 가까워짐 . - t 분포의 적률생성함수는 정의되지 않음 . - 참고: t분포 . t &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x) = frac{ Gamma( frac{ nu + 1}{2})}{ sqrt{ nu pi} Gamma( frac{ nu}{2})}(1+ frac{x^2}{ nu})^{-( frac{ nu+1}{2})}$ . t &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = 0, ; nu &gt; 1$ . - $Var(X) = frac{ nu}{ nu-2} ,( nu&gt;2), ; infty ,(1&lt;v leq2)$ . t &#48516;&#54252; plot . import numpy as np np.random.standard_t(df, size) . - df는 자유도, size는 표본의 수 . np.random.standard_t(df = 5, size = 1000) . - np.random.standard_t(df = 5, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.standard_t(df = 5, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.standard_t(df = 5, size = 1000)&#39;) plt.show() . - $x = 0$을 기준으로 대칭임 . - 자유도가 5이므로 표본 크기는 6 . - 모표준편차 대신 표본표준편차를 알고 표본 크기가 6일 때 표준화한 표본 평균($ frac{x- bar{x}}{ sqrt{ frac{s}{n}}}$)에 대한 분포 . - t분포는 표준정규분포보다 꼬리 부근에 밀도가 높음 &gt; 모표준편차 대신 표본표준편차를 사용하기 때문 &gt; 표본의 특성상 추출할 때마다 다르므로 변동성이 있음 . F &#48516;&#54252; . - F 검정과 분산분석(ANOVA)등에서 주로 사용됨 . - 카이제곱 분포가 한 집단의 분산에 대해 다뤘다면 F 분포는 두 집단의 분산에 대해 다룸 . - 두 확률변수 $V_1, V_2$가 각각 자유도가 $ nu_1, nu_2$이고 서로 독립인 카이제곱 분포를 따를 때 다음의 확률변수 F는 자유도가 ($ nu_1, nu_2$)인 F-분포를 따름 . - 적률생성함수가 존재하지 않음 . - $F = frac{ frac{V_1}{ nu_1}}{ frac{V_2}{ nu_2}} sim F( nu_1, nu_2)$ . - 참고: F 분포 . F &#48516;&#54252; &#49457;&#51656; . - 분자와 분모의 자유도가 뒤바뀐 F 분포 성질: $F_{ nu_1, nu_2, alpha} = frac{1}{F_{ nu_2, nu_1, alpha}}$ . - t 분포를 제곱하면 분자와 분모의 자유도가 각각 1, $ nu$인 F분포가 된다 . - $t = frac{Z}{ sqrt{ frac{U}{ nu}}} sim t_{ nu}$ . F &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x) = frac{ Gamma( frac{ nu_1+ nu_2}{2})( frac{ nu_1}{ nu_2})^{ frac{ nu_1}{2}}x^{ frac{ nu_1}{2}-1}}{ Gamma( frac{ nu_1}{2}) Gamma( frac{ nu_2}{2})(1+ frac{ nu_1}{ nu_2}x)^{ frac{ nu_1+ nu_2}{2}}}$ . F &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X)= frac{ nu_2}{ nu_2-2}, ; nu_2&gt;2$ . - $Var(X)= frac{2{ nu_{2}}^{2}( nu_1+ nu_2-2)}{ nu_1( nu_2-2)^{2}( nu_2-4)}, ; nu_2&gt;4$ . F &#48516;&#54252; plot . import numpy as np np.random.f(dfnum, dfden, size) . - dfnum은 분자의 자유도, dfden은 분모의 자유도, size는 표본의 수 . np.random.f(dfnum = 1, dfden = 10, size = 1000) . - np.random.f(dfnum = 1, dfden = 5, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.f(dfnum = 1, dfden = 10, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.f(dfnum = 1, dfden = 10, size = 1000)&#39;) plt.show() . &#48288;&#53440; &#48516;&#54252; . - 제한된 범위$[0, 1]$에서 확률적인 모델링에 적합함(ex: 비율) . - 두개의 매개변수 $ alpha, beta$에 따라 그래프의 모양이 다양함 . - 베타 분포는 확률에 대한 확률분포 &gt; 베이즈안 통계학에서 이항 분포의 켤레 사전 분포로 사용됨 . - 베이지안 방법 &gt; 모수를 확률변수로 생각하여 사전 정보를 활용해 모수를 추정함 . - 이항 분포에서는 성공 확률 $p$가 고정이고 성공 횟수($n-x=$ 실패횟수)가 확률변수인데 베타 분포에서는 성공 횟수($ alpha-1$)와 실패 횟수($ beta-1$)이 고정이고 성공 확률이 확률변수임 . - 베타 분포에서 $ alpha =1, beta=1$이면 균일분포와 동일함 &gt; $ alpha=1, beta=1$이면 성공 횟수와 실패 횟수 둘다$0$이므로 성공확률을 특정할 수 없어서 균일분포 모양을 띄움 . - 참고: 베타 분포 . &#48288;&#53440; &#54632;&#49688; . - 베타 분포의 확률 밀도 함수의 적분값을 1로 만드는 상수 . - 이항 계수를 실수범위까지 확장한 것 . $B( alpha, beta)= int_{0}^{1}x^{ alpha -1}(1-x)^{ beta - 1}dx = frac{ Gamma( alpha) Gamma( beta)}{ Gamma( alpha + beta)}$ . &#48288;&#53440; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x)= frac{1}{B( alpha, beta)}x^{ alpha-1}(1-x)^{ beta-1}, quad 0 leq x leq1, ;( alpha , beta&gt;0)$ . &#48288;&#53440; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X)= frac{ alpha}{ alpha + beta}$ . - $Var(X)= frac{ alpha beta}{( alpha+ beta)^{2}( alpha+ beta+1)}$ . - $ underset{x}{ mathrm{argmax}} , f(x)= frac{ alpha-1}{ alpha + beta - 2}, ; ( alpha, beta &gt; 1)$ . - 최빈값은 성공횟수($ alpha-1$)와 실패횟수($ beta-1$)에 대한 성공률(= 성공횟수($ alpha-1$) / 성공횟수($ alpha-1$) + 실패횟수($ beta-1$)) . &#48288;&#53440; &#48516;&#54252;&#50752; &#51060;&#54637; &#48516;&#54252; . - 베타 분포는 확률에 대한 확률분포라고 했음 . - 예시를 들어서 설명하자 . - 게임을 하는 중임 &gt; 동전이 있는데 앞면이 나오면 이김 &gt; 그런데 앞면과 뒷면이 나올 확률을 알지 못함 . - 연습으로 동전을 10번 던져봤더니 앞면이 3번 뒷면이 7번 나왔음 &gt; 앞면이 나와야 이기므로 앞면이 나올 확률이 뒷면이 나올 확률 보다 높으면 좋겠음 . - 위에 상황에서 앞면이 나올 확률이 0.5보다 클 확률은 얼마일까? &gt; 확률에 대한 확률분포 . $P(X&gt;0.5) = 1-P(X&lt;0.5) =1- int_{0}^{0.5} frac{ Gamma(12)}{ Gamma(4) Gamma(8)}x^{4-1}(1-x)^{8-1}dx =1- int_{0}^{0.5} binom{12}{4}x^{4-1}(1-x)^{8-1}dx = ,???$ | . - 적분하기가 힘들다 . - R의 pbeta() 함수로 구해보자 . import rpy2 import os os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; %load_ext rpy2.ipython . C: anaconda3 envs py38r40 lib site-packages rpy2 robjects packages.py:366: UserWarning: The symbol &#39;quartz&#39; is not in this R namespace/package. warnings.warn( . %%R 1 - pbeta(0.5, shape1 = 4, shape2 = 8) . [1] 0.1132812 . - 앞면이 3번 뒷면이 7번 나왔을 때 앞면이 나올 확률이 0.5보다 클 확률은 0.1132812이다 &gt; 약 11% . - 아무래도 게임에서 이기기는 힘들어 보인다 . - 그런데 위의 식에서 3번째 줄을 보면 이항 분포가 보인다 . - 성공확률의 거듭제곱과 실패확률의 거듭제곱은 이항분포의 확률 질량 함수에서도 존재함 . - 베타 분포에서는 확률변수 $X$가 성공 확률인 반면 이항 분포에서는 확률변수 $X$가 성공 횟수임 . - 베타 분포: $ frac{1}{B( alpha, beta)}x^{ alpha-1}(1-x)^{ beta-1}, ;$ $x$는 성공 확률 . - 이항 분포: $ binom{n}{x} ,p^{k} ,(1-p)^{n-x}, ;$ $x$는 성공 횟수 . - 이렇기에 이항 분포의 모수를 추정하는데 베타 분포가 사전 분포로 사용된다 . &#48288;&#53440; &#48516;&#54252; plot . - scipy.stats.beta()를 통해 다양한 베타 분포를 그려보자 . import numpy as np import matplotlib.pyplot as plt from scipy.stats import beta x = np.linspace(0, 1, 1000) beta_pdf1 = beta(a = 0.5, b = 0.5).pdf(x) beta_pdf2 = beta(a = 5, b = 1).pdf(x) beta_pdf3 = beta(a = 1, b = 3).pdf(x) beta_pdf4 = beta(a = 2, b = 2).pdf(x) beta_pdf5 = beta(a = 2, b = 5).pdf(x) plt.figure(figsize = (7, 5)) plt.plot(x, beta_pdf1, label = &#39;α = 0.5, β = 0.5&#39;) plt.plot(x, beta_pdf2, label = &#39;α = 5, β = 1&#39;) plt.plot(x, beta_pdf3, label = &#39;α = 1, β = 3&#39;) plt.plot(x, beta_pdf4, label = &#39;α = 2, β = 2&#39;) plt.plot(x, beta_pdf5, label = &#39;α = 2, β = 5&#39;) plt.xlabel(&#39;rate of success(x)&#39;) plt.ylabel(&#39;Beta pdf&#39;) plt.title(&#39;Beta distribution&#39;) plt.grid() plt.legend() plt.show() . - $x$축은 성공확률이어서 0과 1사이임 . - $y$축 자체가 확률이 아니라 $ int_{a}^{b}f(x)dx$가 확률이고 $y$축은 $f(x)$임 . - $ alpha = 1, beta geq 1$이면 성공횟수는 0인데 실패횟수는 존재하므로 성공확률 $x$가 낮을 수록 함수값이 큼 . - $ alpha geq 1, beta = 1$이면 성공횟수는 존재하는데 실패횟수는 0이므로 성공확률 $x$가 높을 수록 함수값이 큼 . - $ alpha &gt; 1, beta &gt; 1$이면 기댓값 부근에서 함수값이 크다 + $ alpha+ beta$가 커지고 $ alpha$와 $ beta$가 비슷하면 정규분포에 근사 가능 . - $ alpha &lt; 1, beta &lt; 1$이면 $x$가 0 과 1에 극단적으로 치우침 . &#51060;&#49328; &#54869;&#47456; &#48516;&#54252; . - 이산 확률 변수가 가지는 확률 분포 . &#48288;&#47476;&#45572;&#51060; &#49884;&#54665; . - 임의의 결과가 성공 또는 실패와 같이 가능한 결과가 2 가지 . &#48288;&#47476;&#45572;&#51060; &#49884;&#54665; &#51312;&#44148; . - 각 시행의 결과는 상호 배타적인 두 사건(성공 or 실패)으로 구분 . - 성공 확률 $p$, 실패 확률 $q$일 때, $p+q=1$ . - 각 시행은 독립적 . &#51060;&#54637; &#48516;&#54252; . - 서로 독립이고 동일한 베르누이 분포를 따르는 확률변수$X_1, dots,X_n$을 모두 합한 것 &gt; $X = sum limits_{i=1}^{n}X_i$ . - 성공 확률이 $p$인 베르누이 시행을 독립적으로 $n$번 반복했을 때 성공 횟수 $X$는 이항 분포를 따름 . - 기호로는 $X sim B(n,p)$ . - 독립적 시행 &gt; 각 시행은 서로 영향을 주지 않음 . &#51060;&#54637; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688;(PMF) . $f(x) ,= , _{n} rm C_{x} ,p^{x} ,(1-p)^{n-x} ,= , binom{n}{x} ,p^{k} ,(1-p)^{n-x}$ . - 성공 확률 $p$인 베르누이 시행을 $n$번 시행하여 그 중 $x$번을 성공할 확률 질량 함수 . - 베르누이 분포는 이항 분포에서 $n=1$일 때이다 . &#51060;&#54637;&#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = np$ . - $Var(X) = np(1-p)$ . &#51060;&#54637; &#48516;&#54252; plot . import numpy as np np.random.binomial(n, p, size) . - $n$은 표본 크기, $p$는 성공 확률, size는 표본의 수 . np.random.binomial(n = 50, p = 0.5, size = 1000) . - 성공 확률이 p = 0.5인 베르누이 시행을 n = 50번 반복하는 것을 표본 하나로 두고 표본을 size = 1000번 추출한다 . - 동전 던지기($p=0.5$)를 $n$ = $50$번 시행하여 앞면이 나온 횟수($X=0,1,2, dots,49,50$)를 하나의 표본이라 할 때 표본을 $size = 1000$번 추출한다 . - np.random.binomial(n = 10, p = 0.5, size = 1000)을 히스토그램으로 나타내면? . - $np geq 5$ 이면 이항분포를 정규분포로 근사할 수 있다 . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.binomial(n = 10, p = 0.5, size = 1000) plt.hist(sample) plt.title(&#39;np.random.binomial(n = 10, p = 0.5, size = 1000)&#39;) plt.show() . &#54252;&#50500;&#49569; &#48516;&#54252; . - 단위 시간, 단위 공간 안에 어떤 사건이 몇 번 발생할 것인지를 표현하는 이산 확률 분포 . - 이항 분포에서 시행횟수$n$이 매우 크고 성공 확률$p$가 매우 작은 경우 성공횟수는 포아송 분포로 근사 가능 &gt; 나중에 증명 . - 음이항 분포에서 성공횟수$x$가 매우 크고 실패 확률$p$가 매우 작은 경우 실패횟수는 포아송 분포로 근사 가능 &gt; 나중에 증명 . - 포아송 분포의 모수($ lambda$)는 단위 시간에서 사건의 평균 발생 횟수 . &#54252;&#50500;&#49569; &#48516;&#54252; &#51204;&#51228; &#51312;&#44148; . - 독립성: 1시간 동안 우리 집 앞에서 넘어진 사람 수와 친구 집앞에서 넘어진 사람 수는 독립이다 . - 일정성: 1시간 동안 평균 3명이 넘어졌다면 2시간 동안에는 평균 6명이 넘어진다 . - 비집락성: 우리 집 앞에서 같은 시간에 두 명 이상이 넘어질 확률은 0이다 . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) = frac{e^{- lambda} lambda^{x}}{x!}$ . - $x$는 단위 시간에서 사건의 발생 횟수, $ lambda$는 단위 시간에서 사건의 평균 발생 횟수 . - $ lambda = 10$, $x = 7$ &gt; 단위 시간에서 사건의 평균 10번 발생할 때 7번 발생할 확률은? . - 우리 집 앞에서 1시간에 사람이 평균적으로 10명이 넘어진다고 한다. 이 때 1시간에 사람이 5명 넘어질 확률은? . - $ lambda = 10, , x = 5 longrightarrow f(5) = frac{e^{-10} ,10^5}{5!} = 0.03783327480207071$ . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = lambda$ . - $Var(X) = lambda$ . - 평균과 분산이 같으므로 평균이 클수록 그래프가 더 넓게 퍼진다 . &#54252;&#50500;&#49569; &#48516;&#54252; plot . import numpy np.random.poisson(lam, size) . - $ lambda$는 모수, size는 표본의 수 . np.random.poisson(lam = 10, size = 1000) . - 단위 시간에서 사건이 평균 10번 발생할 때 (lam = 10) 단위 시간에서 사건이 몇 번 발생하는지를 하나의 표본이라 할 때 size = 1000번 표본을 추출한다 . - 우리 집 앞에서 1시간당 평균 10명이 넘어질 때($ lambda=10$) 1시간당 몇 명 넘어지는지($x = 0,1,2, dots,10,11, dots$)를 $size = 1000$번 기록한다 . - np.random.poisson(lam = 10, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.poisson(lam = 10, size = 1000) plt.hist(sample, bins = 24) plt.title(&#39;np.random.poisson(lam = 10, size = 1000)&#39;) plt.show() . - $ lambda$를 바꿔볼까? &gt; 우리 집 앞에서 1시간당 평균 4명이 넘어진다면?? . np.random.seed(1) sample = np.random.poisson(lam = 4, size = 1000) plt.hist(sample) plt.title(&#39;np.random.poisson(lam = 4, size = 1000)&#39;) plt.show() . &#44592;&#54616; &#48516;&#54252; . - 어떤 확률변수 $X$가 성공 확률이 $p$인 베르누이 시행에서 처음 성공까지 시도한 횟수라고 할 때 $X$는 성공 확률 $p$인 기하분포를 따른다 . - 처음 성공할 때까지 걸린 시도 횟수 X가 확률 변수이다 . &#44592;&#54616; &#48516;&#54252;&#51032; &#47924;&#44592;&#50613;&#49457; . - $P(X=x+k|X&gt;k)=P(X=x)$ . - 성공 확률 p인 베르누이 시행을 현재 k번 시도 했다 . - 하지만 아직 까지 성공하지 못했다 . - 내가 여태까지 k번 실패했으니까 성공확률이 올라갈까?? &gt; 답은 No . - 내가 이제껏 시도한 횟수와 관계없이 성공할 확률은 p로 동일하다 . - 쉽게 말하자면 내가 순백의 주문서10%를 바르고 있는 중이다 . - 여태까지 50장을 발랐는데도 성공하지 못했다 . - 하지만 확률은 그대로 10%이고 기댓값도 10번으로 동일하다 . - 즉, 처음에 순백의 주문서를 성공시키기 위한 기대되는 시도 횟수는 10번이다 . - 50번을 실패했지만 여전히 순백의 주문서를 성공시키기 위한 기대되는 시도 횟수는 10번이다...... . &#44592;&#54616; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) = (1-p)^{x-1}p, ; x = 1, 2, 3, dots$ . - 성공 확률이 $p$일 때 $x-1$번 째 시도까지는 모두 실패하고 $x$번 째 시도에 성공할 확률 질량 함수 . &#44592;&#54616; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = frac{1}{p}$ . - $Var(X) = frac{1-p}{p^2}$ . &#44592;&#54616; &#48516;&#54252; plot . import numpy np.random.geometric(p, size) . - $p$는 베르누이 시행에서 성공 확률, size는 표본의 수 . np.random.geometric(p = 0.1, size = 1000) . - 성공 확률이 p = 0.1인 베르누이 시행을 성공할 때까지 시도하는 것을 size = 1000번 반복한다 . - 순백의 주문서($p=0.1$)를 성공할 때까지 시도하여 순백의 주문서가 적용될 때까지 걸린 시도 횟수($X=1,2, dots$)를 $size = 1000$번 기록한다 . - np.random.geometric(p = 0.1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.geometric(p = 0.1, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.geometric(p = 0.1, size = 1000)&#39;) plt.show() . &#51020;&#51060;&#54637; &#48516;&#54252; . - 확률변수 $X$를 성공 확률이 $p$인 베르누이 시행을 반복하여 $k$번째 성공이 나올 때 까지 시행횟수라 하면 확률변수 $X$는 음이항 분포를 따름 . - 기하분포는 $k=1$인 음이항 분포 . &#51020;&#51060;&#54637; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) ,= , _{x-1} rm C_{k-1} ,p^{k} ,(1-p)^{x-k} ,= , binom{x-1}{k-1} ,p^{k} ,(1-p)^{x-k}$ . - $x-1$번째 시도까지 성공횟수 $k-1$번였다가 $x$번째 시도에서 성공하여 성공횟수는 $k$가 되었음 . &#51020;&#51060;&#54637; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = frac{k}{p}$ . - $Var(X) = frac{k(1-p)}{p^2}$ . &#51020;&#51060;&#54637; &#48516;&#54252; plot . import numpy np.random.negative_binomial(n, p, size) . - $n$은 성공횟수, $p$는 베르누이 시행에서 성공 확률, size는 표본의 수 . np.random.negative_binomial(n = 5, p = 0.1, size = 1000) . - 성공 확률이 p = 0.1인 베르누이 시행을 5번 성공할 때까지 시도하는 것을 size = 1000번 반복한다 . - 순백의 주문서($p=0.1$)를 5번 성공할 때까지 시도하여 순백의 주문서가 5번 적용될 때까지 걸린 시도 횟수($X=5,6, dots$)를 $size = 1000$번 기록한다 . - np.random.negative_binomial(n = 5, p = 0.1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.negative_binomial(n = 5, p = 0.1, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.negative_binomial(n = 5, p = 0.1, size = 1000)&#39;) plt.show() . - 위에서 기하 분포는 음이항 분포에서 $k = 1$인 특수한 경우라고 했음 . - 진짜로 동일한지 $p = 0.4$인 기하 분포와 $p = 0.4, k = 1$인 음이항 분포를 히스토그램을 그려 비교하자 . np.random.seed(1) sample1 = np.random.geometric(p = 0.4, size = 1000) sample2 = np.random.negative_binomial(n = 1, p = 0.4, size = 1000) fig, ax = plt.subplots(1, 2, figsize = (14, 4)) ax[0].hist(sample1, bins = 12) ax[1].hist(sample2, bins = 12) ax[0].set_title(&#39;np.random.geomaric(p = 0.3, size = 1000)&#39;) ax[1].set_title(&#39;np.random.negative_binomial(n = 1, p = 0.3, size = 1000)&#39;) plt.show() . - 히스토그램을 통해 비교하니 $k= 1$인 음이항 분포는 기하 분포와 동일함을 알 수 있다 . &#52488;&#44592;&#54616; &#48516;&#54252; . - $k$개의 성공과 $N-k$개의 실패로 이루어진 크기가 $N$인 유한모집단에서 크기가 $n$인 표본을 뽑고 이 중 성공의 개수를 $X$라 할 때 확률변수$X$는 초기하 분포를 따름 . - $N, k to infty$이고 $ frac{k}{N} to p$이면 초기하 분포를 이항 분포로 근사 가능 . - 비복원추출을 하기에 각각의 시행이 서로 영향을 미치므로 독립적 시행이 아님 &gt; 베르누이 시행과의 차이점 . - 샘플링 검사 시에 복원추출을 하지 않고 비복원 추출을 하기 때문에 초기하 분포를 주로 사용함 . &#52488;&#44592;&#54616; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) = frac{_{k} , rm C ,_{x} ; times ; _{N-k} ; rm C ,_{n-x}}{_{N} , rm C ,_{n}} $ . - $N$개 중 $n$개를 뽑는 방법 중에서 성공 $k$개에서 $x$개의 성공을 뽑고 실패 $N-k$개에서 $n-x$개의 실패를 뽑을 확률 . &#52488;&#44592;&#54616; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X)=n cdot frac{k}{N}$ . - $Var(X)= n cdot frac{k}{N} cdot frac{N-k}{N} cdot frac{N-n}{N-1}$ . - 이항분포의 기댓값과 분산과 유사함 . - n은 표본크기, $ frac{k}{N}$은 성공확률, $ frac{N-k}{N}$은 실패확률 . - $ frac{N-n}{N-1}$은 유한모집단수정항으로 $n$는 대체로 1보다 크므로 유한모집단수정항도 1보다 작음 &gt; 이항분포보다 분산이 더 작음 . &#52488;&#44592;&#54616; &#48516;&#54252; plot . import numpy np.random.hypergeometric(ngood, nbad, nsample, size) . - $ngood(=k)$은 유한모집단중 성공횟수, $nbad(=N-k)$는 유한모집단중 실패횟수, $nsample(=n)$은 표본크기, size는 표본의 수 . np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000) . - 성공횟수 ngood = 700개와 실패횟수 nbad = 300개로 구성된 크기가 1000인 유한모집단($N$)에서 샘플 nsample = 100개를 비복원추출하여 나온 성공횟수 $x$를 size = 1000번 반복한다 . - 당첨용지 700개($ngood = 700$)와 꽝용지 300개($nbad = 300$)로 구성된 로또용지 1000개(유한모집단의 크기$N$)중에서 100개($nsample = 100$)를 비복원추출하여 나온 성공횟수를 $size = 1000$번 기록한다 . - np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000)&#39;) plt.show() . - 이항분포와 유사해 보임 .",
            "url": "https://gkswotn12345.github.io/green/python/statistics/2021/06/30/%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html",
            "relUrl": "/python/statistics/2021/06/30/%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html",
            "date": " • Jun 30, 2021"
        }
        
    
  
    
        ,"post20": {
            "title": "깃허브 데스크탑",
            "content": "&#44611;&#54728;&#48652; &#45936;&#49828;&#53356;&#53457; &#51060;&#50857;&#54644;&#49436; &#52964;&#48139;&#54616;&#44592; . 처음에 레포지토리 선택할 때 정보를 저장할 폴더 경로를 선택한다 . | 나의 경우에는 &quot;C:/Users/한재수/github_desktop/green&quot; 이다 . | green폴더에 가보면 notebooks폴더가 있는데 거기서 작업한 주피터 노트북 파일은 깃허브 데스크탑 changes에 표시된다 . | 커밋할 파일 하나를 클릭하고 하단에 메시지를 같이 남긴다 . | 변동 내역 메시지를 작성하고 커밋을 했으면 마지막으로 푸쉬를 한다 . | 깃허브에 변동 내역이 저장된다 . | - 아무 것도 변경하지 않고 save만 해도 깃허브 데스크탑 changes에서 감지된다 . - 아무 것도 변경하지 않았는데 커밋이 된다는 의미... --&gt; 아무짝에도 쓸모 없다. --&gt; 이런 경우에는 커밋을 하지 말고 냅두자 . - 파일이 제대로 푸쉬가 안됐다면? --&gt; 깃허브 _notebook 파일에 있는 history를 보자 . - 만약 빨간색으로 $ times$표시가 되어있다면 클릭 --&gt; error메시지를 볼 수 있음 --&gt; 이를 보고 오류 수정 하면 됨 . &#51089;&#50629; &#44277;&#44036; . - 이제부터 작업은 나의 깃허브 레포지토리(green) 저장 폴더인 green에 있는 notebooks에서 해야 한다 . - 만약 &quot;C:/Users/한재수/github_desktop/green/notebooks&quot; 에서 작업하지 않으면 깃허브 데스크탑 changes에 기록되지 않는다 --&gt; 망함 . Liquid Exception: Liquid syntax error &#54644;&#44208; . - Jekyll에서 사용되는 liquid는 {{ 와 }}를 escape 문자로 사용 &gt; 마크다운에 {{ 과 }}이 있으면 커밋이 error가 나고 {{ 과 }} 사이에 있는 내용은 무시됨 . - 해결 방법 &gt; 여는 중괄호 앞에 {% raw %}를 닫는 중괄호 뒤에 {% endraw %}를 추가함 . - 참고: Liquid syntax error 해결 . - 참고: How to escape liquid template tags . &#44611;&#54728;&#48652; &#49436;&#48260; &#50724;&#47448; &#54869;&#51064; . - 깃허브 데스크탑으로 커밋을 하려는데 오류가 발생했음 . - 왜 그런가 찾아보니 내 문제가 아니라 서버 문제였다 . - 갑자기 오류가 생겼는데 내 문제가 아닌 것 같으면 서버 상태를 확인해보자 . - site: 깃허브 서버 오류 확인 .",
            "url": "https://gkswotn12345.github.io/green/python/github/2021/06/26/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91.html",
            "relUrl": "/python/github/2021/06/26/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post21": {
            "title": "데이터과학",
            "content": "&#49440;&#54805;&#54924;&#44480; . &#54924;&#44480;&#47784;&#54805; . - $y_i= beta_0+ beta_1 x_{1}+ epsilon_i$ . - $y_i$는 관측값, $ beta_0$는 절편, $ beta_1$은 기울기, $ epsilon_i$는 오차항 { $ mathbb{N} sim(0, sigma^2$) } . - $ sum_{i=1}^{n} epsilon_i^2 = sum_{i=1}^{n} (y_i- beta_0- beta_1 x_{1})^2$ 을 최소화하는 $ beta_0, beta_1$을 추정한다 --&gt; 최소제곱추정 . &#54632;&#49688;&#51032; &#52572;&#49548;&#44050; . - 함수 $f(x)$가 있다고 하자. 이 함수의 최소값을 알고 싶다 --&gt; 미분 . - convex fuction (볼록 함수 --&gt; 아래로 볼록)는 임의의 두 점 $x_1,x_2$와 [0,1] 사이의 값 t에 대해 $f(tx_1+(1-t)x_2) geq tf(x_1)+(1-t)f(x_2)$가 항상 성립하는 함수이다 . - $f&#39;&#39;(x) &gt; 0$이면 $f(x)$는 아래로 볼록하다 . 함수를 두 번 미분한다 | $f&#39;&#39;(x)&gt;0$이면 볼록함수이다. --&gt; $f&#39;(x)=0$을 만족할 때 $f(x)$의 극소값(=최소값)이므로 $f(x)$가 최소이다 | &#54924;&#44480;&#47784;&#54805; &#44228;&#49688; &#52628;&#51221; . $ bf L = sum_{i=1}^{n} boldsymbol{ epsilon_i}^2 = boldsymbol{ epsilon}^{ top} boldsymbol{ epsilon} = (y - X boldsymbol{ beta})^ top(Y - X boldsymbol{ beta}) , , , , = (y^{ top} - boldsymbol{ beta}^{ top}X^{ top})(y - boldsymbol{ beta}X) = y^{ top}y - y^{ top}X boldsymbol{ beta} - boldsymbol{ beta}^{ top}X^{ top}y + boldsymbol beta^{ top}X^{ top}X boldsymbol{ beta}$ | $ frac{ partial bf L}{ partial boldsymbol beta} = bf 0 - 2 bf X^{ top}y + 2X^{ top}X boldsymbol{ beta} = 0$ | $ bf X^{ top}y = X^{ top}X boldsymbol{ beta} Leftrightarrow boldsymbol{ hat beta} = big( bf X^{ top}X big)^{-1}X^{ top}y $ | - 의문점: 만약$ big( bf X^{ top}X big)^{-1}$이 존재하지 않는다면? . &#49345;&#44288;&#44288;&#44228; . - 두 개의 양적 변수의 연관강도나 방향을 요약하는 수치 통계량 . - 상관관계는 두 변수 사이의 선형 관계에 대한 정보임 . &#49345;&#44288;&#44228;&#49688; . - 상관관계의 정도를 나타냄 . - 모집단 상관계수: $ rho$ . - 표본 상관계수: $r$ . &#49345;&#44288;&#44228;&#49688; &#53945;&#51669; . 상관계수는 항상 $-1 leq r leq 1$ . | $r$의 부호가 두 변수 관계의 방향(음수: 음의 관계, 양수: 양의 관계) . | $r$이 $-1$ or $+1$에 가까울수록 선형 관계가 강함, $0$에 가까우면 선형 관계가 없음 . | $r$이 $0$이라고 두 변수사이의 관계가 없는 것이 아니라 선형 관계가 없다는 의미 --&gt; 곡선 관계일 수 도 있음 . | 상관계수 $r$은 단위가 없음. 각 변수의 척도와도 무관 . | 상관계수는 대칭적 --&gt; $x$와$y$의 상관계수 $=$ $y$와$x$의 상관계수 . |",
            "url": "https://gkswotn12345.github.io/green/python/statistics/2021/06/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B3%BC%ED%95%99.html",
            "relUrl": "/python/statistics/2021/06/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B3%BC%ED%95%99.html",
            "date": " • Jun 25, 2021"
        }
        
    
  
    
        ,"post22": {
            "title": "리스트 함수",
            "content": "&#47532;&#49828;&#53944; &#51221;&#47148; . list.sort()&#54632;&#49688;, sorted()&#54632;&#49688; . - ?.sort()함수는 list형태인 ? 의 요소를 오름차순으로 정렬한다 . - ?.sort(reverse = True)함수는 내림차순으로 정렬한다 . - ?.sort()함수와 sorted()함수는 거의 같다 . - ?.sort()함수는 ?의 속성을 바꾸지만 sorted()함수는 ?의 속성을 바꾸지 않는다 (a.append()와 + 연산의 차이) . a=[1,5,2,3,7,4] a . [1, 5, 2, 3, 7, 4] . a.sort() a . [1, 2, 3, 4, 5, 7] . a.sort(reverse = True) a . [7, 5, 4, 3, 2, 1] . - sort(), sorted()의 key 옵션에 지정된 함수의 결과에따라 정렬한다 . - lambda함수(익명 함수) 사용 --&gt; lambda 매개변수: 결과 . b = [(1, 2), (0, 2), (1, 3), (1, 5), (0, 1), (2, 8)] c = sorted(b, key = lambda x: (x[0], -x[1])) ## x[1]앞에 있는 &#39;-&#39;기호는 현재정렬순서와 반대로이다 print(c) ##첫 번째 원소는 오름차순, 두 번째 원소는 내림차순으로 정렬 . [(0, 2), (0, 1), (1, 5), (1, 3), (1, 2), (2, 8)] . reverse()&#54632;&#49688; . - ?.reverse()함수는 list형태인 ? 의 요소를 역순으로 정렬한다 . d = [1,5,2,3,7,4] d.reverse() print(d) . [4, 7, 3, 2, 5, 1] . reversed()&#54632;&#49688; . - reversed()함수는 요소를 역순으로 정렬해 반환한다 . - 반환값을 그대로 사용하지 않고 list()나 tuple()함수를 통해 사용한다 . d = [1,5,2,3,7,4] reversed(d) . &lt;list_reverseiterator at 0x2185ce99e20&gt; . d = [1,5,2,3,7,4] tuple(reversed(d)) . (4, 7, 3, 2, 5, 1) . &#47532;&#49828;&#53944; &#52488;&#44592;&#54868; . 1&#52264;&#50896; &#47532;&#49828;&#53944; . a = [] ## 빈 리스트로 초기화 a . [] . A = [x] * n . $A = [x, x, x, ..., x, x] --&gt;$ $x$가 $n$개인 $1$차원 리스트 . a = [0]*10 ## 0리스트로 초기화 a . [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] . 2&#52264;&#50896; &#47532;&#49828;&#53944; . n = 5 list = [[0] * n for _ in range(n)] ## 0으로 채원진 2차원 리스트 . list . [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . list[0][0] = 123 . list . [[123, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . - ?? . List = [[0] * 5 for _ in range(5) . 그런데 _ 는 뭐지? . - 사실 _ 자리에 다른 것이 들어가도 된다 이를 테면 i . x = [0*i for i in range(5)] x . [0, 0, 0, 0, 0] . - 위에 List에서 _ 대신에 i를 넣는다고 생각하자 . List = [[0] * 5 for i in range(5) . - 위에 리스트인 x 에서는 i가 리스트 안에 0을 몇 개 생성할 지 정하는 변수였다 . - 위에 리스트인 List 에서는 i가 무슨 역할을 하지?? . - 아무역할도 하지 않는다 . - 0을 5개 생성하고 이를 5번 반복한다 . - List를 정의할 때 부터 정해졌다 . - i는 그저 for문을 쓰기 위해 필요함 --&gt; range(5)의 값을 받아낼 변수가 필요하다 . - 그래서 i 자리에 오는 변수는 아무짝에도 쓸모가 없다 . - 아무 의미가 없어서 그냥 아무 의미 없어보이는 기호인 _를 쓴다(내 생각) . &#47532;&#49828;&#53944; &#52628;&#44032; . ?.append() . - ? --&gt; 리스트 . - 마지막(?[-1]) 위치에 하나의 원소 추가 . a = [] a.append(1) a . [1] . ?.insert(i, v) . - i 위치에 v 원소 추가 . b = [1,2,3,5,6,7] b.insert(3,4) b . [1, 2, 3, 4, 5, 6, 7] . ?.extend() . - 마지막(?[-1]) 위치에 리스트 추가 . c = [1,2,3,4,5] c.extend([6,7,8]) c . [1, 2, 3, 4, 5, 6, 7, 8] . ?.pop() . - pop(i)는 리스트의 i번째 요소를 돌려주고 그 요소는 삭제, pop( ) = pop(-1) . d = [1, 2, 3, 4 ,5] x = d.pop() print(x) print(d) . 5 [1, 2, 3, 4] . arr[::] &#50857;&#48277; . - arr[A:B:C] &gt; index A부터 index B(포함X)까지 C간격으로 arr 생성 . - A가 none이면 처음부터 B가 none이면 끝까지 C가 none이면 1만큼 . arr = list(range(10)) arr . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . arr[1:9:2] . [1, 3, 5, 7] . arr[:10:3] . [0, 3, 6, 9] . arr[1::2] . [1, 3, 5, 7, 9] . arr[1:5:] . [1, 2, 3, 4] . arr[5::] . [5, 6, 7, 8, 9] . arr[:3:] . [0, 1, 2] . arr[::4] . [0, 4, 8] . arr[::] . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . &#47532;&#49828;&#53944; &#49325;&#51228; . ?.remove(x) . - 리스트에서 x원소를 삭제 . - 삭제할 원소가 없을 시 error . a = [1,2,3,4,5,6] a.remove(1) print(a) . [2, 3, 4, 5, 6] . a.remove(10) . ValueError Traceback (most recent call last) &lt;ipython-input-2-72b3315abecc&gt; in &lt;module&gt; -&gt; 1 a.remove(10) ValueError: list.remove(x): x not in list . &#47928;&#51088;&#50676; &#54252;&#54632;&#50668;&#48512; . ?.find(&quot;&#47928;&#51088;&#50676;&quot;) . - ?에 문자열이 존재하면 가장 앞에 원소의 시작 인덱스 값을 반환하며 존재하지 않으면 -1값을 반환 . day = &quot;2021-07-03&quot; . day.find(&#39;2021&#39;) . 0 . day.find(&#39;-&#39;) . 4 . day.find(&#39;2222&#39;) . -1 . &quot;&#47928;&#51088;&#50676;&quot; in ? , &quot;&#47928;&#51088;&#50676;&quot; not in ? . - ?에 문자열이 존재하면 True 반환, 존재하지 않으면 False 반환, not in에 경우는 반대로 . day = &quot;2021-07-03&quot; . &#39;2021&#39; in day . True . &#39;-&#39; not in day . False . &#39;2222&#39; in day . False . list = [&#39;1011&#39;, &#39;2022&#39;, &#39;day&#39;, &#39;model&#39;] . &#39;2022&#39; in list . True . &#39;day&#39; not in list . False . &#39;month&#39; in list . False . enumerate &#54632;&#49688; . - for문을 사용할 때 인덱스를 같이 출력할 수 있음 . - 참고: 파이썬 for문 . cards = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] for i in range(len(cards)): print(i, cards[i]) . 0 A 1 B 2 C . for value in enumerate(cards): print(value) . (0, &#39;A&#39;) (1, &#39;B&#39;) (2, &#39;C&#39;) . - enumerate 함수는 인덱스와 원소로 이루어진 tuple을 생성함 . - 만약 인덱스와 원소를 다른 변수로 만들고 싶다면 tuple unpacking을 사용하면 됨 . for idx, card in enumerate(cards): print(idx, card) . 0 A 1 B 2 C . zip &#54632;&#49688; . - zip 함수는 iterable한 객체들을 인자로 받아 각각의 원소를 tuple로 접근가능한 iterator를 만듦 . - 참고: python zip function . a = (&quot;John&quot;, &quot;Charles&quot;, &quot;Mike&quot;) b = (&quot;Jenny&quot;, &quot;Christy&quot;, &quot;Monica&quot;) zip(a, b) . &lt;zip at 0x28632cc8e40&gt; . list(zip(a, b)) . [(&#39;John&#39;, &#39;Jenny&#39;), (&#39;Charles&#39;, &#39;Christy&#39;), (&#39;Mike&#39;, &#39;Monica&#39;)] . tuple(zip(a, b)) . ((&#39;John&#39;, &#39;Jenny&#39;), (&#39;Charles&#39;, &#39;Christy&#39;), (&#39;Mike&#39;, &#39;Monica&#39;)) .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%ED%95%A8%EC%88%98.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post23": {
            "title": "깃허브 마크다운",
            "content": "&#44611;&#54728;&#48652; &#52852;&#53580;&#44256;&#47532; . 제목 . &quot;부제목&quot; . -toc: true . -branch: master . -badges: true . -comments: true . -author: 한재수 . -categories: [python] . - 위에 내용을 아무곳에나 붙여 넣는다. 부제목은 (&gt;&quot;부제목&quot;), 제목은 (# 제목) . - categories에 해당하는 부분이 깃허브 홈페이지에서 tag에 보이는 부분이다. . - categories 에서 [ ] 안에 여러개를 추가 할 수 있다. ex) [python, R, CSS] . &#48660;&#47196;&#44536; &#44288;&#47532; . 1_ 깃허브 가입하기 | 2_ fastai/fastpages 사용 | 3_ 깃허브 데스크탑 이용 . | (1) 주피터노트북으로 공부한다. . | (2) 깃허브와 연결된 어떤 폴더(드랍박스 안의 green)에 공부한 내용을 넣는다. | (3) 깃허브 데스크탑이라는 프로그램을 이용하여 local(내 윈도우 컴퓨터)에서 remote (github)로 변경사항을 반영한다. | (4) 2~3분 뒤에 블로그 홈페이지에 반영된다. | (5) 공부한 내용을 편집없이 주피터 노트북 파일을 올리기만 하면 블로그에 올라가서 편하다. 필요에 따라 숨기기, 비밀 포스트도 만들 수 있다. | . &#44611;, &#44611;&#54728;&#48652; . - 버전 관리 시스템 . - 서로 코드를 공유 . - 혼자 쓰면 개인 저장소.. . &#51452;&#54588;&#53552; &#45432;&#53944;&#48513; . &#50976;&#50857;&#54620; &#53412; . - 삭제한 셀 복원 --&gt; Edit - Undo cell operation or Esc 후 z키 입력 . - 삭제한 코드 복원 --&gt; Ctrl + z . &#51452;&#54588;&#53552; &#45432;&#53944;&#48513; --&gt; remote --&gt; page (&#50504; &#50732;&#46972;&#44040; &#49688; &#46020; &#51080;&#45796;) . - 깃허브 데스크탑 history에서 이제껏 했던 커밋을 볼 수 있다. 게다가 삭제된 파일을 복구할 수 도 있다. . - 화면 캡쳐 프로그램으로 캡쳐를 함 --&gt; 마크다운에서 캡쳐한 이미지를 ctrl+v하면 캡쳐한 이미지가 삽입된다. . - 이미지 파일을 넣은 주피터 노트북 파일을 올리면 깃허브 notebook에는 올라가지만 블로그에는 올라가지 않는다. . &#47553;&#53356; &#49341;&#51077; . - 보통 링크 삽입은 [label](link)의 형식임 . - 그런데link에 )기호가 있으면 링크 연결에 문제가 있을 수 도 있음 . - [label][key] . - [key]: link . - 위와 같이 해도 링크 연결에 문제가 없고 위의 문제도 해결 가능함 . - 참고: 링크 연결 . &#49688;&#49885; &#44592;&#54840; &#54364;&#54788; . - 3.141592를 변수에 저장하고 싶음 . - pi = 3.141592 . - 그런데 pi 대신에 $ pi$를 사용하고 싶다면?? . - code셀에서 pi를 입력한 후 Tab을 누르면 됨 . pi = 3.141592 π = 3.141592 . pi . 3.141592 . π . 3.141592 . &#44611;&#54728;&#48652; &#45936;&#49828;&#53356;&#53457;&#50640;&#49436; &#50724;&#47448;&#44032; &#45228;&#45716;&#45936; &#47784;&#47476;&#44192;&#45796;. gg --&gt; &#54644;&#44208; &#50756;&#47308; . - 삭제하고 다시 처음부터 시작했다. . &#49688;&#49885;&#51012; &#47691;&#51080;&#44172; &#54364;&#54788;&#54616;&#44256; &#49910;&#45796;&#47732;?? . - $수식$ 꼴로 나타낸다. . - y = x^2 + 1 . - $y = x^2 +1$ . &#48145; &#52392;&#51088; &#54364;&#54788; . - $수식_밑첨자$ . - x_1 + x_2 = x_3 . - $x_1 + x_2 = x_3$ . $ sum$ &#54364;&#54788; . - limits 옵션을 통해 $ sum$의 시작과 끝의 위치를 $ sum$의 바로 위와 아래로 지정가능 . - $ sum_{n=1}^{ infty} frac{1}{n^2}$ . - $ sum limits_{n=1}^{ infty} frac{1}{n^2}$ . &#48177;&#53552; &#54364;&#54788; . - 벡터 표현하기: 화살표, 볼드체 . - $X$는 변수 . - $ boldsymbol{X}, ; vec{X}$는 벡터 . &#50948;&#47196; &#51473;&#44292;&#54840; &#54364;&#54788; . - overbrace를 통해 위로 중괄호를 표현함 . - $x+x+x+ dots+x+x, ;x$를 $n$번 더함 . - $ overbrace{x + cdots + x}^{n rm times}$ . &#51216;&#52237;&#44592; . - s 제외하면 점 하나만 찍힘, s 포함하면 점 세개 찍힌다 . - dots &gt; $ dots$ . - cdots &gt; $ cdots$ . - ddots &gt; $ ddots$ . &#50976;&#50857;&#54620; latex . boldsymbol . - applies to nearly all symbols, not just letters and numbers . - ex) $ boldsymbol{A} ,A$ . bf . - Used to turn on boldface; affects uppercase and lowercase letters, and digits . - ex) ${ bf 123} ,{123}$ . therefore . - therefore를 통해 삼각형 모양 점3개를 만듦 . - $ therefore 1+1= text{힘든 삶}$ . bigcup . - 집합열을 포현할 때 합집합 기호의 밑과 위에 시작과 끝을 표시하고 싶다면 bigcup과 limits를 사용하자 . - $ cup_{i=1}^{ infty} A_i$ &gt; cup_{i=1}^{ infty} A_i . - $ bigcup_{i=1}^{ infty} A_i$ &gt; bigcup_{i=1}^{ infty} A_i . - $ bigcup limits_{i=1}^{ infty} A_i$ &gt; bigcup limits_{i=1}^{ infty} A_i . &#47588;&#50864; &#50976;&#50857;&#54620; &#47560;&#53356;&#45796;&#50868; &#49324;&#51060;&#53944; . - &lt;Jupyter 노트북에서 Markdown 및 LaTeX를 작성하는 방법 알아보기&gt; --&gt; https://ichi.pro/ko/jupyter-noteubug-eseo-markdown-mich-latexleul-jagseonghaneun-bangbeob-al-abogi-18246612521469 . - latex command 총 정리 --&gt; https://www.tutorialspoint.com/tex_commands/percentage.htm .",
            "url": "https://gkswotn12345.github.io/green/python/github/markdown/jupyter/2021/06/24/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4.html",
            "relUrl": "/python/github/markdown/jupyter/2021/06/24/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post24": {
            "title": "백준 문제풀기",
            "content": ". &#48177;&#51456; &#54616;&#47732;&#49436; &#50508;&#50500;&#45240; &#51216; . 같은 언어, 같은 코드여도 시간이 다를 수 있음 . | 메모리도 다를 수 있음 . | . &#51077;&#52636;&#47141;&#44284; &#49324;&#52825;&#50672;&#49328; . &#49324;&#52825;&#50672;&#49328; &#52636;&#47141; . a, b = map(int, input().split()) print(a+b) print(a-b) print(a*b) print(a//b) print(a%b) . 10 4 21 2 1 . A+B - 1 . a, b = map(int, input().split()) print(a+b) . 12 . &#45208;&#47672;&#51648; . (A+B)%C는 ((A%C) + (B%C))%C 와 같을까? . | (A×B)%C는 ((A%C) × (B%C))%C 와 같을까? . | 세 수 A, B, C가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오. . | . A, B, C = map(int, input().split()) print((A+B)%C) print(((A%C) + (B%C))%C) print((A*B)%C) print(((A%C) * (B%C))%C) . 1 1 0 0 . &#44273;&#54616;&#44592; . a = str(input()) b = str(input()) result = ([int(a) * int(b[2-x]) for x in range(3)]) for i in range(3): print(result[i]) print(int(a)*int(b)) . 2360 3776 1416 181720 . &#54217;&#44512;&#51008; &#45336;&#44192;&#51648; . 각 케이스마다 한 줄씩 평균을 넘는 학생들의 비율을 반올림하여 소수점 셋째 자리까지 출력한다. | . C = int(input()) for i in range(C): line = list(map(int, input().split())) mean = sum(line[1:]) / line[0] over_mean = [x for x in range(1, len(line)) if line[x] &gt; mean] over_mean_percent = len(over_mean) * 100 / line[0] print(&#39;{:.3f}%&#39;.format(over_mean_percent)) . 57.143% . &#44256;&#50577;&#51060; &#52636;&#47141; . - 문자열은 &#39; &#39;로 둘러 싸임 . - 를 출력하고 싶으면 . - &#39;을 출력하고 싶으면 &#39; 또는 문자열을 &quot; &quot;로 감싸기 . - 정규표현식의 일종임 --&gt; 정규표현식 공부하기 . print(&#39; &#39;) . File &#34;&lt;ipython-input-28-eaac87876c3b&gt;&#34;, line 1 print(&#39; &#39;) ^ SyntaxError: EOL while scanning string literal . print(&#39; &#39;) . . print(&#39;&#39;&#39;) . File &#34;&lt;ipython-input-33-c6d045ece466&gt;&#34;, line 1 print(&#39;&#39;&#39;) ^ SyntaxError: EOF while scanning triple-quoted string literal . print(&#39; &#39;&#39;) . &#39; . print(&quot;&#39;&quot;) . &#39; . print(&#39; / n ) ( &#39;) n( / ) n (__)|&#39;) . / ) ( &#39;) ( / ) (__)| . &#44053;&#50500;&#51648; . - 문자열에서 &quot; &quot;를 표현하고 싶으면 &#39; &#39;로 감싸기 . - 또는 문자열을 &#39;&#39;&#39; &#39;&#39;&#39;로 감싸는 방법도 있음 . print(&quot;&quot;&quot;) . File &#34;&lt;ipython-input-46-3f29872ceae9&gt;&#34;, line 1 print(&#34;&#34;&#34;) ^ SyntaxError: EOF while scanning triple-quoted string literal . print(&#39;&quot;&#39;) . &#34; . print(&#39;&#39;&#39; | _/| n|q p| /} n( 0 )&quot;&quot;&quot; n|&quot;^&quot;` | n||_/= __| &#39;&#39;&#39;) . | _/| |q p| /} ( 0 )&#34;&#34;&#34; |&#34;^&#34;` | ||_/= __| . - &#39;&#39;&#39; &#39;&#39;&#39;로 감쌀 때 앞의 &#39;&#39;&#39; 앞에 r을 적으면 문자열을 원시 문자열로 처리함 . - 를 표현하기 위해 로 하지 않고 그냥 역슬래시만 해도 가능 . print(&#39;| _/| n|q p| /} n( 0 )&quot;&quot;&quot; n|&quot;^&quot;` | n||_/= __|&#39;) . | _/| |q p| /} ( 0 )&#34;&#34;&#34; |&#34;^&#34;` | ||_/= __| . print(r&#39;&#39;&#39;| _/| |q p| /} ( 0 )&quot;&quot;&quot; |&quot;^&quot;` | ||_/= __|&#39;&#39;&#39;) . | _/| |q p| /} ( 0 )&#34;&#34;&#34; |&#34;^&#34;` | ||_/= __| . . if&#47928; . &#46160; &#49688; &#48708;&#44368;&#54616;&#44592; . A, B = map(int, input().split()) if A&gt;B: print(&#39;&gt;&#39;) elif A&lt;B: print(&#39;&lt;&#39;) else: print(&#39;==&#39;) . &gt; . &#49884;&#54744; &#51216;&#49688; &#52636;&#47141; . def result(grade): if grade &gt;= 90 and grade &lt;= 100: print(&quot;A&quot;) elif grade &gt;= 80 and grade &lt;= 89: print(&quot;B&quot;) elif grade &gt;= 70 and grade &lt;= 79: print(&quot;C&quot;) elif grade &gt;= 60 and grade &lt;= 69: print(&quot;D&quot;) else: print(&quot;F&quot;) grade = int(input()) result(grade) . A . &#50980;&#45380; &#54032;&#45800; . 윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다. . | 예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다. . | . def leap_year(year): if (year%4 ==0 and year%100 != 0) or year%400 == 0: print(1) else: print(0) year = int(input()) leap_year(year) . 1 . &#49324;&#48516;&#47732; &#44256;&#47476;&#44592; . 첫 줄에는 정수 x가 주어진다. (−1000 ≤ x ≤ 1000; x ≠ 0) 다음 줄에는 정수 y가 주어진다. (−1000 ≤ y ≤ 1000; y ≠ 0) . | 점 (x, y)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다. . | . def quadrant(a,b): if a&gt;0 and b&gt;0: print(1) elif a&gt;0 and b&lt;0: print(4) elif a&lt;0 and b&gt;0: print(2) elif a&lt;0 and b&lt;0: print(3) x = int(input()) y = int(input()) quadrant(x, y) . 4 . &#50508;&#46988; &#49884;&#44228; . 45분 일찍 알람 설정하기 | . h, m = map(int, input().split()) if m &gt;= 45: print(h, m-45) elif h == 0: print(23, m+15) else: print(h-1, m+15) . 23 40 . . for&#47928; . &#44396;&#44396;&#45800; . n = int(input()) for i in range(1,10): print(&#39;%s * %s = %s&#39; % (n, i, n*i)) . 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 . A+B - 3 . 첫째 줄에 테스트 케이스의 개수 T가 주어진다. . | 각 테스트 케이스마다 A+B를 출력한다. . | . T = int(input()) for i in range(T): A, B = map(int, input().split()) print(A+B) . 6 . 10 . 75 . 1&#48512;&#53552; n&#44620;&#51648; &#54633; . 반복문 있는 버전 | . n = int(input()) sum = 0 for i in range(1, n+1): sum += i print(sum) . 55 . 반복문 없는 버전 | . n = int(input()) print(int(n * (n+1) / 2)) . 55 . sys.stdin.readline() . 본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. . | 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다. . | Python을 사용하고 있다면 input() 대신 sys.stdin.readline()을 사용할 수 있다. . | 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우 .rstrip()을 추가로 해 주는 것이 좋다. . | . import sys T = int(input()) for i in range(T): A, B = map(int, sys.stdin.readline().split()) print(A+B) . ValueError Traceback (most recent call last) &lt;ipython-input-3-173fe188e1c6&gt; in &lt;module&gt; 2 T = int(input()) 3 for i in range(T): -&gt; 4 A, B = map(int, sys.stdin.readline().split()) 5 print(A+B) ValueError: not enough values to unpack (expected 2, got 0) . - error 왜 뜨지? . - sys.stdin.readline()를 쓸 때마다 에러가 난다. . 1&#48512;&#53552; N&#44620;&#51648; &#52636;&#47141; . N = int(input()) for i in range(1, N+1): print(i) . 1 2 3 4 5 . N&#48512;&#53552; 1&#44620;&#51648; &#52636;&#47141; . N = int(input()) for i in range(1, N+1): print(N-i+1) . 5 4 3 2 1 . A+B - 7 . 각 테스트 케이스마다 &quot;Case #x: &quot;를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다. | . import sys T = int(input()) for i in range(1, T+1): A, B = map(int, sys.stdin.readline().split()) print(&#39;Case #%s: %s&#39; % (i, A+B)) . Case #1: 6 . Case #2: 6 . Case #3: 8 . &#48324; &#52237;&#44592; - 1 . 문제 출처: 백준 2438번 | . N = int(input()) for i in range(1, N+1): for j in range(i): print(&#39;*&#39;, end = &#39;&#39;) print(&#39; n&#39;, end = &#39;&#39;) . * ** *** **** ***** . print&#54632;&#49688; &#50857;&#48277; . print(출력할 객체, end = &#39;함수가 종료될 때 실행하는 값&#39;) . | print()함수에서 end값을 따로 지정하지 않으면 끝을 줄바꿈 문자로 한다. . | . print(&#39;안녕&#39;, end = &#39;~~~~&#39;) print(&#39;하세요&#39;) . 안녕~~~~하세요 . N = int(input()) for i in range(N): for j in range(1, N-i): print(&quot; &quot;, end = &quot;&quot;) for k in range(i+1): print(&quot;*&quot;, end = &quot;&quot;) print(&quot; n&quot;, end = &quot;&quot;) . * ** *** **** ***** . X&#48372;&#45796; &#51089;&#51008; &#49688; . 첫째 줄에 N과 X가 주어진다. (1 ≤ N, X ≤ 10,000) . | 둘째 줄에 수열 A를 이루는 정수 N개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다. . | X보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. X보다 작은 수는 적어도 하나 존재한다. . | . N, X = map(int, input().split()) A = list(map(int, input().split())) for i in range(N): if A[i] &lt; X: print(A[i], end = &quot; &quot;) . 1 0 . . while&#47928; . A+B - 5 . 입력의 마지막에는 0 두 개가 들어온다. | . while True: A,B = map(int, input().split()) if A==0 and B==0: break else: print(A+B) . 2 . 4 . &#45908;&#54616;&#44592; &#49324;&#51060;&#53364; . 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. . | 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. . | 26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다. . | 위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다. . | N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.(0&lt;=N&lt;=99 인 정수) . | . n = N = int(input()) N_cycle = 0 while True: if N &lt; 10: N = int(2*str(N)) N_cycle += 1 else: N = int(str(N)[-1]+str(int(str(N)[0])+int(str(N)[-1]))[-1]) N_cycle += 1 if N == n: print(N_cycle) break . 60 . . &#54632;&#49688; . N&#44060;&#51032; &#54633; . 정수 n개가 주어졌을 때, n개의 합을 구하는 함수를 작성하시오. | . def solve1(a): sum = 0 for i in range(len(a)): sum += a[i] return(sum) . a=[0,1,2,3,4] solve1(a) . 10 . def solve2(a): return(sum(a)) . a=[0,1,2,3,4] solve2(a) . 10 . &#49472;&#54532; &#45336;&#48260; . 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다. | . z = set(range(1,10001)) - {x+sum([int(a) for a in str(x)]) for x in range(1,10001)} z = list(z) z.sort() for i in range(len(z)): print(z[i]) # 출력이 너무 길어서 출력은 생략 . &#54620;&#49688; . 어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. . | 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. . | N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오. . | . N = int(input()) def solve(a): if a &lt; 100: print(a) else: n = 99 for i in range(100, a+1): if int(str(i)[1]) - int(str(i)[0]) == int(str(i)[2]) - int(str(i)[1]): n += 1 print(n) solve(N) . 129 . . &#51116;&#44480;&#54632;&#49688;(&#51473;&#50836;&#54632; &#50500;&#47560;&#46020; &#44536;&#47532;&#44256; &#54775;&#44040;&#47548;) . - 재귀함수를 구상해보자. . - 재귀함수는 관계가 중요하다. . - 팩토리얼에서는 $fact(x)= x * fact(x-1)$ 관계가 성립한다. . - $fact(0), fact(1)$ 은 1이다. . - x가 0 또는 1일 때는 return을 1로 설정하고 나머지의 경우에는 $fact(x)= x * fact(x-1)$ 을 return한다면 재귀함수가 된다. . - 즉, 기본값 [$fact(0 or 1)=1$] 을 알고 관계식 [$fact(x)= x * fact(x-1)$] 을 안다면 재귀함수로 구현할 수 있다. . &#54057;&#53664;&#47532;&#50620; . 0보다 크거나 같은 정수 N이 주어진다. . | 이때, 재귀함수를 이용하여 N!을 출력하는 프로그램을 작성하시오. . | . N = int(input()) def fact(x): if x == 0 or x == 1: return 1 else: return x*fact(x-1) print(fact(N)) . &#54588;&#48372;&#45208;&#52824; &#49688; 5 . n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오. . | 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. . | 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. . | n은 20보다 작거나 같은 자연수 . | . N = int(input()) def fibo(x): if x == 0: return 0 elif x == 1: return 1 else: return fibo(x-1) + fibo(x-2) print(fibo(N)) . 55 . &#54588;&#48372;&#45208;&#52824; &#49688;&#50676; &#47700;&#47784;&#51060;&#51228;&#51060;&#49496; . 피보나치 재귀 함수의 경우 이미 구한 값을 구하기 위해 반복을 많이 해서 효율성이 떨어진다. . | 재귀 함수가 효율적이지 못하다면 메모이제이션을 사용한다. . | 재귀함수가 한 번 호출될 때마다 결과값을 저장하여 효율성을 높이는 것이 좋다. (메모이제이션) . | . N = int(input()) fibonacci = {0:0, 1:1} ## 메모이제이션을 위한 딕셔러니 선언 def fibo(x): if x in fibonacci: return fibonacci[x] fibonacci[x] = fibo(x-1) + fibo(x-2) return fibonacci[x] print(fibo(N)) . 55 . print(&#39;&#47928;&#51088;&#50676;&#39;) . $ star$ 과 $ star$ 사이에 빈칸이 있다. 이유는 ,(콤마) 때문이다. | . print(&#39;*&#39;, &#39;*&#39;, end = &quot;&quot;) . * * . ,(콤마)를 없애면 $ star$ 과 $ star$ 사이에 빈칸이 없다. | . print(&#39;*&#39; &#39;*&#39;, end = &quot;&quot;) . ** . &#54616;&#45432;&#51060; &#53457; &#51060;&#46041; &#49692;&#49436; . 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. . | 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다. . | 첫째 줄에 옮긴 횟수 K를 출력한다. . | 두 번째 줄부터 수행 과정을 출력한다. . | . N = int(input()) def Hanoi(n,from_pos,to_pos,aux_pos): if n==1: print(from_pos,to_pos) else: Hanoi(n-1,from_pos,aux_pos,to_pos) print(from_pos,to_pos) ## 가장 큰 원반을 목적지로 이동 Hanoi(n-1,aux_pos,to_pos,from_pos) print(2**N-1) Hanoi(N,1,3,2) . 7 1 3 1 2 3 2 1 3 2 1 2 3 1 3 . . &#47928;&#51088;&#50676; . &#49707;&#51088;&#51032; &#54633; . N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오. | . N = int(input()) num_str = str(input()) num_str = num_str.replace(&#39;0&#39;,&quot;&quot;) print(sum([int(num_str[x]) for x in range(len(num_str))])) . 15 . - map 함수 사용 . N = int(input()) num_str = str(input()) print(sum(map(int, num_str))) . 15 . &#45800;&#50612;&#51032; &#44060;&#49688; . 영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. . | 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. . | 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다. . | . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] == &#39;&#39;: spaces += 1 if s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 6 . - 어이없는 상황을 맞이함 . - 아래 코드는 틀린 코드임 . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . - input을 a = &#39; Mazatneunde Wae Teullyeoyo&#39; 으로 하게 되면(&#39; &#39;은 빼고) 앞에 띄어쓰기가 있으므로 len(s) - 1 = 3이 출력되야 하는데 4가 출력됨 . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 4 . - 사실 위 코드에 문제가 없는 건 아님 . - 만약 앞 뒤 모두 띄어쓰기가 있다면? . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 4 . - 4가 출력됨?? . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 2 . - 웃긴게 뒤에만 띄어쓰기가 있는 경우에는 올바르게 출력함 . &#45800;&#50612; &#44277;&#48512; . 알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. . | 단, 대문자와 소문자를 구분하지 않는다. . | . - 처음에는 for문을 2개 사용해서 같은 원소가 몇 개인지 알아낼려고 했다 . - 그런데 문자열길이가 백만이라 for문을 2번 돌면 2초안에 통과를 못할 것 같았다 . - 그래서 for문을 2개 쓰는 대신 다른 방법을 생각했다 . - 문자열을 대문자로 바꾸고 A~Z까지 원소를 삭제한 후 문자열 길이를 비교해 몇 개가 있는지 파악하기로 했다. . - 나중에 찾아보니 count 함수를 쓰면 더 쉽게 할 수 있다. . alphabet = str(input()) alp = alphabet.upper() alpha_list = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;] lenghts = len(alphabet) max_alpha = [] for i in alpha_list: if i in alp: a_len = len(alp.replace(i, &#39;&#39;)) if a_len &lt; lenghts: lenghts = a_len del max_alpha[:] max_alpha.append(i) elif a_len == lenghts: max_alpha.append(i) if len(max_alpha) &gt; 1: print(&#39;?&#39;) else: print(max_alpha[0]) . ? . &#50500;&#49828;&#53412; &#53076;&#46300; . 알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하는 프로그램을 작성하시오. | . input_ = str(input()) print(ord(input_)) . 48 . &#50508;&#54028;&#48307; &#52286;&#44592; . 알파벳 소문자로만 이루어진 단어 S가 주어진다. . | 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오. . | . S = str(input()) for i in &#39;abcdefghijklmnopqrstuvwxyz&#39;: find_ = S.find(i) print(find_, end = &quot; &quot;) . 1 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 . &#47928;&#51088;&#50676; &#48152;&#48373; . 문자열 S를 입력받은 후에, 각 문자를 R번 반복해 새 문자열 P를 만든 후 출력하는 프로그램을 작성하시오. | . T = int(input()) for i in range(T): R, S = map(str, input().split()) R = int(R) string = &#39;&#39; print(&#39;&#39;.join([string + (S[j] * R) for j in range(len(S))])) . /////HHHHHTTTTTPPPPP . &#49345;&#49688; . 상근이의 동생 상수는 수학을 정말 못한다. 상수는 숫자를 읽는데 문제가 있다. . | 이렇게 수학을 못하는 상수를 위해서 상근이는 수의 크기를 비교하는 문제를 내주었다. . | 상근이는 세 자리 수 두 개를 칠판에 써주었다. 그 다음에 크기가 큰 수를 말해보라고 했다. . | 상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. . | 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다. 두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오. . | . a, b = map(str, input().split()) rev_a = int(a[2] + a[1] + a[0]) rev_b = int(b[2] + b[1] + b[0]) if rev_a &gt; rev_b: print(rev_a) else: print(rev_b) . 437 . &#53356;&#47196;&#50500;&#54000;&#50500; &#50508;&#54028;&#48307; . 문제 출처: 백준 2941번 | . - 아니 디버깅하고 있었다가 예제 모두 맞춰서 이제 됐나? 싶어서 제출 했더니 정답임.. 근데 왜 맞지?? . - 왜 정답인지 생각해 봤음 . - 내 코드를 보면 ddz=z= 가 입력되면 dz=: 1개, z=: 2개임 . - z= 원래 1개여야 맞지만 dz=에 있는 z=을 z=에 포함시켜 2개임 . - 그래서 total_num이 원래보다 +1이 됐음 . - 정상 출력은 total_num + len(S) - 2 * total_num임 . - 2를 곱한 이유는 알파벳 1개당 길이가 2여서임(&#39;dz=&#39;제외) . - 근데 사실 출력이 잘못됨. 왜냐하면 &#39;dz=&#39;의 길이는 3이기 때문 --&gt; 출력값이 &#39;dz=&#39; 하나당 1씩 부족함 . - 그런데 &#39;dz=&#39; 에 &#39;z=&#39;이 포함돼서 +1이 되어 -1과 +1이 서로 상쇄됨 . - 그래서 정답을 출력함, 노리고 한 건 아니지만 어부지리로 맞춘셈 . S = str(input()) s_len = len(S) total_num = (s_len - len(S.replace(&#39;dz=&#39;,&#39;&#39;))) // 3 for i in [&#39;c=&#39;, &#39;c-&#39;, &#39;d-&#39;, &#39;lj&#39;, &#39;nj&#39;, &#39;s=&#39;, &#39;z=&#39;]: total_num += (s_len - len(S.replace(i, &#39;&#39;))) // 2 print(len(S) - total_num) . 3 . - 아래는 다른 사람이 작성한 코드를 보고 영감을 받아 작성한 코드임 . - 위에서 문제점은 dz=에 z=이 포함된것이다 . - 만약 &#39;dz=&#39;을 없앤다면 괜찮을까? --&gt; 그렇지 않음 . - 만약 ddz=z=이면 &#39;dz=&#39;을 없애도 &#39;dz=&#39;이 남게 된다 . - 만약 &#39;dz=&#39;을 없애는 대신에 다른 문자로 바꾼다면? 예컨데 알파벳이 아닌 다른 문자 . - &#39;dz=&#39;을 * 로 바꾼다면 ddz=z= --&gt; d*z=이 되어 제대로 개수를 셀 수 있음 . - 또 다른 장점은 이제 더 이상 알파벳의 개수를 셀 때 //2 or //3 을 하지 않아도 됨 . - 왜냐하면 크로아티아 알파벳을 한 자리 문자로 바꿨기 때문임 . - 모두 길이가 1이므로 바꾼 후에 최종 문자열의 길이를 출력하면 됨 . S = input() for i in [&#39;c=&#39;, &#39;c-&#39;, &#39;dz=&#39;, &#39;d-&#39;, &#39;lj&#39;, &#39;nj&#39;, &#39;s=&#39;, &#39;z=&#39;]: S = S.replace(i, &#39;*&#39;) print(len(S)) . 3 . &#44536;&#45824;&#47196; &#52636;&#47141;&#54616;&#44592; . 문제 출처: 백준 11718번 | . while 1: try: print(input()) except: break . Hello world! . &#44536;&#45824;&#47196; &#52636;&#47141;&#54616;&#44592;2 . 문제 출처: 백준 11719번 | . - 그대로 출력하기 문제와 동일한 코드로 해결됨 . while True: try: print(input()) except: break . Hello world! . UCPC&#45716; &#47924;&#50631;&#51032; &#50557;&#51088;&#51068;&#44620;? . 문제 출처: 백준 15904번 | . words = input() cnt = 0 for i in range(len(words)): if cnt == 0 and words[i] == &#39;U&#39;: cnt += 1 elif cnt == 1 and words[i] == &#39;C&#39;: cnt += 1 elif cnt == 2 and words[i] == &#39;P&#39;: cnt += 1 elif cnt == 3 and words[i] == &#39;C&#39;: cnt += 1 if cnt == 4: print(&#39;I love UCPC&#39;) else: print(&#39;I hate UCPC&#39;) . I love UCPC . . &#48652;&#47336;&#53944; &#54252;&#49828;(brute force) . - 완전탐색 알고리즘으로 가능한 모든 경우의 수를 탐색한다. --&gt; 100%확률로 정답 출력 . &#48660;&#47001;&#51117; . 기존 룰: 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. . | 변형 룰: N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오. . | . N, M = map(int,input().split()) card = list(map(int,input().split())) def blackjack(card,length,Max): card_list=[] for i in range(N): for j in range(N): for k in range(N): if i != j and j != k and i != k: if card[i]+card[j]+card[k] &lt;= Max: card_list.append(card[i]+card[j]+card[k]) print(max(card_list)) blackjack(card,N,M) ## 아쉬운점: for문3번사용 --&gt; O(n^3) . 21 . &#48516;&#54644;&#54633; . 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. . | 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. . | 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. . | 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. . | 반대로, 생성자가 여러 개인 자연수도 있을 수 있다. . | 자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오. . | . N = int(input()) def solve(x): list=[] for i in range(1, x+1): generator = i + sum([int(str(i)[j]) for j in range(len(str(i)))]) if generator == x: list.append(i) if len(list) &gt; 0: return(min(list)) else: return 0 print(solve(N)) . 198 . &#51076;&#51032;&#51032; &#49707;&#51088;&#51032; (&#44033; &#51088;&#47551;&#49688; + &#51088;&#44592; &#51088;&#49888;) . x=12345 sum([int(str(x)[i]) for i in range(len(str(x)))])+x ### 리스트 컴프리헨션 . 12360 . &#48152;&#50732;&#47548; &#50724;&#52264;(&#48177;&#51456; &#47928;&#51228; &#50500;&#45784; + &#47924;&#51312;&#44148; &#51069;&#51004;&#49464;&#50836;) . - 문제를 풀다보면 나누기 연산을 할 때가 있다 . - 만약 나누기연산과 몫 연산의 결과가 같다면 무조건 몫 연산자를 쓰자 &gt; 10 / 5 = 10 // 5 . - 왜???? . - 0.1 + 0.2 = 0.3 일까? &gt; no . - ???? 정말로? . 0.1 + 0.2 . 0.30000000000000004 . - 정말로 0.1 + 0.2 = 0.3이 아님 . 0.1 + 0.2 == 0.3 . False . - 하나 더: 1.2 * 3 = 3.6 일까? &gt; no . 1.2 * 3 . 3.5999999999999996 . 1.2 * 3 == 3.6 . False . - 밑에 문제인 IQ Test도 틀린 이유가 몫 연산자를 쓰지 않고 나누기 연산자를 사용한 것이다 . - 위에서 확인한 봐와 같이 반올림 오차 때문에 float형은 불안정하므로 몫 연산자를 사용하는 것이 무조건 안전하다 . IQ Test(&#48145;&#50640; &#49345;&#54889; &#46412;&#47928;&#50640; &#48152;&#47168; &#52286;&#50500; &#48420;&#51020;) + &#47582;&#45716; &#44163; &#44057;&#51008;&#45936; &#44228;&#49549; &#53952;&#47548;..., &#44536;&#47000;&#49436; &#45796;&#47480; &#49324;&#46988; &#53076;&#46300; &#48420;&#45716;&#45936; &#50780; &#53952;&#47160;&#45716;&#51648; &#47784;&#47476;&#44192;&#51020; + &#50508;&#50500;&#45256;&#45796; . IQ Test의 문제 중에는 공통된 패턴을 찾는 문제가 있다. 수열이 주어졌을 때 다음 수를 찾는 문제이다. . | 예를 들어 1, 2, 3, 4, 5가 주어졌다. 다음 수는 무엇인가? 당연히 답은 6이다. . | 약간 더 어려운 문제를 보면 3, 6, 12, 24, 48이 주어졌을 때 다음 수는 무엇인가? 역시 답은 96이다. . | 이제 제일 어려운 문제를 보자. . | 1, 4, 13, 40이 주어졌을 때 다음 수는 무엇일까? 답은 121이다. . | 그 이유는 항상 다음 수는 앞 수 * 3 + 1이기 때문이다. . | 은진이는 위의 3문제를 모두 풀지 못했으므로 자동으로 풀어주는 프로그램을 작성하기로 했다. . | 항상 모든 답은 구하는 규칙은 앞 수 * a + b이다. 그리고 a와 b는 정수이다. . | 수 N개가 주어졌을 때 규칙에 맞는 다음 수를 구하는 프로그램을 작성하시오. . | . - N은 2여도 1, 1 과 같이 답이 있을 수 있다. . - 일반적으로 N = 2이면 다음 수는 여러개이다, . - $1, 2$ --&gt; 다음 수 $3(a=0, b=1)$ or $-8(a=-10, b=12)$ 등등 . - a, b 둘다 0일 수 도 있음 . - 스파게티 코드 + 틀렸습니다 . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule(x): if len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif len(x) == 2 and x[0] == x[1]: return x[0] if len(x) == 1: return &#39;A&#39; if x[0] == x[1] == x[2] : a = 0 elif x[1] == x[0] and x[1] != x[2]: return &#39;B&#39; else: a = (x[2] - x[1]) / (x[1] - x[0]) b = x[1] - a * x[0] for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; elif x[i+1] == 0: ## 이 부분이 문제였다. x[i+1] == 0이면 그 뒤는 확인 안하고 return 0 실행 return 0 return int(a * x[-1] + b) print(sequence_rule(N_list)) . - 위에 있는 코드를 정리하자 . - 틀렸습니다 . - exit(0) --&gt; python 프로그램 종료 . - exit(0)써서 코드 짤려했는데 복잡하고 틀렸다고 처리돼서 다른 방법을 찾아 떠났음 . - 이 파일을 둘러보다가 예전에 왜 틀렸는지 모르겠던 기억에 맞은 사람 코드랑 비교해봄 . - 내 코드: a = (x[1] - x[2]) / (x[0] - x[1]) . - 맞은 사람 코드: a = (x[1] - x[2]) // (x[0] - x[1]) . - 나누기 연산자 대신에 몫 연산자를 사용했음 &gt; 뭔 차이인데? . - 10/5 = 2.0이지만 10//5 = 2 &gt; 그래서 왜?? &gt; 출력을 보면 소수점이 없어야 함 &gt; 하지만 나는 소수점이 있으므로 틀림 . - 근데 그 이유가 아니었다 &gt; return (int(a * x[-1] + b)) 이므로 int형이다 &gt; 소수점 없다는 의미 &gt; 그럼 왜 나누기 연산자 쓰면 틀리고 몫 연산자 쓰면 맞음?? &gt; 그러게? . - 아마 float형이 불안정해서 그럴 것이다 &gt; 그래서 안전하게 나누기 대신 몫 연산자를 쓰는 것이 좋음 &gt; 결과가 같을때 만: 10 / 5 = 10 // 5 . - 밑에 있는 코드는 17%부근에서 틀렸습니다로 처리됨 + 내 제출들을 보면 런타임에러(NameError)가 많이 있음 &gt; 이유: if len(x) == 1: 에서 return할 때 &#39;A&#39;가 아닌 A라고 했음 . - &#39;A&#39;라고 해도 17%부근에서 틀렸음 . - 하지만 나누기 연산자 대신에 몫 연산자를 쓰고 정답처리 됐음 . 틀린 코드 | . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule2(x): if len(x) == 1: return &#39;A&#39; elif len(x) == 2 and x[0] == x[1]: return x[1] elif len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 else: a = (x[1] - x[2]) / (x[0] - x[1]) b = x[1] - a * x[0] for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; return int(a * x[-1] + b) print(sequence_rule2(N_list)) . 13 . 맞은 코드 | . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule2(x): if len(x) == 1: return &#39;A&#39; elif len(x) == 2 and x[0] == x[1]: return x[1] elif len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 else: a = (x[2] - x[1]) // (x[1] - x[0]) b = x[1] - a * x[0] for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; return int(a * x[-1] + b) print(sequence_rule2(N_list)) . 13 . - continue --&gt; 아래 코드를 실행하지 않고 건너뜀 . for i in range(10): # 0부터 99까지 증가하면서 100번 반복 if i % 2 == 0: # i를 2로 나누었을 때 나머지가 0면 짝수 continue # 아래 코드를 실행하지 않고 건너뜀 print(i) . 1 3 5 7 9 . - 맞았습니다(3시간 걸림 힘들다) . - 위에 있는 틀린 코드와 밑의 코드는 무슨 차이일까... &gt; 나누기 연산자와 몫 연산자의 차이 . N = int(input()) x = list(map(int, input().split())) if N == 1: print(&#39;A&#39;) elif N == 2: if x[0] == x[1]: print(x[0]) else: print(&#39;A&#39;) else: if x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 b = x[1] else: a = (x[2] - x[1]) // (x[1] - x[0]) b = x[1] - x[0] * a result = True for i in range(N - 1): if x[i] * a + b == x[i+1]: continue else: result = False if result: print(a * x[-1] + b) else: print(&#39;B&#39;) . 121 . &#50689;&#54868;&#44048;&#46021; &#49676; . 종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. . | 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다. . | 숌이 만든 ($N leq10000$)번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. . | . - $N leq 10000$ --&gt; 계산 결과 영화제목은 최대 7자리 . - 7자리 수까지 666을 포함하는 수를 모두 생성한 후 오름차순으로 정렬 . - 문제점: 666xxx 같은 수를 표현한다고 치자 --&gt; 이때 xxx = 010이라면 자연수가 아니므로 010을 수로 표현할 수 없음 . - 666xxx --&gt; 66600x + 6660xx . - 하지만 좋은 방법이 떠오름 . - 666xxx --&gt; 66yxxx , y = 6이므로 yxxx =&gt; range(6000,7000) . - 위와 같이 표현하면 666010도 표현 가능! . import math result = [666] result.extend([int(str(i) + &#39;666&#39;) for i in range(1, 3000)]) ## x666, xy666, xyy666, 1yyy666, 2yyy666 --&gt; 앞으로 나오는 x는 자연수, y는 0포함 result.extend([int(&#39;66&#39; + str(i)) for i in range(6000,7000)]) ## 666yyy result.extend([int(&#39;66&#39; + str(i)) for i in range(600, 700)]) ## 666yy result.extend([int(&#39;666&#39; + str(i)) for i in range(10)]) ## 666y result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 30) for j in range(600, 700)]) ## x666yy, 1y666yy, 2y666yy result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 100) for j in range(60, 70)]) ## x666y, xy666y result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 3) for j in range(6000, 7000)]) ## 1666yyy, 2666yyy result.extend([int(str(i) + &#39;666&#39; + str(j)) for i in range(100, 300) for j in range(10)]) ## 1yy666y, 2yy666y result.extend([int(str(i) + &#39;666&#39;) for i in range(1000, 3000)]) ## 1yyy666, 2yyy666 result = list(set(result)) result.sort() N = int(input()) print(result[N-1]) . 1666 . - 다른 사람 아이디어 보고 만든 코드 --&gt; 내 코드보다 코드 길이가 10배 짧아서 10배 좋다고 생각할라 했는데 시간이 너무 오래 걸리네? --&gt; 내 실수인 걸로 할라 했는데 숏코딩 보니까 다른 사람도 시간이 오래 걸렸다. . - 종말의 수는 $10000$개가 최대이므로 아무거 커도 $3000000$ 이하이다. . - $3000000$까지의 숫자 중 $666$을 포함하면 새로운 리스트에 포함한다. . result = [] result.extend([int(str(i)) for i in range(666,3000000) if str(i).find(&#39;666&#39;) != -1]) N = int(input()) print(result[N-1]) . 1666 . - 숏코딩으로 만들었음(가독성 쓰레기) . print([i for i in range(9**7)if&#39;666&#39;in str(i)][int(input())-1]) . 1666 . &#52404;&#49828;&#54032; &#45796;&#49884; &#52832;&#54616;&#44592; . $8 times8$ 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠한다. | 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오. | . - 밑에 있는 코드 왜 틀림??????????????? . - W로 채워진 8$ times$8 체스판을 input 하면 답이 32가 나와야 하는데 chess1, chess2 = 24, 25가 나온다.(원인 불명) . - 아 왜 틀렸냐고... 안해 다른 거 할 거야 . N, M = map(int, input().split()) data = [] for i in range(N): data.append(list(input())) def chess(n, m): x, y = 0, 7 chess_list = [] while x &lt; n - 7 and y &lt; n: a, b = 0, 7 while a &lt; m - 7 and b &lt; m: chess1, chess2 = 0, 0 for i in range(x, y): for j in range(a, b): if (a + x) % 2 ==0: if (i + j) % 2 == 0: if data[i][j] == &#39;B&#39;: chess1 += 1 else: chess2 += 1 if (i + j) % 2 == 1: if data[i][j] == &#39;B&#39;: chess2 += 1 else: chess1 += 1 else: if (i + j) % 2 == 0: if data[i][j] == &#39;B&#39;: chess2 += 1 else: chess1 += 1 if (i + j) % 2 == 1: if data[i][j] == &#39;B&#39;: chess1 += 1 else: chess2 += 1 chess_list.extend([chess1, chess2]) a += 1 b += 1 x += 1 y += 1 print(chess_list) chess(N, M) . - input . 8, 8 . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . - output . [24, 25] . &#45929;&#52824;(7568&#48264;) . N = int(input()) body = [] for i in range(N): body.append(list(map(int,input().split()))) for i in range(N): rank = 1 for j in range(N): if body[i][0] &lt; body[j][0] and body[i][1] &lt; body[j][1]: rank += 1 print(rank, end = &quot; &quot;) . 2 2 1 2 5 . a=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;] x=&#39; &#39;.join(a) a=1,2,3 print(a) . (1, 2, 3) . . &#49548;&#49688; . &#50500;&#54028;&#53944; &#51076;&#45824;(5615&#48264;) --&gt; &#49884;&#44036; &#52488;&#44284; pass . 아파트 면적은 $2xy+x+y = k$ --&gt; 2k+1 = (2x+1)(2y+1) , $x,y$는 양의 정수 . | 즉, 아파트 면적을 k라 할 때 2k+1은 합성수이다. . | 만약, $2k+1$이 소수라면 잘못된 아파트 면적이다. . | . &#49548;&#49688; &#54032;&#48324; . def Is_prime_number(a): from math import sqrt for i in range(2,int(sqrt(a)+1)): if a%i==0: return True else: return False . from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return False else: return True def apart(n): sum = 0 for i in range(n): x = int(input()) if Is_prime_number(2*x+1) == True: sum +=1 return(sum) N = int(input()) apart(N) . - error: 이렇게 코드를 짜면 N에 어떤 수를 대입해도 if Is_prime_number(2*x+1) == True 부분이 항상 참이여서 sum += 1이 실행된다.(원인불명) . from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return 0 else: return 1 def apart(n): sum = 0 for i in range(n): x = int(input()) if Is_prime_number(2*x+1) == 1: sum += 1 return(sum) N = int(input()) apart(N) . - error: 이렇게 코드를 짜면 N에 어떤 수를 대입해도 if Is_prime_number(2*x+1) == True 부분이 항상 참이여서 sum += 1이 실행된다.(마찬가지로 원인불명) . - 아파트 임대 --&gt; 시간 초과 코드 . import sys from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return False return True def apart(n): sum = 0 for i in range(n): x = int(sys.stdin.readline()) if Is_prime_number(2*x+1) == 1: sum += 1 return(sum) N = int(input()) apart(N) . 2 . &#49548;&#49688;&#54032;&#51221; &#51032;&#47928;&#51216; . def is_prime_number(x): # 2부터 x의 제곱근까지의 모든 수를 확인하며 for i in range(2, int(sqrt(x)) + 1): # x가 해당 수로 나누어떨어진다면 if x % i == 0: return False # 소수가 아님 return True # 소수임 . - 위에 코드는 문제가 없다.$ ,$ x에 2나 3을 넣어도 잘 작동함. . def is_prime_number(x): # 2부터 x의 제곱근까지의 모든 수를 확인하며 for i in range(2, int(sqrt(x)) + 1): # x가 해당 수로 나누어떨어진다면 if x % i == 0: return False # 소수가 아님 else: return True # 소수임 . - 위에 코드는 문제가 있다. x에 2나 3을 넣으면 return이 없다. . - 아마 2나 3을 넣으면 range(2,1) 이 돼서 그럴 것이다. . &#54028;&#51060;&#50028; &#53076;&#46300; &#49892;&#54665; &#49884;&#44036; &#52769;&#51221; . import time start = time.time() ## 시작 시간 저장 ## --작업 코드-- print(&quot;time :&quot;, time.time() - start) . &#49548;&#49688; &#52286;&#44592;1 . 주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오. | . N = int(input()) def Is_prime_num(x): if x == 1: return False for i in range(2, int(x**0.5) + 1): if x % i == 0: return False return True prime_num = 0 num_list = list(map(int, input().split())) for i in range(N): if Is_prime_num(num_list[i]) == True: prime_num += 1 print(prime_num) . 3 . &#49548;&#49688; &#52286;&#44592;2 . 자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오. . | 만약 N과 M사이에 소수가 없다면 1을 출력하시오. . | . N = int(input()) M = int(input()) def Is_prime_num(x): if x == 1: return False for i in range(2, int(x**0.5)+1): if x % i == 0: return False return True prime_list = [] for j in range(N, M+1): if Is_prime_num(j) == True: prime_list.append(j) if len(prime_list) == 0: print(-1) else: print(sum(prime_list)) print(min(prime_list)) . 620 61 . &#50640;&#46972;&#53664;&#49828;&#53580;&#45348;&#49828;&#51032; &#52404;&#47484; &#53685;&#54620; &#49548;&#49688; &#52286;&#44592;(&#49548;&#49688; &#52286;&#44592;2 &#45796;&#47480; &#54400;&#51060;) . - N과M은 10000이하의 자연수 이므로 미리 에라토스테네스의 체를 통해 소수를 구해놓자 . N = int(input()) M = int(input()) n = 10000 m = int(n**0.5) prime_list = [False, False] + [True] * (n-1) for i in range(2, m+1): if prime_list[i] == True: for j in range(2*i, n+1, i): prime_list[j] = False prime_num_list = [ x for x in range(N, M+1) if prime_list[x] == True] if len(prime_num_list) == 0: print(-1) else: print(sum(prime_num_list)) print(min(prime_num_list)) . 620 61 . if prime_list[i] == True: . - 위 부분은 아래와 같이 해도 됨 . if prime_list[i]: . prime_list[i] 자체가 True or False임 . &#49548;&#51064;&#49688;&#48516;&#54644; . 정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오. | . import sys n = 3164 m = int(n**0.5) prime_nums = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_nums[i] == True: for j in range(2*i, n+1, i): prime_nums[j] = False N = int(input()) M = int(N**0.5) def factorization_into_primes(x): if x == 1: sys.exit(0) stack = 0 mul = 1 for k in range(2, M+1): if prime_nums[k] == False: continue else: l = x/k while l == int(l): print(k) mul *= k stack += 1 l = l/k if stack == 0: print(x) elif mul != N: print(int(x/mul)) . 7 11 13 . &#49548;&#49688; &#44396;&#54616;&#44592; . M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오. | . n = 1000000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False M, N = map(int, input().split()) prime_num = [x for x in range(M, N+1) if prime_num_list[x] == True] for k in range(len(prime_num)): print(prime_num[k]) . 3 5 7 11 13 . &#48288;&#47476;&#53944;&#46993; &#44277;&#51456; . 베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다. . | 예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23) . | 자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오. . | . n = 123456 * 2 m = int(n**0.5) prime_nums = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_nums[i] == True: for j in range(2*i, n+1, i): prime_nums[j] = False def prime_number(num): print(len([x for x in range(num+1, 2*num+1) if prime_nums[x] == True])) while True: n = int(input()) if n == 0: break prime_number(n) . 1 . 4 . 3 . 21 . 135 . 1033 . 8392 . &#44264;&#46300;&#48148;&#55120;&#51032; &#52628;&#52769; . 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다. . | 2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오. . | 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다. . | . - 신기한점 . n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False prime_num = [x for x in range(2, n+1) if prime_num_list[x] == True] ### 여기까지 동일 last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True].reverse() type(last_prime_num) . - 위의 코드에서 type(last_prime_num)의 결과는 Nonetype임 . ### 동일 부분 생략 last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True] last_prime_num.reverse() type(last_prime_num) . - 위의 코드에서 type(last_prime_num)의 결과는 list임 . - 무슨 차이일까? . n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False prime_num = [x for x in range(2, n+1) if prime_num_list[x] == True] last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True] last_prime_num.reverse() p = len(prime_num) T = int(input()) for i in range(T): N = int(input()) for j in range(N//2, N+1): if j in prime_num and N - j in prime_num: print(N - j, j) break . 5 7 . - 위의 코드는 시간이 매우 오래 걸리는 쓰레기임 . - 새로 만들었음 . - 시간이 $ frac{1}{4}$ 이 됐다: 2344ms --&gt; 556ms . import sys n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i]: for j in range(2*i, n+1, i): prime_num_list[j] = False T = int(input()) for i in range(T): N = int(sys.stdin.readline()) for j in range(N//2, N+1): if prime_num_list[j] and prime_num_list[N - j]: print(N - j, j) break . 5 7 . - 더 줄이고 싶다 . - 시간이 96ms로 단축됨 . - [$ star star star$] 여러번 반복하여 입력을 받는 경우에는 input() 대신 sys.stdin.readline() 사용 [$ star star star$] . . &#44592;&#48376; &#49688;&#54617;1 (&#49884;&#44036; &#52488;&#44284; &#51452;&#51032;) . &#45804;&#54077;&#51060;&#45716; &#50732;&#46972;&#44032;&#44256; &#49910;&#45796;. . 땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다. . | 달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다. . | 달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오. . | . - 달팽이는 올라가고 싶다 --&gt; 시간 초과 코드(while 반복문 사용) . A, B, V = map(int,input().split()) ### 시간 초과 day = 1 h = 0 while 1: h += A if h &gt;= V: break h -= B day += 1 print(day) . 25 . - 달팽이는 올라가고 싶다 --&gt; 시간 초과 해결한 코드(한 줄 수식) . import math A, B, V = map(int,input().split()) ### 시간 초과 해결 print(math.ceil((V-A)/(A-B))+1) . 25 . &#49552;&#51061;&#48516;&#44592;&#51216; . A는 고정 비용, B는 가변 비용, C는 수익, k는 판매량 . | $C*k &gt; A + B*k$ --&gt; $k &gt; frac{A}{C-B}$ . | . A, B, C = map(int, input().split()) if abs(C-B) &lt; 0.5: ### C == B 여부를 판단 print(-1) elif int(A/(C-B)) &lt; 0: print(-1) else: print(int(A/(C-B)) + 1) . -1 . - 위에 코드보다 더 간결한 코드 . - A에 관계없이 B &gt;= C이면 손익분기점이 없다. . A, B, C = map(int, input().split()) if B &gt;= C: ### C == B 여부를 판단 print(-1) else: print(int(A/(C-B)) + 1) . 11 . Fly me to the Alpha Centauri . 시작할 땐 1만큼 도착할 때도 1만큼 이동 . | k만큼 이동한 후에 k-1 or k or k+1 만큼 이동 가능 . | . - 이동 횟수를 최소화할려면? . - $x지점(출발=0) to{1} to{2} to{3} to dots to{n} to{n-1} to dots to{2} to{1} to{y지점}(도착=0)$ . - $이동 ,거리 = sum_{i=1}^{n}{k} + sum_{i=1}^{n-1}{k} = frac{n(n+1)}{2} + frac{(n-1)n}{2} = n^2$ . - $y-x = n^2$ . - $이동 ,횟수 = 화살표의 ,개수 = n+(n-1)=2n-1$ . - 즉 $n^2$의 거리를 이동하기 위한 최소한의 이동 횟수는 $2n-1$이다. . - 바꿔말하면 $2n-1$번의 이동으로 갈 수 있는 최대 거리는 $n^2$이다. . - 위에 방법에 기반하여 정리를 해봤다. . - 위에서는 이동 거리가 $n^2$에 대해서 고려했다. 하지만 이동 거리가 제곱수가 아닐 수 도 있다. . - 예로 이동 거리가 110이면 이동 횟수는 $ sqrt{100} leq sqrt{110} leq sqrt{121}$ 이므로 10 or 11 or 12이다. . - $n^2 = 1+1+2+2+ dots+(n-1)+(n-1)+n$ 이다. . - 100 과 121의 차이는 21 = 10 + 11 --&gt; 100은 이동 횟수 $2n-1=19$, 101$ sim$110 은 $2n=20$, 111$ sim$121은 $2n+1=21$이다. . T = int(input()) for i in range(T): x, y = map(int, input().split()) n = y - x m = int(n**0.5) if n**0.5 == m: print(2*m - 1) elif n - m**2 &lt;= m: print(2*m) else: print(2*m + 1) . 3 . 3 . 4 . &#49444;&#53461; &#48176;&#45804; . 상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. . | 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다. . | 상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. . | 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 된다. . | 하지만 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다. . | 상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오. . | 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다. . | . - 봉지를 최소화 해야 한다. --&gt; 5kg 봉지를 최대한 많이 써야 한다. . - 설탕의 무게를 5로 나눈다. . - 만약 5로 나눠지면 끝이다. 그러지 않다면 5kg 봉지를 하나씩 줄여나가고 나머지를 3kg 봉지로 담는다. . - 5kg 봉지를 하나씩 줄이다가 0이 됐다면 전부 3kg 봉지를 사용한다. . - 그래도 안된다면 정확하게 Nkg을 만드는 것이 불가능하므로 -1을 출력한다. . N = int(input()) def sugar(n): k = n//5 l = n % 5 if l == 0: return k else: n = n - k*5 if n % 3 ==0: return k + 1 else: n = n - (k-1)*5 if n % 3 ==0: return k - 1 + n//3 else: n = n - (k-2)*5 if n % 3 == 0: return k - 2 + n//3 else: n = n -(k-3)*5 if n % 3 ==0: return k - 3 + n//3 else: ...... if n &lt; 0: return -1 . 이런식으로 전개될 것이다. | . N = int(input()) def sugar(n): k = n // 5 l = n % 5 for i in range(k+1): if l == 0: return k break elif l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 201 . - 코드를 둘러보던 중 위의 코드가 비효율적이라 느껴졌다 . - 왜냐하면 for문에서 if l == 0: 은 처음 한 번 해서 False이면 영원히 False이다 --&gt; else: l += 5 때문 . - 하지만 for문 안에 있어서 k+1번 쓸모없는 행위를 반복해야 한다. . - 그래서 아래와 같이 수정했다 . - 그런데 시간이 64ms 에서 72ms가 됐다??? . N = int(input()) def sugar(n): k = n // 5 l = n % 5 if l == 0: return k for i in range(k+1): if l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 201 . print &#50752; return &#51032; &#52264;&#51060;(&#44036;&#45800;&#55176;) . - return 은 종료문이다. 함수에서 return을 만나면 함수가 종료된다. . - 그렇기에 return이 여러개여도 하나만 반환된다. . - 여러 값을 반환하고 싶다면 return a,b,c, $ dots$ . - print()는 그렇지 않다. . - 위에 설탕배달 코드에서 return을 print()로 바꾼다면 항상 -1을 출력하지만 . - return이기 때문에 return k or return k + l//3이 실행되지 않을 때만 return -1이 실행된다. . &#48516;&#49688;&#52286;&#44592; . 이와 같이 나열된 분수들을 1/1 -&gt; 1/2 -&gt; 2/1 -&gt; 3/1 -&gt; 2/2 -&gt; … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자. . | X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오. . | . - 분모 + 분자 = n + 1인 분수가 n개 있다. . - 분모 + 분자가 2인 분수가 1개, 3인 분수가 2개, 4인 분수가 3개, $ dots$, n+1인 분수가 n개 . - 분모 + 분자가 $n+1$인 끝점: $1+2+3+ dots+n-2+n-1+n$ . x = int(input()) n = int((x * 2) ** 0.5) k = n * (n + 1) // 2 a = k - x if a &lt; 0: n += 1 k += n a = k - x if n % 2 == 0: print(str(n-a)+&#39;/&#39;+str(1+a)) else: print(str(1+a)+&#39;/&#39;+str(n-a)) . 4 10 4 15 5/1 . &#49688;&#54617;&#51008; &#48708;&#45824;&#47732;&#44053;&#51032;&#51077;&#45768;&#45796;(19532&#48264;) . - 백준은 내부 라이브러리만 사용 가능, numpy는 외부 라이브러리라 사용 불가능 . import numpy as np a, b, c, d, e, f = map(int, input().split()) array1 = np.array([[a, b], [d, e]]) array2 = np.array([c, f]) x, y = np.linalg.inv(array1) @ array2 print(round(x), round(y)) . - 연립 일차 방정식을 행렬을 통해 풀어 보자 . a, b, c, d, e, f = map(int, input().split()) det = a * e - b * d print(round((e * c - f *b ) / det), round((a * f - c * d) / det)) . -1 2 . &#48512;&#45376;&#54924;&#51109;&#51060; &#46112;&#53580;&#50556; . 아파트에 거주를 하려면 조건이 있는데 . | a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다 . | 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다 . | . - a층의 b호 사람 수 = a층의 b-1호 사람 수 + a-1층의 b호 사람 수 . - 기본적으로 생각하면 0층 b호에는 n명이 살고 a층 1호에는 1명이 a층 2호에는 a+2명이 산다. . - 점화식을 알고 있으므로 재귀 함수를 사용했음 . - 호출을 여러 번 해야해서 좋지 않음 . - 시간 초과에 걸림 . def apart(a, b): if a == 0: return b if b == 1: return 1 return apart(a, b - 1) + apart(a - 1, b) T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart(k, n)) . 37442160 . - 이미 구한 층,호수 사람 수는 기록하는 방법 사용(메모이제이션) . - 똑같이 시간 초과 . List = [[0] * 14 for _ in range(15)] List[0] = [x for x in range(1, 15)] for i in range(len(List)): List[i][0] = 1 for j in range(len(List)): List[j][1] = j + 2 def apart(a, b): if List[a][b - 1] != 0: return List[a][b - 1] return apart(a, b - 1) + apart(a - 1, b) T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart(k, n)) . 37442160 . - 난 위의 코드가 메모이제이션인 것 같았다. . - 근데 처음 짠 코드와 다른 게 없었다. 메모이제이션이 아닌 가 보다. . - 수학으로 풀려면 계차수열을 사용해야 하는데 복잡해 보인다. . - 그래서 이번에는 처음부터 아파트를 채워놓고 시작하는 방법을 사용했다. . - 층과 호수를 입력하면 채워진 아파트에서 그 층과 호수에 사는 사람 수를 출력한다. . - 최대 사람수가 사는 14층 14호를 입력하면 첫 번째와 두 번째 코드는 2초 정도 걸렸는데 이 코드는 바로 출력된다. . - 시간 초과 해결 . apart = [[0] * 14 for _ in range(15)] apart[0] = [x for x in range(1, 15)] x = len(apart) for i in range(x): apart[i][0] = 1 for j in range(x): apart[j][1] = j + 2 for i in range(1, x): for j in range(1, x - 1): apart[i][j] = apart[i][j-1] + apart[i - 1][j] T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart[k][n - 1]) . 37442160 . &#48516;&#49328;&#52376;&#47532; . 문제 출처: 백준 1009번 | . - 이 문제는 $a^b$의 일의 자리 숫자만 알면 풀 수 있음 . - 그런데 $a^b$의 값은 최대 $100^1000000$이므로 이를 계산하기는 불가능함 . - 여기서 중요한 점은 전체 값이 필요한 게 아니라 일의 자리만 필요하다는 것 . - 데이터가 $a^b$꼴로 주어진 점에서 힌트를 얻었는데 어떤 수 $m$의 일의 자리수가 $n$이면 $m^x$의 일의 자리수는 $n^x$의 일의 자리수와 동일함 &gt; 당연한 소리 . - 그리고 $0 leq n leq 9$이고 $n^x$의 일의 자리수는 규칙성을 띈다 . - 예시로 $7^x$꼴의 일의 자리수는 7, 9, 3, 1이 반복된다 . - 이를 이용하여 문제를 해결하자 . T = int(input()) for _ in range(T): a, b = map(int, input().split()) a = a % 10 b = (b % 4) + 4 ## x^0 = 1이므로 x = str(a ** b)[-1] if x == &#39;0&#39;: print(10) else: print(int(x)) . 1 . 7 . 6 . 1 . 9 . 3&#51032; &#48176;&#49688; . 문제 출처: 백준 1769번 | . x = input() cnt = 0 while len(x) &gt; 1: x = str(sum([int(i) for i in x])) cnt += 1 print(cnt) if int(x) % 3 == 0: print(&#39;YES&#39;) else: print(&#39;NO&#39;) ## input ## 1234567 . 3 NO . . &#44592;&#48376; &#49688;&#54617; 2 -- &#44592;&#54616; . &#53552;&#47131;(&#52280;&#44256;&#54644;&#49436; &#54400;&#50632;&#51020;) . 두 원의 중심과 반지름이 각각 주어졌을 때 교점의 개수를 출력하시오 | . - 두 점에서 만나는 경우 . r1 + r2 &gt; d and abs(r1 - r2) &lt; d . - 두 원의 위치관계 참고 : https://mathbang.net/101 . T = int(input()) for i in range(T): x1, y1, r1, x2, y2, r2 = map(int, input().split()) d = ((x1 - x2)**2 + (y1 - y2)**2)**0.5 if d == 0: if r1 == r2: print(-1) else: print(0) elif r1 + r2 &lt; d: print(0) elif r1 + r2 &gt; d and abs(r1 -r2) &lt; d: print(2) elif r1 + r2 == d: print(1) elif abs(r2 - r1) == d: print(1) elif abs(r2 - r1) &gt; d: print(0) . 2 . 1 . 0 . &#53469;&#49884; &#44592;&#54616;&#54617; . 택시 기하학에서 두 점 $T_1(x_1,y_1)$, $T_2(x_2,y_2)$ 사이의 거리는 다음과 같이 구할 수 있다. . | $D(T_1, T_2) = |x_1 - x_2| + |y_1 - y_2|$ . | 첫째 줄에는 유클리드 기하학에서 반지름이 R인 원의 넓이를, 둘째 줄에는 택시 기하학에서 반지름이 R인 원의 넓이를 출력한다. . | . - 반지름이 $R$일 때 원은 $|x_1 - x_2| + |y_1 - y_2| = R$의 자취임 . - 이를 그려본면 택시 기하학에서 원은 마름모임을 쉽게 알 수 있음 . - 넓이는 $ frac{2R times 2R}{2} = 2R^2$ . import math R = int(input()) π = math.pi print(π*R**2) print(2*R**2) . 1385.4423602330987 882 . . &#51221;&#47148; . &#49688; &#51221;&#47148;&#54616;&#44592; 1 . N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. | . - 선택 정렬 . N = int(input()) List = [] for i in range(N): num = int(input()) List.append(num) n = len(List) for j in range(n): min_idx = j for k in range(j + 1, n): if List[k] &lt; List[min_idx]: min_idx = k List[j], List[min_idx] = List[min_idx], List[j] print(List[j]) . 1 2 3 4 5 . - 내장 함수 ?.sort() . N = int(input()) List = [] for i in range(N): num = int(input()) List.append(num) List.sort() for j in range(len(List)): print(List[j]) . 1 2 3 4 5 . &#49688; &#51221;&#47148;&#54616;&#44592; 2 . N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. | . - 아래의 병합 정렬 코드는 시간초과임 . - 왜냐하면 리스트의 길이가 매우 긴데 재귀 함수를 사용했기 때문 . - 재귀 함수 호출이 매우 많이 일어나서 시간이 오래 걸림 . - 그래서 재귀 함수 없는 코드로 짜봤는데 시간 초과 --&gt; 그냥 파이썬이 느림 . - pop(0)이 문제였음 --&gt; $O(N)$ . - 그래서 pop()를 안쓰고 코드를 구성 . N = int(input()) unsorted_list = [] for i in range(N): unsorted_list.append(int(input())) def merge_sort(x): if len(x) &lt;= 1: return x mid = len(x) // 2 left = x[:mid] right = x[mid:] left1 = merge_sort(left) right1 = merge_sort(right) return merge(left1, right1) def merge(left, right): sorted_list = [] while left and right: if left[0] &lt; right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) while left: sorted_list.append(left.pop(0)) while right: sorted_list.append(right.pop(0)) return sorted_list sort_list = merge_sort(unsorted_list) for i in range(N): print(sort_list[i]) . - python은 시간 초과여서 pypy3로 제출해서 맞춤 . - 위 코드는 pypy3로 제출해도 시간 초과임 . N = int(input()) unsorted_list = [] for i in range(N): unsorted_list.append(int(input())) def mergeSort(x): ## 나누기 n = len(x) if n &lt;= 1: return x mid = n // 2 left = x[:mid] ## mid를 기준으로 왼쪽 right = x[mid:] ## mid를 기준으로 오른쪽 next_left = mergeSort(left) ## 재귀적으로 나누기 next_right = mergeSort(right) ## 재귀적으로 나누기 return merge(next_left, next_right) def merge(left, right): ## 병합하기 i = 0 j = 0 sorted_list = list() while i &lt; len(left) and j &lt; len(right): ## left와 right중 더 작은 값 넣기 if left[i] &lt; right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 ## left와 right 중 남은 값을 넣어주기 while i &lt; len(left): sorted_list.append(left[i]) i += 1 while j &lt; len(right): sorted_list.append(right[j]) j += 1 return sorted_list sort_list = mergeSort(unsorted_list) for i in range(N): print(sort_list[i]) . 1 2 3 4 5 . &#49688; &#51221;&#47148;&#54616;&#44592; 3 . N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. . | N은 최대 10000000, 10000보다 작거나 같은 자연수 . | 수 정렬하기 2와 다르게 메모리 제한이 있다. . | . - 수 정렬하기 2에서 사용했던 코드는 메모리 제한에 걸림 . - 힌트를 보고 생각했음 . - 그런데 생각해보면 메모리가 8MB 이다 . - N이 최대 10000000이면 short형(2byte, c언어)를 쓰더라도 20000000byte로 20MB이다 --&gt; 메모리 초과 . - 근데 N이 10000000이라고 하면 적어도 어느 자연수 하나는 1000번 이상 등장함(비둘기집 원리) . - 그러면 1~10000까지 번호를 새긴 깡통을 만들어두고 input으로 등장한 숫자와 같은 번호의 깡통에 투표를 하는 매커니즘으로 생각하면 어떨까 . - [0]*10001인 리스트를 만듦. 등장한 숫자가 i라면 list의 i번째 요소의 값을 1씩 증가시킴 . - 최종적으로 리스트의 처음 인덱스부터 끝까지 value만큼 출력한다 . - 10000000크기의 list를 만드는 대신에 10000크기의 list를 만듦 --&gt; 메모리 소비 줄임 . - input() 대신 sys.stdin.readline() 사용, 근데 왜 나는 sys.stdin.readline()가 error가 날까... --&gt; 그래서 사용을 안하는 버릇생김 . - Test는 input()으로 해도 제출은 sys.stdin.readline()로 하는 습관 가지기 . 이 코드는 메모리 초과임 | . - arr[i] = 0이어도 뒤에 for문을 실행한다 . - arr[i] = 0이면 pass 하도록 아래와 같이 코드를 바꿨다 . import sys arr = [0] * 10001 N = int(input()) for i in range(N): arr[int(sys.stdin.readline())] += 1 for i in range(1, 10001): for j in range(arr[i]): print(i) . 1 2 4 5 5 . - 문제를 보니 카운팅 정렬로 해결하는 문제였다 --&gt; 카운팅 정렬 공부해야지 . &#53685;&#44228;&#54617; . 수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자. . | 산술평균 : N개의 수들의 합을 N으로 나눈 값 . | 중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값 . | 최빈값 : N개의 수들 중 가장 많이 나타나는 값 . | 범위 : N개의 수들 중 최댓값과 최솟값의 차이 . | N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오. . | . - 이 코드는 잘못된 코드임. while문에서 빠져나오지 못함 . - 처음에는 while문만 보다가 while문은 이상한점이 없어서 처음부터 다시 봤음 . - 처음에 입력을 받는 부분이 잘못됨. 양수와 음수를 구별하는 if-else코드가 for문안에 들어가야 한다 . - 그렇지 않으면 입력을 받아 저장하는 x가 counting되지 않음 . - 또 문제가 있음 while문에서 k+1을 쓰면 무한loop에 빠지고 4001을 써야함(이유는 자고 일어나서..) . - 이유를 찾았다 . for k in range(neg_nums[i]): val_sum -= i . - for문에 변수로 k를 사용해서 k값이 4000에서 다른값으로 변한 것 --&gt; 변수명 안겹치게 하기 . - 또 문제가 있다 . - 중앙값이 제대로 출력되지 않음. 입력으로 1, 3, 8, -2, 2를 주어졌을 때 중앙값으로 8이 출력됨 . - while문에서 num &lt; mid일 때만 수행하라고 했는데 왜지?? num이 mid보다 커져도 for문이 계속 작동하여 median = 8을 store함 . - 이유를 알고보니까 이런 거임. 내가 일을 시키는 입장인데 내가 주는 업무를 수행하는데 12시간 넘으면 쉬라고 명령함 . - 근데 업무로 일 40시간 하기를 시킴.. . - while문에서는 num &lt; mid이면 탈출하라고 했음. True일 동안 for i in range(4001)을 수행해야 함 . - 근데 시킨 업무가 range(4001)여서 i가 0 부터 4000이 될동안 num도 mid보다 커지지만 일단 시킨 업무가 for i in range(4001)이라 멈출 수 없고 다 끝낸 뒤 num &gt;= min여서 while문 탈출 . - 또 문제가 있음... . - 파이썬 round()를 하면 대부분 잘 작동함 근데 -1.5, -3.5같이 -?.5 (?은 홀수)의 경우에 제대로 값을 반환하지 않음 . - 또 2.5, 4.5 같이 ?.5(?은 짝수)의 경우 제대로 값을 반환하지 않음 . - -1.5를 반올림하면 -1이 맞지만 round(-1.5)는 -2를 return한다. 또 2.5를 반올림하면 2가 맞지만 round(2.5)는 2를 return한다 . - 파이썬에서는 반올림 자리가 5인 경우, 앞자리가 홀수면 올림, 짝수면 버림을 한다. 이를 고려해주어야 한다 . - 진짜 마지막으로 에러가 하나 있었다 . - 범위를 구하는 곳에서 오류가 있었는데 입력으로 0, 0, 0, -1, -2 가 주어지면 2가 출력되야 하지만 1이 출력됐다 . - 왜냐하면 양수로 0이 입력됐지만 max_pos = 0이기 때문 . - 그래서 양수는 입력되지 않았다고 판단하여 -1 - (-2) = 1을 범위로 output함 . N = int(input()) k = 4000 pos_nums = [0] * (k+1) neg_nums = [0] * (k+1) for _ in range(N): x = int(input()) if x &gt;= 0: pos_nums[x] += 1 else: neg_nums[-x] += 1 val_sum = 0 min_pos = 0 max_neg = 0 max_pos = 0 min_neg = 0 for i in range(k+1): if pos_nums[i] != 0: max_pos = i if min_pos == 0: min_pos += i for j in range(pos_nums[i]): val_sum += i for i in range(k+1): if neg_nums[i] != 0: min_neg = -i if max_neg == 0: max_neg -= i for k in range(neg_nums[i]): val_sum -= i mean = val_sum / N num_pos = sum(pos_nums) num_neg = sum(neg_nums) mid = (N + 1) // 2 num = 0 if num_pos &gt;= num_neg: mid -= num_neg while num &lt; mid: for i in range(k+1): if pos_nums[i] != 0: for j in range(pos_nums[i]): num += 1 median = i else: mid -= num_pos while num &lt; mid: for i in range(k+1): if neg_nums[i] != 0: for j in range(neg_nums[i]): num += 1 median = -i range_ = 0 if max_pos != 0 and min_neg != 0: range_ = max_pos - min_neg elif max_pos == 0: range_ = max_neg - min_neg elif min_neg == 0: range_ = max_pos - min_pos mode = [] freq = max(pos_nums + neg_nums) for i in range(k+1): if pos_nums[i] == freq: mode.append(i) if neg_nums[i] == freq: mode.append(-i) if mode: mode.remove(min(mode)) mode_ = min(mode) else: mode_ = min(mode) print(mean) print(median) print(mode) print(range_) . - 위에서 잘못된 부분을 디버깅한 코드 . - 디버깅은 print()를 사용했는데 나중에 이에 대해 다뤄보자 . - 시간 초과 --&gt; input() 말고 sys.stdin.readline()써야함 . - 입력구문을 바꾸니 맞았다 . - 디버깅하느라 힘들었음 . N = int(input()) k = 4000 pos_nums = [0] * (k+1) neg_nums = [0] * (k+1) for _ in range(N): x = int(input()) if x &gt;= 0: pos_nums[x] += 1 else: neg_nums[-x] += 1 val_sum = 0 min_pos = [] max_neg = 0 max_pos = 0 min_neg = 0 for i in range(k+1): if pos_nums[i] != 0: max_pos = i if len(min_pos) &lt; 1: min_pos.append(i) for j in range(pos_nums[i]): val_sum += i for i in range(1, k+1): if neg_nums[i] != 0: min_neg = -i if max_neg == 0: max_neg -= i for m in range(neg_nums[i]): val_sum -= i ## 산술평균 def round2(number): if number &gt;= 0: if number - int(number) &gt;= 0.5: a = 1 else: a = 0 return int(number) + a else: if int(number) - number &gt; 0.5: a = -1 else: a = 0 return int(number) + a mean = round2(val_sum / N) ## 중앙값 num_pos = sum(pos_nums) num_neg = sum(neg_nums) mid = (N + 1) // 2 num = 0 if num_pos &gt;= num_neg: mid -= num_neg for i in range(k+1): if pos_nums[i] != 0: for j in range(pos_nums[i]): num += 1 median = i if num &gt;= mid: break else: mid -= num_pos for i in range(k+1): if neg_nums[i] != 0: for j in range(neg_nums[i]): num += 1 median = -i if num &gt;= mid: break ## 범위 range_ = 0 if min_pos and min_neg != 0: range_ = max_pos - min_neg elif len(min_pos) &lt; 1: range_ = max_neg - min_neg elif min_neg == 0: range_ = max_pos - min_pos[0] ## 최빈값 mode = [] freq = max(pos_nums + neg_nums) for i in range(4001): if pos_nums[i] == freq: mode.append(i) if neg_nums[i] == freq: mode.append(-i) if len(mode) &gt; 1: mode.remove(min(mode)) mode_ = min(mode) else: mode_ = min(mode) print(mean) print(median) print(mode_) print(range_) . 2 2 1 10 . &#45208;&#51060;&#49692; &#51221;&#47148; . 문제 출처: 백준 10814번 | . N = int(input()) data = [] for i in range(N): member = list(input().split()) + [i] member[0] = int(member[0]) data.append(member) data.sort(key = lambda x: (x[0], x[2])) for j in range(N): print(data[j][0], data[j][1]) . 20 Sunyoung 21 Junkyu 21 Dohyun . . &#44536;&#47532;&#46356; &#50508;&#44256;&#47532;&#51608; . &#46041;&#51204; 0 . 준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다. . | 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. . | 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오. . | 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수) . | . N , K = map(int, input().split()) coins = [] for i in range(N): coins.append(int(input())) num = [K] for j in range(N - 1): val = coins[j+1] / coins[j] replace = num[j] // val num[j] -= replace * val num.append(replace) print(int(sum(num))) . 12 . &#51075;&#50612;&#48260;&#47536; &#44292;&#54840; . 세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들고 난 후 괄호를 모두 지웠다. . | 그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다. . | . - 한번만 minus 기호가 나오면 그 뒤에 수는 모두 빼기로 만들 수 있음 . - 50 - 70 + 80 + 90 --&gt; 50 - (70 + 80 + 90) . - join(), split(), replace(), map() 함수 사용 . string = str(input()) s1 = string.split(&#39;-&#39;) s2 = s1[0] s2 = s2.split(&#39;+&#39;) s2 = list(map(int, s2)) s3 = s1[1:] if len(s3) &gt; 0: s3 = &#39;-&#39;.join(s3) s3 = s3.replace(&#39;-&#39;, &#39;+&#39;) s3 = s3.split(&#39;+&#39;) s3 = list(map(int, s3)) print(sum(s2) - sum(s3)) else: print(sum(s2)) . 0 . ATM . 문제 출처: 백준 11399번 . | 인하은행에는 ATM이 1대밖에 없다. . | 줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 $P_i$가 주어졌다. . | 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오. . | . - times를 sort()함수를 통해 오름차순으로 정렬 . - 최소값 $=$ 첫 번째 원소 $ times$ N $+$ 두 번째 원소 $ times$ (N-1) $+ dots +$ 마지막 원소 $ times$ 1 . N = int(input()) times = list(map(int, input().split())) times.sort() print(sum([times[i] * (N - i) for i in range(N)])) . 32 . &#51452;&#50976;&#49548; . 설명이 길어서 링크를 남긴다. . | 문제 출처: 백준 13305번](https://www.acmicpc.net/problem/13305 . | . - 현재 주유소 가격보다 더 싼 주유소가 있는 곳 까지의 거리만큼만 구매하여 더 싼 주유소까지 감 . - 정확히는 현재 주유소 가격보다 더 싼 주유소 중 가장 거리가 가까운 주유소 . - 더 싼 주유소 까지 갔으면 그 주유소보다 더 싼 주유소가 있는 곳 까지의 거리만큼만 구매하여 더 싼 주유소까지 감 . - 만약 더 싼 곳이 없으면 목표지점까지 남은 거리 만큼 기름을 구매 . - 이를 도착할 때 까지 반복함 . - 백준 문제 예시를 보자 . 기름 가격이 현재 5원 보다 더 싼 곳은 2원이므로 5원에서 2원까지 거리인 2km를 갈 수 있을 정도만 기름을 구매함(2L 구매) . | 현재 2원 보다 더 싼 곳은 1원이므로 2원에서 1원까지 거리인 4km를 갈 수 있을 정도만 기름을 구매함(4L 구매) . | 목표 지점에 도착했으므로 끝 . | N = int(input()) lengths = list(map(int, input().split())) oils = list(map(int, input().split())) idx = 0 costs = 0 for i in range(1, len(oils)): if oils[i] &lt;= oils[idx]: costs += oils[idx] * lengths[i - 1] idx = i else: costs += oils[idx] * lengths[i - 1] print(costs) . 10 . - 아래는 더 간결한 코드(중복 부분 제거) . N = int(input()) lengths = list(map(int, input().split())) oils = list(map(int, input().split())) idx = 0 costs = 0 for i in range(1, len(oils)): costs += oils[idx] * lengths[i - 1] if oils[i] &lt;= oils[idx]: idx = i print(costs) . 10 . &#51452;&#50976;&#49548; &#47928;&#51228; &#46356;&#48260;&#44613; . - 아래는 잘못된 코드임 . N = int(input()) lengths = list(map(int, input().split())) oils = list(map(int, input().split())) idx = 0 costs = 0 for i in range(1, len(oils)): if oils[i] &lt;= oils[idx]: costs += oils[idx] * lengths[idx] idx = i else: costs += oils[idx] * lengths[i - 1] print(costs) . - 아래 코드가 잘못됨 . costs += oils[idx] * lengths[idx] . - 아래 코드로 수정해야함 . lengths[idx] --&gt; lengths[i - 1] . - 디버깅 하면서 느낀점 : 다양한 상황을 고려하고 [$ star$]종이에 쓰면서[$ star$] 어떻게 흘러가는지 분석하자 . &#54924;&#51032;&#49892; &#48176;&#51221; . 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. . | 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. . | 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. . | 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다. . | . - 가장 빨리 끝나는 회의를 배정하는 것이 best임, 시작 시간과 종료 시간이 같은 것이 있을 수 있으므로 종료 시간이 같다면 먼저 시작하는 것을 앞에 배정함 . - 그 회의를 마치고 다음 회의를 고를 때 마찬가지로 가장 빨리 끝나는 회의를 배정함 . - 이를 반복하면 된다 . - [1, 1]과 [0, 1]이 있다면 [0, 1]을 배정하고 [1, 1]을 해야한다. 순서를 바꾸면 1개가 최대임 . - 처음에는 종료 시간만 고려해서 틀림 --&gt; 디버깅을 합시다 . - 그래서 생각한 것이 &quot;아!, 시작 시간과 종료 시간 간격이 짧은 것이 더 좋겠지([5, 8]보단 [6, 8]더 좋을 거야)&quot;라고 했음 . - 그래서 종료 시간 기준으로 오름차순 정렬한 후 시작 시간 기준으로 내림차순 정렬을 했다. 하지만 위에서 다룬 [1, 1]과 [0, 1]의 상황에 의해 틀림 . - 종료 시간기준으로 오름차순 정렬한 후 이를 시작 시간 기준으로 오름차순 정렬해야 함 --&gt; 맞았습니다 . meeting_time = [] N = int(input()) for i in range(N): meeting_time.append(list(map(int, input().split()))) meeting_num = 1 meeting_time.sort(key = lambda finish_time: (finish_time[1], finish_time[0])) ## 종료 시간을 기준으로 오름차순 정렬한 것을 시작 시간을 기준으로 오름차순 정렬 fir_meeting = meeting_time[0] for i in range(1, N): if meeting_time[i][0] &gt;= fir_meeting[1]: meeting_num += 1 fir_meeting = meeting_time[i] print(meeting_num) . 4 . A $ to$ B . 문제 출처: 백준 16953번 | . - 미로찾기 할 때 출발지점에서 시작하는 것보다 도착지점에서 시작하는 것이 미로 탈출을 더 쉽게 만듦 . - 이런 느낌으로 접근하자 . - A에서 B를 만드는 것 보다 역으로 B에서 A를 만든다고 생각하는 거임 . - 만약 B가 x자리수인데 x자리 숫자가 1이라면 A에서 B를 만드는 과정에서 A가 x-1자리인 순간이 있었고 그 때 마지막 자리에 1을 추가하는 연산을 했음을 알 수 있음 . - 이런식으로 생각하면 만약 B의 x자리의 숫자가 1이 아닌 홀수다 &gt; A 에서 B를 만드는 것이 불가능 . - 만약 B의 x자리의 숫자가 짝수다 &gt; 일단 B를 2로 나누자 . - 위에서 한 것을 반복하면 됨 . - 그리디 알고리즘으로 풀었는데 BFS로도 풀 수 있다고 함 &gt; 나중에 그래프 탐색 문제도 풀어보자 . A, B = map(int, input().split()) num = 1 while B != A: if str(B)[-1] == &#39;1&#39; and B &gt; A: B = int(str(B)[:-1]) num += 1 elif B % 2 == 1 or B &lt; A: num = -1 break else: B = B // 2 num += 1 print(num) . 5 . &#52852;&#46300; &#54633;&#52404; &#45440;&#51060; . 문제 출처: 백준 15903번 | . - 가장 작은 카드 2장을 뽑아서 더한 값으로 초기화 함 . - 또 다시 전체 카드 중에서 가장 작은 카드 2장을 뽑아서 더한 값으로 초기화 함 . - 위를 반복하면 됨 . - 힙(Heap)자료 구조로 풀 수 있다고 함 &gt; 공부하기 . n, m = map(int, input().split()) cards = list(map(int, input().split())) cards.sort() cnt = 0 while cnt &lt; m: cards[0] = cards[1] = cards[0] + cards[1] cards.sort() cnt += 1 print(sum(cards)) . 16 . . &#51221;&#49688;&#47200; &#48143; &#51312;&#54633;&#47200; . &#51060;&#54637; &#44228;&#49688; 2 . 자연수 N과 정수 K가 주어졌을 때 이항 계수 $ binom{N}{K}$를 10,007로 나눈 나머지를 구하는 프로그램을 작성하시오. | . - $ _{n} rm C_{k} ;= ; _{n-1} rm C_{k-1} ;+ ;_{n-1} rm C_{k}$ . - n명 중 k명을 선택하는 방법 = 일단 나를 k명에 포함하고 나머지 n-1명 중 k-1명을 선택하는 방법 + 나를 k명에서 제외하고 나머지 n-1명 중 k명을 선택하는 방법 . - 메모이제이션 활용 . - 아래 코드는 수를 곱하고 나누고 하는 과정에서 오차가 발생함(이유 알 것 같음) . N, K = map(int, input().split()) if K &gt; N - K: K = N - K def binom(n, k): frac = 1 if k == 0: return frac for i in range(k): frac *= (n - i) frac /= (k - i) return frac print(binom(N, K)) . 270288240945436736896419468186285475891156693372573153808127299354545159392842888344379470775469423606583114895222426893312341135200171386904964166401328583914403638232447354301148995510201690344719626632436541851159067180652764129719441081806265387434048424366211327146525860903129335008845962936320 . - 아래코드는 메모이제이션으로 구현했다 . - 계산해보면 알겠지만 $_{1000} rm C_{500}$은 매우$ times 100$ 큰 수이다. 300자리임 . - 그래서 $_{1000} rm C_{500}$를 계산할 때 위와같이 구하면 곱하고 나누는 과정에서 소수점 오차가 발생하고 이는 결과적으로 밑의 코드와 다른 값을 출력하게 된다 . - 메모이제이션을 안 쓴 코드와 쓴 코드로 구한 $_{1000} rm C_{500}$ 값을 비교하면 다른 것을 알 수 있다 . - 아래 코드는 오류 발생(만약 위의 코드가 오차없이 답을 구한다면 똑같이 오류 발생) --&gt; 재귀 깊이에 관한 오류 . - 백준에서 정한 파이썬 재귀 깊이는 1000이다. 즉, 같은 함수를 1000번 이상 호출하면 오류가 난다 . - 그래서 오류가 나지 않으려면 재귀 깊이를 sys.setrecursionlimit()를 통해 바꾸던가 해야함 . - 오류가 발생한 이유를 알았으니 아래 코드를 다시 수정함 . import sys sys.setrecursionlimit(10**6) N, K = map(int, input().split()) if K &gt; N - K: K = N - K binom_list = [[-1] * 501 for _ in range(1001)] def binom(n, k): if binom_list[n][k] != -1: return binom_list[n][k] elif n &lt; k: return 0 elif k == 0: return 1 elif n == 1: return 1 binom_list[n][k] = binom(n-1, k) + binom(n-1, k-1) return binom_list[n][k] print(binom(N, K)) . 270288240945436569515614693625975275496152008446548287007392875106625428705522193898612483924502370165362606085021546104802209750050679917549894219699518475423665484263751733356162464079737887344364574161119497604571044985756287880514600994219426752366915856603136862602484428109296905863799821216320 . - 사실 재귀함수를 사용하지 않고 첫 번째 코드를 수정하는 것으로도 정답을 맞출 수 있다 . - 문제는 /(나누기) 이다 / 대신 //(몫 구하기)를 사용하면 해결된다 . - /(나누기 연산자)는 큰 값을 계산할 때 오차에 취약하다 . - 그래서 // 를 쓰는 것이 좋다. 물론 /와 // 결과가 같을 때 ex) 10 / 2 = 10 // 2 . - 밑의 코드 결과는 메모이제이션을 사용한 코드와 같은 것을 알 수 있다 . N, K = map(int, input().split()) if K &gt; N - K: K = N - K def binom(n, k): frac = 1 for i in range(k): frac *= (n - i) for i in range(k): frac //= (k - i) return frac print(binom(N, K)) . 270288240945436569515614693625975275496152008446548287007392875106625428705522193898612483924502370165362606085021546104802209750050679917549894219699518475423665484263751733356162464079737887344364574161119497604571044985756287880514600994219426752366915856603136862602484428109296905863799821216320 . &#54057;&#53664;&#47532;&#50620; 0&#51032; &#44060;&#49688; . 문제 출처: 백준 1676번 | . - 끝이 0인 수는 어떤 수를 곱하든지 간에 0으로 끝남 . - 2와 5가 곱해지면 10이 됨 &gt; 10이 한 번 곱해질 때마다 0의 개수가 1개 증가함 . - 2의 개수가 5의 개수보다 훨씬 많으므로 사실상 5의 개수는 0의 개수와 동일함 . - 25와 같이 5가 여러번 곱해진 수를 잘 고려해야 함 . N = int(input()) cnt = 0 for i in range(1, N+1): val = i while val % 5 == 0: if val % 5 == 0: val //= 5 cnt += 1 print(cnt) ## input &gt; 25 . 6 . - 간결한 코드 숏코딩에서 찾음 . - N의 범위는 최대 500으로 이를 넘지않는 5의 거듭제곱수는 $5^3$임 . - 즉 N을 5로 나눈 몫을 통해 5의 배수의 개수를 찾음 . - 25의 배수(&lt;125)는 소인수 5의 개수가 2개이므로 N을 25로 나눔으로써 25의 배수를 찾고 마찬가지로 125로 나눠 125 배수의 개수를 찾음 . - 이를 모두 더하면 소인수 5의 총 개수임 . N = int(input()) print(N//5 + N//25 + N//125) ## input &gt; 6 . 6 . &#51312;&#54633; 0&#51032; &#44060;&#49688; . 문제 출처: 백준 2004번 | . - 팩토리얼 0의 개수를 푼 것과 같이 풀면 된다 . - 2와 5의 개수를 세서 2와 5중 더 적은 숫자만큼 끝자리에 0이 생김 . - 바로 for문 사용하면 N, M의 범위 때문에 시간초과임 . N, M = map(int, input().split()) if N - M &lt; M: M = N - M k = j = i = 1 i2 = j2 = k2 = 1 cnt2 = cnt = 0 ## n C m = n! / (n-m)! / m! while 5**i &lt; 2000000001: ## n!의 소인수 5의 개수를 더해줌 cnt += N // (5**i) i += 1 while 5**j &lt; 1000000001: ## m!의 소인수 5의 개수를 빼줌 cnt -= M // (5**j) j += 1 while 5**k &lt; 2000000001: ## (n-m)!의 소인수 5의 개수를 빼줌 cnt -= (N - M) // (5**k) k += 1 while 2**i2 &lt; 2000000001: ## n!의 소인수 2의 개수를 더해줌 cnt2 += N // (2**i2) i2 += 1 while 2**j2 &lt; 1000000001: ## m!의 소인수 2의 개수를 뺴줌 cnt2 -= M // (2**j2) j2 += 1 while 2**k2 &lt; 2000000001: ## (n-m)!의 소인수 2의 개수를 빼줌 cnt2 -= (N - M) // (2**k2) k2 += 1 print(min(cnt, cnt2)) ## 소인수 2와 5의 개수 중 최소값이 끝자리 0의 개수 ## input ## 25 12 . 2 . . &#46041;&#51201; &#44228;&#54925;&#48277; . &#54588;&#48372;&#45208;&#52824; &#54632;&#49688; . 문제가 길어서 출처를 남김: 백준 피보나치 함수 문제 | . - 직접 0과 1이 몇번 출력되는지 계산해도 된다 . - 근데 규칙을 보면 출력되는 횟수의 합이 피보나치 수열을 따름 . - 그리고 0이 출력되는 횟수가 1이 출력되는 횟수보다 1이 더 작다 (fibo(3) 이상 부터) . - fibo(1) = 5이므로 0은 5 // 2 번 1은 5 - 5 // 2번 출력됨 . T = int(input()) def fibo(n): fir_fibo = 0 sec_fibo = 1 for i in range(n): next_fibo = fir_fibo + sec_fibo fir_fibo = sec_fibo sec_fibo = next_fibo return next_fibo for i in range(T): N = int(input()) if N == 0: print(1, 0) elif N == 1: print(0, 1) elif N &gt; 1: fibo_N = fibo(N) print(fibo_N // 2, fibo_N - (fibo_N // 2)) . - 위의 코드는 틀렸다 . - 계산해보니 0출력 횟수와 1출력 횟수 차이는 1이 아니었음 . - fibo(5)의 경우 0은 3번, 1은 5번 출력함 . - fibo(n)일 떄 0은 fibo(n-1)번 1은 fibo(n)번 출력함 (n &gt; 1) . T = int(input()) def fibo(n): if n &lt;= 1: return n fir_fibo = 0 sec_fibo = 1 for i in range(n-1): next_fibo = fir_fibo + sec_fibo fir_fibo = sec_fibo sec_fibo = next_fibo return next_fibo for i in range(T): N = int(input()) if N == 0: print(1, 0) elif N == 1: print(0, 1) elif N &gt; 1: print(fibo(N-1), fibo(N)) . 1 0 . 0 1 . 1 2 . &#49888;&#45208;&#45716; &#54632;&#49688; &#49892;&#54665; . 문제 출처: 백준 9184번 | . w_dict = {(0,0,0):1} def w(a, b, c): if (a, b, c) in w_dict: return w_dict[(a, b, c)] if a &lt;= 0 or b &lt;= 0 or c &lt;= 0: return 1 elif a &gt; 20 or b &gt; 20 or c &gt; 20: return w(20, 20, 20) elif a &lt; b and b &lt; c: w_dict[(a, b, c)] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c) else: w_dict[(a, b, c)] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1) return w_dict[(a, b, c)] while True: A, B, C = map(int, input().split()) if A == B == C == -1: break print(&#39;w(%s, %s, %s) = %s&#39; % (A, B, C, w(A, B, C))) . w(1, 1, 1) = 2 . w(2, 2, 2) = 4 . w(10, 4, 6) = 523 . w(50, 50, 50) = 1048576 . w(-1, 7, 18) = 1 . &#54028;&#46020;&#48152; &#49688;&#50676; . 문제 출처: 백준 9461번 | . - 점화식: $f(n) = f(n-2)+f(n-3)$ . padoban_sequence_dict = {1:1, 2:1, 3:1} def padoban_sequence(n): if n in padoban_sequence_dict: return padoban_sequence_dict[n] padoban_sequence_dict[n] = padoban_sequence(n-3) + padoban_sequence(n-2) return padoban_sequence_dict[n] T = int(input()) for _ in range(T): N = int(input()) print(padoban_sequence(N)) . 3 . 16 . 01&#53440;&#51068; . 문제 출처: 백준 1904번 | . - 점화식 노가다로 구했음 --&gt; 만약 노가다로 찾을 수 없는 문제를 해결해야 한다면... . - 피보나치 수열의 점화식과 동일함 . - 점화식: $f(n) = f(n-1) + f(n-2)$ . 이 코드는 재귀함수를 사용해 top-down으로 구현함 | . - RecursionError 발생 --&gt; 재귀 깊이 초과 . - 그래서 재귀 깊이를 크게 하려고 했는데 조건을 보니 N이 최대 $10^6$ 이다 . - 그래서 그냥 bottom-up방식으로 코드를 짜기로 함 . - 재귀 깊이를 크게 했더니 --&gt; 시간 초과 . top-down 코드 | . tile_dict = {1:1, 2:2} def tile(n): if n in tile_dict: return tile_dict[n] tile_dict[n] = tile(n-1) + tile(n-2) return tile_dict[n] N = int(input()) print((tile(N) % 15746)) . 5 . bottom-up 코드 | . - 메모리 초과 --&gt; 왜? 이유 모름 . N = int(input()) x = 10**6 tile_list = [1, 1, 2] + [0]*(x-2) for i in range(3, N+1): tile_list[i] = tile_list[i-1] + tile_list[i-2] print((tile_list[N] % 15746)) . 5 . - 그래서 다른 방법으로 코드 구현했음 . - 시간 초과(0.75초) --&gt; 왜? . N = int(input()) if N &lt;= 2: print(N) else: fir = 1 sec = 2 for i in range(N-2): next_ = fir + sec fir = sec sec = next_ print(next_ % 15746) . 5 . - 참고: https://m.blog.naver.com/hankrah/221863365092 . - map()함수 사용 . - 메모리 초과 --&gt; append() 때문인 듯 . N = int(input()) def fibonacci(n): fibo = [1, 2] [*map(lambda _: fibo.append(sum(fibo[-2:])), range(2, n))] ## tuple unpacking return fibo[n-1] print(fibonacci(N) % 15746) . 5 . - 아래 코드는 정답임 . - 일단 재귀 함수로 구현한 top-down방식은 시간이 오래걸린다 . - 그러므로 bottom-up 방식을 사용했다 . - 근데 메모리초과가 발생했다 --&gt; 이유가 뭐지?? . - 처음엔 몰랐는데 생각해보니 나는 숫자를 다 계산한 다음에 15746으로 나눈 나머지를 구했다 . - N = 1000000 이라면 백만번째 피보나치 항의 값을 구하는 것인데 수가 얼마나 크나면 겁나 큼 --&gt; 수가 너무 커서 메모리 터짐 . - 그래서 N 번째 피보나치 수열을 구한 뒤에 15746으로 나누지 않고 15746으로 나눈 값들을 더해나갔다 --&gt; 이게 왜 성립함?? . - 편의를 위해 15746대신 7000을 쓰자 . - 다음은 피보나치 수열의 점화식과 같은 형태임 . - 10000 + 20000 = 30000, 20000 + 30000 = 50000 . - 일단 최종 결과인 50000을 7000으로 나눈 나머지는 1000 이다 . - 30000을 7000으로 나눈 나머지는 2000이다. 그러면 20000 + 30000 에서 30000 대신 2000을 써도 식이 성립할까? . - 20000 + 2000 = 22000, 22000을 7000으로 나눈 나머지는 1000 이다 --&gt; 식이 성립함 . - 왜 성립하냐면 50000을 7000으로 나눌 것인데 50000을 20000과 30000으로 쪼갤 수 있음 . - (20000 + 30000) % 7000은 20000을 7000으로 나눈 나머지와 30000을 7000으로 나눈 나머지를 더한 것임 --&gt; 근데 더한 값이 7000보다 클 수 도 있으니 더한 값을 7000으로 또 나눠준다 . - 동그란 케잌으로 생각하자 한 번에 7000만큼의 케잌을 조각내어 퍼갈 수 있음(피자 8등분 하듯이 50000중에 7000만큼 조각 케잌 모양으로 퍼감) . - 케잌크기가 50000이라면 7번 퍼가면 1000이 남는다 . - 근데 50000을 20000과 30000으로 나눈뒤에(50000만 크기의 동그란 케잌을 각각 20000, 30000크기인 반원형 케잌으로 cut) 20000에서 7000만큼 퍼가고 30000에서 7000만큼 퍼가도 된다 . - 20000에서 퍼가고 남은 케잌 조각과 30000에서 퍼가고 남은 케잌 조각을 합쳐서 다시 케잌을 만들고 이 케잌에서 7000을 퍼가면 결과적으로 50000에서 7000을 퍼간것과 동일함 . N = int(input()) x = 10**6 tile_list = [0]*(x+1) tile_list[1] = 1 tile_list[2] = 2 for i in range(3, N+1): tile_list[i] = (tile_list[i-1] + tile_list[i-2]) % 15746 print(tile_list[N]) . 5 . RGB&#44144;&#47532; . 문제 출처: 백준 1149번 | . - N = 10이라면 10개를 최소 비용으로 칠하는 방법은 9개까지 칠하는 방법이 여러개 있음(일단 $dp[9]$라고 하자) + 10번째 칠하는 방법은 3가지 . - $dp[9]+P_{10}$의 최소값이 $dp[10]$이 된다 . - 일반화하면 $min(dp[i-1]+P_i) = dp[i]$ --&gt; 아닌듯 . - 위의 논리는 그리디 알고리즘이다. 항상 최소가 되는 비용을 선택하면 전체적으로도 비용이 최소가 되기를 바라는 것이다 --&gt; 하지만 틀렸다 . - $dp[10]$은 10개까지 색칠하는 여러 방법 =&gt; $min(dp[10]+P_{11}) to dp[11]$ . - $dp[11]$은 최소값 -&gt; 100원이라 하자, 다음으로 싼게 110원 . - $dp[11]+P_{12} to dp[12]$ 이미 $dp[11]$이 최소값 --&gt; 100원을 골라서 $dp[12]$는 200원임 다른건 뭐냐? 1원이 있고 1000원, 근데 1원은 이미 고른 색이어서 못 고름 . - $dp[12]$는 200이 아니라 111원임 $dp[11]$이 최소지만 $dp[12]$는 최소가 아니었음 . - 그럼 남음 방법 뭐임?? . - $dp[11]$을 최소값으로 골랐지만 $dp[12]$가 최소가 아닌 이유는 중복되는 색깔을 선택하지 못하기 때문 . - 그러면 $dp[11]$을 전체의 최소값으로 선택하지 말고 색깔마다 최소값을 고르자 --&gt; 11번째 색이 각각 (빨,초,파)인 경우에 최소값을 구하자 --&gt; 총 3가지가 존재함 . - 이제 $dp[12]$는 어떻게 구하냐면 $dp[11]$과 $P_{12}$의 조합이 총 6가지 존재 . - 6개 중에서 12번째 색이 빨, 파, 초가 존재하는데 각각 2개씩 있다 --&gt; 각각 2개 중에서 더 적은 비용을 고른다 . - 그러면 이제 12번째 색이 빨, 파, 초 일때의 전체 비용의 최소값이 존재 --&gt; $dp[12]$는 색깔별로 존재하니까 총 3개 . - 위와 같은 논리로 마지막 N번째까지 최소비용으로 선택하면 된다 . 처음 짠 코드 | . - 이상한 값을 출력함 . - $dp[i+1][0]$의 의미는 i번째 색깔로 0을 선택했다는 의미임 --&gt; 즉 house_prices[i][0] 이어야함 . - 근데 house_prices가 0이 아니라 $dp[i]$의 값을 0으로 선택했음 --&gt; $dp[i][0]$ 이라면 $dp[i+1]$은 1 or 2이다. 0이 아님 . - 틀렸습니다 . N = int(input()) house_prices = [] for _ in range(N): house_prices.append(list(map(int, input().split()))) dp = [[0]*3 for _ in range(1001)] dp[1] = house_prices[0] for i in range(1, N): dp[i+1][0] = min(dp[i][0] + house_prices[i][1], dp[i][0] + house_prices[i][2]) dp[i+1][1] = min(dp[i][1] + house_prices[i][0], dp[i][1] + house_prices[i][2]) dp[i+1][2] = min(dp[i][2] + house_prices[i][0], dp[i][2] + house_prices[i][1]) print(min(dp[N])) . 102 . 디버깅한 코드 | . - 맞았습니다 . N = int(input()) house_prices = [] for _ in range(N): house_prices.append(list(map(int, input().split()))) dp = [[0]*3 for _ in range(1001)] dp[1] = house_prices[0] for i in range(1, N): dp[i+1][0] = min(dp[i][1] + house_prices[i][0], dp[i][2] + house_prices[i][0]) dp[i+1][1] = min(dp[i][0] + house_prices[i][1], dp[i][2] + house_prices[i][1]) dp[i+1][2] = min(dp[i][0] + house_prices[i][2], dp[i][1] + house_prices[i][2]) print(min(dp[N])) . 96 . &#51221;&#49688; &#49340;&#44033;&#54805; . 문제 출처: 백준 1932번 | . - 위의 RGB 문제와 같은 매커니즘이다 . - 그리디 알고리즘으로 접근하면 주어진 조건하에 항상 최대값을 골라야 하지만 항상 최대값을 고른다고 전체가 최대가 되는 것이 아니다(선택에 제약이 있기 때문: 인접한 곳만 선택 가능) . - 현재 n층 i번째에 위치하고 있다면 n+1층으로 내려갈 때 n+1층의 i번째 or i+1번째만 선택 가능 . - N = 4일 때 $dp[4]$는 무엇일까? . - 4층은 칸이 4개가 존재 --&gt; 이를 인덱스로 생각하면 0~3 . - 그러면 4층의 0번째, 4층의 1번째, 4층의 2번째, 4층의 3번째까지 가는 방법이 각각 여러개가 있을 것이다(대각선상에 존재하는 경우는 1개) . - 그러면 각각 그 중에서 최대값을 선택함 --&gt; 4층의 0번째까지 가는 방법 중 최대값, 4층의 1번째까지 가는 방법 중 최대값 ... --&gt; 총 4개 존재함: 인덱스가 4개 이므로 . - 그 4가지 방법 중 최대값이 4층까지 가는 방법 중 가장 큰 값이다 . N = int(input()) triangle = [] for _ in range(N): triangle.append(list(map(int, input().split()))) dp = [[0]*x for x in range(1,501)] dp[0][0] = triangle[0][0] ## 0층 꼭짓점 ## 1층은 왼쪽 대각선과 오른쪽 대각선만 존재하고 대각선 사이에는 데이터가 없어서 따로 처리했음 if N &gt; 1: dp[1][0] = triangle[1][0] + dp[0][0] ## 왼쪽 대각선 dp[1][1] = triangle[1][1] + dp[0][0] ## 오른쪽 대각선 for i in range(1, N-1): for k in range(1, i+1): dp[i+1][0] = dp[i][0] + triangle[i+1][0] ## 왼쪽 대각선 dp[i+1][k] = max(dp[i][k-1]+triangle[i+1][k] , dp[i][k]+triangle[i+1][k]) ## 대각선 사이 dp[i+1][i+1] = dp[i][i] + triangle[i+1][i+1] ## 오른쪽 대각선 print(max(dp[N-1])) . 30 . - 재채점 되어서 확인했더니 틀렸습니다 &gt; N = 1일 때를 고려하지 않아 indexerror 발생 . - N = 1일 때를 고려하도록 수정했음 &gt; 맞았습니다 . &#44228;&#45800; &#50724;&#47476;&#44592; . 문제 출처: 백준 2579번 | . - 계단은 최대 300개, 칸 마다 점수는 10000이하의 자연수 . - 도착 지점은 무조건 밟아야 한다 . - 그래서 출발 지점부터 시작하지말고 도착 지점부터 시작한다고 생각했음 . - $dp[i]$ --&gt; 마지막으로 밟은 지점이 step의 i번째 인덱스일 때 점수가 최대가 되도록 하는 경로 . - $dp[i] = max(step[i] + dp[i-2] , step[i] + dp[i-1])$ --&gt; 아닌듯, 연속해서 3번 밟을 수 없음. $step[i] + dp[i-2]$는 상관없지만 $step[i] + dp[i-1]$는 상관있음 . - $dp[i] = max(step[i] + step[i-1] + dp[i-3]) , max(step[i] + step[i-2] + dp[i-3])$ . - i번째 계단을 밟는데 i-1번째 계단과 i-2번째 계단을 밟았는지 밟지않았는지가 중요하다 . - 만약 i-1번째와 i-2번째 계단을 둘다 밟았다면 i번째 계단을 밟을 수 없다 . - 만약 i-1번째나 i-2번째 계단 중 한 곳만 밟았다면 i번째 계단을 밟을 수 있다 . - 만약 i-1번째나 i-2번째 계단을 둘다 밟지 않았으면 i번째 계단을 밟을 수 없다 . - 하나하나씩 써보자 . - $dp[0]$ = 도착 지점의 점수 . - $dp[1] = step[1]$ (0번쨰 계단 안밟음) , $step[1] + dp[0]$ (0번째 계단 밟음) . - $dp[2] = step[2] + dp[0]$ (1번쨰 계단 안밟음, 0번째 계단 밟음), $step[2] + dp[1] (= step[1])$ (1번째 계단 밟음, 0번째 계단 안밟음) . - $dp[3] = step[3] + dp[2] (= step[2] + dp[0])$ (2번쨰 계단 밟음, 1번째 계단 안밟음), $step[3] + dp[1] (= step[3] + dp[1] = max(step[1], step[1] + dp[0])$ (2번쨰 계단 안밟음, 1번째 계단 밟음) . - 위에 틀린 부분이 있음, 규칙상 0번째 계단(도착 지점)은 무조건 밟아야 하는데 $dp[1](= step[1])$, $dp[2](= step[2] + step[1])$ 은 0번째 계단을 밟지 않았으므로 제외해야 함 . N = int(input()) step = [] for _ in range(N): step.append(int(input())) step.reverse() ## 도착부터 시작할거임 --&gt; 미로찾기할 때 출발부터 시작안하고 도착부터 시작하듯이 dp = [[0] * 2 for _ in range(300)] ## dp[i][0] =&gt; i-1번째를 밟고 i-2번째를 안밟음, dp[i][1] =&gt; i-1번째를 안밟고 i-2번째를 밟음 dp[0][0] = step[0] dp[0][1] = step[0] if N &gt;= 2: dp[1][0] = step[1] + step[0] dp[1][1] = -(3*10**6) ## 0번째 계단은 무조건 밟아야 하는데 dp[1][1]은 0번째 계단을 안 밟음 --&gt; 그래서 의도적으로 dp[1][1]을 경유하면 절대로 최대값이 나오지 안도록 값을 조정함 if N &gt;= 3: dp[2][0] = -(3*10**6) ## dp[1][1]과 마찬가지임 dp[2][1] = step[2] + step[0] for i in range(3, N): dp[i][0] = step[i] + dp[i-1][1] dp[i][1] = step[i] + max(dp[i-2][0], dp[i-2][1]) print(max(dp[N-1][0], dp[N-1][1], dp[N-2][0], dp[N-2][1])) ## 출발지점을 밟는 길과 밟지 않는 길 중에서 점수 획득이 가장 높은 것을 선택 . 75 . 1&#47196; &#47564;&#46308;&#44592; . 문제 출처: 백준 1463번 | . - 일단 내 생각: 3으로 나누는 것이 수를 1로 만드는데 가장 효과적이라 생각했음 . - 그래서 일단 3으로 나눈다 --&gt; 만약 3으로 나눠지지 않는다면?? . - 만약 1을 뺀 값이 3으로 나눠지면 1을 뺀다 --&gt; 그렇지 않다면 2로 나눈다 --&gt; 만약 2로도 나눠지지 않는다면? . - 1을 뺀다 . - 만약 2의 거듭제곱수이면 2로만 나누기 . - 틀렸습니다 . num = N = int(input()) numbers = [0]*(1+10**6) power_of_2 = {} i = 2 j = 1 while i &lt; 10**6: power_of_2[i] = j j += 1 i *= 2 while True: if num &lt; 2: break if num in power_of_2: numbers[1] = numbers[num] + power_of_2[num] break if num % 3 == 0: now_num = num // 3 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif (num-1) % 3 == 0: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif num % 2 == 0: now_num = num // 2 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue else: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num if num &lt; 2: break print(numbers[1]) . - 만약 number가 소인수로 2와 3만을 가지는 시점이 온다면? . - $number = 2^a cdot 3^b$ . - 1까지 만드려면 2로 a번 나누고 3으로 b번 나누면 됨 --&gt; a+b번 필요함 . - 그냥 모든 경우를 고려한다면? . - N이 주어지면 N을 3으로 나누고 2로 나누고 1을 뺀다 . - 각각에 대해서 또 다시 3으로 나누고 2로 나누고 1을 뺀다 . - 이를 1이 될 때까지 반복 . - 음... 어떻게 함? 재귀로? . - 디버깅 중... . - 근데 위와 같이 하면 $N = 10^6$일 때 연산횟수가 커서 시간초과가 발생할 것 같음 . ## 시간초과 ## N = int(input()) numbers = [0]*(1+10**6) def divide3(x): if x == 1: return numbers[1] if x % 3 == 0: if numbers[x // 3] == 0: numbers[x // 3] += (numbers[x] + 1) else: numbers[x // 3] = min(numbers[x] + 1, numbers[x // 3]) x //= 3 divide3(x) if x % 2 == 0: divide2(x) sub1(x) def divide2(y): if y == 1: return numbers[1] if y % 2 == 0: if numbers[y // 2] == 0: numbers[y // 2] += (numbers[y] + 1) else: numbers[y // 2] = min(numbers[y] + 1, numbers[y // 2]) y //= 2 divide2(y) if y % 3 == 0: divide3(y) sub1(y) def sub1(z): if z == 1: return numbers[1] if z &gt; 1: if numbers[z-1] == 0: numbers[z-1] += (numbers[z] + 1) else: numbers[z-1] = min(numbers[z] + 1, numbers[z-1]) z -= 1 if z % 3 == 0: divide3(z) if z % 2 == 0: divide2(z) sub1(z) divide3(N) divide2(N) sub1(N) print(numbers[1]) . - 굳이 1을 빼야할까? . - 2나 3으로 나눠지지 않을 때만 1을 빼는 것이 좋을 것 같음 . - 하지만 10에 경우 위와 같이 하면 10 - 5 - 4 - 2 - 1 . - 정답은 10 - 9 - 3 - 1 . - 만약 1을 뺀 값이 $2^a cdot 3^b$ 꼴이라면 1을 빼자 . 이것도 틀리면 질문검색 볼거임 | . - 5%에서 틀렸습니다.... . num = N = int(input()) numbers = [0]*(1+10**6) mul_2_3 = {} power_of_2 = {} i = 2 j = 1 while i &lt; 10**6: power_of_2[i] = j j += 1 i *= 2 power_of_3 = {} i = 3 j = 1 while i &lt; 10**6: power_of_3[i] = j j += 1 i *= 3 for i in range(1,13): for j in range(1,20): if list(power_of_3.keys())[i-1] * list(power_of_2.keys())[j-1] &lt; 10**6: mul_2_3[list(power_of_3.keys())[i-1] * list(power_of_2.keys())[j-1]] = i+j mul_2_3.update(power_of_2) mul_2_3.update(power_of_3) while True: if num &lt; 2: break if num in mul_2_3: numbers[1] = numbers[num] + mul_2_3[num] break if num % 3 == 0: now_num = num // 3 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif (num-1) in mul_2_3: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif num % 2 == 0: now_num = num // 2 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue else: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num if num &lt; 2: break print(numbers[1]) . - 질문검색 보고 옴 &gt; 모든 경우를 탐색해 보자 . - 맞았습니다!!! . - 위에서는 어렵게 생각했는지 모든 경우를 탐색하는 코드를 각각의 경우에 대해서 설계했는데 밑에서는 i의 값을 1씩 줄여나가면서 3가지 경우에 대해 탐색하도록 코드를 구성했음 . i = N = int(input()) dp = [0]*(1+10**6) while i &gt; 1: if i % 3 == 0: if dp[i // 3] == 0: dp[i // 3] += (1 + dp[i]) else: dp[i // 3] = min(dp[i] + 1, dp[i // 3]) if i % 2 == 0: if dp[i // 2] == 0: dp[i // 2] += (1 + dp[i]) else: dp[i // 2] = min(dp[i] + 1, dp[i // 2]) if dp[i-1] == 0: dp[i-1] += (1 + dp[i]) else: dp[i-1] = min(dp[i] + 1, dp[i-1]) i -= 1 print(dp[1]) . 4 . &#49772;&#50868; &#44228;&#45800; &#49688; . 문제 출처: 백준10844번 | . - N = 1일 때 9, N = 2일 때 17 . - N = 3일 때 32이었음(내가 손수 구함) . - 다음과 같은 규칙이 바로 생각났음 &gt; $dp[i+1] = 2 times dp[i] - 2^{i-1}$ . - 위 규칙에 따르면 N = 4일 때 60인데 손수 구할 용기가 안나서 검증없이 바로 코드로 구현함 . - ^^ 틀렸습니다 . - i가 어느 정도 커지면 음수가 된다 . - 규칙을 바꿔봄 &gt; $dp[i+1] = 2 times dp[i] - i$ . - 일단 위의 규칙은 음수가 될 일은 절대 없음 . - 위 규칙에 따르면 N = 4일 때 61인데 손수 구할 용기가 안나서 검증없이 바로 코드로 구현함 . - 틀렸습니다 ^^ . - 이제 N = 4일 때 dp를 구해보자 &gt; 손수 구해보니 N = 4일 때 61임 !!!! &gt; 규칙이 틀렸나? . - 일단 직관적으로 생각하면 $dp[i] = 2^{i-1}*9$ . - 왜냐하면 옆 자릿수와 차이가 1이여야 하므로 +1 or -1임 즉 2가지 경우이므로 2를 계속 곱하고 숫자가 1~9까지 9개이므로 9를 곱합 . - 하지만 9에 경우 -1은 가능하지만 +1은 없음 또 0에 경우 +1은 가능하지만 -1은 존재하지 않는다 &gt; 차이만큼 빼줘야함 . - 위에 기반하면 N = 1: 9 - 0, N = 2: 18 - 1, N = 3: 36 - 4, N = 4: 72 - 11 &gt; 규칙이 보이지 않음 . - 그리고 또 2자리는 1자리에 기반하여 만들고 3자리는 2자리에 기반하여 만듦 ex) 23 --&gt; 232 or 234, 232 --&gt; 2321 or 2323 . - N = 5일 때 118인지 확인할까? . N = int(input()) dp = [0]*101 dp[1] = 9 for i in range(1, 100): dp[i+1] = (2*dp[i] - i) % 1000000000 print(dp[N]) . - 질문검색 보고옴 . - 코드 대충 봐보니 i-1번째에 기반하여 i번째를 만드는 것 같았음 . - 끝자리가 0이나 9인 경우에는 다음 자리에 올 수 있는 숫자가 1개 뿐이므로 이를 고려하여 코드를 구성하자 . - 아니면 끝자리가 0~9 까지 10개이므로 배열을 10칸으로 만들자 . - $dp[i][j]$의 의미는 자릿수가 i인데 끝자리가 j인 경우임 . N = int(input()) dp = [[0]*10 for _ in range(101)] for k in range(1, 10): dp[1][k] = 1 for i in range(1, 100): for j in range(10): if j == 0: dp[i+1][j] = dp[i][j+1] % 1000000000 elif j == 9: dp[i+1][j] = dp[i][j-1] % 1000000000 else: dp[i+1][j] = (dp[i][j+1] + dp[i][j-1]) % 1000000000 print(sum(dp[N]) % 1000000000) . 116 . - 흐음 질문검색에서 아이디어를 가져온거라 정답을 맞춘게 맞춘게 아님 . - 옛날이었으면 풀었을 듯... 요새 안하다보니 감이 떨어짐 . &#54252;&#46020;&#51452; &#49884;&#49885; . 문제 출처: 백준 2156번 | . - 문제를 보자마자 전에 풀었던 계단오르기와 유사하다고 생각이 들었음 . - $dp[i]$는 두 종류가 있음 &gt; i-1번째 와인을 마신 경우와 i-1번째 와인을 마시지 않은 경우 &gt; 두 경우 중 최대값이 $dp[i]$임 . - $dp[i][1] = wines[i] + dp[i-1][0]$ . - $dp[i][0] = max(wines[i] + dp[i-2][0], wines[i] + dp[i-2][1], wines[i] + dp[i-3][1])$ . - $dp[i][0]$은 i-1번째 와인을 마시지 않은 경우 . - $dp[i][1]$는 i-1번째 와인을 마신 경우 . N = int(input()) dp = [[0] * 2 for __ in range(10001)] wines = [0] for _ in range(N): wine = int(input()) wines.append(wine) dp[1][0] = wines[1] dp[1][1] = wines[1] + wines[0] if N &gt; 1: dp[2][0] = wines[2] dp[2][1] = wines[2] + wines[1] for i in range(3, N+1): dp[i][0] = max(wines[i] + dp[i-2][0], wines[i] + dp[i-2][1], wines[i] + dp[i-3][1]) dp[i][1] = wines[i] + dp[i-1][0] print(max(dp[N][0], dp[N][1], dp[N-1][1])) . 33 . &#44032;&#51109; &#44596; &#51613;&#44032;&#54616;&#45716; &#48512;&#48516; &#49688;&#50676; . 문제 출처: 백준 11053번 | . - 모르겠다 공부 ㄱㄱ . - 공부하고 왔음 . - 수열A: 10, 20, 30, 11, 12, 13, 14, 40, 15, 16 이런 수열이 있다고 해보자 . - 위에서 다룬 수열을 A라고 해보자 . - A[6] = 13, dp[6] = 4이다. dp[6] = 4라는 뜻은 A[6]이 마지막 원소이고 만약 수열A가 A[5]까지만 존재했다면 가장 긴 증가하는 부분 수열의 길이는 3이라는 의미이다 . - A[6]을 추가하는데 되도록이면 증가하는 부분 수열의 길이가 크면 좋음 &gt; A[6]이 마지막 원소가 될 수 있는 여러개의 증가하는 부분 수열 중에서 길이가 가장 긴 것에 A[6]을 추가해야 함 . - 즉 dp[1]에서 dp[5]중에서 가장 큰 값에다 A[6]을 추가하여 새로운 dp[6]을 만듦 &gt; dp[i]는 i번째 인덱스 값을 수열의 마지막 원소로 가지는 증가하는 부분 수열 중 가장 길이가 긴 것 . - 가장 긴 증가하는 부분 수열 점화식: $dp[n] = max(dp[i], dp[j], dots, dp[k]) + 1, quad (A[n] &gt; A[i], A[j], dots,A[k]])$ . N = int(input()) dp = [0] * 1001 data = list(map(int, input().split())) arr = [0] + data for i in range(1, N+1): for j in range(i): if arr[i] &gt; arr[j]: dp[i] = max(dp[j] + 1, dp[i]) print(max(dp)) . 5 . &#44032;&#51109; &#44596; &#48148;&#51060;&#53664;&#45769; &#48512;&#48516; &#49688;&#50676; . 문제 출처: 백준 11054번 | . - 질문 검색에서 아이디어 참고함 . - 증가하는 부분 수열 + 감소하는 부분 수열 - 1(겹치는 부분)의 최댓값을 구하자 . - dp_up[n]은 n를 마지막 원소로 가지는 증가하는 부분 수열 중 길이가 가장 긴 것 . - dp_down[n]은 n를 첫번째 원소로 가지는 감소하는 부분 수열 중 길이가 가장 긴 것 . N = int(input()) dp_up = [0] * 1001 dp_down = [1] * 1001 data = list(map(int, input().split())) arr = [0] + data ## 가징 긴 바이토닉 부분 수열 for i in range(1, N+1): for j in range(i): if arr[i] &gt; arr[j]: dp_up[i] = max(dp_up[j] + 1, dp_up[i]) for i in range(N, 0, -1): for j in range(N, i, -1): if arr[i] &gt; arr[j]: dp_down[i] = max(dp_down[j] + 1, dp_down[i]) print(max(list(map(lambda x, y: x+y, dp_up, dp_down)))-1) . 7 . - 위에서 사용한 lambda 함수 간단히 참고 . a = [1, 2, 3, 4, 5] b = [10, 1 ,2, 3, 4] print(max(list(map(lambda x, y: x+y, a, b)))-1) . 10 . - 서로 동일한 index위치에 있는 값을 더한 후 최대값 - 1을 출력 . - 리스트 길이가 다르다면? . a = [1, 2, 3, 4, 5] b = [1 ,2, 10] print(max(list(map(lambda x, y: x+y, a, b)))-1) . 12 . - b는 길이가 3이어서 a의 4와 5 원소는 고려되지 않음 . &#51204;&#44611;&#51460; . 문제 출처: 백준 2565번 | . - A와 B는 연결되어 있으므로 세트임 . - 우선 A, B에 대해 오름차순 정렬을 함(A, B 순서 바뀌어도 ok) &gt; 전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨지므로 . - dp[n]은 n번째 전깃줄이 마지막에 위치하는 LIS임 . - n번째의 전깃줄은 n-1번째 전깃줄에 대해 A, B 각각 숫자가 커야함 . - dp 최대값을 구한 후 N에서 빼면 제거해야 할 전깃줄의 개수임 . N = int(input()) arr = [[0, 0]] dp = [0] * 101 for _ in range(N): arr.append(list(map(int, input().split()))) arr1 = sorted(arr, key = lambda x: (x[0], x[1])) for i in range(1, N+1): for j in range(i): if arr1[i][0] &gt; arr1[j][0] and arr1[i][1]&gt; arr1[j][1]: dp[i] = max(dp[j] + 1, dp[i]) print(N - max(dp)) . 3 . &#54588;&#48372;&#45208;&#52824; &#49688; 2 . 문제 출처: 백준 2748번 | . - n은 90보다 작거나 같은 자연수 . N = int(input()) first_fibo = 0 second_fibo = 1 for i in range(N): next_fibo = first_fibo + second_fibo first_fibo = second_fibo second_fibo = next_fibo print(first_fibo) . 55 . &#54588;&#48372;&#45208;&#52824; &#49688; 3 . 문제 출처: 백준 2749번 | . - n은 1,000,000,000,000,000,000보다 작거나 같은 자연수 . - 아래와 같은 bottom-up 방식은 시간초과임 . N = int(input()) first_fibo = 0 second_fibo = 1 for i in range(N): next_fibo = (first_fibo + second_fibo) % 1000000 first_fibo = second_fibo % 1000000 second_fibo = next_fibo % 1000000 print(first_fibo) . 228875 . - 곰곰이 생각해보니 n이 최대 100경이라 for문 써도 컴퓨터 터지고 배열로 만들어도 컴퓨터 터짐 . - 피보나치 수열의 일반항이 생각나서 검색해봄 . - 근데 n이 너무 커서 overflow 때문에 불가능 . - 위의 방법을 사용하지 않으면 어떻게 푸는지 모르겠어서 질문 검색을 보니 피사노 주기 를 이용하여 푼다고 한다 . - 참고: 피보나치 수를 구하는 여러가지 방법 . - 아무튼 그래서 피사노 주기를 통해서 문제를 해결함 . N = int(input()) m = 10**6 P = 15 * (10**5) M = N % P fibo = {0:0, 1:1} for i in range(M): fibo[i+2] = (fibo[i] % m + fibo[i+1] % m) % m print(fibo[M]) . 228875 . &#54588;&#48372;&#45208;&#52824; &#49688; 4 . 문제 출처: 백준 10826번 | . - n은 10000보다 작거나 같은 자연수 . N = int(input()) dp = [0] * 10001 dp[1] = 1 for i in range(N-1): dp[i+2] = dp[i] + dp[i+1] print(dp[N]) . 55 . LCS . 문제 출처: 백준 9251번 | . - 머리가 멍청해짐 &gt; 어려워서 공부하고 옴 . - a와 b 두 문자열이 있음 . - 두 문자열의 길이가 각각 n과 m이라고 해보자 . - 만약 a[ i ]와 b[ j ] 문자가 서로 같다면 dp[ i ][ j ] = dp[ i-1 ][ j-1 ]+1과 동일함 . - 만약 문자가 서로 다르다면 dp[ i ][ j ] = max(dp[ i-1 ][ j ], dp[ i ][ j-1 ]) . a = input() b = input() dp = [[0] * (len(b)+1) for _ in range(len(a)+1)] for i in range(1, len(a)+1): for j in range(1, len(b)+1): if a[i-1] == b[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i][j-1], dp[i-1][j]) print(dp[len(a)][len(b)]) ## input ## ACAYKP ## CAPCAK . 4 . &#50672;&#49549;&#54633; . 문제 출처: 백준 1912번 | . &#54217;&#48276;&#54620; &#48176;&#45229; . 문제 출처: 백준 12865번 | . . &#44396;&#54788; . &#48727;&#47932; . 문제 출처: 백준 14719번 | . - $n$번째 블록의 높이를 $x$라 해보자 . - 만약 $x$이상인 높이 $y$가 $n+α$번째에 있다면 그 사이에 빗물을 $x$높이 까지 담을 수 있음 . - 만약 $x$이상인 높이가 없다면?? &gt; 탐색하는 방향을 거꾸로 하면 된다(처음 $ to$ 끝 대신 끝 $ to$ 처음) . - 그렇게 되면 처음에 탐색했을 때와 반대로 되므로 똑같이 크거나 같은 블록을 찾아 나가면 된다 . - 처음 $ to$ 끝 탐색과 끝 $ to$ 처음 탐색을 할 때 서로 겹치는 부분이 없을 것 같지만 높이가 같은 경우에는 겹치게 되므로 이에 대해서는 한번만 고려하자 . - 위에 설명만 들으면 어려울 것 같으니 예를 들어보자 . - 시작 &gt; 끝 . - 블록의 높이가 3 1 2 3 3 1 1 2 라 하면 처음부터 탐색하므로 시작 블록 높이는 3이다 . - 3보다 크거나 같은 블록을 찾아 헤매다니니 4번째에 3이 존재함 &gt; 빗물을 3만큼 담을 수 있음 . - 이제 블록의 기준이 바뀜 (3 &gt; 3) . - 이제 또 다시 3보다 크거나 같은 블록을 헤매다니자 &gt; 3이 존재함 &gt; 빗물을 0만큼 담음 . - 3보다 큰 블록이 없음 &gt; 하지만 그렇다고 빗물을 못담는것이 아니다 3과 2사이에 빗물을 2만큼 담을 수 있다 &gt; 이런 경우를 고려하기 위해 이제 탐색 방향을 바꾸자 . - 끝 &gt; 시작 . - 시작 블록 높이는 2이다 . - 2보다 크거나 같은 블록은 3가 있음 &gt; 빗물을 2만큼 담음 . - 이제 블록의 높이 기준이 3으로 바뀜 . - 3보다 크거나 같은 블록이 바로 앞에 있음 &gt; 빗물을 0만큼 담음 . - 이제 다시 3보다 크거나 같은 블록을 찾자 &gt; 마지막 블록의 높이가 3이다 &gt; 빗물을 3만큼 담음 . - 결과를 보자 . - 두가지 경우를 더하면 결과로 8이 나오지만 사실 정답은 5인데 왜냐하면 3 1 2 3 부분이 두 가지 모두에서 고려되어 빗물이 추가로 더해졌기 때문이다 . - 이렇기에 시작 &gt; 끝 탐색에서 크거나 같은 경우를 고려했다면 끝 &gt; 시작 탐색에서는 큰 경우만 고려해야 함 . - 만약 끝 &gt; 시작 탐색에서 크거나 같은 경우를 고려했다면 시작 &gt; 끝 탐색에서는 큰 경우만 고려 . h, w = map(int, input().split()) blocks = list(map(int, input().split())) ## 시작 &gt; 끝 탐색 start1 = blocks[0] idx1 = 0 water1 = 0 for i in range(1, w): if blocks[i] &gt;= start1: for j in range(idx1+1, i): water1 += start1 - blocks[j] idx1 = i start1 = blocks[i] ## 끝 &gt; 시작 탐색 blocks1 = blocks.reverse() start2 = blocks[0] idx2 = 0 water2 = 0 for i in range(1, w): if blocks[i] &gt; start2: for j in range(idx2+1, i): water2 += start2 - blocks[j] idx2 = i start2 = blocks[i] print(water1 + water2) . 5 . . &#49828;&#53469;(stack) . &#49828;&#53469; . 문제 출처: 백준 10828번 | . - 스택(stack)은 선입후출 구조임 &gt; 한쪽이 막힌 원기둥에 공을 넣는다고 생각하자 &gt; 처음 넣은 공을 빼려면 이제껏 넣어던 공을 모두 빼야 빼낼 수 있음 . N = int(input()) stack = [] def push(num): stack.append() def pop(): if stack: print(stack.pop()) else: print(-1) def size(): print(len(stack)) def empty(): if stack: print(0) else: print(1) def top(): if stack: print(stack[-1]) else: print(-1) orders = [] for _ in range(N): orders.append(input().split()) for i in range(N): if orders[i][0] == &#39;push&#39;: x = str(orders[i][-1]) xx = &#39;push&#39; + &#39;(&#39; + x + &#39;)&#39; xxx = &#39;&#39;.join(xx) eval(xxx) else: y = orders[i][0] + &#39;()&#39; eval(y) . 2 2 0 2 1 -1 0 1 -1 0 3 . &#51228;&#47196; . 문제 출처: 백준 10773번 | . - 스택 구조를 통해 해결하면 된다 . K = int(input()) stack = [] for _ in range(K): num = int(input()) if num == 0: stack.pop() else: stack.append(num) print(sum(stack)) . 0 . &#44292;&#54840; . 문제 출처: 백준 9012번 | . - &#39;(&#39;가 입력되면 스택에 추가하고 &#39;)&#39;가 입력되면 제거하는 방식으로 오류가 발생하면 잘못된 문자열임을 판단하자 . T = int(input()) for _ in range(T): string = input() stack = [] cnt = 0 for i in range(len(string)): if string[i] == &#39;(&#39;: stack.append(&#39;(&#39;) elif string[i] == &#39;)&#39;: ## else:로 하면 틀림 &gt; 이유 모름 if stack: stack.pop() else: cnt = -1 break if not stack and cnt == 0: print(&quot;YES&quot;) else: print(&quot;NO&quot;) . YES . &#44512;&#54805;&#51105;&#55180; &#49464;&#49345; . 문제출처: 백준 4949번 | . - 괄호 문제에서 대괄호가 추가된 경우임 . - stack에 &#39;(&#39;와 &#39;[&#39;를 추가하고 &#39;)&#39;과 &#39;]&#39;이 입력되었을 때 stack.pop()을 하는데 서로 짝이 맞지 않으면 잘못된 문자열 . - &#39;(&#39;, &#39;)&#39;와 &#39;[&#39;, &#39;]&#39; 각각의 쌍이 맞지 않아도 잘못된 문자열 . - &#39;(&#39;다음에 &#39;)&quot;이 와야하고 &#39;[&#39;다음에 &#39;]&#39;이 와야함 &gt; 이를 지키지 않아도 잘못된 문자열 . - input 대신에 sys.stdin.readline을 사용하면 틀림 &gt; 이유 모름 . while True: string = input() stack = [] cnt = 0 num1 = 0 num2 = 0 if string == &#39;.&#39;: break else: for i in string: if i == &#39;(&#39;: stack.append(&#39;(&#39;) num1 += 1 elif i == &#39;)&#39;: num1 -= 1 if num1 &lt; 0: cnt = -1 if stack: tmp = stack.pop() if tmp != &#39;(&#39;: cnt = -1 break elif i == &#39;[&#39;: stack.append(&#39;[&#39;) num2 += 1 elif i == &#39;]&#39;: num2 -= 1 if num2 &lt; 0: cnt = -1 if stack: tmp = stack.pop() if tmp != &#39;[&#39;: cnt = -1 break if num1 == 0 and num2 == 0 and cnt != -1: print(&quot;yes&quot;) else: print(&quot;no&quot;) . yes . yes . no . no . no . yes . yes . &#49828;&#53469; &#49688;&#50676; . 문제 출처: 백준 1874번 | . - stack에 숫자를 1부터 n까지 push함 . - 그러다가 input으로 받은 nums 리스트의 마지막 원소와 stack의 마지막 원소가 동일하면 pop함 . - pop한 숫자의 배열과 기존의 input으로 받은 nums 리스트의 배열과 동일하면 성공적임 . - 만약 그렇지 않다면 동일한 배열로 만드는 것이 불가능하므로 &#39;NO&#39;를 출력 &gt; 불가능한 경우는 다음과 같음 . - push와 pop의 개수가 다름 &gt; push는 n번 하지만 동일한 패턴의 배열로 만드는게 불가능하여 pop을 실행 못함 &gt; pop의 개수가 적음 . n = int(input()) nums = [] stack = [] print_ = [] for _ in range(n): nums.append(int(input())) nums.reverse() i = 1 cnt = 0 while i &lt;= n: stack.append(i) print_.append(&#39;+&#39;) cnt += 1 if stack and nums: while stack[-1] == nums[-1]: if stack[-1] == nums[-1]: stack.pop() nums.pop() print_.append(&#39;-&#39;) cnt -= 1 if not stack or not nums: break i += 1 if cnt == 0: for j in print_: print(j) else: print(&#39;NO&#39;) . + + + + - - + + - + + - - - - - . &#50724;&#53360;&#49688; . 문제 출처: 백준 17298번 | . - 마지막 인덱스부터 처음 인덱스 순서로 진행할 거임 i(N-1 $ to$ 0) . - 일단 num.pop()한 값을 tmp에 저장 &gt; tmp는 num의 마지막 원소임 . - 그리고 tmp를 stack에 append한다 . - stack은 num[i]의 오큰수를 찾는 역할임 &gt; stack에는 num의 마지막 원소부터 처음 원소까지 append된다 . - 스택 구조 특징(후입선출)상 stack[-1]은 num[i]의 바로 오른쪽이며 stack[0]은 num[i]와 오른쪽으로 가장 멀리 떨어진 원소임 . - 그래서 stack으로 어떻게 오큰수 찾음? &gt; 일단 tmp &gt; num[i]이면 num[i]의 오큰수는 tmp임 . - 만약 tmp &lt;= num[i]라면 stack.pop()과 비교함 . - 만약 stack.pop() &gt; num[i]라면 num[i]의 오큰수는 stack.pop()임 . - 만약 stack.pop() &lt;= num[i]라면 기존의 stack.pop()을 버리고 다시 stack.pop()한 값과 비교 &gt; stack의 모든 원소와 비교해도 오큰수가 없으면 -1 . - 질문검색 참고해서 풀었음 . N = int(input()) num = list(map(int, input().split())) arr = [-1] * N stack = [] for i in range(N-2, -1, -1): tmp = num.pop() ## num[i]와 num[i+1](=tmp)을 비교하기 위한 수단 ## for문을 반복할 때 마다 num의 마지막 원소가 pop되어짐 &gt; 총 (N-2-0)+1개 pop stack.append(tmp) ## num의 마지막원소부터 계속하여 추가함 while stack: if num[i] &lt; tmp: arr[i] = tmp break else: val = stack.pop() if num[i] &lt; val: arr[i] = val stack.append(val) ## num[i]와 비교를 위해 val를 pop했는데 num[i] &lt; val이어서 아직 val은 쓸모 있음 &gt; 그러므로 다시 val을 append break else: ## num[i] &gt;= stack.pop() &gt; num[i]의 오른쪽 숫자중에서 가장 왼쪽에 있는 수 부터 살펴봄 &gt; arr[i] = -1 ## 그런데 num[i]보다 더 작으므로 앞으로 쓸모가 없음(val을 다시 append하지 않음) &gt; 왜냐면 앞으로 탐색할 것은 num[i]의 왼쪽에 있는 수 인데 예로 num[x]라 하자 ## stack.pop()이 num[x]의 오큰수하 하자 &gt; 그런데 stack.pop() &gt;= num[i]이므로 num[x]의 오큰수는 num[i]가 됨 &gt; 그러므로 stack.pop()은 이제 무쓸모 print(*arr) ## input &gt; N = 4, num = 9 5 4 8 . -1 8 8 -1 . . &#53328;(queue) . &#53328; 2 . 문제 출처: 백준 18258번 | . - 큐(queue)는 선입선출(= 후입선출) 구조임 . - 양쪽이 뚫린 원기둥에서 한쪽 입구에 push하면 반대쪽 입구에서 pop된다 . - collections의 deque를 import하여 사용한다 . - 코드를 보면 input == &#39;pop&#39;이 아니라 input[:2] == &#39;po&#39;라고 한것을 볼 수 있음 &gt; 왜 그럼? 그냥 input_ == &#39;pop&#39;하지.. . - input이 정확히 &#39;pop&#39;이 아니라 개행문자가 포함되어 &#39;pop &#39;이면 실행이 안됨(아님 말고) &gt; 그래서 input_[:2] == &#39;po&#39;라고 함 . from collections import deque N = int(input()) queue = deque() ## queue 생성 for _ in range(N): input_ = input() if input_[:2] == &#39;pu&#39;: data = int(input_.split()[1]) queue.append(data) elif input_[:2] == &#39;po&#39;: if queue: print(queue.popleft()) else: print(-1) elif input_[:2] == &#39;si&#39;: print(len(queue)) elif input_[:2] == &#39;em&#39;: if queue: print(0) else: print(1) elif input_[:2] == &#39;fr&#39;: if queue: print(queue[0]) else: print(-1) elif input_[:2] == &#39;ba&#39;: if queue: print(queue[-1]) else: print(-1) ## input ## 15 ## push 1 ## push 2 ## front ## back ## size ## empty ## pop ## pop ## pop ## size ## empty ## pop ## push 3 ## empty ## front . 1 . 2 . 2 . 0 . 1 . 2 . -1 . 0 . 1 . -1 . 0 . 3 . &#52852;&#46300; 2 . 문제 출처: 백준 2164번 | . - 큐(queue) 자료구조를 활용하면 됨 . from collections import deque N = int(input()) queue = deque(list(range(1, N+1))) while len(queue) &gt; 1: queue.popleft() ## 맨 앞에 있는 원소를 버림 queue.append(queue.popleft()) ## 맨 앞에 있는 원소를 맨 뒤로 보냄 print(queue[0]) ## input &gt; 6 . 4 . &#50836;&#49464;&#54392;&#49828; &#47928;&#51228; 0 . 문제 출처: 백준 11866번 | . - 1~n번째 값을 줄세우고 k번째 이전의 값을 마지막 인덱스에 이어붙인 후 k번째 값을 제거함 &gt; 이를 모든 원소를 제거할 때까지 반복함 . - 헷갈리니 예시를 들어보자 . - 1 2 3 4 5 6 7 이 있고 3번째 데이터를 제거한다고 하자 . - (1 2) 3(제거) 4 5 6 7 &gt; 3번째 앞의 데이터(= 1, 2)를 4 5 6 7 뒤에 이어 붙이고 3을 제거함 &gt; queue.append(queue.popleft())를 k-1번 반복하고 k번째는 queue.popleft()하면 된다 . - (4 5) 6(제거) 7 1 2 &gt; 또 다시 3번째 앞의 데이터(= 4, 5)를 7 1 2 뒤에 이어 붙이고 6을 제거함 . - 이를 계속하면 된다 + 남은 원소를 m개라 할 때 m이 3보다 작어지면 (3 % m - 1) 번째 인덱스의 값을 제거하고 앞의 데이터들을 뒤에 이어붙이면 됨 . from collections import deque N, K = map(int, input().split()) queue = deque(list(range(1, N+1))) death_seq = [] while queue: ## queue에 원소가 있을때까지 if len(queue) &gt;= K: for _ in range(K-1): queue.append(queue.popleft()) ## k번째 앞의 데이터를 맨 뒤에 이어 붙임 death_seq.append(queue.popleft()) ## k번째 데이터 삭제^^ else: m = (K % len(queue)) - 1 if m == -1: ## 만약 -1이면 마지막 인덱스를 의미하므로 m = len(queue) - 1로 바꿈 m = len(queue) - 1 for __ in range(m): queue.append(queue.popleft()) ## k번째 앞의 데이터를 맨 뒤에 이어 붙임 death_seq.append(queue.popleft()) ## k번째 데이터 삭제^^ print(&#39;&lt;&#39;, end = &#39;&#39;) ## death_seq 출력 for k in range(N): if k != (N-1): print(str(death_seq[k]) + &#39;, &#39;, end = &#39;&#39;) else: print(str(death_seq[k]), end = &#39;&#39;) print(&#39;&gt;&#39;, end = &#39;&#39;) ## input &gt; 7 3 . &lt;3, 6, 2, 7, 5, 1, 4&gt; . &#54532;&#47536;&#53552; &#53328; . 문제 출처: 백준 1966번 | . - 중요도가 같더라도 순서에 따라 이름이 다르므로 큐 구조를 2개 만듦 &gt; 하나는 중요도 담는 용도 나머지는 이름 저장 용도 . - max함수를 통해 인쇄조건을 판단 &gt; 인쇄해도 되면 중요도 큐와 이름 큐에서 각각 popleft()함 &gt; cnt값에 +1 &gt; 만약 우리가 궁금해한 인덱스이면 cnt 출력 . - 인쇄조건에 맞지 않으면 popleft()한 중요도를 다시 append하고 이름 담는 큐에서도 popleft() 후 apppend한다 . from collections import deque T = int(input()) for _ in range(T): N, M = map(int, input().split()) queue1 = deque(list(map(int, input().split()))) queue2 = deque([&#39;x_&#39; + str(i) for i in range(N)]) cnt = 1 while queue1: tmp1 = queue1.popleft() if queue1: if tmp1 &gt;= max(queue1): tmp2 = queue2.popleft() if tmp2[2:] == str(M): print(cnt) break cnt += 1 else: queue1.append(tmp1) queue2.append(queue2.popleft()) else: print(cnt) ## input ## 3 ## 1 0 ## 5 ## 4 2 ## 1 2 3 4 ## 6 0 ## 1 1 9 1 1 1 . 1 . 2 . 5 . - 위 코드에서 아쉬운 점은 중요도와 이름 정보를 담기 위해 2가지 queue를 만들었다는 것임 . - 이름 정보는 인덱스임 &gt; 중요도와 인덱스를 한번에 queue에 담고 싶음 &gt; enumerate 함수를 사용해서 할 수 있음 . from collections import deque T = int(input()) for _ in range(T): N, M = map(int, input().split()) queue = deque([*enumerate(map(int, input().split()))]) ## 인덱스와 중요도를 하나의 queue에 담음 cnt = 1 while queue: tmp = queue.popleft() if queue: if tmp[1] &gt;= max(list(zip(*queue))[1]): ## zip 함수를 통해 중요도만 추출하여 최대값과 비교 if tmp[0] == M: print(cnt) break cnt += 1 else: queue.append(tmp) else: print(cnt) ## input은 위와 동일함 . 1 . 2 . 5 . . &#45937;(deque) . &#45937; . 문제 출처: 백준 10866번 | . - 덱은 스택과 큐를 합친 구조 &gt; 양쪽으로 넣고(append) 빼기(pop) 가능함 . from collections import deque N = int(input()) deque = deque() for _ in range(N): input_ = input() if input_[:2] == &#39;pu&#39;: num = int(input_.split()[1]) if input_[5] == &#39;f&#39;: ## push_front와 push_back구별 deque.appendleft(num) else: deque.append(num) elif input_[:2] == &#39;po&#39;: if input_[4] == &#39;f&#39;: if deque: print(deque.popleft()) else: print(-1) else: if deque: print(deque.pop()) else: print(-1) elif input_[:2] == &#39;si&#39;: print(len(deque)) elif input_[:2] == &#39;em&#39;: if deque: print(0) else: print(1) elif input_[:2] == &#39;fr&#39;: if deque: print(deque[0]) else: print(-1) elif input_[:2] == &#39;ba&#39;: if deque: print(deque[-1]) else: print(-1) ## input ## 15 ## push_back 1 ## push_front 2 ## front ## back ## size ## empty ## pop_front ## pop_back ## pop_front ## size ## empty ## pop_back ## push_front 3 ## empty ## front . 2 . 1 . 2 . 0 . 2 . 1 . -1 . 0 . 1 . -1 . 0 . 3 . . &#51060;&#48516; &#53456;&#49353; . &#45208;&#47924; &#51088;&#47476;&#44592; . 문제 출처: 백준 2805번 | . - 이진탐색으로 해결가능할 듯 하다 &gt; 처음 푸는 유형이었음 . - 나무를 높이 순서로 오름차순 정렬한 후 0과 최대 나무 높이를 중간으로 나눠서 기준치를 넘는지 안넘는지를 판단함&gt; 1~100사이 랜덤 숫자 맞추듯이 . - 목표는 나무를 x미터 까지 잘랐을 땐 기준치 미달인데 x+1미터를 자르니 기준치를 넘기는 x+1을 찾는 것 . - 여러번 틀려서 디버깅 해보니 나무를 반으로 나누는데 최대값은 나무의 최대 높이로 하고 최소값은 나무의 최소 높이로 설정했었다 . - 위에 처럼하면 잘못됐는데 왜냐하면 이 문제의 해가 나무의 최소 높이보다 더 낮은 높이를 절단해야 하면 답이 나오지 않기 때문이다 . - ex) 나무가 3개 있고 높이가 각각 10 20 30이라 하고 필요한 나무는 10미터이라 하자 . - 이 경우는 잘못된 코드로 풀어도 가능함 &gt; 왜냐면 정답이 20미터인데 20은 10과 30 사이 숫자이므로 . - 하지만 필요한 나무가 60미터라면 정답은 0미터여야 하지만 틀린 코드는 최소값 10과 최대값 30 사이를 이분탐색하므로 0이 나올 수 가 없음 . N, M = map(int, input().split()) x = list(map(int, input().split())) x.sort() def trees_sum(h): ## 잘라서 나온 나무 높이의 합 구하기 _sum= 0 for i in range(N): if x[i] &gt; h: _sum += x[i] - h return _sum def cut(trees): left = 0 ## 잘못된 코드는 left = trees[0] 나머지는 동일함 right = trees[-1] mid = (left + right) // 2 sum_ = trees_sum(mid) while True: if right - left &lt; 2: break if sum_ &gt;= M: left = mid mid = (left + right) // 2 sum_ = trees_sum(mid) else: right = mid mid = (left + right) // 2 sum_ = trees_sum(mid) return mid print(cut(x)) ## input ## 4 7 ## 20 15 10 17 . 15 .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "relUrl": "/python/algorithm/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post25": {
            "title": "파이썬 딥러닝",
            "content": "&#53584;&#49436;&#54540;&#47196; . 무지성 코드(예제 그대로 복붙 손으로) | . import tensorflow as tf W = tf.Variable(tf.ones(shape=(2,2)), name = &quot;W&quot;) b = tf.Variable(tf.zeros(shape=(2)), name = &quot;b&quot;) @tf.function def model(x): return W * x + b out_a = model([1,0]) print(out_a) . tf.Tensor( [[1. 0.] [1. 0.]], shape=(2, 2), dtype=float32) . &#52488;&#54217;&#47732;(&#44036;&#45800;&#55176;) . - 평면의 단면은 직선, 부피의 단면은 평면, 그 이상은??? . - 직선($ax + by + c = 0$)은 2차원의 초평면, 평면($ax + by + cz + d = 0$)은 3차원의 초평면 . - $a_1x_1 + a_2x_2 + a_3x_3 + a_4x_4 + c = 0$ 는 뭐라고 불러야 돼??? --&gt; 4차원 공간에 그려짐 . - 평면을 일반화하여 초평면을 만듦 . - n차원의 그려진 초평면 --&gt; n-1차원 공간 . - 초평면은 공간을 분할하는 역할 --&gt; 직선은 평면을 분할, 평면은 공간을 분할 . - [$ ast$] n차원의 초평면은 n차원을 분할 [$ ast$] . &#54140;&#49481;&#53944;&#47200; .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/23/%EB%94%A5%EB%9F%AC%EB%8B%9D.html",
            "relUrl": "/python/2021/06/23/%EB%94%A5%EB%9F%AC%EB%8B%9D.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post26": {
            "title": "map 함수",
            "content": "map &#54632;&#49688; &#53945;&#51669; . - 여러 개의 데이터를 한 번에 다른 형태로 변화하기 위해 사용한다. . - map 함수는 원본 리스트를 변경하지 않고 새 리스트를 생성한다. . - map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환해야 한다. . - map 함수는 리스트의 요소를 지정된 함수로 처리한다. . x=list(range(5)) x . [0, 1, 2, 3, 4] . def two_times(x): return x*2 . y=two_times(x) y . [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] . z=list(map(two_times, x)) z . [0, 2, 4, 6, 8] . map &#54632;&#49688; &#49324;&#50857;&#48277; . - map(함수, 반복가능한 객체) . x = [1.1, 2.1, 3.1, 4.1] y = map(int, x) print(y) . &lt;map object at 0x0000023B6D93D040&gt; . - map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환한다. $ rightarrow [ star$] 변환하지 않으면 위와 같은 결과를 출력한다. [$ star$] . - print(y)하지 않고 그냥 y만 입력해도 된다. . x = [1.1, 2.1, 3.1, 4.1] y = list(map(int, x)) y . [1, 2, 3, 4] . def minus(a): return a - 0.1 . list(map(minus, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . - minus 함수는 map 함수를 위해 한 번 쓰고 버려질 운명이다. 만드는게 귀찮음... . map &#54632;&#49688;&#50640; &#46988;&#45796; &#49885; &#49324;&#50857; . x = [1.1, 2.1, 3.1, 4.1] list(map(lambda a: a - 0.1, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . input().split()&#44284; map . - input()함수는 c언어의 scanf()함수와 비슷하다. . z = input() . z . &#39;hello&#39; . - input()으로 입력받은 값은 문자열이다. . n = input() . type(n) . str . - input()함수에서 안내문구를 추가할 수 도 있다. . Q = input(&#39;숫자 하나를 입력하세요:&#39;) . Q . &#39;26&#39; . - input()함수의 출력값을 문자열이 아닌 다른 자료형으로 바꾸고 싶다면? . w = int(input(&#39;숫자 하나를 입력하세요:&#39;)) . type(w) . int . - input().split(&quot;기준문자열&quot;)을 사용하면 입력값을 변수 여러 개에 저장할 수 있다. . - split()에서 &quot;기준문자열&quot;이 없는 즉 default는 공백이다. . a, b = input().split() # 입력받은 값을 공백(스페이스, 탭, 엔터 등)을 기준으로 분리 . a, b . (&#39;10&#39;, &#39;20&#39;) . c = a, b type(c) . tuple . - a와b가 문자열이다. . - int형으로 바꾸고 싶다면? . a, b = int(input().split()) . TypeError Traceback (most recent call last) &lt;ipython-input-17-0de5d52cb787&gt; in &lt;module&gt; -&gt; 1 a, b = int(input().split()) TypeError: int() argument must be a string, a bytes-like object or a number, not &#39;list&#39; . - int()함수를 쓰면 될 것 같았는데 오류가 나온다 . - error메시지를 읽어보니 int()함수는 무조건 a string, a bytes-like object or a number 여야 한다.(not &#39;list&#39;) . - a, b는 tuple인 것 같다. . - 그러면 어떻게 하지? $ longrightarrow$ map()함수를 쓰면 된다. . a, b = map(int, input().split()) # 입력받은 값을 정수로 변환 . a, b . (10, 20) . type(a) . int . type(b) . int . - a, b = map(int, input().split())을 풀어서 쓰면 다음과 같은 코드이다. . x = input().split() # input().split()의 결과는 문자열 리스트 m = map(int, x) # 리스트의 요소를 int형으로 변환, 결과는 맵 객체 a, b = m # 맵 객체는 변수 여러 개에 저장 가능 . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#54620; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . L = list(map(int, input().split())) L . [10, 8, 7, 1, 0, 3, 5, 2] . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#50668;&#47084; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . data = [] N = int(input()) for i in range(N): data.append(list(map(int, input().split()))) . data . [[1, 4, 0, 2], [17, 8, 1, 0, 4, 6], [1, 0], [0, 4, 5], [0, 0, 10]] .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "date": " • Jun 21, 2021"
        }
        
    
  
    
        ,"post27": {
            "title": "파이썬 기말시험",
            "content": "import pandas as pd import numpy as np class nexon(): &#39;&#39;&#39; 202016248 통계학과 한재수 파이썬 기말시험 1번 문제에 대한 코드 &#39;&#39;&#39; def __init__(self): self.upgradestate = pd.DataFrame({&#39;day0&#39;:[0]*100}) self.prob = 0.3 self.i = 1 def attempt(self): self.attemptresult = np.random.binomial(n=1, p=self.prob, size=100) def update(self): self.upgradestate[&#39;day%s&#39; % self.i] = np.minimum(self.upgradestate[&#39;day%s&#39; % (self.i-1)] + self.attemptresult, 5) ## +5이후로는 증가하지 않는다 self.ratio = sum(self.upgradestate.loc[:,&#39;day%s&#39; % self.i] == 5) / 100 . #1-(1) test1=nexon() for test1.i in range(1,63): test1.attempt() test1.update() 100*test1.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다 . 100.0 . class nexon2(nexon): &#39;&#39;&#39; 202016248 통계학과 한재수 파이썬 기말시험 2번 문제에 대한 코드 &#39;&#39;&#39; def __init__(self): nexon.__init__(self) self.prob = 0.7 self.failstate = pd.DataFrame({&#39;day0&#39;:[0]*100}) def update(self): nexon.update(self) self.failstate[&#39;day%s&#39; % self.i] = self.failstate[&#39;day%s&#39; % (self.i-1)] + (self.attemptresult==0)*1 for j in range(100): if self.upgradestate.iloc[j,self.i] == 0: self.failstate.iloc[j,self.i] = self.failstate.iloc[j,self.i]-1 ## i-1번째 + 강화시도(0 or 1) = i번째 ## i,i-1번째 강화상태가 0이라는 의미는 i-1째에 시도한 강화가 실패했다는 의미. ## upgradestate가 0이라는 의미는 실패했다는 것이므로 실패횟수가 하나 쌓인다. ## +0에서는 실패횟수가 쌓이지 않으므로 failstate값을 하나 뺀다. if (self.upgradestate.iloc[j,self.i] == 5) and (self.attemptresult[j] == 0): ## i-1번째 + 강화시도(0 or 1) = i번째 ## i번째가 +5강화이면서 i-1번째 시도한 강화가 실패라는 의미는 ## i-1번째가 +5강화였다는 의미이다. 그러므로 i번째 실패횟수가 +1 됐을것이다. ## +5강화에서는 강화를 도전하지 않을 것이다. ## 그러므로 i번째 실패횟수를 1을 감소시킨다. self.failstate.iloc[j,self.i] = self.failstate.iloc[j,self.i]-1 ## +5에서는 강화를 시도하지 않을것이므로 ## 만약 실패했다면 failstate값을 하나 뺀다. def reset(self): for j in range(100): if (self.upgradestate.iloc[j,self.i] &gt;0) and (self.upgradestate.iloc[j,self.i] &lt; 5): if self.failstate.iloc[j,self.i] == 2: self.failstate.iloc[j,self.i] = 0 self.upgradestate.iloc[j,self.i] = 0 ## 실패스택이 2라면 실패스택을 0으로 바꾸고 강화상태를 +0으로 바꾼다 def arrangeprobt(self): if self.ratio &gt;= 0.5: self.prob = 0.9 ## +5강 비율이 50%이상이라면 전체유저의 강화 성공확률을 90%로 바꾼다. . #2-(1) test2=nexon2() for test2.i in range(1,63): test2.attempt() test2.update() test2.reset() 100*test2.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . #2-(2) test3=nexon2() for test3.i in range(1,32): test3.attempt() test3.update() test3.reset() 100*test3.ratio ## 31일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 99명이였다. . 99.0 . #2-(3) test4=nexon2() for test4.i in range(1,63): test4.attempt() test4.update() test4.reset() test4.arrangeprobt() 100*test4.ratio ## 과반수가 +5강화 일때 성공확률을 0.9로 바꾼다,62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . - 다음문장을 잘 읽고 참 거짓을 판단하여라. (10점) . (1) tuple은 원소의 값을 임의로 바꿀 수 있다.=&gt; &#39;거짓&#39; . (2) class 에 정의된 함수(=메서드)는 self 만을 인자로 받을수 있다.=&gt; &#39;거짓&#39; .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "relUrl": "/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "date": " • Jun 18, 2021"
        }
        
    
  
    
        ,"post28": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://gkswotn12345.github.io/green/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post29": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://gkswotn12345.github.io/green/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "수상 . - 1학년 2학기 때 장학금 10만원… . 학점 . - 1학년 1학기: 4.38 . - 1학년 2학기: 4.50 . - 2학년 1학기: 4.00(희망), 4.42(현실)? . 프로그래밍 언어 . - R . - 파이썬 . - 잘하고 싶다… . 자격증 . - 있을까? . 토익 . - 할거임 . 대외활동 . - 해야지 . 봉사활동 . - .. .",
          "url": "https://gkswotn12345.github.io/green/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://gkswotn12345.github.io/green/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}