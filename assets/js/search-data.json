{
  
    
        "post0": {
            "title": "탐색 알고리즘",
            "content": "&#44618;&#51060; &#50864;&#49440; &#53456;&#49353;(Depth First Search, DFS) . - 모든 정점을 한번만 방문 . - 시작 노드에서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색 . - 방문할 노드와 방문한 노드를 기준으로 탐색 . - 특정 노드가 방문할 노드 --&gt; 탐색, 방문한 노드면 --&gt; 지나감 . - 그래프나 트리는 dictionary로 생성 . - 스택 구조 or 재귀 함수로 구현 가능 . DFS &#51109;&#51216; . - 단지 현 경로상의 노드들만을 기억하면 되므로 저장공간의 수요가 비교적 적음 . - 목표노드가 깊은 단계에 있을 경우 해를 빨리 구함 . DFS &#45800;&#51216; . - 해가 없는 경로에 깊이 빠질 가능성 존재 . - 얻어진 해가 최단 경로가 된다는 보장이 없음 --&gt; 목표에 이르는 경로가 다수일 때 해에 다다르면 탐색을 끝내버림 --&gt; 이때 얻어진 해는 최적이 아닐 수 있음 . DFS 참고: https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89 | . DFS &#53076;&#46300; &#44396;&#54788;(&#49828;&#53469;) . - tree 구조 . - 노드: [A], [B], [C], [D], [E], [F], [G], [H], [I], [J] . - 분기: [A, B, E], [A, B, F, I], [A, C, G], [A, D, H, I] . tree = {&#39;A&#39;: [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;], &#39;B&#39;: [&#39;A&#39;, &#39;E&#39;, &#39;F&#39;], &#39;C&#39;: [&#39;A&#39;, &#39;G&#39;], &#39;D&#39;: [&#39;A&#39;, &#39;H&#39;], &#39;E&#39;: [&#39;B&#39;], &#39;F&#39;: [&#39;B&#39;, &#39;I&#39;], &#39;G&#39;: [&#39;C&#39;], &#39;H&#39;: [&#39;D&#39;, &#39;J&#39;], &#39;I&#39;: [&#39;F&#39;], &#39;J&#39;: [&#39;H&#39;]} . &#47532;&#49828;&#53944; &#54876;&#50857; . - list.pop()은 성능이 떨어짐 --&gt; $O(n)$ . def DFS_list(graph, start_node): visited = [] ## 방문한 노드 will_visit = [] ## 방문할 노드 will_visit.append(start_node) ## 방문할 노드에 시작 노드 추가 while will_visit: ## 방문할 노드가 있다면(리스트에 원소가 있으면 True) node = will_visit.pop() ## 마지막 노드 추가(스택 구조 사용) if node not in visited: ## 만약 아직 방문한 노드가 아니라면 visited.append(node) ## 이제 방문했으니까 방문한 노드에 추가 will_visit.extend(reversed(graph[node])) ## 방문한 노드에 연결된 노드를 탐색해보자 print(visited) print(will_visit) print(&#39;-&#39;) ## 방문과정 확인 return visited ## 방문한 노드를 반환 DFS_list(tree, &#39;A&#39;) ## 마지막은 return 값 . [&#39;A&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;E&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;E&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;I&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;I&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;] [&#39;D&#39;, &#39;C&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;] [&#39;D&#39;, &#39;G&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;] [&#39;D&#39;, &#39;G&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;] [&#39;D&#39;, &#39;C&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;] [&#39;D&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;] [&#39;H&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;] [&#39;H&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;] [&#39;J&#39;, &#39;D&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;] [&#39;J&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] [&#39;H&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] [] - . [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] . deque &#54876;&#50857; . - 성능이 좋음 --&gt; $O(1)$ . - 사용: from collections import deque . - visit도 dictionary를 사용하여 해시로 구현하면 $O(1)$로 효율$ uparrow$(추가 예정) . def DFS_deque(graph, start_node): from collections import deque ## deque패키지 import visited = [] ## 방문한 노드 will_visit = deque() ## 방문할 노드 will_visit.append(start_node) ## 방문할 노드에 시작 노드 추가 while will_visit: ## 방문할 노드가 있다면(리스트에 원소가 있으면 True) node = will_visit.popleft() ## 마지막 노드 추가(스택 구조 사용) if node not in visited: ## 만약 아직 방문한 노드가 아니라면 visited.append(node) ## 이제 방문했으니까 방문한 노드에 추가 will_visit.extend(graph[node]) ## 방문한 노드에 연결된 노드를 탐색해보자 print(visited) print(will_visit) print(&#39;-&#39;) ## 방문과정 확인 return visited ## 방문한 노드를 반환 DFS_deque(tree, &#39;A&#39;) . [&#39;A&#39;] deque([&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]) - [&#39;A&#39;, &#39;B&#39;] deque([&#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;E&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] deque([&#39;D&#39;, &#39;A&#39;, &#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] deque([&#39;A&#39;, &#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] deque([&#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] deque([&#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] deque([&#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] deque([&#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] deque([&#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] deque([&#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;B&#39;, &#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;C&#39;, &#39;D&#39;, &#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;D&#39;, &#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([&#39;F&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([&#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([]) - . [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] . &#51116;&#44480;&#54632;&#49688; &#54876;&#50857; . &#45320;&#48708; &#50864;&#49440; &#53456;&#49353;(Breadth First Search, BFS) . &#48177;&#53944;&#47000;&#53433;((backtracking) .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/09/%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "relUrl": "/python/algorithm/2021/07/09/%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "그리디 알고리즘",
            "content": "&#44536;&#47532;&#46356; &#50508;&#44256;&#47532;&#51608;(&#50837;&#49900;&#51137;&#51060; &#50508;&#44256;&#47532;&#51608;, Greedy Algorithm)&#51060;&#46976;? . - 다이나믹 프로그래밍이 모든 경우를 확인 한다는 점에서 고안된 알고리즘 . - 매 선택마다 가장 최적인 답을 선택하여 결론을 도출 --&gt; 알파고: 자신 차례마다 가장 승률이 높은 수를 선택 . - but, 매 선택마다 최적이지만 결과가 최적이라는 보장 없음 . - 마시멜로 실험: 당장은 1개, 기다리면 2개 --&gt; 최적해: 기다리고 2개 먹기 . - 하지만 그리디 알고리즘은 지금 최적의 선택인 1개를 선택 --&gt; 최적해 아님 . &#44536;&#47084;&#47732; &#50612;&#46500; &#44221;&#50864;&#50640; &#51096; &#46041;&#51089;&#54616;&#45716;&#44032;? . - 탐욕 선택 속성(greedy choice property): 한번의 선택이 다음 선택과는 무관 . - 최적 부분 구조(optimal substructure): 매 순간의 최적해 --&gt; 문제에 대한 최적해 . &#44536;&#47532;&#46356; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . - 백준 - 설탕 배달: https://www.acmicpc.net/problem/2839 . - 설탕 N kg을 3kg, 5kg봉지에 담아야 하는데 봉지의 수를 최소화 . 최적 부분 구조: 매 순간 봉지의 수를 최소화하려는 행위(3kg 봉지 보다 5kg 봉지 사용)는 문제에 대한 최적해(봉지의 수 최소화) . | 탐욕 선택 속성: 전에 5kg 봉지를 선택하든 3kg 봉지를 선택하든 상관없이 현재 남아있는 무게를 가지고만 판단하여 선택 . | - 그리디 알고리즘: 5kg 봉지로만 담는 것이 최선 . - 만약 5kg 봉지로만 담는 것이 불가능하면? . - 5kg 봉지를 하나 줄이고 3kg 봉지를 사용함 . - 이를 반복함 --&gt; 만약 담는 것이 불가능하면 -1 return . 설탕 배달(그리디 알고리즘) | . - 설탕의 무게는 N kg . 5kg 봉지 선택(최적 판단) . | 5kg 봉지 선택(최적 판단) . | 5kg 봉지만 계속 선택 --&gt; total: k 번 선택(최적 판단) . | 만약 남은 무게가 예컨데 4kg 이라 5kg 봉지에 담지 못한다면 3kg 선택(최적 판단) . | 3kg 에 담고나면 1kg 이 남음 --&gt; 어느 봉지에도 담지 못함 . | 5kg 봉지를 k - 1번 선택하고 3kg 봉지를 선택 . | 5kg 봉지를 0번 선택할 때 까지 반복 --&gt; 이 경우에도 답이 없다면 해가 존재하지 않음 . | N = int(input()) def sugar(n): k = n // 5 l = n % 5 for i in range(k+1): if l == 0: return k break elif l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 21 . - 설탕 무게가 101kg 일시 5kg 19개, 3kg 2개를 선택 .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/09/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "relUrl": "/python/algorithm/2021/07/09/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "format 함수",
            "content": "format &#54632;&#49688; . - 문자열을 포매팅(formatting)하는데 사용 . - 포매팅: 문자열의 원하는 위치에 특정 변수를 삽입 . - 아래 예제를 보자 . &#39;이름:{},나이:{},성별:{}&#39;.format(&#39;홍길동&#39;,&#39;21&#39;,&#39;남&#39;) . &#39;이름:홍길동,나이:21,성별:남&#39; . - 순서대로 홍길동, 21, 남이 {}에 삽입됨 . - 구구단도 쉽게 출력할 수 있음 . i = 2 for j in range(1, 10): print(&#39;{} X {} = {}&#39;.format(i, j, i*j)) . 2 X 1 = 2 2 X 2 = 4 2 X 3 = 6 2 X 4 = 8 2 X 5 = 10 2 X 6 = 12 2 X 7 = 14 2 X 8 = 16 2 X 9 = 18 . [$ star$]&#49548;&#49688;&#51216; &#51088;&#47551;&#49688; &#54364;&#54788;[$ star$] . - 알고리즘 문제를 풀다보면 특정 소수점 자릿수까지 출력을 요구할 때가 있음 . - 계산 결과를 소수점 셋째 자리 까지 표현하려면? . a = 10 b = 3 a / b . 3.3333333333333335 . - 소수점 셋째 짜리 까지 표현하고 싶음 . - format 함수 사용! . a = 10 b = 3 print(&#39;{:.3f}&#39;.format(a / b)) . 3.333 . - round 함수도 되는데? . - round(x, a) --&gt; x를 소수점 a번째 까지 나타냄 . a = 10 b = 3 round(a / b, 3) . 3.333 . - 아래와 같은 경우는? . a = 10 b = 2 a / b . 5.0 . - format 함수 . a = 10 b = 2 print(&#39;{:.3f}&#39;.format(a / b)) . 5.000 . - round 함수 . a = 10 b = 2 round(a / b, 3) . 5.0 . - format 함수는 소수점 셋째 자리까지 나타낸 반면 round 함수는 첫째 자리까지 나타냄 . - 결론: 원하는 자릿수 까지 나타내려면 round 함수 대신 format 함수를 쓰자 .",
            "url": "https://gkswotn12345.github.io/green/python/2021/07/09/format%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/2021/07/09/format%ED%95%A8%EC%88%98.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "정렬 알고리즘",
            "content": "- 데이터를 오름차순으로 정렬해보자! . &#49440;&#53469; &#51221;&#47148; . - 가장 작은 수를 첫 번째 인덱스로 선택 그 다음으로 작은 수를 두 번째 인덱스로 선택 . - 이런식으로 가장 큰 수까지 마지막 인덱스로 선택하면 정렬 끝 . &#49440;&#53469; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다. . List = [5, 8, 7, 1, 2] . 2 첫 번째 인덱스와 나머지 $n - 1$개의 수를 비교하여 가장 작은 수와 위치를 바꾼다. . 3 5와 비교하여 1이 가장 작으므로 5와 1의 위치를 바꾼다. . List = [1, 8, 7, 5, 2] . 4 이제 두 번째 인덱스와 나머지$n - 2$개의 수를 비교하여 남은 수 중 가장 작은 수와 위치를 바꾼다. . 5 8과 비교하여 2가 가장 작으므로 8과 2의 위치를 바꾼다. . List = [1, 2, 7, 5, 8] . 6 이런 식으로 $n-1$번째 인덱스와 나머지 1개의 수를 비교하여 오름차순 정렬을 마친다. . List = [1, 2, 5, 7, 8] . &#49440;&#53469; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(n - 1): min_idx = i for j in range(i + 1, n): if List[j] &lt; List[min_idx]: min_idx = j List[i], List[min_idx] = List[min_idx], List[i] print(List) . [1, 8, 7, 5, 2] [1, 2, 7, 5, 8] [1, 2, 5, 7, 8] [1, 2, 5, 7, 8] . &#48260;&#48660; &#51221;&#47148; . - 연속된 인덱스를 비교하여 더 큰 값을 오른쪽으로 보냄 . - 한 사이클을 돌면 가장 큰 값이 맨 뒤에 위치 . - 사이클마다 남은 수 중 가장 큰 값이 뒤에 위치함 . &#48260;&#48660; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다. . List = [5, 8, 7, 1, 2] . 2 첫 번째 인덱스와 두 번째 인덱스를 비교하여 더 큰값을 오른쪽에 위치시킨다. . 3 5와 8을 비교하면 8이 더 크므로 8을 오른쪽을 보낸다. . List = [5, 8, 7, 1, 2] . 4 이제 두 번째 인덱스와 세 번째 인덱스를 비교한다. . 5 8과 7을 비교하면 8이 더 크므로 8을 오른쪽으로 보낸다. . List = [5, 7, 8, 1, 2] . 6 이런식으로 한 사이클을 돌면 8이 마지막에 위치한다. . List = [5, 7, 1, 2, 8] . 7 다시 사이클을 돌면 7이 8 왼쪽에 위치한다. . List = [5, 1, 2, 7, 8] . 8 이런식으로 $n - 1$ 번의 사이클을 돌면 자료가 오름차순으로 정렬된다. . List = [1, 2, 5, 7 ,8] . &#48260;&#48660; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(n - 1, 0, -1): for j in range(i): if List[j + 1] &lt; List[j]: List[j + 1], List[j] = List[j], List[j + 1] print(List) . [5, 7, 1, 2, 8] [5, 1, 2, 7, 8] [1, 2, 5, 7, 8] [1, 2, 5, 7, 8] . &#49341;&#51077; &#51221;&#47148; . - 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교함 . - 자신의 위치를 찾아 삽입함 . - 일반적으로 선택 정렬, 버블 정렬 보다 빠름 . &#49341;&#51077; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다. . List = [5, 8, 7, 1, 2] . 2 두 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . List = [5, 8, 7, 1, 2] . 3 5와 8을 비교하면 8이 더 크므로 8을 오른쪽을 보낸다. . List = [5, 8, 7, 1, 2] . 4 세 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . 5 7과 8을 비교하면 8이 더 크고 5와 7을 비교하면 7이 더 크므로 5와 8사이에 위치한다. . List = [5, 7, 8, 1, 2] . 6 네 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . 7 1이 부분 리스트 중 가장 작으므로 맨 앞에 삽입 . List = [1, 5, 7, 8, 2] . 8 마지막 원소를 부분 리스트에서 적절한 위치에 삽입 . 9 2는 부분 리스트 중 1 다음으로 작으므로 1 오른쪽에 삽입 . List = [1, 2, 5, 7, 8] . &#49341;&#51077; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(1, n): j = i - 1 key = List[i] while List[j] &gt; key and j &gt;= 0: List[j+1] = List[j] j = j - 1 List[j+1] = key print(List) . [5, 8, 7, 1, 2] [5, 7, 8, 1, 2] [1, 5, 7, 8, 2] [1, 2, 5, 7, 8] .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/04/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "relUrl": "/python/algorithm/2021/07/04/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "date": " • Jul 4, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "확률 분포",
            "content": "&#54869;&#47456; &#48516;&#54252;&#46976;? . - 확률 분포(probability distribution)는 확률 변수가 특정한 값을 가질 확률을 나타내는 함수를 의미한다 --&gt; 출처: https://ko.wikipedia.org/wiki/%ED%99%95%EB%A5%A0_%EB%B6%84%ED%8F%AC . &#44536;&#47111;&#45796;&#47732; &#54869;&#47456; &#48320;&#49688;&#46976;? . - 확률변수(Random Variable)란 무작위 실험을 했을 때, 특정 확률로 발생하는 각각의 결과를 수치로 표현한 변수 . - 무작위 실험 --&gt; 동전 던지기 . - 특정 확률 --&gt; 앞면이 나올 확률 $ frac{1}{2}$, 뒷면이 나올 확률 $ frac{1}{2}$ . - 수치 --&gt; 앞면 = $1$, 뒷면 = $2$ . &#50672;&#49549; &#54869;&#47456; &#48516;&#54252; . - 연속 확률 변수가 가지는 확률 분포 . - 이산 확률 변수는 확률을 $P(X=x)$와 같이 표현 가능, 연속 확률 변수는 불가능 . - 연속 확률 변수는 확률을 $P(A leq X leq B)$로 표현 가능 . &#51221;&#44508;&#48516;&#54252; . - 정규 분포는 수집된 자료의 분포를 근사하는 데에 자주 사용됨 . - 중심극한정리에 의하여 독립적인 확률변수들의 평균은 정규 분포에 가까워지는 성질이 있기 때문임 . - 신뢰구간이나 가설검정 등의 모델에서 사용 . - 기호로는 $N sim ( mu, sigma^{2})$ . - 정규분포의 기댓값, 중앙값, 최빈값은 $ mu$, 분산은 $ sigma^{2}$ . - 표준정규분포는 평균이 0, 표준편차가 1인 경우임 --&gt; $N sim (0, 1)$ . - 정규분포에서 $ mu pm2 sigma$에 전체 데이터 중 $95 %$가 존재 . &#54364;&#51456;&#54868; . - 정규 분포 밀도 함수에서 $Z =$ $ frac{X - mu}{ sigma}$ 를 통해 $X$(원점수)를 $Z$($z$점수) 표준화하여 표준정규분포(z-분포)를 얻을 수 있다 . &#51221;&#44508;&#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688;(PDF) . $f(x) = frac{1}{ sqrt{2 pi sigma^{2}}}e^{- frac{(x-m)^{2}}{2 sigma^{2}}}$ . &#51221;&#44508;&#48516;&#54252; plot . import numpy as np np.random.normal(loc, scale, size) . - loc는 평균, scale은 표준편차, size는 반복 횟수 . np.random.normal(loc = 0, scale = 1, size = 1000) . - np.random.normal(loc = 0, scale = 1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.normal(loc = 0, scale = 1, size = 1000) plt.hist(sample) plt.title(&#39;np.random.normal(loc = 0, scale = 1, size = 1000)&#39;) plt.show() . &#44512;&#51068; &#48516;&#54252; . - 모든 확률 변수에 대하여 구간 내에서 균일한 확률을 가짐 . - 임의의 구간 내에서 균일한 확률을 가지기에 난수 생성기로 쓰임 . - 이산 확률 변수에서도 가능 . &#44512;&#51068; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x) = begin{cases} frac{1}{b-a} &amp; text{for $x in [a,b]$} 0 &amp; text{otherwise} end{cases} $ . - $f(x)$는 구간 $[a,b]$에서 균등한 확률을 가짐 . &#44512;&#51068; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - 기댓값 = $ frac{a+b}{2}$ . - 분산 = $ frac{(b-a)^{2}}{12}$ . &#44512;&#51068; &#48516;&#54252; plot . import numpy as np np.random.uniform(low, high, size) . - low는 출력값의 최소 경계, high은 출력값의 최대 경계, size는 반복 횟수 . np.random.uniform(low = 0, high = 1, size = 1000) . - np.random.uniform(low = 0, high = 1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.uniform(low = 0, high = 1, size = 1000) plt.hist(sample) plt.title(&#39;np.random.normal(loc = 0, scale = 1, size = 1000)&#39;) plt.show() . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;($x^2$&#48516;&#54252;) . - $k$개의 서로 독립인 표준 정규 확률변수를 각각 제곱하여 합해 얻어진 분포 . - 이때 $k$는 자유도이며 카이제곱 분포의 매개변수 . - 신뢰구간이나 가설검정 등의 모델에서 사용 . - $k$개의 독립적이고 표준정규분포를 따르는 확률변수 $Z_1, dots,Z_k$가 있을 때 자유도 $k$의 카이제곱 분포는 . - 확률변수 $Q = sum^{k}_{i=1}Z{_i}{^2}$의 분포임 . - 따라서 $Q sim X{_k}{^i}$ . - 참고: https://ko.wikipedia.org/wiki/%EC%B9%B4%EC%9D%B4%EC%A0%9C%EA%B3%B1_%EB%B6%84%ED%8F%AC . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x; k) = frac{1}{2^ frac{k}{2} Gamma( frac{k}{2})}x^{ frac{k}{2}-1}e^{- frac{x}{2}}$ . - $ Gamma( frac{k}{2})$는 감마함수이다 . &#44048;&#47560;&#54632;&#49688;(Gamma Function) . $ Gamma( alpha) = int_{0}^{ infty}x^{ alpha-1}e^{-x}dx, , alpha geq 0$ . &#44048;&#47560;&#54632;&#49688; &#49457;&#51656; . - $ Gamma( alpha+1) = alpha Gamma( alpha)$ . - $ Gamma(n) = (n-1)!, , n in mathbb{N}$ . - $ Gamma( frac{1}{2}) = sqrt{ pi}$ . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - 기댓값 = $k$ . - 분산 = $2k$ . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252; plot . import numpy as np np.random.chisquare(df, size) . - df는 자유도, size는 반복 횟수 . np.random.chisquare(df = 10, size = 1000) . - np.random.chisquare(df = 10, size = 1000)를 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.chisquare(df = 10, size = 1000) plt.hist(sample) plt.title(&#39;np.random.chisquare(df = 10, size = 1000)&#39;) plt.show() . - 자유도(df)를 바꿔볼까? . - df = 5 . np.random.seed(1) sample = np.random.chisquare(df = 5, size = 1000) plt.hist(sample) plt.title(&#39;np.random.chisquare(df = 5 , size = 1000)&#39;) plt.show() . - df = 1 . - 표준정규분포의 제곱은 자유도가 1인 카이제곱 분포를 따름 . - $V = ( frac{X- mu}{ sigma})^{2} sim X^{2}(1)$ . - 표본을 10000개 뽑아 둘을 비교해보자! . np.random.seed(2) sample = np.random.chisquare(df = 1, size = 10000) plt.hist(sample) plt.title(&#39;np.random.chisquare(df = 1 , size = 10000)&#39;) plt.show() . np.random.seed(2) sample = np.random.normal(loc = 0, scale = 1, size = 10000) sample = sample**2 plt.hist(sample) plt.title(&#39;square of a standard normal distribution&#39;) plt.show() . - 두 분포가 거의 동일하다 . - 표준정규분포의 제곱은 자유도가 1인 카이제곱 분포를 따른다는 것을 확인할 수 있다 . &#51060;&#49328; &#54869;&#47456; &#48516;&#54252; . - 이산 확률 변수가 가지는 확률 분포 . &#48288;&#47476;&#45572;&#51060; &#49884;&#54665; . - 임의의 결과가 성공 또는 실패와 같이 가능한 결과가 2 가지 . &#48288;&#47476;&#45572;&#51060; &#49884;&#54665; &#51312;&#44148; . - 각 시행의 결과는 상호 배타적인 두 사건(성공 or 실패)으로 구분 . - 성공 확률 p, 실패 확률 q일 때, $p+q=1$ . - 각 시행은 독립적 . &#51060;&#54637; &#48516;&#54252; . - 성공 확률이 p인 베르누이 시행을 독립적으로 n번 반복했을 때 성공 횟수 X는 이항 분포를 따름 . - 기호로는 $X sim B(n,p)$ . - 독립적 시행 --&gt; 각 시행은 서로 영향을 주지 않음 . &#51060;&#54637; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688;(PMF) . $f(x) ,= , _{n} rm C_{x} ,p^{x} ,p^{n-x} ,= , binom{n}{x} ,p^{k} ,p^{n-x}$ . - 성공 확률 $p$인 베르누이 시행을 $n$번 시행하여 그 중 $x$번을 성공할 확률 질량 함수 . - 베르누이 분포는 이항 분포에서 $n=1$일 때이다 . &#51060;&#54637;&#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - 기댓값 = $np$ . - 분산 = $np(1-p)$ . &#51060;&#54637; &#48516;&#54252; plot . import numpy as np np.random.binomial(n, p, size) . - $n$은 표본 크기, $p$는 성공 확률, size는 반복 횟수 . np.random.binomial(n = 50, p = 0.5, size = 1000) . - 성공 확률이 p = 0.5인 베르누이 시행을 n = 50번 반복하는 것을 size = 1000번 반복한다 . - 동전 던지기($p=0.5$)를 $n$ = $50$번 시행하여 앞면이 나온 횟수($X=0,1,2, dots,49,50$)를 $size = 1000$번 기록한다 . - np.random.binomial(n = 10, p = 0.5, size = 1000)을 히스토그램으로 나타내면? . - $np geq 5$ 이면 이항분포를 정규분포로 근사할 수 있다 . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.binomial(n = 10, p = 0.5, size = 1000) plt.hist(sample) plt.title(&#39;np.random.binomial(n = 10, p = 0.5, size = 100)&#39;) plt.show() . &#54252;&#50500;&#49569; &#48516;&#54252; . - 단위 시간, 단위 공간 안에 어떤 사건이 몇 번 발생할 것인지를 표현하는 이산 확률 분포 . - 포아송 분포의 모수($ lambda$)는 단위 시간에서 사건의 평균 발생 횟수 . &#54252;&#50500;&#49569; &#48516;&#54252; &#51204;&#51228; &#51312;&#44148; . - 독립성: 1시간 동안 우리 집앞에서 넘어진 사람 수와 친구 집앞에서 넘어진 사람 수는 독립이다 . - 일정성: 1시간 동안 평균 3명이 넘어졌다면 2시간 동안에는 평균 6명이 넘어진다 . - 비집락성: 우리 집앞에서 같은 시간에 두 명 이상이 넘어질 확률은 0이다 . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) = frac{e^{- lambda} lambda^{x}}{x!}$ . - $x$는 단위 시간에서 사건의 발생 횟수, $ lambda$는 단위 시간에서 사건의 평균 발생 횟수 . - $ lambda = 10$, $x = 7$ --&gt; 단위 시간에서 사건의 평균 10번 발생할 때 7번 발생할 확률은? . - 우리 집앞에서 1시간에 사람이 평균적으로 10명이 넘어진다고 한다. 이 때 1시간에 사람이 5명 넘어질 확률은? . - $ lambda = 10, , x = 5 longrightarrow f(5) = frac{e^{-10} ,10^5}{5!} = 0.03783327480207071$ . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - 기댓값 = $ lambda$ . - 분산 = $ lambda$ . &#54252;&#50500;&#49569; &#48516;&#54252; plot . import numpy np.random.poisson(lam ,size) . - $ lambda$는 모수, size는 반복 횟수 . np.random.poisson(lam = 10 ,size = 1000) . - 단위 시간에서 사건이 평균 10번 발생할 때 (lam = 10) 단위 시간에서 사건이 몇 번 발생하는지를 size = 1000번 반복한다 . - 우리 집앞에서 1시간당 평균 10명이 넘어질 때($ lambda=10$) 1시간당 몇 명 넘어지는지($x = 0,1,2, dots,10,11, dots$)를 $size = 1000$번 기록한다 . - np.random.poisson(lam = 10, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.poisson(lam = 10, size = 1000) plt.hist(sample) plt.title(&#39;np.random.poisson(lam = 10, size = 1000)&#39;) plt.show() . - $ lambda$를 바꿔볼까? --&gt; 우리 집앞에서 1시간당 평균 4명이 넘어진다면?? . np.random.seed(1) sample = np.random.poisson(lam = 4, size = 1000) plt.hist(sample) plt.title(&#39;np.random.poisson(lam = 4, size = 1000)&#39;) plt.show() .",
            "url": "https://gkswotn12345.github.io/green/python/statistics/2021/06/30/%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html",
            "relUrl": "/python/statistics/2021/06/30/%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html",
            "date": " • Jun 30, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "깃허브 데스크탑",
            "content": "&#44611;&#54728;&#48652; &#45936;&#49828;&#53356;&#53457; &#51060;&#50857;&#54644;&#49436; &#52964;&#48139;&#54616;&#44592; . 처음에 레포지토리 선택할 때 정보를 저장할 폴더 경로를 선택한다. . | 나의 경우에는 &quot;C:/Users/한재수/github_desktop/green&quot; 이다. . | green폴더에 가보면 notebooks폴더가 있는데 거기서 작업한 주피터 노트북 파일은 깃허브 데스크탑 changes에 표시된다. . | 커밋할 파일 하나를 클릭하고 하단에 메시지를 같이 남긴다. . | 변동 내역 메시지를 작성하고 커밋을 했으면 마지막으로 푸쉬를 한다. . | 깃허브에 변동 내역이 저장된다. . | 아무 것도 변경하지 않고 save만 해도 깃허브 데스크탑 changes에서 감지된다. | 아무 것도 변경하지 않았는데 커밋이 된다는 의미... --&gt; 아무짝에도 쓸모 없다. --&gt; 이런 경우에는 커밋을 하지 말고 냅두자. | . &#51089;&#50629; &#44277;&#44036; . 이제부터 작업은 나의 깃허브 레포지토리(green) 저장 폴더인 green에 있는 notebooks에서 해야 한다. | 만약 &quot;C:/Users/한재수/github_desktop/green/notebooks&quot; 에서 작업하지 않으면 깃허브 데스크탑 changes에 기록되지 않는다. --&gt; 망함 | .",
            "url": "https://gkswotn12345.github.io/green/python/github/2021/06/26/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91.html",
            "relUrl": "/python/github/2021/06/26/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "데이터과학",
            "content": "&#49440;&#54805;&#54924;&#44480; . &#54924;&#44480;&#47784;&#54805; . - $y_i= beta_0+ beta_1 x_{1}+ epsilon_i$ . - $y_i$는 관측값, $ beta_0$는 절편, $ beta_1$은 기울기, $ epsilon_i$는 오차항 { $ mathbb{N} sim(0, sigma^2$) } . - $ sum_{i=1}^{n} epsilon_i^2 = sum_{i=1}^{n} (y_i- beta_0- beta_1 x_{1})^2$ 을 최소화하는 $ beta_0, beta_1$을 추정한다. --&gt; 최소제곱추정 . &#54632;&#49688;&#51032; &#52572;&#49548;&#44050; . - 함수 $f(x)$가 있다고 하자. 이 함수의 최소값을 알고 싶다. --&gt; 미분 . - convex fuction (볼록 함수 --&gt; 아래로 볼록)는 임의의 두 점 $x_1,x_2$와 [0,1] 사이의 값 t에 대해 $f(tx_1+(1-t)x_2) geq tf(x_1)+(1-t)f(x_2)$가 항상 성립하는 함수이다. . - $f&#39;&#39;(x) &gt; 0$이면 $f(x)$는 아래로 볼록하다. . 함수를 두 번 미분한다. | $f&#39;&#39;(x)&gt;0$이면 볼록함수이다. --&gt; $f&#39;(x)=0$을 만족할 때 $f(x)$의 극소값(=최소값)이므로 $f(x)$가 최소이다. | &#54924;&#44480;&#47784;&#54805; &#44228;&#49688; &#52628;&#51221; . $ bf L = sum_{i=1}^{n} boldsymbol{ epsilon_i}^2 = boldsymbol{ epsilon}^{ top} boldsymbol{ epsilon} = (y - X boldsymbol{ beta})^ top(Y - X boldsymbol{ beta}) , , , , = (y^{ top} - boldsymbol{ beta}^{ top}X^{ top})(y - boldsymbol{ beta}X) = y^{ top}y - y^{ top}X boldsymbol{ beta} - boldsymbol{ beta}^{ top}X^{ top}y + boldsymbol beta^{ top}X^{ top}X boldsymbol{ beta}$ | $ frac{ partial bf L}{ partial boldsymbol beta} = bf 0 - 2 bf X^{ top}y + 2X^{ top}X boldsymbol{ beta} = 0$ | $ bf X^{ top}y = X^{ top}X boldsymbol{ beta} Leftrightarrow boldsymbol{ hat beta} = big( bf X^{ top}X big)^{-1}X^{ top}y $ | - 의문점: 만약$ big( bf X^{ top}X big)^{-1}$이 존재하지 않는다면? .",
            "url": "https://gkswotn12345.github.io/green/python/statistics/2021/06/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B3%BC%ED%95%99.html",
            "relUrl": "/python/statistics/2021/06/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B3%BC%ED%95%99.html",
            "date": " • Jun 25, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "리스트 처리",
            "content": "&#47532;&#49828;&#53944; &#51221;&#47148; . list.sort()&#54632;&#49688;, sorted()&#54632;&#49688; . - ?.sort()함수는 list형태인 ? 의 요소를 오름차순으로 정렬한다. . - ?.sort(reverse = True)함수는 내림차순으로 정렬한다. . - ?.sort()함수와 sorted()함수는 거의 같다. . - ?.sort()함수는 ?의 속성을 바꾸지만 sorted()함수는 ?의 속성을 바꾸지 않는다. (a.append()와 + 연산의 차이) . a=[1,5,2,3,7,4] a . [1, 5, 2, 3, 7, 4] . a.sort() a . [1, 2, 3, 4, 5, 7] . a.sort(reverse = True) a . [7, 5, 4, 3, 2, 1] . - sort(), sorted()의 key 옵션에 지정된 함수의 결과에따라 정렬한다. . - lambda함수(익명 함수) 사용 --&gt; lambda 매개변수: 결과 . b = [(1, 2), (0, 2), (1, 3), (1, 5), (0, 1), (2, 8)] c = sorted(b, key = lambda x: (x[0], -x[1])) ## x[1]앞에 있는 &#39;-&#39;기호는 현재정렬순서와 반대로이다. print(c) ##첫 번째 원소는 오름차순, 두 번째 원소는 내림차순으로 정렬 . [(0, 2), (0, 1), (1, 5), (1, 3), (1, 2), (2, 8)] . reverse()&#54632;&#49688; . - ?.reverse()함수는 list형태인 ? 의 요소를 역순으로 정렬한다. . d = [1,5,2,3,7,4] d.reverse() print(d) . [4, 7, 3, 2, 5, 1] . &#47532;&#49828;&#53944; &#52488;&#44592;&#54868; . 1&#52264;&#50896; &#47532;&#49828;&#53944; . a = [] ## 빈 리스트로 초기화 a . [] . A = [x] * n . $A = [x, x, x, ..., x, x] --&gt;$ $x$가 $n$개인 $1$차원 리스트 . a = [0]*10 ## 0리스트로 초기화 a . [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] . 2&#52264;&#50896; &#47532;&#49828;&#53944; . n = 5 list = [[0] * n for _ in range(n)] ## 0으로 채원진 2차원 리스트 . list . [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . list[0][0] = 123 . list . [[123, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . - ?? . List = [[0] * 5 for _ in range(5) . 그런데 _ 는 뭐지? . - 사실 _ 자리에 다른 것이 들어가도 된다. 이를 테면 i . x = [0*i for i in range(5)] x . [0, 0, 0, 0, 0] . - 위에 List에서 _ 대신에 i를 넣는다고 생각하자. . List = [[0] * 5 for i in range(5) . - 위에 리스트인 x 에서는 i가 리스트 안에 0을 몇 개 생성할 지 정하는 변수였다. . - 위에 리스트인 List 에서는 i가 무슨 역할을 하지?? . - 아무역할도 하지 않는다. . - 0을 5개 생성하고 이를 5번 반복한다. . - List를 정의할 때 부터 정해졌다. . - i는 그저 for문을 쓰기 위해 필요함 --&gt; range(5)의 값을 받아낼 변수가 필요하다. . - 그래서 i 자리에 오는 변수는 아무짝에도 쓸모가 없다. . - 아무 의미가 없어서 그냥 아무 의미 없어보이는 기호인 _를 쓴다.(내 생각) . &#47532;&#49828;&#53944; &#52628;&#44032; . ?.append() . - ? --&gt; 리스트 . - 마지막(?[-1]) 위치에 하나의 원소 추가 . a = [] a.append(1) a . [1] . ?.insert(i, v) . - i 위치에 v 원소 추가 . b = [1,2,3,5,6,7] b.insert(3,4) b . [1, 2, 3, 4, 5, 6, 7] . ?.extend() . - 마지막(?[-1]) 위치에 리스트 추가 . c = [1,2,3,4,5] c.extend([6,7,8]) c . [1, 2, 3, 4, 5, 6, 7, 8] . &#47928;&#51088;&#50676; &#54252;&#54632;&#50668;&#48512; . ?.find(&quot;&#47928;&#51088;&#50676;&quot;) . - ?에 문자열이 존재하면 가장 앞에 원소의 시작 인덱스 값을 반환하며 존재하지 않으면 -1값을 반환 . day = &quot;2021-07-03&quot; . day.find(&#39;2021&#39;) . 0 . day.find(&#39;-&#39;) . 4 . day.find(&#39;2222&#39;) . -1 . &quot;&#47928;&#51088;&#50676;&quot; in ? , &quot;&#47928;&#51088;&#50676;&quot; not in ? . - ?에 문자열이 존재하면 True 반환, 존재하지 않으면 False 반환, not in에 경우는 반대로 . day = &quot;2021-07-03&quot; . &#39;2021&#39; in day . True . &#39;-&#39; not in day . False . &#39;2222&#39; in day . False . list = [&#39;1011&#39;, &#39;2022&#39;, &#39;day&#39;, &#39;model&#39;] . &#39;2022&#39; in list . True . &#39;day&#39; not in list . False . &#39;month&#39; in list . False .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC.html",
            "relUrl": "/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "깃허브 마크다운",
            "content": "&#44611;&#54728;&#48652; &#52852;&#53580;&#44256;&#47532; . 제목 . &quot;부제목&quot; . -toc: true . -branch: master . -badges: true . -comments: true . -author: 한재수 . -categories: [python] . - 위에 내용을 아무곳에나 붙여 넣는다. 부제목은 (&gt;&quot;부제목&quot;), 제목은 (# 제목) . - categories에 해당하는 부분이 깃허브 홈페이지에서 tag에 보이는 부분이다. . - categories 에서 [ ] 안에 여러개를 추가 할 수 있다. ex) [python, R, CSS] . &#48660;&#47196;&#44536; &#44288;&#47532; . 1_ 깃허브 가입하기 | 2_ fastai/fastpages 사용 | 3_ 깃허브 데스크탑 이용 . | (1) 주피터노트북으로 공부한다. . | (2) 깃허브와 연결된 어떤 폴더(드랍박스 안의 green)에 공부한 내용을 넣는다. | (3) 깃허브 데스크탑이라는 프로그램을 이용하여 local(내 윈도우 컴퓨터)에서 remote (github)로 변경사항을 반영한다. | (4) 2~3분 뒤에 블로그 홈페이지에 반영된다. | (5) 공부한 내용을 편집없이 주피터 노트북 파일을 올리기만 하면 블로그에 올라가서 편하다. 필요에 따라 숨기기, 비밀 포스트도 만들 수 있다. | . &#44611;, &#44611;&#54728;&#48652; . - 버전 관리 시스템 . - 서로 코드를 공유 . - 혼자 쓰면 개인 저장소.. . &#51452;&#54588;&#53552; &#45432;&#53944;&#48513; . &#50976;&#50857;&#54620; &#53412; . - 삭제한 셀 복원 --&gt; Edit - Undo cell operation or Esc 후 z키 입력 . - 삭제한 코드 복원 --&gt; Ctrl + z . &#51452;&#54588;&#53552; &#45432;&#53944;&#48513; --&gt; remote --&gt; page (&#50504; &#50732;&#46972;&#44040; &#49688; &#46020; &#51080;&#45796;) . - 깃허브 데스크탑 history에서 이제껏 했던 커밋을 볼 수 있다. 게다가 삭제된 파일을 복구할 수 도 있다. . - 화면 캡쳐 프로그램으로 캡쳐를 함 --&gt; 마크다운에서 캡쳐한 이미지를 ctrl+v하면 캡쳐한 이미지가 삽입된다. . - 이미지 파일을 넣은 주피터 노트북 파일을 올리면 깃허브 notebook에는 올라가지만 블로그에는 올라가지 않는다. . &#49688;&#49885; &#44592;&#54840; &#54364;&#54788; . - 3.141592를 변수에 저장하고 싶음 . - pi = 3.141592 . - 그런데 pi 대신에 $ pi$를 사용하고 싶다면?? . - code셀에서 pi를 입력한 후 Tab을 누르면 됨 . pi = 3.141592 π = 3.141592 . pi . 3.141592 . π . 3.141592 . &#44611;&#54728;&#48652; &#45936;&#49828;&#53356;&#53457;&#50640;&#49436; &#50724;&#47448;&#44032; &#45228;&#45716;&#45936; &#47784;&#47476;&#44192;&#45796;. gg --&gt; &#54644;&#44208; &#50756;&#47308; . - 삭제하고 다시 처음부터 시작했다. . &#45236;&#44032; &#52286;&#50500;&#45240; &#47560;&#53356;&#45796;&#50868; &#50857;&#48277; . &#49688;&#49885;&#51012; &#47691;&#51080;&#44172; &#54364;&#54788;&#54616;&#44256; &#49910;&#45796;&#47732;?? . - $수식$ 꼴로 나타낸다. . - y = x^2 + 1 . - $y = x^2 +1$ . &#48145; &#52392;&#51088; &#54364;&#54788; . - $수식_밑첨자$ . - x_1 + x_2 = x_3 . - $x_1 + x_2 = x_3$ . &#50976;&#50857;&#54620; latex . boldsymbol . - applies to nearly all symbols, not just letters and numbers . - ex) $ boldsymbol{A} ,A$ . bf . - Used to turn on boldface; affects uppercase and lowercase letters, and digits . - ex) ${ bf 123} ,{123}$ . &#47588;&#50864; &#50976;&#50857;&#54620; &#47560;&#53356;&#45796;&#50868; &#49324;&#51060;&#53944; . - &lt;Jupyter 노트북에서 Markdown 및 LaTeX를 작성하는 방법 알아보기&gt; --&gt; https://ichi.pro/ko/jupyter-noteubug-eseo-markdown-mich-latexleul-jagseonghaneun-bangbeob-al-abogi-18246612521469 . - latex command 총 정리 --&gt; https://www.tutorialspoint.com/tex_commands/percentage.htm .",
            "url": "https://gkswotn12345.github.io/green/python/github/markdown/jupyter/2021/06/24/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4.html",
            "relUrl": "/python/github/markdown/jupyter/2021/06/24/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "백준 문제풀기",
            "content": ". &#49324;&#52825;&#50672;&#49328; . &#46160; &#51088;&#50672;&#49688; A&#50752; B&#44032; &#51452;&#50612;&#51652;&#45796;. &#51060;&#46412;, A+B, A-B, A*B, A/B(&#47787;), A%B(&#45208;&#47672;&#51648;)&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . a, b = map(int, input().split()) print(a+b) print(a-b) print(a*b) print(a//b) print(a%b) . 10 4 21 2 1 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . a, b = map(int, input().split()) print(a+b) . 12 . &#54217;&#44512;&#51008; &#45336;&#44192;&#51648; . 각 케이스마다 한 줄씩 평균을 넘는 학생들의 비율을 반올림하여 소수점 셋째 자리까지 출력한다. | . C = int(input()) for i in range(C): line = list(map(int, input().split())) mean = sum(line[1:]) / line[0] over_mean = [x for x in range(1, len(line)) if line[x] &gt; mean] over_mean_percent = len(over_mean) * 100 / line[0] print(&#39;{:.3f}%&#39;.format(over_mean_percent)) . 57.143% . . if&#47928; . &#46160; &#51221;&#49688; A&#50752; B&#44032; &#51452;&#50612;&#51276;&#51012; &#46412;, A&#50752; B&#47484; &#48708;&#44368;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . A, B = map(int, input().split()) if A&gt;B: print(&#39;&gt;&#39;) elif A&lt;B: print(&#39;&lt;&#39;) else: print(&#39;==&#39;) . &gt; . &#49884;&#54744; &#51216;&#49688;&#47484; &#51077;&#47141;&#48155;&#50500; 90 ~ 100&#51216;&#51008; A, 80 ~ 89&#51216;&#51008; B, 70 ~ 79&#51216;&#51008; C, 60 ~ 69&#51216;&#51008; D, &#45208;&#47672;&#51648; &#51216;&#49688;&#45716; F&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . def result(grade): if grade &gt;= 90 and grade &lt;= 100: print(&quot;A&quot;) elif grade &gt;= 80 and grade &lt;= 89: print(&quot;B&quot;) elif grade &gt;= 70 and grade &lt;= 79: print(&quot;C&quot;) elif grade &gt;= 60 and grade &lt;= 69: print(&quot;D&quot;) else: print(&quot;F&quot;) grade = int(input()) result(grade) . A . &#50672;&#46020;&#44032; &#51452;&#50612;&#51276;&#51012; &#46412;, &#50980;&#45380;&#51060;&#47732; 1, &#50500;&#45768;&#47732; 0&#51012; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다. . | 예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다. . | . def leap_year(year): if (year%4 ==0 and year%100 != 0) or year%400 == 0: print(1) else: print(0) year = int(input()) leap_year(year) . 1 . &#49324;&#48516;&#47732; &#44256;&#47476;&#44592; . 첫 줄에는 정수 x가 주어진다. (−1000 ≤ x ≤ 1000; x ≠ 0) 다음 줄에는 정수 y가 주어진다. (−1000 ≤ y ≤ 1000; y ≠ 0) . | 점 (x, y)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다. . | . def quadrant(a,b): if a&gt;0 and b&gt;0: print(1) elif a&gt;0 and b&lt;0: print(4) elif a&lt;0 and b&gt;0: print(2) elif a&lt;0 and b&lt;0: print(3) x = int(input()) y = int(input()) quadrant(x, y) . 4 . &#50508;&#46988; &#49884;&#44228; . 45분 일찍 알람 설정하기 | . h, m = map(int, input().split()) if m &gt;= 45: print(h, m-45) elif h == 0: print(23, m+15) else: print(h-1, m+15) . 23 40 . . for&#47928; . N&#51012; &#51077;&#47141;&#48155;&#51008; &#46244;, &#44396;&#44396;&#45800; N&#45800;&#51012; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. &#52636;&#47141; &#54805;&#49885;&#50640; &#47582;&#52656;&#49436; &#52636;&#47141;&#54616;&#47732; &#46108;&#45796;. . n = int(input()) for i in range(1,10): print(&#39;%s * %s = %s&#39; % (n, i, n*i)) . 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 첫째 줄에 테스트 케이스의 개수 T가 주어진다. . | 각 테스트 케이스마다 A+B를 출력한다. . | . T = int(input()) for i in range(T): A, B = map(int, input().split()) print(A+B) . 6 . 10 . 75 . n&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, 1&#48512;&#53552; n&#44620;&#51648; &#54633;&#51012; &#44396;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 반복문 있는 버전 | . n = int(input()) sum = 0 for i in range(1, n+1): sum += i print(sum) . 55 . 반복문 없는 버전 | . n = int(input()) print(int(n * (n+1) / 2)) . 55 . sys.stdin.readline() . 본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. . | 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다. . | Python을 사용하고 있다면 input() 대신 sys.stdin.readline()을 사용할 수 있다. . | 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우 .rstrip()을 추가로 해 주는 것이 좋다. . | . import sys T = int(input()) for i in range(T): A, B = map(int, sys.stdin.readline().split()) print(A+B) . ValueError Traceback (most recent call last) &lt;ipython-input-3-173fe188e1c6&gt; in &lt;module&gt; 2 T = int(input()) 3 for i in range(T): -&gt; 4 A, B = map(int, sys.stdin.readline().split()) 5 print(A+B) ValueError: not enough values to unpack (expected 2, got 0) . - error 왜 뜨지? . - sys.stdin.readline()를 쓸 때마다 에러가 난다. . &#51088;&#50672;&#49688; N&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, 1&#48512;&#53552; N&#44620;&#51648; &#54620; &#51460;&#50640; &#54616;&#45208;&#50473; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . N = int(input()) for i in range(1, N+1): print(i) . 1 2 3 4 5 . &#51088;&#50672;&#49688; N&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, N&#48512;&#53552; 1&#44620;&#51648; &#54620; &#51460;&#50640; &#54616;&#45208;&#50473; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . N = int(input()) for i in range(1, N+1): print(N-i+1) . 5 4 3 2 1 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 각 테스트 케이스마다 &quot;Case #x: &quot;를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다. | . import sys T = int(input()) for i in range(1, T+1): A, B = map(int, sys.stdin.readline().split()) print(&#39;Case #%s: %s&#39; % (i, A+B)) . Case #1: 6 . Case #2: 6 . Case #3: 8 . &#52395;&#51704; &#51460;&#50640;&#45716; &#48324; 1&#44060;, &#46168;&#51704; &#51460;&#50640;&#45716; &#48324; 2&#44060;, N&#48264;&#51704; &#51460;&#50640;&#45716; &#48324; N&#44060;&#47484; &#52237;&#45716; &#47928;&#51228; . 하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오. | . print&#54632;&#49688; &#50857;&#48277; . print(출력할 객체, end = &#39;함수가 종료될 때 실행하는 값&#39;) . | print()함수에서 end값을 따로 지정하지 않으면 끝을 줄바꿈 문자로 한다. . | . print(&#39;안녕&#39;, end = &#39;~~~~&#39;) print(&#39;하세요&#39;) . 안녕~~~~하세요 . N = int(input()) for i in range(N): for j in range(1, N-i): print(&quot; &quot;, end = &quot;&quot;) for k in range(i+1): print(&quot;*&quot;, end = &quot;&quot;) print(&quot; n&quot;, end = &quot;&quot;) . * ** *** **** ***** . &#51221;&#49688; N&#44060;&#47196; &#51060;&#47336;&#50612;&#51652; &#49688;&#50676; A&#50752; &#51221;&#49688; X&#44032; &#51452;&#50612;&#51652;&#45796;. &#51060;&#46412;, A&#50640;&#49436; X&#48372;&#45796; &#51089;&#51008; &#49688;&#47484; &#47784;&#46160; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 첫째 줄에 N과 X가 주어진다. (1 ≤ N, X ≤ 10,000) . | 둘째 줄에 수열 A를 이루는 정수 N개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다. . | X보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. X보다 작은 수는 적어도 하나 존재한다. . | . N, X = map(int, input().split()) A = list(map(int, input().split())) for i in range(N): if A[i] &lt; X: print(A[i], end = &quot; &quot;) . 1 0 . . while&#47928; . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 입력의 마지막에는 0 두 개가 들어온다. | . while True: A,B = map(int, input().split()) if A==0 and B==0: break else: print(A+B) . 2 . 4 . &#45908;&#54616;&#44592; &#49324;&#51060;&#53364; . 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. . | 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. . | 26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다. . | 위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다. . | N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.(0&lt;=N&lt;=99 인 정수) . | . n = N = int(input()) N_cycle = 0 while True: if N &lt; 10: N = int(2*str(N)) N_cycle += 1 else: N = int(str(N)[-1]+str(int(str(N)[0])+int(str(N)[-1]))[-1]) N_cycle += 1 if N == n: print(N_cycle) break . 60 . . &#54632;&#49688; . N&#44060;&#51032; &#54633; . 정수 n개가 주어졌을 때, n개의 합을 구하는 함수를 작성하시오. | . def solve1(a): sum = 0 for i in range(len(a)): sum += a[i] return(sum) . a=[0,1,2,3,4] solve1(a) . 10 . def solve2(a): return(sum(a)) . a=[0,1,2,3,4] solve2(a) . 10 . &#49472;&#54532; &#45336;&#48260; . 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다. | . z = set(range(1,10001)) - {x+sum([int(a) for a in str(x)]) for x in range(1,10001)} z = list(z) z.sort() for i in range(len(z)): print(z[i]) # 출력이 너무 길어서 출력은 생략 . &#54620;&#49688; . 어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. . | 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. . | N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오. . | . N = int(input()) def solve(a): if a &lt; 100: print(a) else: n = 99 for i in range(100, a+1): if int(str(i)[1]) - int(str(i)[0]) == int(str(i)[2]) - int(str(i)[1]): n += 1 print(n) solve(N) . 129 . . &#51116;&#44480;&#54632;&#49688;(&#51473;&#50836;&#54632; &#50500;&#47560;&#46020; &#44536;&#47532;&#44256; &#54775;&#44040;&#47548;) . - 재귀함수를 구상해보자. . - 재귀함수는 관계가 중요하다. . - 팩토리얼에서는 $fact(x)= x * fact(x-1)$ 관계가 성립한다. . - $fact(0), fact(1)$ 은 1이다. . - x가 0 또는 1일 때는 return을 1로 설정하고 나머지의 경우에는 $fact(x)= x * fact(x-1)$ 을 return한다면 재귀함수가 된다. . - 즉, 기본값 [$fact(0 or 1)=1$] 을 알고 관계식 [$fact(x)= x * fact(x-1)$] 을 안다면 재귀함수로 구현할 수 있다. . &#54057;&#53664;&#47532;&#50620; . 0보다 크거나 같은 정수 N이 주어진다. . | 이때, 재귀함수를 이용하여 N!을 출력하는 프로그램을 작성하시오. . | . N = int(input()) def fact(x): if x == 0 or x == 1: return 1 else: return x*fact(x-1) print(fact(N)) . &#54588;&#48372;&#45208;&#52824; &#49688;&#50676; . n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오. . | 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. . | 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. . | . N = int(input()) def fibo(x): if x == 0: return 0 elif x == 1: return 1 else: return fibo(x-1) + fibo(x-2) print(fibo(N)) . 55 . &#54588;&#48372;&#45208;&#52824; &#49688;&#50676; &#47700;&#47784;&#51060;&#51228;&#51060;&#49496; . 피보나치 재귀 함수의 경우 이미 구한 값을 구하기 위해 반복을 많이 해서 효율성이 떨어진다. . | 재귀 함수가 효율적이지 못하다면 메모이제이션을 사용한다. . | 재귀함수가 한 번 호출될 때마다 결과값을 저장하여 효율성을 높이는 것이 좋다. (메모이제이션) . | . N = int(input()) fibonacci = {0:0, 1:1} ## 메모이제이션을 위한 딕셔러니 선언 def fibo(x): if x in fibonacci: return fibonacci[x] fibonacci[x] = fibo(x-1) + fibo(x-2) return fibonacci[x] print(fibo(N)) . 55 . &#48324; &#52237;&#44592;(Pass) . N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다. . | 크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다. . | N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. . | . print(&#39;&#47928;&#51088;&#50676;&#39;) . $ star$ 과 $ star$ 사이에 빈칸이 있다. 이유는 ,(콤마) 때문이다. | . print(&#39;*&#39;, &#39;*&#39;, end = &quot;&quot;) . * * . ,(콤마)를 없애면 $ star$ 과 $ star$ 사이에 빈칸이 없다. | . print(&#39;*&#39; &#39;*&#39;, end = &quot;&quot;) . ** . def star(x): if x == 3: return print(&#39;*** n* * n***&#39;, end = &quot;&quot;) else: return ## *자리에 star(x/3)대입하면 될 줄 알았는데... . &#54616;&#45432;&#51060; &#53457; &#51060;&#46041; &#49692;&#49436; . 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. . | 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다. . | 첫째 줄에 옮긴 횟수 K를 출력한다. . | 두 번째 줄부터 수행 과정을 출력한다. . | . N = int(input()) def Hanoi(n,from_pos,to_pos,aux_pos): if n==1: print(from_pos,to_pos) else: Hanoi(n-1,from_pos,aux_pos,to_pos) print(from_pos,to_pos) ## 가장 큰 원반을 목적지로 이동 Hanoi(n-1,aux_pos,to_pos,from_pos) print(2**N-1) Hanoi(N,1,3,2) . 7 1 3 1 2 3 2 1 3 2 1 2 3 1 3 . . &#48652;&#47336;&#53944; &#54252;&#49828;(brute force) . - 완전탐색 알고리즘으로 가능한 모든 경우의 수를 탐색한다. --&gt; 100%확률로 정답 출력 . &#48660;&#47001;&#51117; . 기존 룰: 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. . | 변형 룰: N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오. . | . N, M = map(int,input().split()) card = list(map(int,input().split())) def blackjack(card,length,Max): card_list=[] for i in range(N): for j in range(N): for k in range(N): if i != j and j != k and i != k: if card[i]+card[j]+card[k] &lt;= Max: card_list.append(card[i]+card[j]+card[k]) print(max(card_list)) blackjack(card,N,M) ## 아쉬운점: for문3번사용 --&gt; O(n^3) . 21 . &#48516;&#54644;&#54633; . 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. . | 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. . | 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. . | 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. . | 반대로, 생성자가 여러 개인 자연수도 있을 수 있다. . | 자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오. . | . N = int(input()) def solve(x): list=[] for i in range(1, x+1): generator = i + sum([int(str(i)[j]) for j in range(len(str(i)))]) if generator == x: list.append(i) if len(list) &gt; 0: return(min(list)) else: return 0 print(solve(N)) . 198 . &#51076;&#51032;&#51032; &#49707;&#51088;&#51032; (&#44033; &#51088;&#47551;&#49688; + &#51088;&#44592; &#51088;&#49888;) . x=12345 sum([int(str(x)[i]) for i in range(len(str(x)))])+x ### 리스트 컴프리헨션 . 12360 . IQ Test(&#48145;&#50640; &#49345;&#54889; &#46412;&#47928;&#50640; &#48152;&#47168; &#52286;&#50500; &#48420;&#51020;) + &#47582;&#45716; &#44163; &#44057;&#51008;&#45936; &#44228;&#49549; &#53952;&#47548;..., &#44536;&#47000;&#49436; &#45796;&#47480; &#49324;&#46988; &#53076;&#46300; &#48420;&#45716;&#45936; &#50780; &#53952;&#47160;&#45716;&#51648; &#47784;&#47476;&#44192;&#51020;. . IQ Test의 문제 중에는 공통된 패턴을 찾는 문제가 있다. 수열이 주어졌을 때 다음 수를 찾는 문제이다. . | 예를 들어 1, 2, 3, 4, 5가 주어졌다. 다음 수는 무엇인가? 당연히 답은 6이다. . | 약간 더 어려운 문제를 보면 3, 6, 12, 24, 48이 주어졌을 때 다음 수는 무엇인가? 역시 답은 96이다. . | 이제 제일 어려운 문제를 보자. . | 1, 4, 13, 40이 주어졌을 때 다음 수는 무엇일까? 답은 121이다. . | 그 이유는 항상 다음 수는 앞 수 * 3 + 1이기 때문이다. . | 은진이는 위의 3문제를 모두 풀지 못했으므로 자동으로 풀어주는 프로그램을 작성하기로 했다. . | 항상 모든 답은 구하는 규칙은 앞 수 * a + b이다. 그리고 a와 b는 정수이다. . | 수 N개가 주어졌을 때 규칙에 맞는 다음 수를 구하는 프로그램을 작성하시오. . | . - N은 2여도 1, 1 과 같이 답이 있을 수 있다. . - 일반적으로 N = 2이면 다음 수는 여러개이다, . - $1, 2$ --&gt; 다음 수 $3(a=0, b=1)$ or $-8(a=-10, b=12)$ 등등 . - a, b 둘다 0일 수 도 있음 . - 스파게티 코드 + 틀렸습니다 . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule(x): if len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif len(x) == 2 and x[0] == x[1]: return x[0] if len(x) == 1: return &#39;A&#39; if x[0] == x[1] == x[2] : a = 0 elif x[1] == x[0] and x[1] != x[2]: return &#39;B&#39; else: a = (x[2] - x[1]) / (x[1] - x[0]) b = x[1] - a * x[0] for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; elif x[i+1] == 0: ## 이 부분이 문제였다. x[i+1] == 0이면 그 뒤는 확인 안하고 return 0 실행 return 0 return int(a * x[-1] + b) print(sequence_rule(N_list)) . - 위에 있는 코드를 정리하자 . - 틀렸습니다 . - exit(0) --&gt; python 프로그램 종료 . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule2(x): if len(x) == 1: return A elif len(x) == 2 and x[0] == x[1]: return x[1] elif len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 else: a = (x[1] - x[2]) / (x[0] - x[1]) b = x[1] - x[0] * a for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; return (int(a * x[-1] + b)) print(sequence_rule2(N_list)) . 13 . - continue --&gt; 아래 코드를 실행하지 않고 건너뜀 . for i in range(10): # 0부터 99까지 증가하면서 100번 반복 if i % 2 == 0: # i를 2로 나누었을 때 나머지가 0면 짝수 continue # 아래 코드를 실행하지 않고 건너뜀 print(i) . 1 3 5 7 9 . - 맞았습니다(3시간 걸림 힘들다) . - 위의 코드와 밑의 코드는 무슨 차이일까... . N = int(input()) x = list(map(int, input().split())) if N == 1: print(&#39;A&#39;) elif N == 2: if x[0] == x[1]: print(x[0]) else: print(&#39;A&#39;) else: if x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 b = x[1] else: a = (x[2] - x[1]) // (x[1] - x[0]) b = x[1] - x[0] * a result = True for i in range(N - 1): if x[i] * a + b == x[i+1]: continue else: result = False if result: print(a * x[-1] + b) else: print(&#39;B&#39;) . 121 . &#50689;&#54868;&#44048;&#46021; &#49676; . 종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. . | 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다. . | 숌이 만든 ($N leq10000$)번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. . | . - $N leq 10000$ --&gt; 계산 결과 영화제목은 최대 7자리 . - 7자리 수까지 666을 포함하는 수를 모두 생성한 후 오름차순으로 정렬 . - 문제점: 666xxx 같은 수를 표현한다고 치자 --&gt; 이때 xxx = 010이라면 자연수가 아니므로 010을 수로 표현할 수 없음 . - 666xxx --&gt; 66600x + 6660xx . - 하지만 좋은 방법이 떠오름 . - 666xxx --&gt; 66yxxx , y = 6이므로 yxxx =&gt; range(6000,7000) . - 위와 같이 표현하면 666010도 표현 가능! . import math result = [666] result.extend([int(str(i) + &#39;666&#39;) for i in range(1, 3000)]) ## x666, xy666, xyy666, 1yyy666, 2yyy666 --&gt; 앞으로 나오는 x는 자연수, y는 0포함 result.extend([int(&#39;66&#39; + str(i)) for i in range(6000,7000)]) ## 666yyy result.extend([int(&#39;66&#39; + str(i)) for i in range(600, 700)]) ## 666yy result.extend([int(&#39;666&#39; + str(i)) for i in range(10)]) ## 666y result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 30) for j in range(600, 700)]) ## x666yy, 1y666yy, 2y666yy result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 100) for j in range(60, 70)]) ## x666y, xy666y result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 3) for j in range(6000, 7000)]) ## 1666yyy, 2666yyy result.extend([int(str(i) + &#39;666&#39; + str(j)) for i in range(100, 300) for j in range(10)]) ## 1yy666y, 2yy666y result.extend([int(str(i) + &#39;666&#39;) for i in range(1000, 3000)]) ## 1yyy666, 2yyy666 result = list(set(result)) result.sort() N = int(input()) print(result[N-1]) . 1666 . - 다른 사람 아이디어 보고 만든 코드 --&gt; 내 코드보다 코드 길이가 10배 짧아서 10배 좋다고 생각할라 했는데 시간이 너무 오래 걸리네? --&gt; 내 실수인 걸로 할라 했는데 숏코딩 보니까 다른 사람도 시간이 오래 걸렸다. . - 종말의 수는 $10000$개가 최대이므로 아무거 커도 $3000000$ 이하이다. . - $3000000$까지의 숫자 중 $666$을 포함하면 새로운 리스트에 포함한다. . result = [] result.extend([int(str(i)) for i in range(666,3000000) if str(i).find(&#39;666&#39;) != -1]) N = int(input()) print(result[N-1]) . 1666 . - 숏코딩으로 만들었음(가독성 쓰레기) . print([i for i in range(9**7)if&#39;666&#39;in str(i)][int(input())-1]) . 1666 . &#52404;&#49828;&#54032; &#45796;&#49884; &#52832;&#54616;&#44592; . $8 times8$ 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠한다. | 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오. | . - 밑에 있는 코드 왜 틀림??????????????? . - W로 채워진 8$ times$8 체스판을 input 하면 답이 32가 나와야 하는데 chess1, chess2 = 24, 25가 나온다.(원인 불명) . - 아 왜 틀렸냐고... 안해 다른 거 할 거야 . N, M = map(int, input().split()) data = [] for i in range(N): data.append(list(input())) def chess(n, m): x, y = 0, 7 chess_list = [] while x &lt; n - 7 and y &lt; n: a, b = 0, 7 while a &lt; m - 7 and b &lt; m: chess1, chess2 = 0, 0 for i in range(x, y): for j in range(a, b): if (a + x) % 2 ==0: if (i + j) % 2 == 0: if data[i][j] == &#39;B&#39;: chess1 += 1 else: chess2 += 1 if (i + j) % 2 == 1: if data[i][j] == &#39;B&#39;: chess2 += 1 else: chess1 += 1 else: if (i + j) % 2 == 0: if data[i][j] == &#39;B&#39;: chess2 += 1 else: chess1 += 1 if (i + j) % 2 == 1: if data[i][j] == &#39;B&#39;: chess1 += 1 else: chess2 += 1 chess_list.extend([chess1, chess2]) a += 1 b += 1 x += 1 y += 1 print(chess_list) chess(N, M) . - input . 8, 8 . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . - output . [24, 25] . &#45929;&#52824;(7568&#48264;) . N = int(input()) body = [] for i in range(N): body.append(list(map(int,input().split()))) for i in range(N): rank = 1 for j in range(N): if body[i][0] &lt; body[j][0] and body[i][1] &lt; body[j][1]: rank += 1 print(rank, end = &quot; &quot;) . 2 2 1 2 5 . a=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;] x=&#39; &#39;.join(a) a=1,2,3 print(a) . (1, 2, 3) . . &#49548;&#49688; . &#50500;&#54028;&#53944; &#51076;&#45824;(5615&#48264;) --&gt; &#49884;&#44036; &#52488;&#44284; pass . 아파트 면적은 $2xy+x+y = k$ --&gt; 2k+1 = (2x+1)(2y+1) , $x,y$는 양의 정수 . | 즉, 아파트 면적을 k라 할 때 2k+1은 합성수이다. . | 만약, $2k+1$이 소수라면 잘못된 아파트 면적이다. . | . &#49548;&#49688; &#54032;&#48324; . def Is_prime_number(a): from math import sqrt for i in range(2,int(sqrt(a)+1)): if a%i==0: return True else: return False . from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return False else: return True def apart(n): sum = 0 for i in range(n): x = int(input()) if Is_prime_number(2*x+1) == True: sum +=1 return(sum) N = int(input()) apart(N) . - error: 이렇게 코드를 짜면 N에 어떤 수를 대입해도 if Is_prime_number(2*x+1) == True 부분이 항상 참이여서 sum += 1이 실행된다.(원인불명) . from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return 0 else: return 1 def apart(n): sum = 0 for i in range(n): x = int(input()) if Is_prime_number(2*x+1) == 1: sum += 1 return(sum) N = int(input()) apart(N) . - error: 이렇게 코드를 짜면 N에 어떤 수를 대입해도 if Is_prime_number(2*x+1) == True 부분이 항상 참이여서 sum += 1이 실행된다.(마찬가지로 원인불명) . - 아파트 임대 --&gt; 시간 초과 코드 . import sys from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return False return True def apart(n): sum = 0 for i in range(n): x = int(sys.stdin.readline()) if Is_prime_number(2*x+1) == 1: sum += 1 return(sum) N = int(input()) apart(N) . 2 . &#49548;&#49688;&#54032;&#51221; &#51032;&#47928;&#51216; . def is_prime_number(x): # 2부터 x의 제곱근까지의 모든 수를 확인하며 for i in range(2, int(sqrt(x)) + 1): # x가 해당 수로 나누어떨어진다면 if x % i == 0: return False # 소수가 아님 return True # 소수임 . - 위에 코드는 문제가 없다.$ ,$ x에 2나 3을 넣어도 잘 작동함. . def is_prime_number(x): # 2부터 x의 제곱근까지의 모든 수를 확인하며 for i in range(2, int(sqrt(x)) + 1): # x가 해당 수로 나누어떨어진다면 if x % i == 0: return False # 소수가 아님 else: return True # 소수임 . - 위에 코드는 문제가 있다. x에 2나 3을 넣으면 return이 없다. . - 아마 2나 3을 넣으면 range(2,1) 이 돼서 그럴 것이다. . &#54028;&#51060;&#50028; &#53076;&#46300; &#49892;&#54665; &#49884;&#44036; &#52769;&#51221; . import time start = time.time() ## 시작 시간 저장 ## --작업 코드-- print(&quot;time :&quot;, time.time() - start) . &#49548;&#49688; &#52286;&#44592;1 . 주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오. | . N = int(input()) def Is_prime_num(x): if x == 1: return False for i in range(2, int(x**0.5) + 1): if x % i == 0: return False return True prime_num = 0 num_list = list(map(int, input().split())) for i in range(N): if Is_prime_num(num_list[i]) == True: prime_num += 1 print(prime_num) . 3 . &#49548;&#49688; &#52286;&#44592;2 . 자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오. . | 만약 N과 M사이에 소수가 없다면 1을 출력하시오. . | . N = int(input()) M = int(input()) def Is_prime_num(x): if x == 1: return False for i in range(2, int(x**0.5)+1): if x % i == 0: return False return True prime_list = [] for j in range(N, M+1): if Is_prime_num(j) == True: prime_list.append(j) if len(prime_list) == 0: print(-1) else: print(sum(prime_list)) print(min(prime_list)) . 620 61 . &#50640;&#46972;&#53664;&#49828;&#53580;&#45348;&#49828;&#51032; &#52404;&#47484; &#53685;&#54620; &#49548;&#49688; &#52286;&#44592;(&#49548;&#49688; &#52286;&#44592;2 &#45796;&#47480; &#54400;&#51060;) . - N과M은 10000이하의 자연수 이므로 미리 에라토스테네스의 체를 통해 소수를 구해놓자 . N = int(input()) M = int(input()) n = 10000 m = int(n**0.5) prime_list = [False, False] + [True] * (n-1) for i in range(2, m+1): if prime_list[i] == True: for j in range(2*i, n+1, i): prime_list[j] = False prime_num_list = [ x for x in range(N, M+1) if prime_list[x] == True] if len(prime_num_list) == 0: print(-1) else: print(sum(prime_num_list)) print(min(prime_num_list)) . 620 61 . if prime_list[i] == True: . - 위 부분은 아래와 같이 해도 됨 . if prime_list[i]: . prime_list[i] 자체가 True or False임 . &#49548;&#51064;&#49688;&#48516;&#54644; . 정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오. | . import sys n = 3164 m = int(n**0.5) prime_nums = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_nums[i] == True: for j in range(2*i, n+1, i): prime_nums[j] = False N = int(input()) M = int(N**0.5) def factorization_into_primes(x): if x == 1: sys.exit(0) stack = 0 mul = 1 for k in range(2, M+1): if prime_nums[k] == False: continue else: l = x/k while l == int(l): print(k) mul *= k stack += 1 l = l/k if stack == 0: print(x) elif mul != N: print(int(x/mul)) . 7 11 13 . &#49548;&#49688; &#44396;&#54616;&#44592; . M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오. | . n = 1000000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False M, N = map(int, input().split()) prime_num = [x for x in range(M, N+1) if prime_num_list[x] == True] for k in range(len(prime_num)): print(prime_num[k]) . 3 5 7 11 13 . &#48288;&#47476;&#53944;&#46993; &#44277;&#51456; . 베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다. . | 예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23) . | 자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오. . | . n = 123456 * 2 m = int(n**0.5) prime_nums = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_nums[i] == True: for j in range(2*i, n+1, i): prime_nums[j] = False def prime_number(num): print(len([x for x in range(num+1, 2*num+1) if prime_nums[x] == True])) while True: n = int(input()) if n == 0: break prime_number(n) . 1 . 4 . 3 . 21 . 135 . 1033 . 8392 . &#44264;&#46300;&#48148;&#55120;&#51032; &#52628;&#52769; . 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다. . | 2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오. . | 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다. . | . - 신기한점 . n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False prime_num = [x for x in range(2, n+1) if prime_num_list[x] == True] ### 여기까지 동일 last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True].reverse() type(last_prime_num) . - 위의 코드에서 type(last_prime_num)의 결과는 Nonetype임 . ### 동일 부분 생략 last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True] last_prime_num.reverse() type(last_prime_num) . - 위의 코드에서 type(last_prime_num)의 결과는 list임 . - 무슨 차이일까? . n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False prime_num = [x for x in range(2, n+1) if prime_num_list[x] == True] last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True] last_prime_num.reverse() p = len(prime_num) T = int(input()) for i in range(T): N = int(input()) for j in range(N//2, N+1): if j in prime_num and N - j in prime_num: print(N - j, j) break . 5 7 . - 위의 코드는 시간이 매우 오래 걸리는 쓰레기임 . - 새로 만들었음 . - 시간이 $ frac{1}{4}$ 이 됐다: 2344ms --&gt; 556ms . n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i]: for j in range(2*i, n+1, i): prime_num_list[j] = False T = int(input()) for i in range(T): N = int(sys.) for j in range(N//2, N+1): if prime_num_list[j] and prime_num_list[N - j]: print(N - j, j) break . 5 7 . - 더 줄이고 싶다 . - 시간이 96ms로 단축됨 . - [$ star star star$] 여러번 반복하여 입력을 받는 경우에는 input() 대신 sys.stdin.readline() 사용 [$ star star star$] . . &#44592;&#48376; &#49688;&#54617;1 (&#49884;&#44036; &#52488;&#44284; &#51452;&#51032;) . &#45804;&#54077;&#51060;&#45716; &#50732;&#46972;&#44032;&#44256; &#49910;&#45796;. . 땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다. . | 달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다. . | 달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오. . | . - 달팽이는 올라가고 싶다 --&gt; 시간 초과 코드(while 반복문 사용) . A, B, V = map(int,input().split()) ### 시간 초과 day = 1 h = 0 while 1: h += A if h &gt;= V: break h -= B day += 1 print(day) . 25 . - 달팽이는 올라가고 싶다 --&gt; 시간 초과 해결한 코드(한 줄 수식) . import math A, B, V = map(int,input().split()) ### 시간 초과 해결 print(math.ceil((V-A)/(A-B))+1) . 25 . &#49552;&#51061;&#48516;&#44592;&#51216; . A는 고정 비용, B는 가변 비용, C는 수익, k는 판매량 . | $C*k &gt; A + B*k$ --&gt; $k &gt; frac{A}{C-B}$ . | . A, B, C = map(int, input().split()) if abs(C-B) &lt; 0.5: ### C == B 여부를 판단 print(-1) elif int(A/(C-B)) &lt; 0: print(-1) else: print(int(A/(C-B)) + 1) . -1 . - 위에 코드보다 더 간결한 코드 . - A에 관계없이 B &gt;= C이면 손익분기점이 없다. . A, B, C = map(int, input().split()) if B &gt;= C: ### C == B 여부를 판단 print(-1) else: print(int(A/(C-B)) + 1) . 11 . Fly me to the Alpha Centauri . 시작할 땐 1만큼 도착할 때도 1만큼 이동 . | k만큼 이동한 후에 k-1 or k or k+1 만큼 이동 가능 . | . - 이동 횟수를 최소화할려면? . - $x지점(출발=0) to{1} to{2} to{3} to dots to{n} to{n-1} to dots to{2} to{1} to{y지점}(도착=0)$ . - $이동 ,거리 = sum_{i=1}^{n}{k} + sum_{i=1}^{n-1}{k} = frac{n(n+1)}{2} + frac{(n-1)n}{2} = n^2$ . - $y-x = n^2$ . - $이동 ,횟수 = 화살표의 ,개수 = n+(n-1)=2n-1$ . - 즉 $n^2$의 거리를 이동하기 위한 최소한의 이동 횟수는 $2n-1$이다. . - 바꿔말하면 $2n-1$번의 이동으로 갈 수 있는 최대 거리는 $n^2$이다. . - 위에 방법에 기반하여 정리를 해봤다. . - 위에서는 이동 거리가 $n^2$에 대해서 고려했다. 하지만 이동 거리가 제곱수가 아닐 수 도 있다. . - 예로 이동 거리가 110이면 이동 횟수는 $ sqrt{100} leq sqrt{110} leq sqrt{121}$ 이므로 10 or 11 or 12이다. . - $n^2 = 1+1+2+2+ dots+(n-1)+(n-1)+n$ 이다. . - 100 과 121의 차이는 21 = 10 + 11 --&gt; 100은 이동 횟수 $2n-1=19$, 101$ sim$110 은 $2n=20$, 111$ sim$121은 $2n+1=21$이다. . T = int(input()) for i in range(T): x, y = map(int, input().split()) n = y - x m = int(n**0.5) if n**0.5 == m: print(2*m - 1) elif n - m**2 &lt;= m: print(2*m) else: print(2*m + 1) . 3 . 3 . 4 . &#49444;&#53461; &#48176;&#45804; . 상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. . | 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다. . | 상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. . | 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 된다. . | 하지만 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다. . | 상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오. . | 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다. . | . - 봉지를 최소화 해야 한다. --&gt; 5kg 봉지를 최대한 많이 써야 한다. . - 설탕의 무게를 5로 나눈다. . - 만약 5로 나눠지면 끝이다. 그러지 않다면 5kg 봉지를 하나씩 줄여나가고 나머지를 3kg 봉지로 담는다. . - 5kg 봉지를 하나씩 줄이다가 0이 됐다면 전부 3kg 봉지를 사용한다. . - 그래도 안된다면 정확하게 Nkg을 만드는 것이 불가능하므로 -1을 출력한다. . N = int(input()) def sugar(n): k = n//5 l = n % 5 if l == 0: return k else: n = n - k*5 if n % 3 ==0: return k + 1 else: n = n - (k-1)*5 if n % 3 ==0: return k - 1 + n//3 else: n = n - (k-2)*5 if n % 3 == 0: return k - 2 + n//3 else: n = n -(k-3)*5 if n % 3 ==0: return k - 3 + n//3 else: ...... if n &lt; 0: return -1 . 이런식으로 전개될 것이다. | . N = int(input()) def sugar(n): k = n // 5 l = n % 5 for i in range(k+1): if l == 0: return k break elif l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 201 . - 코드를 둘러보던 중 위의 코드가 비효율적이라 느껴졌다 . - 왜냐하면 for문에서 if l == 0: 은 처음 한 번 해서 False이면 영원히 False이다 --&gt; else: l += 5 때문 . - 하지만 for문 안에 있어서 k+1번 쓸모없는 행위를 반복해야 한다. . - 그래서 아래와 같이 수정했다 . - 그런데 시간이 64ms 에서 72ms가 됐다??? . N = int(input()) def sugar(n): k = n // 5 l = n % 5 if l == 0: return k for i in range(k+1): if l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 201 . print &#50752; return &#51032; &#52264;&#51060;(&#44036;&#45800;&#55176;) . - return 은 종료문이다. 함수에서 return을 만나면 함수가 종료된다. . - 그렇기에 return이 여러개여도 하나만 반환된다. . - 여러 값을 반환하고 싶다면 return a,b,c, $ dots$ . - print()는 그렇지 않다. . - 위에 설탕배달 코드에서 return을 print()로 바꾼다면 항상 -1을 출력하지만 . - return이기 때문에 return k or return k + l//3이 실행되지 않을 때만 return -1이 실행된다. . &#48516;&#49688;&#52286;&#44592; . 이와 같이 나열된 분수들을 1/1 -&gt; 1/2 -&gt; 2/1 -&gt; 3/1 -&gt; 2/2 -&gt; … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자. . | X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오. . | . - 분모 + 분자 = n + 1인 분수가 n개 있다. . - 분모 + 분자가 2인 분수가 1개, 3인 분수가 2개, 4인 분수가 3개, $ dots$, n+1인 분수가 n개 . - 분모 + 분자가 $n+1$인 끝점: $1+2+3+ dots+n-2+n-1+n$ . x = int(input()) n = int((x * 2) ** 0.5) k = n * (n + 1) // 2 a = k - x if a &lt; 0: n += 1 k += n a = k - x if n % 2 == 0: print(str(n-a)+&#39;/&#39;+str(1+a)) else: print(str(1+a)+&#39;/&#39;+str(n-a)) . 4 10 4 15 5/1 . &#49688;&#54617;&#51008; &#48708;&#45824;&#47732;&#44053;&#51032;&#51077;&#45768;&#45796;(19532&#48264;) . - 백준은 내부 라이브러리만 사용 가능, numpy는 외부 라이브러리라 사용 불가능 . import numpy as np a, b, c, d, e, f = map(int, input().split()) array1 = np.array([[a, b], [d, e]]) array2 = np.array([c, f]) x, y = np.linalg.inv(array1) @ array2 print(round(x), round(y)) . - 연립 일차 방정식을 행렬을 통해 풀어 보자 . a, b, c, d, e, f = map(int, input().split()) det = a * e - b * d print(round((e * c - f *b ) / det), round((a * f - c * d) / det)) . -1 2 . &#48512;&#45376;&#54924;&#51109;&#51060; &#46112;&#53580;&#50556; . 아파트에 거주를 하려면 조건이 있는데 . | a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다 . | 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다 . | . - a층의 b호 사람 수 = a층의 b-1호 사람 수 + a-1층의 b호 사람 수 . - 기본적으로 생각하면 0층 b호에는 n명이 살고 a층 1호에는 1명이 a층 2호에는 a+2명이 산다. . - 점화식을 알고 있으므로 재귀 함수를 사용했음 . - 호출을 여러 번 해야해서 좋지 않음 . - 시간 초과에 걸림 . def apart(a, b): if a == 0: return b if b == 1: return 1 return apart(a, b - 1) + apart(a - 1, b) T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart(k, n)) . 37442160 . - 이미 구한 층,호수 사람 수는 기록하는 방법 사용(메모이제이션) . - 똑같이 시간 초과 . List = [[0] * 14 for _ in range(15)] List[0] = [x for x in range(1, 15)] for i in range(len(List)): List[i][0] = 1 for j in range(len(List)): List[j][1] = j + 2 def apart(a, b): if List[a][b - 1] != 0: return List[a][b - 1] return apart(a, b - 1) + apart(a - 1, b) T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart(k, n)) . 37442160 . - 난 위의 코드가 메모이제이션인 것 같았다. . - 근데 처음 짠 코드와 다른 게 없었다. 메모이제이션이 아닌 가 보다. . - 수학으로 풀려면 계차수열을 사용해야 하는데 복잡해 보인다. . - 그래서 이번에는 처음부터 아파트를 채워놓고 시작하는 방법을 사용했다. . - 층과 호수를 입력하면 채워진 아파트에서 그 층과 호수에 사는 사람 수를 출력한다. . - 최대 사람수가 사는 14층 14호를 입력하면 첫 번째와 두 번째 코드는 2초 정도 걸렸는데 이 코드는 바로 출력된다. . - 시간 초과 해결 . apart = [[0] * 14 for _ in range(15)] apart[0] = [x for x in range(1, 15)] x = len(apart) for i in range(x): apart[i][0] = 1 for j in range(x): apart[j][1] = j + 2 for i in range(1, x): for j in range(1, x - 1): apart[i][j] = apart[i][j-1] + apart[i - 1][j] T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart[k][n - 1]) . 37442160 . . &#44592;&#48376; &#49688;&#54617; 2 -- &#44592;&#54616; . &#53552;&#47131;(&#52280;&#44256;&#54644;&#49436; &#54400;&#50632;&#51020;) . 두 원의 중심과 반지름이 각각 주어졌을 때 교점의 개수를 출력하시오 | . - 두 점에서 만나는 경우 . r1 + r2 &gt; d and abs(r1 - r2) &lt; d . - 두 원의 위치관계 참고 : https://mathbang.net/101 . T = int(input()) for i in range(T): x1, y1, r1, x2, y2, r2 = map(int, input().split()) d = ((x1 - x2)**2 + (y1 - y2)**2)**0.5 if d == 0: if r1 == r2: print(-1) else: print(0) elif r1 + r2 &lt; d: print(0) elif r1 + r2 &gt; d and abs(r1 -r2) &lt; d: print(2) elif r1 + r2 == d: print(1) elif abs(r2 - r1) == d: print(1) elif abs(r2 - r1) &gt; d: print(0) . 2 . 1 . 0 . &#53469;&#49884; &#44592;&#54616;&#54617; . 택시 기하학에서 두 점 $T_1(x_1,y_1)$, $T_2(x_2,y_2)$ 사이의 거리는 다음과 같이 구할 수 있다. . | $D(T_1, T_2) = |x_1 - x_2| + |y_1 - y_2|$ . | 첫째 줄에는 유클리드 기하학에서 반지름이 R인 원의 넓이를, 둘째 줄에는 택시 기하학에서 반지름이 R인 원의 넓이를 출력한다. . | . - 반지름이 $R$일 때 원은 $|x_1 - x_2| + |y_1 - y_2| = R$의 자취임 . - 이를 그려본면 택시 기하학에서 원은 마름모임을 쉽게 알 수 있음 . - 넓이는 $ frac{2R times 2R}{2} = 2R^2$ . import math R = int(input()) π = math.pi print(π*R**2) print(2*R**2) . 1385.4423602330987 882 . . &#51221;&#47148; . &#49688; &#51221;&#47148;&#54616;&#44592; . N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. | . - 선택 정렬 . N = int(input()) List = [] for i in range(N): num = int(input()) List.append(num) n = len(List) for j in range(n): min_idx = j for k in range(j + 1, n): if List[k] &lt; List[min_idx]: min_idx = k List[j], List[min_idx] = List[min_idx], List[j] print(List[j]) . 1 2 3 4 5 . - 내장 함수 ?.sort() . N = int(input()) List = [] for i in range(N): num = int(input()) List.append(num) List.sort() for j in range(len(List)): print(List[j]) . 1 2 3 4 5 .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "relUrl": "/python/algorithm/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "파이썬 딥러닝",
            "content": "&#53584;&#49436;&#54540;&#47196; . 무지성 코드(예쩨 그대로 복붙 손으로) | . import tensorflow as tf W = tf.Variable(tf.ones(shape=(2,2)), name = &quot;W&quot;) b = tf.Variable(tf.zeros(shape=(2)), name = &quot;b&quot;) @tf.function def model(x): return W * x + b out_a = model([1,0]) print(out_a) . tf.Tensor( [[1. 0.] [1. 0.]], shape=(2, 2), dtype=float32) . &#52488;&#54217;&#47732;(&#44036;&#45800;&#55176;) . 평면의 단면은 직선, 부피의 단면은 평면, 그 이상은??? | 직선($ax + by + c = 0$)은 2차원의 초평면, 평면($ax + by + cz + d = 0$)은 3차원의 초평면 | $a_1x_1 + a_2x_2 + a_3x_3 + a_4x_4 + c = 0$ 는 뭐라고 불러야 돼??? --&gt; 4차원 공간에 그려짐 | 평면을 일반화하여 초평면을 만듦 | n차원의 그려진 초평면 --&gt; n-1차원 공간 | 초평면은 공간을 분할하는 역할 --&gt; 직선은 평면을 분할, 평면은 공간을 분할 | [$ ast$] n차원의 초평면은 n차원을 분할 [$ ast$] | . &#54140;&#49481;&#53944;&#47200; .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/23/%EB%94%A5%EB%9F%AC%EB%8B%9D.html",
            "relUrl": "/python/2021/06/23/%EB%94%A5%EB%9F%AC%EB%8B%9D.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "map 함수",
            "content": "map &#54632;&#49688; &#53945;&#51669; . - 여러 개의 데이터를 한 번에 다른 형태로 변화하기 위해 사용한다. . - map 함수는 원본 리스트를 변경하지 않고 새 리스트를 생성한다. . - map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환해야 한다. . - map 함수는 리스트의 요소를 지정된 함수로 처리한다. . x=list(range(5)) x . [0, 1, 2, 3, 4] . def two_times(x): return x*2 . y=two_times(x) y . [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] . z=list(map(two_times, x)) z . [0, 2, 4, 6, 8] . map &#54632;&#49688; &#49324;&#50857;&#48277; . - map(함수, 반복가능한 객체) . x = [1.1, 2.1, 3.1, 4.1] y = map(int, x) print(y) . &lt;map object at 0x0000023B6D93D040&gt; . - map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환한다. $ rightarrow [ star$] 변환하지 않으면 위와 같은 결과를 출력한다. [$ star$] . - print(y)하지 않고 그냥 y만 입력해도 된다. . x = [1.1, 2.1, 3.1, 4.1] y = list(map(int, x)) y . [1, 2, 3, 4] . def minus(a): return a - 0.1 . list(map(minus, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . - minus 함수는 map 함수를 위해 한 번 쓰고 버려질 운명이다. 만드는게 귀찮음... . map &#54632;&#49688;&#50640; &#46988;&#45796; &#49885; &#49324;&#50857; . x = [1.1, 2.1, 3.1, 4.1] list(map(lambda a: a - 0.1, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . input().split()&#44284; map . - input()함수는 c언어의 scanf()함수와 비슷하다. . z = input() . z . &#39;hello&#39; . - input()으로 입력받은 값은 문자열이다. . n = input() . type(n) . str . - input()함수에서 안내문구를 추가할 수 도 있다. . Q = input(&#39;숫자 하나를 입력하세요:&#39;) . Q . &#39;26&#39; . - input()함수의 출력값을 문자열이 아닌 다른 자료형으로 바꾸고 싶다면? . w = int(input(&#39;숫자 하나를 입력하세요:&#39;)) . type(w) . int . - input().split(&quot;기준문자열&quot;)을 사용하면 입력값을 변수 여러 개에 저장할 수 있다. . - split()에서 &quot;기준문자열&quot;이 없는 즉 default는 공백이다. . a, b = input().split() # 입력받은 값을 공백(스페이스, 탭, 엔터 등)을 기준으로 분리 . a, b . (&#39;10&#39;, &#39;20&#39;) . c = a, b type(c) . tuple . - a와b가 문자열이다. . - int형으로 바꾸고 싶다면? . a, b = int(input().split()) . TypeError Traceback (most recent call last) &lt;ipython-input-17-0de5d52cb787&gt; in &lt;module&gt; -&gt; 1 a, b = int(input().split()) TypeError: int() argument must be a string, a bytes-like object or a number, not &#39;list&#39; . - int()함수를 쓰면 될 것 같았는데 오류가 나온다 . - error메시지를 읽어보니 int()함수는 무조건 a string, a bytes-like object or a number 여야 한다.(not &#39;list&#39;) . - a, b는 tuple인 것 같다. . - 그러면 어떻게 하지? $ longrightarrow$ map()함수를 쓰면 된다. . a, b = map(int, input().split()) # 입력받은 값을 정수로 변환 . a, b . (10, 20) . type(a) . int . type(b) . int . - a, b = map(int, input().split())을 풀어서 쓰면 다음과 같은 코드이다. . x = input().split() # input().split()의 결과는 문자열 리스트 m = map(int, x) # 리스트의 요소를 int형으로 변환, 결과는 맵 객체 a, b = m # 맵 객체는 변수 여러 개에 저장 가능 . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#54620; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . L = list(map(int, input().split())) L . [10, 8, 7, 1, 0, 3, 5, 2] . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#50668;&#47084; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . data = [] N = int(input()) for i in range(N): data.append(list(map(int,input().split()))) . data . [[1, 4, 0, 2], [17, 8, 1, 0, 4, 6], [1, 0], [0, 4, 5], [0, 0, 10]] .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "date": " • Jun 21, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "파이썬 기말시험",
            "content": "import pandas as pd import numpy as np class nexon(): &#39;&#39;&#39; 202016248 통계학과 한재수 파이썬 기말시험 1번 문제에 대한 코드 &#39;&#39;&#39; def __init__(self): self.upgradestate = pd.DataFrame({&#39;day0&#39;:[0]*100}) self.prob = 0.3 self.i = 1 def attempt(self): self.attemptresult = np.random.binomial(n=1, p=self.prob, size=100) def update(self): self.upgradestate[&#39;day%s&#39; % self.i] = np.minimum(self.upgradestate[&#39;day%s&#39; % (self.i-1)] + self.attemptresult, 5) ## +5이후로는 증가하지 않는다 self.ratio = sum(self.upgradestate.loc[:,&#39;day%s&#39; % self.i] == 5) / 100 . #1-(1) test1=nexon() for test1.i in range(1,63): test1.attempt() test1.update() 100*test1.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다 . 100.0 . class nexon2(nexon): &#39;&#39;&#39; 202016248 통계학과 한재수 파이썬 기말시험 2번 문제에 대한 코드 &#39;&#39;&#39; def __init__(self): nexon.__init__(self) self.prob = 0.7 self.failstate = pd.DataFrame({&#39;day0&#39;:[0]*100}) def update(self): nexon.update(self) self.failstate[&#39;day%s&#39; % self.i] = self.failstate[&#39;day%s&#39; % (self.i-1)] + (self.attemptresult==0)*1 for j in range(100): if self.upgradestate.iloc[j,self.i] == 0: self.failstate.iloc[j,self.i] = self.failstate.iloc[j,self.i]-1 ## i-1번째 + 강화시도(0 or 1) = i번째 ## i,i-1번째 강화상태가 0이라는 의미는 i-1째에 시도한 강화가 실패했다는 의미. ## upgradestate가 0이라는 의미는 실패했다는 것이므로 실패횟수가 하나 쌓인다. ## +0에서는 실패횟수가 쌓이지 않으므로 failstate값을 하나 뺀다. if (self.upgradestate.iloc[j,self.i] == 5) and (self.attemptresult[j] == 0): ## i-1번째 + 강화시도(0 or 1) = i번째 ## i번째가 +5강화이면서 i-1번째 시도한 강화가 실패라는 의미는 ## i-1번째가 +5강화였다는 의미이다. 그러므로 i번째 실패횟수가 +1 됐을것이다. ## +5강화에서는 강화를 도전하지 않을 것이다. ## 그러므로 i번째 실패횟수를 1을 감소시킨다. self.failstate.iloc[j,self.i] = self.failstate.iloc[j,self.i]-1 ## +5에서는 강화를 시도하지 않을것이므로 ## 만약 실패했다면 failstate값을 하나 뺀다. def reset(self): for j in range(100): if (self.upgradestate.iloc[j,self.i] &gt;0) and (self.upgradestate.iloc[j,self.i] &lt; 5): if self.failstate.iloc[j,self.i] == 2: self.failstate.iloc[j,self.i] = 0 self.upgradestate.iloc[j,self.i] = 0 ## 실패스택이 2라면 실패스택을 0으로 바꾸고 강화상태를 +0으로 바꾼다 def arrangeprobt(self): if self.ratio &gt;= 0.5: self.prob = 0.9 ## +5강 비율이 50%이상이라면 전체유저의 강화 성공확률을 90%로 바꾼다. . #2-(1) test2=nexon2() for test2.i in range(1,63): test2.attempt() test2.update() test2.reset() 100*test2.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . #2-(2) test3=nexon2() for test3.i in range(1,32): test3.attempt() test3.update() test3.reset() 100*test3.ratio ## 31일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 99명이였다. . 99.0 . #2-(3) test4=nexon2() for test4.i in range(1,63): test4.attempt() test4.update() test4.reset() test4.arrangeprobt() 100*test4.ratio ## 과반수가 +5강화 일때 성공확률을 0.9로 바꾼다,62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . - 다음문장을 잘 읽고 참 거짓을 판단하여라. (10점) . (1) tuple은 원소의 값을 임의로 바꿀 수 있다.=&gt; &#39;거짓&#39; . (2) class 에 정의된 함수(=메서드)는 self 만을 인자로 받을수 있다.=&gt; &#39;거짓&#39; .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "relUrl": "/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "date": " • Jun 18, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://gkswotn12345.github.io/green/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post14": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://gkswotn12345.github.io/green/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "Study with me",
          "content": "수상 . - 1학년 2학기 때 장학금 10만원… . 학점 . - 1학년 1학기: 4.38 . - 1학년 2학기: 4.50 . - 2학년 1학기: 4.00(희망), 4.42(현실)? . 프로그래밍 언어 . - R . - 파이썬 . - 잘하고 싶다… . 자격증 . - 있을까? . 토익 . - 할거임 . 대외활동 . - 해야지 . 봉사활동 . - .. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://gkswotn12345.github.io/green/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://gkswotn12345.github.io/green/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}