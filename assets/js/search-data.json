{
  
    
        "post0": {
            "title": "정렬 알고리즘",
            "content": "- 데이터를 오름차순으로 정렬해보자! . &#49440;&#53469; &#51221;&#47148; . - 가장 작은 수를 첫 번째 인덱스로 선택 그 다음으로 작은 수를 두 번째 인덱스로 선택 . - 이런식으로 가장 큰 수까지 마지막 인덱스로 선택하면 정렬 끝 . &#49440;&#53469; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다. . List = [5, 8, 7, 1, 2] . 2 첫 번째 인덱스와 나머지 $n - 1$개의 수를 비교하여 가장 작은 수와 위치를 바꾼다. . 3 5와 비교하여 1이 가장 작으므로 5와 1의 위치를 바꾼다. . List = [1, 8, 7, 5, 2] . 4 이제 두 번째 인덱스와 나머지$n - 2$개의 수를 비교하여 남은 수 중 가장 작은 수와 위치를 바꾼다. . 5 8과 비교하여 2가 가장 작으므로 8과 2의 위치를 바꾼다. . List = [1, 2, 7, 5, 8] . 6 이런 식으로 $n-1$번째 인덱스와 나머지 1개의 수를 비교하여 오름차순 정렬을 마친다. . List = [1, 2, 5, 7, 8] . &#49440;&#53469; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(n - 1): min_idx = i for j in range(i + 1, n): if List[j] &lt; List[min_idx]: min_idx = j List[i], List[min_idx] = List[min_idx], List[i] print(List) . [1, 8, 7, 5, 2] [1, 2, 7, 5, 8] [1, 2, 5, 7, 8] [1, 2, 5, 7, 8] . &#48260;&#48660; &#51221;&#47148; . - 연속된 인덱스를 비교하여 더 큰 값을 오른쪽으로 보냄 . - 한 사이클을 돌면 가장 큰 값이 맨 뒤에 위치 . - 사이클마다 남은 수 중 가장 큰 값이 뒤에 위치함 . &#48260;&#48660; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다. . List = [5, 8, 7, 1, 2] . 2 첫 번째 인덱스와 두 번째 인덱스를 비교하여 더 큰값을 오른쪽에 위치시킨다. . List = [5, 8, 7, 1, 2] . 3 5와 8을 비교하면 8이 더 크므로 8을 오른쪽을 보낸다. . List = [5, 8, 7, 1, 2] . 4 이제 두 번째 인덱스와 세 번째 인덱스를 비교한다. . 5 8과 7을 비교하면 8이 더 크므로 8을 오른쪽으로 보낸다. . List = [5, 7, 8, 1, 2] . 6 이런식으로 한 사이클을 돌면 8이 마지막에 위치한다. . List = [5, 7, 1, 2, 8] . 7 다시 사이클을 돌면 7이 8 왼쪽에 위치한다. . List = [5, 1, 2, 7, 8] . 8 이런식으로 $n - 1$ 번의 사이클을 돌면 자료가 오름차순으로 정렬된다. . List = [1, 2, 5, 7 ,8] . &#48260;&#48660; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(n - 1, 0, -1): for j in range(i): if List[j + 1] &lt; List[j]: List[j + 1], List[j] = List[j], List[j + 1] print(List) . [5, 7, 1, 2, 8] [5, 1, 2, 7, 8] [1, 2, 5, 7, 8] [1, 2, 5, 7, 8] .",
            "url": "https://gkswotn12345.github.io/green/python/2021/07/04/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "relUrl": "/python/2021/07/04/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "date": " • Jul 4, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "확률 분포",
            "content": "&#54869;&#47456; &#48516;&#54252;&#46976;? . - 확률 분포(probability distribution)는 확률 변수가 특정한 값을 가질 확률을 나타내는 함수를 의미한다. --&gt; 출처: https://ko.wikipedia.org/wiki/%ED%99%95%EB%A5%A0_%EB%B6%84%ED%8F%AC . &#44536;&#47111;&#45796;&#47732; &#54869;&#47456; &#48320;&#49688;&#46976;? . - 확률변수(Random Variable)란 무작위 실험을 했을 때, 특정 확률로 발생하는 각각의 결과를 수치로 표현한 변수 . - 무작위 실험 --&gt; 동전 던지기 . - 특정 확률 --&gt; 앞면이 나올 확률 $ frac{1}{2}$, 뒷면이 나올 확률 $ frac{1}{2}$ . - 수치 --&gt; 앞면 = $1$, 뒷면 = $2$ . &#50672;&#49549; &#54869;&#47456; &#48516;&#54252; . 연속 확률 변수가 가지는 확률 분포 | . &#51221;&#44508;&#48516;&#54252; . - 정규 분포는 수집된 자료의 분포를 근사하는 데에 자주 사용됨 . - 중심극한정리에 의하여 독립적인 확률변수들의 평균은 정규 분포에 가까워지는 성질이 있기 때문임 . - 기호로는 $N sim ( mu, sigma^{2})$ . - 정규분포의 기댓값, 중앙값, 최빈값은 $ mu$, 분산은 $ sigma^{2}$ . - 표준정규분포는 평균이 0, 표준편차가 1인 경우임 --&gt; $N sim (0, 1)$ . - 정규분포에서 $ mu pm2 sigma$에 전체 데이터 중 $95 %$가 존재 . &#54364;&#51456;&#54868; . - 정규 분포 밀도 함수에서 $Z =$ $ frac{X - mu}{ sigma}$ 를 통해 $X$(원점수)를 $Z$($z$점수) 표준화하여 표준정규분포(z-분포)를 얻을 수 있다. . &#51221;&#44508;&#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x) ,= , frac{1}{ sqrt{2 pi sigma^{2}}}e^{- frac{(x-m)^{2}}{2 sigma^{2}}}$ . &#51221;&#44508;&#48516;&#54252; plot . import numpy as np np.random.normal(loc, scale, size) . - loc는 평균, scale은 표준편차, size는 반복 횟수 . np.random.normal(loc = 0, scale = 1, size = 1000) . - np.random.normal(loc = 0, scale = 1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.normal(loc = 0, scale = 1, size = 1000) plt.hist(sample) plt.title(&#39;np.random.normal(loc = 0, scale = 1, size = 1000)&#39;) plt.show() . &#51060;&#49328; &#54869;&#47456; &#48516;&#54252; . 이산 확률 변수가 가지는 확률 분포 | . &#48288;&#47476;&#45572;&#51060; &#49884;&#54665; . - 임의의 결과가 성공 또는 실패와 같이 가능한 결과가 2 가지 . &#48288;&#47476;&#45572;&#51060; &#49884;&#54665; &#51312;&#44148; . - 각 시행의 결과는 상호 배타적인 두 사건(성공 or 실패)으로 구분 . - 성공 확률 p, 실패 확률 q일 때, $p+q=1$ . - 각 시행은 독립적 . &#51060;&#54637; &#48516;&#54252; . - 성공 확률이 p인 베르누이 시행을 독립적으로 n번 반복했을 때 성공 횟수 X는 이항 분포를 따름 . - 기호로는 $X sim B(n,p)$ . - 독립적 시행 --&gt; 각 시행은 서로 영향을 주지 않음 . &#51060;&#54637; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688;(PMF) . $f(x) ,= , _{n} rm C_{x} ,p^{x} ,p^{n-x} ,= , binom{n}{x} ,p^{k} ,p^{n-x}$ . - 성공 확률 $p$인 베르누이 시행을 $n$번 시행하여 그 중 $x$번을 성공할 확률 질량 함수 . - 베르누이 분포는 이항 분포에서 $n=1$일 때이다. . &#51060;&#54637;&#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - 기댓값 = $np$ . - 분산 = $np(1-p)$ . &#51060;&#54637; &#48516;&#54252; plot . import numpy as np np.random.binomial(n, p, size) . - $n$은 표본 크기, $p$는 성공 확률, size는 반복 횟수 . np.random.binomial(n = 50, p = 0.5, size = 1000) . - 성공 확률이 p = 0.5인 베르누이 시행을 n = 50번 반복하는 것을 size = 1000번 반복한다. . - 동전 던지기($p=0.5$)를 $n$ = $50$번 시행하여 앞면이 나온 횟수($X=0,1,2, dots,49,50$)를 $size = 1000$번 기록한다. . - np.random.binomial(n = 10, p = 0.5, size = 1000)을 히스토그램으로 나타내면? . - $np geq 5$ 이면 이항분포를 정규분포로 근사할 수 있다. . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.binomial(n = 10, p = 0.5, size = 1000) plt.hist(sample) plt.title(&#39;np.random.binomial(n = 10, p = 0.5, size = 100)&#39;) plt.show() . &#54252;&#50500;&#49569; &#48516;&#54252; . - 단위 시간, 단위 공간 안에 어떤 사건이 몇 번 발생할 것인지를 표현하는 이산 확률 분포 . - 포아송 분포의 모수($ lambda$)는 단위 시간에서 사건의 평균 발생 횟수 . &#54252;&#50500;&#49569; &#48516;&#54252; &#51204;&#51228; &#51312;&#44148; . - 독립성: 1시간 동안 우리 집앞에서 넘어진 사람 수와 친구 집앞에서 넘어진 사람 수는 독립이다. . - 일정성: 1시간 동안 평균 3명이 넘어졌다면 2시간 동안에는 평균 6명이 넘어진다. . - 비집락성: 우리 집앞에서 같은 시간에 두 명 이상이 넘어질 확률은 0이다. . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) ,= , frac{e^{- lambda} lambda^{x}}{x!}$ . - $x$는 단위 시간에서 사건의 발생 횟수, $ lambda$는 단위 시간에서 사건의 평균 발생 횟수 . - $ lambda = 10$, $x = 7$ --&gt; 단위 시간에서 사건의 평균 10번 발생할 때 7번 발생할 확률은? . - 우리 집앞에서 1시간에 사람이 평균적으로 10명이 넘어진다고 한다. 이 때 1시간에 사람이 5명 넘어질 확률은? . - $ lambda = 10, x = 5$ --&gt; $f(5) = frac{e^{-10} ,10^5}{5!} = 0.03783327480207071$ . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - 기댓값 = $ lambda$ . - 분산 = $ lambda$ . &#54252;&#50500;&#49569; &#48516;&#54252; plot . import numpy np.random.poisson(lam ,size) . - $ lambda$는 모수, size는 반복 횟수 . np.random.poisson(lam = 10 ,size = 1000) . - 단위 시간에서 사건이 평균 10번 발생할 때 (lam = 10) 단위 시간에서 사건이 몇 번 발생하는지를 size = 1000번 반복한다. . - 우리 집앞에서 1시간당 평균 10명이 넘어질 때($ lambda=10$) 1시간당 몇 명 넘어지는지($x = 0,1,2, dots,10,11, dots$)를 $size = 1000$번 기록한다. . - np.random.poisson(lam = 10, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.poisson(lam = 10, size = 1000) plt.hist(sample) plt.title(&#39;np.random.poisson(lam = 10, size = 1000)&#39;) plt.show() . - $ lambda$를 바꿔볼까? --&gt; 우리 집앞에서 1시간당 평균 4명이 넘어진다면?? . np.random.seed(1) sample = np.random.poisson(lam = 4, size = 1000) plt.hist(sample) plt.title(&#39;np.random.poisson(lam = 4, size = 1000)&#39;) plt.show() .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/30/%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html",
            "relUrl": "/python/2021/06/30/%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html",
            "date": " • Jun 30, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "깃허브 데스크탑",
            "content": "&#44611;&#54728;&#48652; &#45936;&#49828;&#53356;&#53457; &#51060;&#50857;&#54644;&#49436; &#52964;&#48139;&#54616;&#44592; . 처음에 레포지토리 선택할 때 정보를 저장할 폴더 경로를 선택한다. . | 나의 경우에는 &quot;C:/Users/한재수/github_desktop/green&quot; 이다. . | green폴더에 가보면 notebooks폴더가 있는데 거기서 작업한 주피터 노트북 파일은 깃허브 데스크탑 changes에 표시된다. . | 커밋할 파일 하나를 클릭하고 하단에 메시지를 같이 남긴다. . | 변동 내역 메시지를 작성하고 커밋을 했으면 마지막으로 푸쉬를 한다. . | 깃허브에 변동 내역이 저장된다. . | 아무 것도 변경하지 않고 save만 해도 깃허브 데스크탑 changes에서 감지된다. | 아무 것도 변경하지 않았는데 커밋이 된다는 의미... --&gt; 아무짝에도 쓸모 없다. --&gt; 이런 경우에는 커밋을 하지 말고 냅두자. | . &#51089;&#50629; &#44277;&#44036; . 이제부터 작업은 나의 깃허브 레포지토리(green) 저장 폴더인 green에 있는 notebooks에서 해야 한다. | 만약 &quot;C:/Users/한재수/github_desktop/green/notebooks&quot; 에서 작업하지 않으면 깃허브 데스크탑 changes에 기록되지 않는다. --&gt; 망함 | .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/26/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91.html",
            "relUrl": "/python/2021/06/26/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "리스트 처리",
            "content": "&#47532;&#49828;&#53944; &#51221;&#47148; . list.sort()&#54632;&#49688;, sorted()&#54632;&#49688; . - ?.sort()함수는 list형태인 ? 의 요소를 오름차순으로 정렬한다. . - ?.sort(reverse = True)함수는 내림차순으로 정렬한다. . - ?.sort()함수와 sorted()함수는 거의 같다. . - ?.sort()함수는 ?의 속성을 바꾸지만 sorted()함수는 ?의 속성을 바꾸지 않는다. (a.append()와 + 연산의 차이) . a=[1,5,2,3,7,4] a . [1, 5, 2, 3, 7, 4] . a.sort() a . [1, 2, 3, 4, 5, 7] . a.sort(reverse = True) a . [7, 5, 4, 3, 2, 1] . - sort(), sorted()의 key 옵션에 지정된 함수의 결과에따라 정렬한다. . - lambda함수(익명 함수) 사용 --&gt; lambda 매개변수: 결과 . b = [(1, 2), (0, 2), (1, 3), (1, 5), (0, 1), (2, 8)] c = sorted(b, key = lambda x: (x[0], -x[1])) ## x[1]앞에 있는 &#39;-&#39;기호는 현재정렬순서와 반대로이다. print(c) ##첫 번째 원소는 오름차순, 두 번째 원소는 내림차순으로 정렬 . [(0, 2), (0, 1), (1, 5), (1, 3), (1, 2), (2, 8)] . reverse()&#54632;&#49688; . - ?.reverse()함수는 list형태인 ? 의 요소를 역순으로 정렬한다. . d = [1,5,2,3,7,4] d.reverse() print(d) . [4, 7, 3, 2, 5, 1] . &#47532;&#49828;&#53944; &#52488;&#44592;&#54868; . 1&#52264;&#50896; &#47532;&#49828;&#53944; . a = [] ## 빈 리스트로 초기화 a . [] . A = [x] * n . $A = [x, x, x, ..., x, x] --&gt;$ $x$가 $n$개인 $1$차원 리스트 . a = [0]*10 ## 0리스트로 초기화 a . [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] . 2&#52264;&#50896; &#47532;&#49828;&#53944; . n = 5 list = [[0] * n for _ in range(n)] ## 0으로 채원진 2차원 리스트 . list . [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . list[0][0] = 123 . list . [[123, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . - ?? . List = [[0] * 5 for _ in range(5) . 그런데 _ 는 뭐지? . - 사실 _ 자리에 다른 것이 들어가도 된다. 이를 테면 i . x = [0*i for i in range(5)] x . [0, 0, 0, 0, 0] . - 위에 List에서 _ 대신에 i를 넣는다고 생각하자. . List = [[0] * 5 for i in range(5) . - 위에 리스트인 x 에서는 i가 리스트 안에 0을 몇 개 생성할 지 정하는 변수였다. . - 위에 리스트인 List 에서는 i가 무슨 역할을 하지?? . - 아무역할도 하지 않는다. . - 0을 5개 생성하고 이를 5번 반복한다. . - List를 정의할 때 부터 정해졌다. . - i는 그저 for문을 쓰기 위해 필요함 --&gt; range(5)의 값을 받아낼 변수가 필요하다. . - 그래서 i 자리에 오는 변수는 아무짝에도 쓸모가 없다. . - 아무 의미가 없어서 그냥 아무 의미 없어보이는 기호인 _를 쓴다.(내 생각) . &#47532;&#49828;&#53944; &#52628;&#44032; . ?.append() . - ? --&gt; 리스트 . - 마지막(?[-1]) 위치에 하나의 원소 추가 . a = [] a.append(1) a . [1] . ?.insert(i, v) . - i 위치에 v 원소 추가 . b = [1,2,3,5,6,7] b.insert(3,4) b . [1, 2, 3, 4, 5, 6, 7] . ?.extend() . - 마지막(?[-1]) 위치에 리스트 추가 . c = [1,2,3,4,5] c.extend([6,7,8]) c . [1, 2, 3, 4, 5, 6, 7, 8] . &#47928;&#51088;&#50676; &#54252;&#54632;&#50668;&#48512; . ?.find(&quot;&#47928;&#51088;&#50676;&quot;) . - ?에 문자열이 존재하면 가장 앞에 원소의 시작 인덱스 값을 반환하며 존재하지 않으면 -1값을 반환 . day = &quot;2021-07-03&quot; . day.find(&#39;2021&#39;) . 0 . day.find(&#39;-&#39;) . 4 . day.find(&#39;2222&#39;) . -1 . &quot;&#47928;&#51088;&#50676;&quot; in ? , &quot;&#47928;&#51088;&#50676;&quot; not in ? . - ?에 문자열이 존재하면 True 반환, 존재하지 않으면 False 반환, not in에 경우는 반대로 . day = &quot;2021-07-03&quot; . &#39;2021&#39; in day . True . &#39;-&#39; not in day . False . &#39;2222&#39; in day . False . list = [&#39;1011&#39;, &#39;2022&#39;, &#39;day&#39;, &#39;model&#39;] . &#39;2022&#39; in list . True . &#39;day&#39; not in list . False . &#39;month&#39; in list . False .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC.html",
            "relUrl": "/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "백준 문제풀기",
            "content": "&#49324;&#52825;&#50672;&#49328; . &#46160; &#51088;&#50672;&#49688; A&#50752; B&#44032; &#51452;&#50612;&#51652;&#45796;. &#51060;&#46412;, A+B, A-B, A*B, A/B(&#47787;), A%B(&#45208;&#47672;&#51648;)&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . a, b = map(int, input().split()) print(a+b) print(a-b) print(a*b) print(a//b) print(a%b) . 10 4 21 2 1 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . a, b = map(int, input().split()) print(a+b) . 12 . if&#47928; . &#46160; &#51221;&#49688; A&#50752; B&#44032; &#51452;&#50612;&#51276;&#51012; &#46412;, A&#50752; B&#47484; &#48708;&#44368;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . A, B = map(int, input().split()) if A&gt;B: print(&#39;&gt;&#39;) elif A&lt;B: print(&#39;&lt;&#39;) else: print(&#39;==&#39;) . &gt; . &#49884;&#54744; &#51216;&#49688;&#47484; &#51077;&#47141;&#48155;&#50500; 90 ~ 100&#51216;&#51008; A, 80 ~ 89&#51216;&#51008; B, 70 ~ 79&#51216;&#51008; C, 60 ~ 69&#51216;&#51008; D, &#45208;&#47672;&#51648; &#51216;&#49688;&#45716; F&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . def result(grade): if grade &gt;= 90 and grade &lt;= 100: print(&quot;A&quot;) elif grade &gt;= 80 and grade &lt;= 89: print(&quot;B&quot;) elif grade &gt;= 70 and grade &lt;= 79: print(&quot;C&quot;) elif grade &gt;= 60 and grade &lt;= 69: print(&quot;D&quot;) else: print(&quot;F&quot;) grade = int(input()) result(grade) . A . &#50672;&#46020;&#44032; &#51452;&#50612;&#51276;&#51012; &#46412;, &#50980;&#45380;&#51060;&#47732; 1, &#50500;&#45768;&#47732; 0&#51012; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다. . | 예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다. . | . def leap_year(year): if (year%4 ==0 and year%100 != 0) or year%400 == 0: print(1) else: print(0) year = int(input()) leap_year(year) . 1 . &#49324;&#48516;&#47732; &#44256;&#47476;&#44592; . 첫 줄에는 정수 x가 주어진다. (−1000 ≤ x ≤ 1000; x ≠ 0) 다음 줄에는 정수 y가 주어진다. (−1000 ≤ y ≤ 1000; y ≠ 0) | 점 (x, y)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다. | . def quadrant(a,b): if a&gt;0 and b&gt;0: print(1) elif a&gt;0 and b&lt;0: print(4) elif a&lt;0 and b&gt;0: print(2) elif a&lt;0 and b&lt;0: print(3) x = int(input()) y = int(input()) quadrant(x, y) . 4 . &#50508;&#46988; &#49884;&#44228; . 45분 일찍 알람 설정하기 | . h, m = map(int, input().split()) if m &gt;= 45: print(h, m-45) elif h == 0: print(23, m+15) else: print(h-1, m+15) . 23 40 . for&#47928; . N&#51012; &#51077;&#47141;&#48155;&#51008; &#46244;, &#44396;&#44396;&#45800; N&#45800;&#51012; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. &#52636;&#47141; &#54805;&#49885;&#50640; &#47582;&#52656;&#49436; &#52636;&#47141;&#54616;&#47732; &#46108;&#45796;. . n = int(input()) for i in range(1,10): print(&#39;%s * %s = %s&#39; % (n, i, n*i)) . 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 첫째 줄에 테스트 케이스의 개수 T가 주어진다. | 각 테스트 케이스마다 A+B를 출력한다. | . T = int(input()) for i in range(T): A, B = map(int, input().split()) print(A+B) . 6 . 10 . 75 . n&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, 1&#48512;&#53552; n&#44620;&#51648; &#54633;&#51012; &#44396;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 반복문 있는 버전 | . n = int(input()) sum = 0 for i in range(1, n+1): sum += i print(sum) . 55 . 반복문 없는 버전 | . n = int(input()) print(int(n * (n+1) / 2)) . 55 . sys.stdin.readline() . 본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. | 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다. | Python을 사용하고 있다면 input() 대신 sys.stdin.readline()을 사용할 수 있다. | 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우 .rstrip()을 추가로 해 주는 것이 좋다. | . import sys T = int(input()) for i in range(T): A, B = map(int, sys.stdin.readline().split()) print(A+B) . ValueError Traceback (most recent call last) &lt;ipython-input-3-173fe188e1c6&gt; in &lt;module&gt; 2 T = int(input()) 3 for i in range(T): -&gt; 4 A, B = map(int, sys.stdin.readline().split()) 5 print(A+B) ValueError: not enough values to unpack (expected 2, got 0) . error 왜 뜨지? | sys.stdin.readline()를 쓸 때마다 에러가 난다. | . &#51088;&#50672;&#49688; N&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, 1&#48512;&#53552; N&#44620;&#51648; &#54620; &#51460;&#50640; &#54616;&#45208;&#50473; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . N = int(input()) for i in range(1, N+1): print(i) . 1 2 3 4 5 . &#51088;&#50672;&#49688; N&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, N&#48512;&#53552; 1&#44620;&#51648; &#54620; &#51460;&#50640; &#54616;&#45208;&#50473; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . N = int(input()) for i in range(1, N+1): print(N-i+1) . 5 4 3 2 1 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 각 테스트 케이스마다 &quot;Case #x: &quot;를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다. | . import sys T = int(input()) for i in range(1, T+1): A, B = map(int, sys.stdin.readline().split()) print(&#39;Case #%s: %s&#39; % (i, A+B)) . Case #1: 6 . Case #2: 6 . Case #3: 8 . &#52395;&#51704; &#51460;&#50640;&#45716; &#48324; 1&#44060;, &#46168;&#51704; &#51460;&#50640;&#45716; &#48324; 2&#44060;, N&#48264;&#51704; &#51460;&#50640;&#45716; &#48324; N&#44060;&#47484; &#52237;&#45716; &#47928;&#51228; . 하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오. | . print&#54632;&#49688; &#50857;&#48277; . print(출력할 객체, end = &#39;함수가 종료될 때 실행하는 값&#39;) | print()함수에서 end값을 따로 지정하지 않으면 끝을 줄바꿈 문자로 한다. | . print(&#39;안녕&#39;, end = &#39;~~~~&#39;) print(&#39;하세요&#39;) . 안녕~~~~하세요 . N = int(input()) for i in range(N): for j in range(1, N-i): print(&quot; &quot;, end = &quot;&quot;) for k in range(i+1): print(&quot;*&quot;, end = &quot;&quot;) print(&quot; n&quot;, end = &quot;&quot;) . * ** *** **** ***** . &#51221;&#49688; N&#44060;&#47196; &#51060;&#47336;&#50612;&#51652; &#49688;&#50676; A&#50752; &#51221;&#49688; X&#44032; &#51452;&#50612;&#51652;&#45796;. &#51060;&#46412;, A&#50640;&#49436; X&#48372;&#45796; &#51089;&#51008; &#49688;&#47484; &#47784;&#46160; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 첫째 줄에 N과 X가 주어진다. (1 ≤ N, X ≤ 10,000) | 둘째 줄에 수열 A를 이루는 정수 N개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다. | X보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. X보다 작은 수는 적어도 하나 존재한다. | . N, X = map(int, input().split()) A = list(map(int, input().split())) for i in range(N): if A[i] &lt; X: print(A[i], end = &quot; &quot;) . 1 0 . while&#47928; . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 입력의 마지막에는 0 두 개가 들어온다. | . while True: A,B = map(int, input().split()) if A==0 and B==0: break else: print(A+B) . 2 . 4 . &#45908;&#54616;&#44592; &#49324;&#51060;&#53364; . 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. | 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. | 다음 예를 보자. | 26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다. | 위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다. | N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.(0&lt;=N&lt;=99 인 정수) | . n = N = int(input()) N_cycle = 0 while True: if N &lt; 10: N = int(2*str(N)) N_cycle += 1 else: N = int(str(N)[-1]+str(int(str(N)[0])+int(str(N)[-1]))[-1]) N_cycle += 1 if N == n: print(N_cycle) break . 60 . &#54632;&#49688; . N&#44060;&#51032; &#54633; . 정수 n개가 주어졌을 때, n개의 합을 구하는 함수를 작성하시오. | . def solve1(a): sum = 0 for i in range(len(a)): sum += a[i] return(sum) . a=[0,1,2,3,4] solve1(a) . 10 . def solve2(a): return(sum(a)) . a=[0,1,2,3,4] solve2(a) . 10 . &#49472;&#54532; &#45336;&#48260; . 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다. | . z = set(range(1,10001)) - {x+sum([int(a) for a in str(x)]) for x in range(1,10001)} z = list(z) z.sort() for i in range(len(z)): print(z[i]) # 출력이 너무 길어서 출력은 생략 . &#54620;&#49688; . 어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. | 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. | N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오. | . N = int(input()) def solve(a): if a &lt; 100: print(a) else: n = 99 for i in range(100, a+1): if int(str(i)[1]) - int(str(i)[0]) == int(str(i)[2]) - int(str(i)[1]): n += 1 print(n) solve(N) . 129 . &#51116;&#44480;&#54632;&#49688;(&#51473;&#50836;&#54632; &#50500;&#47560;&#46020; &#44536;&#47532;&#44256; &#54775;&#44040;&#47548;) . - 재귀함수를 구상해보자. . - 재귀함수는 관계가 중요하다. . - 팩토리얼에서는 $fact(x)= x * fact(x)$ 관계가 성립한다. . - $fact(0), fact(1)$ 은 1이다. . - x가 0 또는 1일 때는 return을 1로 설정하고 나머지의 경우에는 $fact(x)= x * fact(x)$ 을 return한다면 재귀함수가 된다. . - 즉, 기본값 [$fact(0 or 1)=1$] 을 알고 관계식 [$fact(x)= x * fact(x)$] 을 안다면 재귀함수로 구현할 수 있다. . &#54057;&#53664;&#47532;&#50620; . 0보다 크거나 같은 정수 N이 주어진다. | 이때, 재귀함수를 이용하여 N!을 출력하는 프로그램을 작성하시오. | . N = int(input()) def fact(x): if x == 0 or x == 1: return 1 else: return x*fact(x-1) print(fact(N)) . &#54588;&#48372;&#45208;&#52824; &#49688;&#50676; . n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오. | 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. | 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. | . N = int(input()) def fibo(x): if x == 0: return 0 elif x == 1: return 1 else: return fibo(x-1) + fibo(x-2) print(fibo(N)) . 55 . &#54588;&#48372;&#45208;&#52824; &#49688;&#50676; &#47700;&#47784;&#51060;&#51228;&#51060;&#49496; . 피보나치 재귀 함수의 경우 이미 구한 값을 구하기 위해 반복을 많이 해서 효율성이 떨어진다. | 재귀 함수가 효율적이지 못하다면 메모이제이션을 사용한다. | 재귀함수가 한 번 호출될 때마다 결과값을 저장하여 효율성을 높이는 것이 좋다. (메모이제이션) | . N = int(input()) fibonacci = {0:0, 1:1} ## 메모이제이션을 위한 딕셔러니 선언 def fibo(x): if x in fibonacci: return fibonacci[x] fibonacci[x] = fibo(x-1) + fibo(x-2) return fibonacci[x] print(fibo(N)) . 55 . &#48324; &#52237;&#44592;(Pass) . N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다. | 크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다. | N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. | . print(&#39;&#47928;&#51088;&#50676;&#39;) . $ star$ 과 $ star$ 사이에 빈칸이 있다. 이유는 ,(콤마) 때문이다. | . print(&#39;*&#39;, &#39;*&#39;, end = &quot;&quot;) . * * . ,(콤마)를 없애면 $ star$ 과 $ star$ 사이에 빈칸이 없다. | . print(&#39;*&#39; &#39;*&#39;, end = &quot;&quot;) . ** . def star(x): if x == 3: return print(&#39;*** n* * n***&#39;, end = &quot;&quot;) else: return ## *자리에 star(x/3)대입하면 될 줄 알았는데... . &#54616;&#45432;&#51060; &#53457; &#51060;&#46041; &#49692;&#49436; . 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. | 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다. | 첫째 줄에 옮긴 횟수 K를 출력한다. | 두 번째 줄부터 수행 과정을 출력한다. | . N = int(input()) def Hanoi(n,from_pos,to_pos,aux_pos): if n==1: print(from_pos,to_pos) else: Hanoi(n-1,from_pos,aux_pos,to_pos) print(from_pos,to_pos) ## 가장 큰 원반을 목적지로 이동 Hanoi(n-1,aux_pos,to_pos,from_pos) print(2**N-1) Hanoi(N,1,3,2) . 7 1 3 1 2 3 2 1 3 2 1 2 3 1 3 . &#48652;&#47336;&#53944; &#54252;&#49828;(brute force) . - 완전탐색 알고리즘으로 가능한 모든 경우의 수를 탐색한다. --&gt; 100%확률로 정답 출력 . &#48660;&#47001;&#51117; . 기존 룰: 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. | 변형 룰: N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오. | . N, M = map(int,input().split()) card = list(map(int,input().split())) def blackjack(card,length,Max): card_list=[] for i in range(N): for j in range(N): for k in range(N): if i != j and j != k and i != k: if card[i]+card[j]+card[k] &lt;= Max: card_list.append(card[i]+card[j]+card[k]) print(max(card_list)) blackjack(card,N,M) ## 아쉬운점: for문3번사용 --&gt; O(n^3) . 21 . &#48516;&#54644;&#54633; . 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. | 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. | 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. | 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. | 반대로, 생성자가 여러 개인 자연수도 있을 수 있다. | 자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오. | . N = int(input()) def solve(x): list=[] for i in range(1, x+1): generator = i + sum([int(str(i)[j]) for j in range(len(str(i)))]) if generator == x: list.append(i) if len(list) &gt; 0: return(min(list)) else: return 0 print(solve(N)) . 198 . &#51076;&#51032;&#51032; &#49707;&#51088;&#51032; (&#44033; &#51088;&#47551;&#49688; + &#51088;&#44592; &#51088;&#49888;) . x=12345 sum([int(str(x)[i]) for i in range(len(str(x)))])+x ### 리스트 컴프리헨션 . 12360 . IQ Test(&#48145;&#50640; &#49345;&#54889; &#46412;&#47928;&#50640; &#48152;&#47168; &#52286;&#50500; &#48420;&#51020;) + &#47582;&#45716; &#44163; &#44057;&#51008;&#45936; &#44228;&#49549; &#53952;&#47548;..., &#44536;&#47000;&#49436; &#45796;&#47480; &#49324;&#46988; &#53076;&#46300; &#48420;&#45716;&#45936; &#50780; &#53952;&#47160;&#45716;&#51648; &#47784;&#47476;&#44192;&#51020;. . IQ Test의 문제 중에는 공통된 패턴을 찾는 문제가 있다. 수열이 주어졌을 때 다음 수를 찾는 문제이다. . | 예를 들어 1, 2, 3, 4, 5가 주어졌다. 다음 수는 무엇인가? 당연히 답은 6이다. . | 약간 더 어려운 문제를 보면 3, 6, 12, 24, 48이 주어졌을 때 다음 수는 무엇인가? 역시 답은 96이다. . | 이제 제일 어려운 문제를 보자. . | 1, 4, 13, 40이 주어졌을 때 다음 수는 무엇일까? 답은 121이다. . | 그 이유는 항상 다음 수는 앞 수 * 3 + 1이기 때문이다. . | 은진이는 위의 3문제를 모두 풀지 못했으므로 자동으로 풀어주는 프로그램을 작성하기로 했다. . | 항상 모든 답은 구하는 규칙은 앞 수 * a + b이다. 그리고 a와 b는 정수이다. . | 수 N개가 주어졌을 때 규칙에 맞는 다음 수를 구하는 프로그램을 작성하시오. . | . - N은 2여도 1, 1 과 같이 답이 있을 수 있다. . - 일반적으로 N = 2이면 다음 수는 여러개이다, . - $1, 2$ --&gt; 다음 수 $3(a=0, b=1)$ or $-8(a=-10, b=12)$ 등등 . - a, b 둘다 0일 수 도 있음 . - 스파게티 코드 + 틀렸습니다 . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule(x): if len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif len(x) == 2 and x[0] == x[1]: return x[0] if len(x) == 1: return &#39;A&#39; if x[0] == x[1] == x[2] : a = 0 elif x[1] == x[0] and x[1] != x[2]: return &#39;B&#39; else: a = (x[2] - x[1]) / (x[1] - x[0]) b = x[1] - a * x[0] for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; elif x[i+1] == 0: ## 이 부분이 문제였다. x[i+1] == 0이면 그 뒤는 확인 안하고 return 0 실행 return 0 return int(a * x[-1] + b) print(sequence_rule(N_list)) . - 위에 있는 코드를 정리하자 . - 틀렸습니다 . - exit(0) --&gt; python 프로그램 종료 . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule2(x): if len(x) == 1: return A elif len(x) == 2 and x[0] == x[1]: return x[1] elif len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 else: a = (x[1] - x[2]) / (x[0] - x[1]) b = x[1] - x[0] * a for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; return (int(a * x[-1] + b)) print(sequence_rule2(N_list)) . 13 . - continue --&gt; 아래 코드를 실행하지 않고 건너뜀 . for i in range(10): # 0부터 99까지 증가하면서 100번 반복 if i % 2 == 0: # i를 2로 나누었을 때 나머지가 0면 짝수 continue # 아래 코드를 실행하지 않고 건너뜀 print(i) . 1 3 5 7 9 . - 맞았습니다(3시간 걸림 힘들다) . - 위의 코드와 밑의 코드는 무슨 차이일까... . N = int(input()) x = list(map(int, input().split())) if N == 1: print(&#39;A&#39;) elif N == 2: if x[0] == x[1]: print(x[0]) else: print(&#39;A&#39;) else: if x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 b = x[1] else: a = (x[2] - x[1]) // (x[1] - x[0]) b = x[1] - x[0] * a result = True for i in range(N - 1): if x[i] * a + b == x[i+1]: continue else: result = False if result: print(a * x[-1] + b) else: print(&#39;B&#39;) . 121 . &#50689;&#54868;&#44048;&#46021; &#49676; . 종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. | 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다. | 숌이 만든 ($N leq10000$)번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. | . - $N leq 10000$ --&gt; 계산 결과 영화제목은 최대 7자리 . - 7자리 수까지 666을 포함하는 수를 모두 생성한 후 오름차순으로 정렬 . - 문제점: 666xxx 같은 수를 표현한다고 치자 --&gt; 이때 xxx = 010이라면 자연수가 아니므로 010을 수로 표현할 수 없음 . - 666xxx --&gt; 66600x + 6660xx . - 하지만 좋은 방법이 떠오름 . - 666xxx --&gt; 66yxxx , y = 6이므로 yxxx =&gt; range(6000,7000) . - 위와 같이 표현하면 666010도 표현 가능! . import math result = [666] result.extend([int(str(i) + &#39;666&#39;) for i in range(1, 3000)]) ## x666, xy666, xyy666, 1yyy666, 2yyy666 --&gt; 앞으로 나오는 x는 자연수, y는 0포함 result.extend([int(&#39;66&#39; + str(i)) for i in range(6000,7000)]) ## 666yyy result.extend([int(&#39;66&#39; + str(i)) for i in range(600, 700)]) ## 666yy result.extend([int(&#39;666&#39; + str(i)) for i in range(10)]) ## 666y result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 30) for j in range(600, 700)]) ## x666yy, 1y666yy, 2y666yy result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 100) for j in range(60, 70)]) ## x666y, xy666y result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 3) for j in range(6000, 7000)]) ## 1666yyy, 2666yyy result.extend([int(str(i) + &#39;666&#39; + str(j)) for i in range(100, 300) for j in range(10)]) ## 1yy666y, 2yy666y result.extend([int(str(i) + &#39;666&#39;) for i in range(1000, 3000)]) ## 1yyy666, 2yyy666 result = list(set(result)) result.sort() N = int(input()) print(result[N-1]) . 1666 . - 다른 사람 아이디어 보고 만든 코드 --&gt; 내 코드보다 코드 길이가 10배 짧아서 10배 좋다고 생각할라 했는데 시간이 너무 오래 걸리네? --&gt; 내 실수인 걸로 할라 했는데 숏코딩 보니까 다른 사람도 시간이 오래 걸렸다. . - 종말의 수는 $10000$개가 최대이므로 아무거 커도 $3000000$ 이하이다. . - $3000000$까지의 숫자 중 $666$을 포함하면 새로운 리스트에 포함한다. . result = [] result.extend([int(str(i)) for i in range(666,3000000) if str(i).find(&#39;666&#39;) != -1]) N = int(input()) print(result[N-1]) . 1666 . - 숏코딩으로 만들었음(가독성 쓰레기) . print([i for i in range(9**7)if&#39;666&#39;in str(i)][int(input())-1]) . 1666 . &#52404;&#49828;&#54032; &#45796;&#49884; &#52832;&#54616;&#44592; . $8 times8$ 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠한다. | 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오. | . - 밑에 있는 코드 왜 틀림??????????????? . - W로 채워진 8$ times$8 체스판을 input 하면 답이 32가 나와야 하는데 chess1, chess2 = 24, 25가 나온다.(원인 불명) . - 아 왜 틀렸냐고... 안해 다른 거 할 거야 . N, M = map(int, input().split()) data = [] for i in range(N): data.append(list(input())) def chess(n, m): x, y = 0, 7 chess_list = [] while x &lt; n - 7 and y &lt; n: a, b = 0, 7 while a &lt; m - 7 and b &lt; m: chess1, chess2 = 0, 0 for i in range(x, y): for j in range(a, b): if (a + x) % 2 ==0: if (i + j) % 2 == 0: if data[i][j] == &#39;B&#39;: chess1 += 1 else: chess2 += 1 if (i + j) % 2 == 1: if data[i][j] == &#39;B&#39;: chess2 += 1 else: chess1 += 1 else: if (i + j) % 2 == 0: if data[i][j] == &#39;B&#39;: chess2 += 1 else: chess1 += 1 if (i + j) % 2 == 1: if data[i][j] == &#39;B&#39;: chess1 += 1 else: chess2 += 1 chess_list.extend([chess1, chess2]) a += 1 b += 1 x += 1 y += 1 print(chess_list) chess(N, M) . - input . 8, 8 . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . - output . [24, 25] . &#45929;&#52824;(7568&#48264;) . N = int(input()) body = [] for i in range(N): body.append(list(map(int,input().split()))) for i in range(N): rank = 1 for j in range(N): if body[i][0] &lt; body[j][0] and body[i][1] &lt; body[j][1]: rank += 1 print(rank, end = &quot; &quot;) . 2 2 1 2 5 . a=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;] x=&#39; &#39;.join(a) a=1,2,3 print(a) . (1, 2, 3) . &#49548;&#49688; . &#50500;&#54028;&#53944; &#51076;&#45824;(5615&#48264;) --&gt; &#49884;&#44036; &#52488;&#44284; pass . 아파트 면적은 $2xy+x+y = k$ --&gt; 2k+1 = (2x+1)(2y+1) , $x,y$는 양의 정수 | 즉, 아파트 면적을 k라 할 때 2k+1은 합성수이다. | 만약, $2k+1$이 소수라면 잘못된 아파트 면적이다. | . &#49548;&#49688; &#54032;&#48324; . def Is_prime_number(a): from math import sqrt for i in range(2,int(sqrt(a)+1)): if a%i==0: return True else: return False . from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return False else: return True def apart(n): sum = 0 for i in range(n): x = int(input()) if Is_prime_number(2*x+1) == True: sum +=1 return(sum) N = int(input()) apart(N) . - error: 이렇게 코드를 짜면 N에 어떤 수를 대입해도 if Is_prime_number(2*x+1) == True 부분이 항상 참이여서 sum += 1이 실행된다.(원인불명) . from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return 0 else: return 1 def apart(n): sum = 0 for i in range(n): x = int(input()) if Is_prime_number(2*x+1) == 1: sum += 1 return(sum) N = int(input()) apart(N) . - error: 이렇게 코드를 짜면 N에 어떤 수를 대입해도 if Is_prime_number(2*x+1) == True 부분이 항상 참이여서 sum += 1이 실행된다.(마찬가지로 원인불명) . - 아파트 임대 --&gt; 시간 초과 코드 . import sys from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return False return True def apart(n): sum = 0 for i in range(n): x = int(sys.stdin.readline()) if Is_prime_number(2*x+1) == 1: sum += 1 return(sum) N = int(input()) apart(N) . 2 . &#49548;&#49688;&#54032;&#51221; &#51032;&#47928;&#51216; . def is_prime_number(x): # 2부터 x의 제곱근까지의 모든 수를 확인하며 for i in range(2, int(sqrt(x)) + 1): # x가 해당 수로 나누어떨어진다면 if x % i == 0: return False # 소수가 아님 return True # 소수임 . - 위에 코드는 문제가 없다.$ ,$ x에 2나 3을 넣어도 잘 작동함. . def is_prime_number(x): # 2부터 x의 제곱근까지의 모든 수를 확인하며 for i in range(2, int(sqrt(x)) + 1): # x가 해당 수로 나누어떨어진다면 if x % i == 0: return False # 소수가 아님 else: return True # 소수임 . - 위에 코드는 문제가 있다. x에 2나 3을 넣으면 return이 없다. . - 아마 2나 3을 넣으면 range(2,1) 이 돼서 그럴 것이다. . &#54028;&#51060;&#50028; &#53076;&#46300; &#49892;&#54665; &#49884;&#44036; &#52769;&#51221; . import time start = time.time() ## 시작 시간 저장 ## --작업 코드-- print(&quot;time :&quot;, time.time() - start) . &#44592;&#48376; &#49688;&#54617;1 (&#49884;&#44036; &#52488;&#44284; &#51452;&#51032;) . &#45804;&#54077;&#51060;&#45716; &#50732;&#46972;&#44032;&#44256; &#49910;&#45796;. . 땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다. . | 달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다. . | 달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오. . | . - 달팽이는 올라가고 싶다 --&gt; 시간 초과 코드(while 반복문 사용) . A, B, V = map(int,input().split()) ### 시간 초과 day = 1 h = 0 while 1: h += A if h &gt;= V: break h -= B day += 1 print(day) . 25 . - 달팽이는 올라가고 싶다 --&gt; 시간 초과 해결한 코드(한 줄 수식) . import math A, B, V = map(int,input().split()) ### 시간 초과 해결 print(math.ceil((V-A)/(A-B))+1) . 25 . &#49552;&#51061;&#48516;&#44592;&#51216; . A는 고정 비용, B는 가변 비용, C는 수익, k는 판매량 | $C*k &gt; A + B*k$ --&gt; $k &gt; frac{A}{C-B}$ | . A, B, C = map(int, input().split()) if abs(C-B) &lt; 0.5: ### C == B 여부를 판단 print(-1) elif int(A/(C-B)) &lt; 0: print(-1) else: print(int(A/(C-B)) + 1) . -1 . - 위에 코드보다 더 간결한 코드 . - A에 관계없이 B &gt;= C이면 손익분기점이 없다. . A, B, C = map(int, input().split()) if B &gt;= C: ### C == B 여부를 판단 print(-1) else: print(int(A/(C-B)) + 1) . 11 . Fly me to the Alpha Centauri . 시작할 땐 1만큼 도착할 때도 1만큼 이동 | k만큼 이동한 후에 k-1 or k or k+1 만큼 이동 가능 | . - 이동 횟수를 최소화할려면? . - $x지점(출발=0) to{1} to{2} to{3} to dots to{n} to{n-1} to dots to{2} to{1} to{y지점}(도착=0)$ . - $이동 ,거리 = sum_{i=1}^{n}{k} + sum_{i=1}^{n-1}{k} = frac{n(n+1)}{2} + frac{(n-1)n}{2} = n^2$ . - $y-x = n^2$ . - $이동 ,횟수 = 화살표의 ,개수 = n+(n-1)=2n-1$ . - 즉 $n^2$의 거리를 이동하기 위한 최소한의 이동 횟수는 $2n-1$이다. . - 바꿔말하면 $2n-1$번의 이동으로 갈 수 있는 최대 거리는 $n^2$이다. . - 위에 방법에 기반하여 정리를 해봤다. . - 위에서는 이동 거리가 $n^2$에 대해서 고려했다. 하지만 이동 거리가 제곱수가 아닐 수 도 있다. . - 예로 이동 거리가 110이면 이동 횟수는 $ sqrt{100} leq sqrt{110} leq sqrt{121}$ 이므로 10 or 11 or 12이다. . - $n^2 = 1+1+2+2+ dots+(n-1)+(n-1)+n$ 이다. . - 100 과 121의 차이는 21 = 10 + 11 --&gt; 100은 이동 횟수 $2n-1=19$, 101$ sim$110 은 $2n=20$, 111$ sim$121은 $2n+1=21$이다. . T = int(input()) for i in range(T): x, y = map(int, input().split()) n = y - x m = int(n**0.5) if n**0.5 == m: print(2*m - 1) elif n - m**2 &lt;= m: print(2*m) else: print(2*m + 1) . 3 . 3 . 4 . &#49444;&#53461; &#48176;&#45804; . 상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. . | 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다. . | 상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. . | 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 된다. . | 하지만 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다. . | 상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오. . | 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다. . | . - 봉지를 최소화 해야 한다. --&gt; 5kg 봉지를 최대한 많이 써야 한다. . - 설탕의 무게를 5로 나눈다. . - 만약 5로 나눠지면 끝이다. 그러지 않다면 5kg 봉지를 하나씩 줄여나가고 나머지를 3kg 봉지로 담는다. . - 5kg 봉지를 하나씩 줄이다가 0이 됐다면 전부 3kg 봉지를 사용한다. . - 그래도 안된다면 정확하게 Nkg을 만드는 것이 불가능하므로 -1을 출력한다. . N = int(input()) def sugar(n): k = n//5 l = n % 5 if l == 0: return k else: n = n - k*5 if n % 3 ==0: return k + 1 else: n = n - (k-1)*5 if n % 3 ==0: return k - 1 + n//3 else: n = n - (k-2)*5 if n % 3 == 0: return k - 2 + n//3 else: n = n -(k-3)*5 if n % 3 ==0: return k - 3 + n//3 else: ...... if n &lt; 0: return -1 . 이런식으로 전개될 것이다. | . N = int(input()) def sugar(n): k = n // 5 l = n % 5 for i in range(k+1): if l == 0: return k break elif l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 201 . print &#50752; return &#51032; &#52264;&#51060;(&#44036;&#45800;&#55176;) . - return 은 종료문이다. 함수에서 return을 만나면 함수가 종료된다. . - 그렇기에 return이 여러개여도 하나만 반환된다. . - 여러 값을 반환하고 싶다면 return a,b,c, $ dots$ . - print()는 그렇지 않다. . - 위에 설탕배달 코드에서 return을 print()로 바꾼다면 항상 -1을 출력하지만 . - return이기 때문에 return k or return k + l//3이 실행되지 않을 때만 return -1이 실행된다. . &#48516;&#49688;&#52286;&#44592; . 이와 같이 나열된 분수들을 1/1 -&gt; 1/2 -&gt; 2/1 -&gt; 3/1 -&gt; 2/2 -&gt; … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자. . | X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오. . | . - 분모 + 분자 = n + 1인 분수가 n개 있다. . - 분모 + 분자가 2인 분수가 1개, 3인 분수가 2개, 4인 분수가 3개, $ dots$, n+1인 분수가 n개 . - 분모 + 분자가 $n+1$인 끝점: $1+2+3+ dots+n-2+n-1+n$ . x = int(input()) n = int((x * 2) ** 0.5) k = n * (n + 1) // 2 a = k - x if a &lt; 0: n += 1 k += n a = k - x if n % 2 == 0: print(str(n-a)+&#39;/&#39;+str(1+a)) else: print(str(1+a)+&#39;/&#39;+str(n-a)) . 4 10 4 15 5/1 . &#49688;&#54617;&#51008; &#48708;&#45824;&#47732;&#44053;&#51032;&#51077;&#45768;&#45796;(19532&#48264;) . - 백준은 내부 라이브러리만 사용 가능, numpy는 외부 라이브러리라 사용 불가능 . import numpy as np a, b, c, d, e, f = map(int, input().split()) array1 = np.array([[a, b], [d, e]]) array2 = np.array([c, f]) x, y = np.linalg.inv(array1) @ array2 print(round(x), round(y)) . - 연립 일차 방정식을 행렬을 통해 풀어 보자 . a, b, c, d, e, f = map(int, input().split()) det = a * e - b * d print(round((e * c - f *b ) / det), round((a * f - c * d) / det)) . -1 2 . &#51221;&#47148; . &#49688; &#51221;&#47148;&#54616;&#44592; . N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. | . - 선택 정렬 . N = int(input()) List = [] for i in range(N): num = int(input()) List.append(num) n = len(List) for j in range(n): min_idx = j for k in range(j + 1, n): if List[k] &lt; List[min_idx]: min_idx = k List[j], List[min_idx] = List[min_idx], List[j] print(List[j]) . 1 2 3 4 5 . - 내장 함수 ?.sort() . N = int(input()) List = [] for i in range(N): num = int(input()) List.append(num) List.sort() for j in range(len(List)): print(List[j]) . 1 2 3 4 5 .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "relUrl": "/python/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "파이썬 딥러닝",
            "content": "&#53584;&#49436;&#54540;&#47196; . 무지성 코드(예쩨 그대로 복붙 손으로) | . import tensorflow as tf W = tf.Variable(tf.ones(shape=(2,2)), name = &quot;W&quot;) b = tf.Variable(tf.zeros(shape=(2)), name = &quot;b&quot;) @tf.function def model(x): return W * x + b out_a = model([1,0]) print(out_a) . tf.Tensor( [[1. 0.] [1. 0.]], shape=(2, 2), dtype=float32) . &#52488;&#54217;&#47732;(&#44036;&#45800;&#55176;) . 평면의 단면은 직선, 부피의 단면은 평면, 그 이상은??? | 직선($ax + by + c = 0$)은 2차원의 초평면, 평면($ax + by + cz + d = 0$)은 3차원의 초평면 | $a_1x_1 + a_2x_2 + a_3x_3 + a_4x_4 + c = 0$ 는 뭐라고 불러야 돼??? --&gt; 4차원 공간에 그려짐 | 평면을 일반화하여 초평면을 만듦 | n차원의 그려진 초평면 --&gt; n-1차원 공간 | 초평면은 공간을 분할하는 역할 --&gt; 직선은 평면을 분할, 평면은 공간을 분할 | [$ ast$] n차원의 초평면은 n차원을 분할 [$ ast$] | . &#54140;&#49481;&#53944;&#47200; .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/23/%EB%94%A5%EB%9F%AC%EB%8B%9D.html",
            "relUrl": "/python/2021/06/23/%EB%94%A5%EB%9F%AC%EB%8B%9D.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "map함수",
            "content": "map&#54632;&#49688; &#53945;&#51669; . 여러 개의 데이터를 한 번에 다른 형태로 변화하기 위해 사용한다. | map 함수는 원본 리스트를 변경하지 않고 새 리스트를 생성한다. | map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환해야 한다. | . map 함수는 리스트의 요소를 지정된 함수로 처리한다. | . x=list(range(5)) x . [0, 1, 2, 3, 4] . def two_times(x): return x*2 . y=two_times(x) y . [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] . z=list(map(two_times, x)) z . [0, 2, 4, 6, 8] . map&#54632;&#49688; &#49324;&#50857;&#48277; . map(함수, 반복가능한 객체) | . x = [1.1, 2.1, 3.1, 4.1] y = map(int, x) print(y) . &lt;map object at 0x0000023B6D93D040&gt; . map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환한다. $ rightarrow [ star$] 변환하지 않으면 위와 같은 결과를 출력한다. [$ star$] | print(y)하지 않고 그냥 y만 입력해도 된다. | . x = [1.1, 2.1, 3.1, 4.1] y = list(map(int, x)) y . [1, 2, 3, 4] . def minus(a): return a - 0.1 . list(map(minus, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . minus 함수는 map함수를 위해 한 번 쓰고 버려질 운명이다. 만드는게 귀찮음... | . map &#54632;&#49688;&#50640; &#46988;&#45796; &#49885; &#49324;&#50857; . x = [1.1, 2.1, 3.1, 4.1] list(map(lambda a: a - 0.1, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . input().split()&#44284; map . input()함수는 c언어의 scanf()함수와 비슷하다. | . z = input() . z . &#39;hello&#39; . input()으로 입력받은 값은 문자열이다. | . n = input() . type(n) . str . input()함수에서 안내문구를 추가할 수 도 있다. | . Q = input(&#39;숫자 하나를 입력하세요:&#39;) . Q . &#39;26&#39; . input()함수의 출력값을 문자열이 아닌 다른 자료형으로 바꾸고 싶다면? | . w = int(input(&#39;숫자 하나를 입력하세요:&#39;)) . type(w) . int . input().split(&quot;기준문자열&quot;)을 사용하면 입력값을 변수 여러 개에 저장할 수 있다. | split()에서 &quot;기준문자열&quot;이 없는 즉 default는 공백이다. | . a, b = input().split() # 입력받은 값을 공백(스페이스, 탭, 엔터 등)을 기준으로 분리 . a, b . (&#39;10&#39;, &#39;20&#39;) . c = a, b type(c) . tuple . a와b가 문자열이다. | int형으로 바꾸고 싶다면? | . a, b = int(input().split()) . TypeError Traceback (most recent call last) &lt;ipython-input-17-0de5d52cb787&gt; in &lt;module&gt; -&gt; 1 a, b = int(input().split()) TypeError: int() argument must be a string, a bytes-like object or a number, not &#39;list&#39; . int()함수를 쓰면 될 것 같았는데 오류가 나온다 | error메시지를 읽어보니 int()함수는 무조건 a string, a bytes-like object or a number 여야 한다.(not &#39;list&#39;) | a, b는 tuple인 것 같다. | 그러면 어떻게 하지? $ longrightarrow$ map()함수를 쓰면 된다. | . a, b = map(int, input().split()) # 입력받은 값을 정수로 변환 . a, b . (10, 20) . type(a) . int . type(b) . int . a, b = map(int, input().split())을 풀어서 쓰면 다음과 같은 코드이다.x = input().split() # input().split()의 결과는 문자열 리스트 m = map(int, x) # 리스트의 요소를 int형으로 변환, 결과는 맵 객체 a, b = m # 맵 객체는 변수 여러 개에 저장 가능 . | . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#54620; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . L = list(map(int, input().split())) L . [10, 8, 7, 1, 0, 3, 5, 2] . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#50668;&#47084; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . data = [] N = int(input()) for i in range(N): data.append(list(map(int,input().split()))) . data . [[1, 4, 0, 2], [17, 8, 1, 0, 4, 6], [1, 0], [0, 4, 5], [0, 0, 10]] .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "date": " • Jun 21, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "파이썬 기말시험",
            "content": "import pandas as pd import numpy as np class nexon(): &#39;&#39;&#39; 202016248 통계학과 한재수 파이썬 기말시험 1번 문제에 대한 코드 &#39;&#39;&#39; def __init__(self): self.upgradestate = pd.DataFrame({&#39;day0&#39;:[0]*100}) self.prob = 0.3 self.i = 1 def attempt(self): self.attemptresult = np.random.binomial(n=1, p=self.prob, size=100) def update(self): self.upgradestate[&#39;day%s&#39; % self.i] = np.minimum(self.upgradestate[&#39;day%s&#39; % (self.i-1)] + self.attemptresult, 5) ## +5이후로는 증가하지 않는다 self.ratio = sum(self.upgradestate.loc[:,&#39;day%s&#39; % self.i] == 5) / 100 . #1-(1) test1=nexon() for test1.i in range(1,63): test1.attempt() test1.update() 100*test1.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다 . 100.0 . class nexon2(nexon): &#39;&#39;&#39; 202016248 통계학과 한재수 파이썬 기말시험 2번 문제에 대한 코드 &#39;&#39;&#39; def __init__(self): nexon.__init__(self) self.prob = 0.7 self.failstate = pd.DataFrame({&#39;day0&#39;:[0]*100}) def update(self): nexon.update(self) self.failstate[&#39;day%s&#39; % self.i] = self.failstate[&#39;day%s&#39; % (self.i-1)] + (self.attemptresult==0)*1 for j in range(100): if self.upgradestate.iloc[j,self.i] == 0: self.failstate.iloc[j,self.i] = self.failstate.iloc[j,self.i]-1 ## i-1번째 + 강화시도(0 or 1) = i번째 ## i,i-1번째 강화상태가 0이라는 의미는 i-1째에 시도한 강화가 실패했다는 의미. ## upgradestate가 0이라는 의미는 실패했다는 것이므로 실패횟수가 하나 쌓인다. ## +0에서는 실패횟수가 쌓이지 않으므로 failstate값을 하나 뺀다. if (self.upgradestate.iloc[j,self.i] == 5) and (self.attemptresult[j] == 0): ## i-1번째 + 강화시도(0 or 1) = i번째 ## i번째가 +5강화이면서 i-1번째 시도한 강화가 실패라는 의미는 ## i-1번째가 +5강화였다는 의미이다. 그러므로 i번째 실패횟수가 +1 됐을것이다. ## +5강화에서는 강화를 도전하지 않을 것이다. ## 그러므로 i번째 실패횟수를 1을 감소시킨다. self.failstate.iloc[j,self.i] = self.failstate.iloc[j,self.i]-1 ## +5에서는 강화를 시도하지 않을것이므로 ## 만약 실패했다면 failstate값을 하나 뺀다. def reset(self): for j in range(100): if (self.upgradestate.iloc[j,self.i] &gt;0) and (self.upgradestate.iloc[j,self.i] &lt; 5): if self.failstate.iloc[j,self.i] == 2: self.failstate.iloc[j,self.i] = 0 self.upgradestate.iloc[j,self.i] = 0 ## 실패스택이 2라면 실패스택을 0으로 바꾸고 강화상태를 +0으로 바꾼다 def arrangeprobt(self): if self.ratio &gt;= 0.5: self.prob = 0.9 ## +5강 비율이 50%이상이라면 전체유저의 강화 성공확률을 90%로 바꾼다. . #2-(1) test2=nexon2() for test2.i in range(1,63): test2.attempt() test2.update() test2.reset() 100*test2.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . #2-(2) test3=nexon2() for test3.i in range(1,32): test3.attempt() test3.update() test3.reset() 100*test3.ratio ## 31일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 99.0 . #2-(3) test4=nexon2() for test4.i in range(1,63): test4.attempt() test4.update() test4.reset() test4.arrangeprobt() 100*test4.ratio ## 과반수가 +5강화 일때 성공확률을 0.9로 바꾼다,62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . 3 &#45796;&#51020;&#47928;&#51109;&#51012; &#51096; &#51069;&#44256; &#52280; &#44144;&#51667;&#51012; &#54032;&#45800;&#54616;&#50668;&#46972;. (10&#51216;) . (1) tuple은 원소의 값을 임의로 바꿀 수 있다.=&gt; &#39;거짓&#39; . (2) class 에 정의된 함수(=메서드)는 self 만을 인자로 받을수 있다.=&gt; &#39;거짓&#39; .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "relUrl": "/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "date": " • Jun 18, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "깃허브 카테고리 설정",
            "content": "&#44611;&#54728;&#48652; &#52852;&#53580;&#44256;&#47532; . 제목 . &quot;부제목&quot; . -toc: true . -branch: master . -badges: true . -comments: true . -author: 한재수 . -categories: [python] . - 위에 내용을 아무곳에나 붙여 넣는다. 부제목은 (&gt;&quot;부제목&quot;), 제목은 (# 제목) . - categories에 해당하는 부분이 깃허브 홈페이지에서 tag에 보이는 부분이다. . &#48660;&#47196;&#44536; &#44288;&#47532; . 1_ 깃허브 가입하기 | 2_ fastai/fastpages 사용 | 3_ 깃허브 데스크탑 이용 . | (1) 주피터노트북으로 공부한다. . | (2) 깃허브와 연결된 어떤 폴더(드랍박스 안의 green)에 공부한 내용을 넣는다. | (3) 깃허브 데스크탑이라는 프로그램을 이용하여 local(내 윈도우 컴퓨터)에서 remote (github)로 변경사항을 반영한다. | (4) 2~3분 뒤에 블로그 홈페이지에 반영된다. | (5) 공부한 내용을 편집없이 주피터 노트북 파일을 올리기만 하면 블로그에 올라가서 편하다. 필요에 따라 숨기기, 비밀 포스트도 만들 수 있다. | . &#44611;, &#44611;&#54728;&#48652; . 버전 관리 시스템 | 서로 코드를 공유 | 혼자 쓰면 개인 저장소.. | . &#51452;&#54588;&#53552; &#45432;&#53944;&#48513; . &#50976;&#50857;&#54620; &#53412; . - 삭제한 셀 복원 --&gt; Edit - Undo cell operation or Esc 후 z키 입력 . - 삭제한 코드 복원 --&gt; Ctrl + z . &#51452;&#54588;&#53552; &#45432;&#53944;&#48513; --&gt; remote --&gt; page (&#50504; &#50732;&#46972;&#44040; &#49688; &#46020; &#51080;&#45796;) . - 깃허브 데스크탑 history에서 이제껏 했던 커밋을 볼 수 있다. 게다가 삭제된 파일을 복구할 수 도 있다. . - 화면 캡쳐 프로그램으로 캡쳐를 함 --&gt; 마크다운에서 캡쳐한 이미지를 ctrl+v하면 캡쳐한 이미지가 삽입된다. . - 이미지 파일을 넣은 주피터 노트북 파일을 올리면 깃허브 notebook에는 올라가지만 블로그에는 올라가지 않는다. . &#44611;&#54728;&#48652; &#45936;&#49828;&#53356;&#53457;&#50640;&#49436; &#50724;&#47448;&#44032; &#45228;&#45716;&#45936; &#47784;&#47476;&#44192;&#45796;. gg . &#47560;&#53356;&#45796;&#50868; &#51089;&#49457;&#54616;&#47732;&#49436; &#49888;&#44592;&#54620; &#51216;&#51012; &#54616;&#45208; &#50508;&#50500;&#45256;&#45796;. . - 1 앞에 띄어쓰기 안됨 . - 2. . 하나를 붙였을 뿐인데 앞에 띄어쓰기가 된다??? . - 3 이유를 모르겠음.. . &#45236;&#44032; &#52286;&#50500;&#45240; &#47560;&#53356;&#45796;&#50868; &#50857;&#48277; . &#49688;&#49885;&#51012; &#47691;&#51080;&#44172; &#54364;&#54788;&#54616;&#44256; &#49910;&#45796;&#47732;?? . - $수식$ 꼴로 나타낸다. . - y = x + 1 . - $y = x +1$ . &#48145; &#52392;&#51088; &#54364;&#54788; . - $수식_밑첨자$ . - x_1 + x_2 = x_3 . - $x_1 + x_2 = x_3$ . &#47588;&#50864; &#50976;&#50857;&#54620; &#47560;&#53356;&#45796;&#50868; &#49324;&#51060;&#53944;&#44032; &#51080;&#50612; &#47553;&#53356;&#47484; &#45224;&#44596;&#45796;. . - &lt;Jupyter 노트북에서 Markdown 및 LaTeX를 작성하는 방법 알아보기&gt; --&gt; https://ichi.pro/ko/jupyter-noteubug-eseo-markdown-mich-latexleul-jagseonghaneun-bangbeob-al-abogi-18246612521469 .",
            "url": "https://gkswotn12345.github.io/green/python/2021/05/24/%EA%B9%83%ED%97%88%EB%B8%8C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC.html",
            "relUrl": "/python/2021/05/24/%EA%B9%83%ED%97%88%EB%B8%8C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC.html",
            "date": " • May 24, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "7. Class 고급",
            "content": "&#53364;&#47000;&#49828;, &#51064;&#49828;&#53556;&#49828;, &#50724;&#48652;&#51229;&#53944; . - 오브젝트 . 클래스 오브젝트 | 인스턴스 오브젝트 | . - 클래스 (=클래스 오브젝트) . - 인스턴스 (=인스턴스 오브젝트) . &#53364;&#47000;&#49828; &#49549;&#49457; vs &#51064;&#49828;&#53556;&#49828; &#49549;&#49457; . &#50696;&#51228;1 . class Testclass1: x=0 y=0 def my_print(self): self.x += 1 Testclass1.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . f=Testclass1 . a=Testclass1() . b=f() . a.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 2 회 출력 . b.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 3 회 출력 . a.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 4 회 출력 . a.my_print() . 현재 인스턴스에서 3 회 출력 전체 인스턴스에서 총 5 회 출력 . - 신기한점: 각 인스턴스에서 instance.my_print()를 실행한 횟수를 서로 공유하는 듯 하다. . &#48516;&#49437; . - 코드를 시점별로 분석해보자. . - 분석을 위해서 커널을 재시작한다. . [시점1]: Testclass1를 선언하는 시점 . class Testclass1: x=0 y=0 def my_print(self): self.x += 1 Testclass1.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . dir(Testclass1) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;, &#39;x&#39;, &#39;y&#39;] . dir(a) . NameError Traceback (most recent call last) &lt;ipython-input-8-3af1c875b71a&gt; in &lt;module&gt; -&gt; 1 dir(a) NameError: name &#39;a&#39; is not defined . dir(b) . NameError Traceback (most recent call last) &lt;ipython-input-9-35660f044d44&gt; in &lt;module&gt; -&gt; 1 dir(b) NameError: name &#39;b&#39; is not defined . – 이 시점에는 Testclass1만이 존재한다. Testclass1를 바로 클래스 오브젝트라고 부름. . Testclass1.x . 0 . Testclass1.y . 0 . – 현재시점에서는 클래스 오브젝트의 수 1개, 인스턴스 오브젝트의 수 0개, 따라서 총 오브젝트 수는 1개임. . [시점2] 클래스에 별칭을 지정하는 시점 . f=Testclass1 . f.x . 0 . f.y . 0 . Testclass1.x . 0 . Testclass1.y . 0 . – 이 시점에서 클래스 오브젝트는 2개가 있는 것 처럼 보인다. . - 그렇다면 이 2개의 클래스 오브젝트는 컴퓨터의 어딘가에 저장이 되어 있을 것이다. . - 구체적으로는 메모리에 저장되어있을것. . - 2개의 클래스오브젝트는 서로 다른 메모리 공간에 저장되어 있을것이다. . - 진짜인가? 확인해보자. id()는 오브젝트(클래스 오브젝트, 인스턴스 오브젝트)가 저장된 메모리 주소를 확인하는 명령어이다. . id(f) . 93967322676384 . – f라는 오브젝트는 93967322676384 메모리에 저장되어 있다. . id(Testclass1) . 93967322676384 . - 어? 그런데 Testclass1의 오브젝트 역시 93967322676384 메모리에 저장되어 있다. . - 추론: 사실 93967322676384라는 메모리공간에 저장된 어떠한 것은 동일한데, 그것을 어떤사람은 Testclass1 이라고 부르고 어떤사람은 f라고 부른다. . - 이는 마치 별명이랑 비슷하다. 나라는 오브젝트를 어떤사람은 최규빈이라고 부르고, 어떤사람은 팬더라고 부른다. 부르는 이름이 2개라고 해서 나라는 오브젝트가 2개가 있는것은 아니다. . - 결국 이 시점에서 클래스 오브젝트의 수는 여전히 1개라고 볼 수 있다. (인스턴스 오브젝트의 수는 0개) . [시점3]: 클래스 오브젝트로부터 인스턴스 오브젝트를 만드는 시점 . a=Testclass1() b=f() . id(Testclass1),id(f),id(a),id(b) . (93967322676384, 93967322676384, 139694857660688, 139694848860656) . – 이 순간에는 클래스 오브젝트 1개, 인스턴스 오브젝트 2개 존재한다. 즉 총 3개의 오브젝트가 존재한다. . - 메모리주소 93967322676384 에 존재하는 오브젝트는 클래스 오브젝트이며 Testclass1 또는 f 라고 불린다. . - 메모리주소 139694857660688 에 존재하는 오브젝트는 인스턴스 오브젝트이며 a라고 불린다. . - 메모리주소 139694848860656 에 존재하는 오브젝트는 인스턴스 오브젝트이며 b라고 불린다. . Testclass1.x, Testclass1.y . (0, 0) . f.x,f.y . (0, 0) . a.x,a.y . (0, 0) . b.x,b.y . (0, 0) . [시점4] . a.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 1), (1, 1), (0, 1)) . - 특징 . a.my_print()를 실행하면 a.x 의 값이 1이 증가한다. | a.my_print()를 실행하면 f.y, a.y, b.y 의 값이 동시에 1이 증가한다. (공유가 되는 느낌) | . [시점5] . b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 2 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 2), (1, 2), (1, 2)) . [시점6] . b.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 3 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 3), (1, 3), (2, 3)) . [시점7] . a.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 4 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 4), (2, 4), (2, 4)) . [시점8] . a.my_print() . 현재 인스턴스에서 3 회 출력 전체 인스턴스에서 총 5 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 5), (3, 5), (2, 5)) . &#50696;&#51228;2 . - 아래처럼 코드를 바꿔도 잘 동작할것 같다. . class Testclass2: def __init__(self): self.x=0 self.y=0 def my_print(self): self.x += 1 Testclass2.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . c=Testclass2() . c.my_print() . AttributeError Traceback (most recent call last) &lt;ipython-input-51-5500abb1215d&gt; in &lt;module&gt; -&gt; 1 c.my_print() &lt;ipython-input-46-72dbe3bd77f6&gt; in my_print(self) 5 def my_print(self): 6 self.x += 1 -&gt; 7 Testclass2.y +=1 8 print(&#34;현재 인스턴스에서 %s 회 출력&#34; % self.x) 9 print(&#34;전체 인스턴스에서 총 %s 회 출력&#34; % self.y) AttributeError: type object &#39;Testclass2&#39; has no attribute &#39;y&#39; . – 왜 에러가 나는가? . dir(Testclass2) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;] . dir(Testclass1) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;, &#39;x&#39;, &#39;y&#39;] . - 관찰1: Testclass2에서는 Testclass1과는 다르게 x,y가 없다. . dir(c) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;, &#39;x&#39;, &#39;y&#39;] . – 관찰2: 그런데 c라는 인스턴스 오브젝트에서는 x,y가 있다. . - 추론: __init__함수는 클래스 오브젝트가 만들어지는 시점에서는 실행되지 않고, 인스텐스 오브젝트가 만들어지는 시점에 실행된다. . - 결국 __init__함수의 역할은 클래스 오브젝트에서 인스턴스 오브젝트를 만든후에 초기화를 위해서 실행하는 어떠한 일련의 명령들을 묶어놓은 것에 불과하다. . – 즉 위의 코드는 굳이 따지면 아래를 실행한 것과 동일하다. . class Testclass2: # def __init__(self): # self.x=0 # self.y=0 def my_print(self): self.x += 1 Testclass2.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . c=Testclass2() . c.x=0 c.y=0 . - 이 상황에서 . c.my_print() . 를 실행하면 . c.x += 1 Testclass2.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % c.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % c.y) . 이 실행되는데, 이때 Testclass2.y 이 정의되어 있지 않으므로 . Testclass2.y +=1 . 에서 에러가 난다. . c.my_print() . AttributeError Traceback (most recent call last) &lt;ipython-input-63-5500abb1215d&gt; in &lt;module&gt; -&gt; 1 c.my_print() &lt;ipython-input-55-66666a70bf33&gt; in my_print(self) 5 def my_print(self): 6 self.x += 1 -&gt; 7 Testclass2.y +=1 8 print(&#34;현재 인스턴스에서 %s 회 출력&#34; % self.x) 9 print(&#34;전체 인스턴스에서 총 %s 회 출력&#34; % self.y) AttributeError: type object &#39;Testclass2&#39; has no attribute &#39;y&#39; . &#50696;&#51228; 3 . - 그렇다면 아래와 같이 수정하면 어떨까? . class Testclass3: def __init__(self): self.x=0 Testclass3.y=0 def my_print(self): self.x += 1 Testclass3.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . a=Testclass3() b=Testclass3() . a.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 2 회 출력 . a.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 3 회 출력 . a.my_print() . 현재 인스턴스에서 3 회 출력 전체 인스턴스에서 총 4 회 출력 . b.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 5 회 출력 . b.my_print() . 현재 인스턴스에서 3 회 출력 전체 인스턴스에서 총 6 회 출력 . – Testclass1과 동일한 기능이 수행되는것 같다. . - 그런데 조금만 생각해보면 엉터리라는 것을 알 수 있다. 아래의 코드를 관찰하여보자. . class Testclass3: def __init__(self): self.x=0 Testclass3.y=0 def my_print(self): self.x += 1 Testclass3.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) a=Testclass3() a.my_print() a.my_print() b=Testclass3() b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 2 회 출력 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . - Testclass3는 인스턴스를 생성할때마다 y=0이 설정된다. 그래서 . b=Testclass3() . 이 시점에서 의도하지 않게 &#39;전체 인스턴스에서 출력된 횟수&#39;를 의미하는 y가 초기화되었다. . - 코드는 엉터리이지만, Testclass3은 의외로 분석할만한 가치가 있다. 특히 위의 실행결과를 시점별로 Testclass1과 비교해보면 재미있다. . - Testclass1 . ### Testclass1 ## 시점1: 클래스 오브젝트 생성 class Testclass1: x=0 y=0 def my_print(self): self.x += 1 Testclass1.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) ## 시점2: 인스턴스 오브젝트 a를 생성 a=Testclass1() ## 시점3: a에서 메소드 실행 a.my_print() ## 시점4: a에서 메소드를 한번 더 실행 a.my_print() ## 시점5: 인스턴스 오브젝트 b를 생성 b=Testclass1() ## 시점6: b에서 메소드를 실행 b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 2 회 출력 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 3 회 출력 . 시점1 시점2 시점3 시점4 시점5 시점6 . Testclass1.x | 0 | 0 | 0 | 0 | 0 | 0 | . Testclass1.y | 0 | 0 | 1 | 2 | 2 | 3 | . a.x | 값없음 | 0 | 1 | 2 | 2 | 2 | . a.y | 값없음 | 0 | 1 | 2 | 2 | 3 | . b.x | 값없음 | 값없음 | 값없음 | 값없음 | 0 | 1 | . b.y | 값없음 | 값없음 | 값없음 | 값없음 | 2 | 3 | . – Testclass3 . #### Testclass3 ## 시점1: 클래스 오브젝트 생성 class Testclass3: def __init__(self): self.x=0 Testclass3.y=0 def my_print(self): self.x += 1 Testclass3.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) ## 시점2: 인스턴스 오브젝트 a를 생성 a=Testclass3() ## 시점3: a에서 메소드 실행 a.my_print() ## 시점4: a에서 메소드를 한번 더 실행 a.my_print() ## 시점5: 인스턴스 오브젝트 b를 생성 b=Testclass3() ## 시점6: b에서 메소드를 실행 b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 2 회 출력 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . 시점1 시점2 시점3 시점4 시점5 시점6 . Testclass3.x | 값없음 | 값없음 | 값없음 | 값없음 | 값없음 | 값없음 | . Testclass3.y | 값없음 | 0 | 1 | 2 | 0 | 1 | . a.x | 값없음 | 0 | 1 | 2 | 2 | 2 | . a.y | 값없음 | 0 | 1 | 2 | 0 | 1 | . b.x | 값없음 | 값없음 | 값없음 | 값없음 | 0 | 1 | . b.y | 값없음 | 값없음 | 값없음 | 값없음 | 0 | 1 | . – Testclass3.y가 업데이트 되면 a.y, b.y도 자동으로 업데이트 된다. . 숙제: . #### Testclass3 ## 시점1: 클래스 오브젝트 생성 class Testclass3: y=0 def __init__(self): self.x=0 def my_print(self): self.x += 1 Testclass3.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) ## 시점2: 인스턴스 오브젝트 a를 생성 a=Testclass3() ## 시점3: a에서 메소드 실행 a.my_print() ## 시점4: a에서 메소드를 한번 더 실행 a.my_print() ## 시점5: 인스턴스 오브젝트 b를 생성 b=Testclass3() ## 시점6: b에서 메소드를 실행 b.my_print() . 시점1 시점2 시점3 시점4 시점5 시점6 . Testclass3.x | | | | | | | . Testclass3.y | | | | | | | . a.x | | | | | | | . a.y | | | | | | | . b.x | | | | | | | . b.y | | | | | | | . &#45348;&#51076;&#49828;&#54168;&#51060;&#49828; . &#50696;&#51228;1 . - 아래의 코드를 관찰하라. . class Testclass1: x=0 . Testclass1.x . 0 . a=Testclass1() . a.x . 0 . – Testclass1.x를 수정하면 a.x가 강제로 수정된다. . Testclass1.x=100 . a.x . 100 . - a.x를 수정한다고 하여 Testclass1.x가 강제로 수정되는 것은 아님 . a.x=200 . Testclass1.x . 100 . a.x . 200 . - 이건 왜이러지? . Testclass1.x=300 . a.x . 200 . - 아래의 상황과 비슷하다. . x=39 def nextyear(): y=x+1 print(x,y) nextyear() . 39 40 . x=39 def nextyear(): y=x+1 print(x,y) x=0 nextyear() . UnboundLocalError Traceback (most recent call last) &lt;ipython-input-29-9c5d2bc270db&gt; in &lt;module&gt; 5 print(x,y) 6 x=0 -&gt; 7 nextyear() &lt;ipython-input-29-9c5d2bc270db&gt; in nextyear() 2 x=39 3 def nextyear(): -&gt; 4 y=x+1 5 print(x,y) 6 x=0 UnboundLocalError: local variable &#39;x&#39; referenced before assignment . – [code1]은 잘 실행되던 코드다. . - [code2]는 실행안되는 코드다. . - [code2]와 [code1]의 차이점은 x=0이라는 코드가 추가로 포함되었는지 유무다. . – (헛소리) x=0 이 잘못된 코드다!! 이걸 실행하는 과정에서 문제가 생겼다!! . - (올바른소리) code1에서는 x는 global variable, code2에서는 x가 local variable 이라서 생기는 문제점이다. . x=39 def nextyear(): x=0 y=x+1 print(x,y) nextyear() . 0 1 . x . 39 . – 다시 우리의 예제로 돌아오자. . ### 시점1 class Testclass1: x=0 ### 시점2 a=Testclass1() ### 시점3 Testclass1.x=100 ### 시점4 a.x=200 ### 시점5 Testclass1.x=300 . 시점1 시점2 시점3 시점4 시점5 . Testclass1.x | 0 | 0 | 100 | 100 | 300 | . a.x | 값없음 | 0 | 100 | 200 | 200 | . a.x의 속성 | - | class | class | instance | instance | . – a.x가 클래스로부터 물려받은 속성인지 (그래서 클래스와 연결되어있는지) 아니면 instance가 독자적으로 가지고 있는 속성인지 어떻게 알 수 있을까? . class Testclass1: x=0 print(&#39;시점1&#39;,Testclass1.x) ### 시점2 a=Testclass1() print(&#39;시점2&#39;,Testclass1.x,a.x,a.__dict__) ### 시점3 Testclass1.x=100 print(&#39;시점3&#39;,Testclass1.x,a.x,a.__dict__) ### 시점4 a.x=200 print(&#39;시점4&#39;,Testclass1.x,a.x,a.__dict__) ### 시점5 Testclass1.x=300 print(&#39;시점5&#39;,Testclass1.x,a.x,a.__dict__) . 시점1 0 시점2 0 0 {} 시점3 100 100 {} 시점4 100 200 {&#39;x&#39;: 200} 시점5 300 200 {&#39;x&#39;: 200} . &#50696;&#51228;2 . x=11 ## 전역변수 ... A def f(): x=22 ## 함수 f안에 설정된 지역변수 print(x) ## 전역에 x=11 있지만 함수안에 x=22가 있으므로 x=22를 사용. --&gt; 22출력됨 def g(): print(x) ## 함수 g안에 x를 찾아봤는데 없음 --&gt; 전역에서 x를 찾음 --&gt; x=11 --&gt; 11출력함. class Testclass2: x=33 ## 클래스 변수 ... B def m1(self): x=44 ## 메소드 변수 ... C def m2(self): self.x=44 ## 인스턴스 변수 ... D . - 결과를 관찰하고 해석해보자. . print(x) . 11 . . Note: 전역변수 출력 . f() . 22 . . Note: f에서 설정된 지역변수 22가 출력됨 . x . 11 . . Note: f내의 지역변수를 사용하여도 전역변수는 변하지 않음. (함수내부에서 선언된 x=22는 함수외부에 영향을 주지못함) . g() . 11 . . Note: g에서 설정된 지역변수가 따로 없으므로 전역변수 출력 . x,Testclass2.x . (11, 33) . . Note: 전역변수 x와 클래스오브젝트에 설정된 변수 x . a=Testclass2() (x,Testclass2.x,a.x),a.__dict__ . ((11, 33, 33), {}) . . Note: 전역변수, 클래스 오브젝트내의 변수, 인스턴스내의 변수. a.__dict__의 결과로 보아 인스턴스내의 변수는 클래스 오브젝트내의 변수를 빌려쓰고 있다. . Testclass2.x=200 (x,Testclass2.x,a.x),a.__dict__ . ((11, 200, 200), {}) . . Note: 클래스오브젝트에서 변수를 고치면 인스턴스에 영향을 미침 . a.m1() (x,Testclass2.x,a.x),a.__dict__ . ((11, 200, 200), {}) . . Note: 메소드 m1내에서 선언된 x=44라는 선언은 아무것도 변화시킬수 없음. . a.m2() (x,Testclass2.x,a.x),a.__dict__ . ((11, 200, 44), {&#39;x&#39;: 44}) . . Note: 메소드 m2에 있는 self.x는 결국 a.x라는 의미이고, 이 선언은 클래스오브젝트 내의 변수와 독립적으로 인스턴스오브젝트 내에서 통용되는 변수를 선언하는 것임. 이 선언의 결과는 a.__dict__의 출력결과에서도 확인가능. . Testclass2.x=300 (x,Testclass2.x,a.x),a.__dict__ . ((11, 300, 44), {&#39;x&#39;: 44}) . . Note: 이제는 a.x와 Testclass2.x 는 분리된 상태이므로, Testclass2.x의 값을 바꾸어도 a.x에는 값의 변화가 없음. . - 뭐 어쩌라는 것임? . - 그냥 그렇다는것.. 내용을 모르고 사용한다면 예상하지 못한 오류가 발생할 수 있으므로 조심해서 사용하자. . 숙제: 전역변수(A), 클래스 변수(B), 메소드 변수(C), 인스턴스 변수(D) . 답: A&gt;B&gt;D&gt;C . &#50672;&#49328;&#51088; &#50724;&#48260;&#47196;&#46377; . - 아래의 코드를 관찰하자. . 1+1 . 2 . - 생각해보니까 1은 int class 에서 생성된 인스턴스이다. . - 코드를 관찰하니 instance와 instance를 +라는 연산이 연결하는 형태임. . class Student: def __init__(self,age=20.0,semester=1): self.age=age self.semester=semester def __add__(self,val): # val==0: 휴학 # val==1: 등록 if val==0: self.age=self.age +0.5 elif val==1: self.age=self.age+0.5 self.semester=self.semester+1 return self def __repr__(self): return &#39;나이: %s n학기: %s&#39; % (self.age,self.semester) . guebin=Student() . guebin.age . 20.0 . guebin.semester . 1 . guebin . 나이: 20.0 학기: 1 . guebin+1 . 나이: 20.5 학기: 2 . guebin+0 . 나이: 21.0 학기: 2 . guebin+0+0+0+0+1+0+1 . 나이: 24.5 학기: 4 . - 연산자 오버로드 핵심아이디어 . 클래스가 일반 파이썬 연산을 재정의하는 것 | 여기에서 연산은 단순히 더하기 빼기를 의미하는게 아니라, print(), +, [0] 와 같은 파이썬 내장문법을 모두 포괄하는 개념이라 이해하는 것이 옳다. | . guebin[0] . TypeError Traceback (most recent call last) &lt;ipython-input-192-961de20e3474&gt; in &lt;module&gt; -&gt; 1 guebin[0] TypeError: &#39;Student&#39; object is not subscriptable . class Student2(Student): def __getitem__(self,index): return [self.age,self.semester][index] . hynn=Student2() . hynn+1+1+0+0 . 나이: 22.0 학기: 3 . hynn[0] . 22.0 . hynn[1] . 3 . hynn[:] . [22.0, 3] . - 연산자 오버로딩을 이해하면 파이썬 전반에 대한 이해폭이 넓어진다. . import pandas as pd . df=pd.DataFrame({&#39;age&#39;:[20,21.5],&#39;semester&#39;:[1,2]}) . df.iloc[:,0] . 0 20.0 1 21.5 Name: age, dtype: float64 . &#46020;&#50880;&#47568; &#51089;&#49457;&#48169;&#48277; . - 넘파이의 경우 아래와 같이 도움말이 잘 작성되어 있다. . import numpy as np a=np.array([1,2,3]) a? . Type: ndarray String form: [1 2 3] Length: 3 File: ~/anaconda3/envs/py38r40/lib/python3.8/site-packages/numpy/__init__.py Docstring: &lt;no docstring&gt; Class docstring: ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using `array`, `zeros` or `empty` (refer to the See Also section below). The parameters given here refer to a low-level method (`ndarray(...)`) for instantiating an array. For more information, refer to the `numpy` module and examine the methods and attributes of an array. Parameters - (for the __new__ method; see Notes below) shape : tuple of ints Shape of created array. dtype : data-type, optional Any object that can be interpreted as a numpy data type. buffer : object exposing buffer interface, optional Used to fill the array with data. offset : int, optional Offset of array data in buffer. strides : tuple of ints, optional Strides of data in memory. order : {&#39;C&#39;, &#39;F&#39;}, optional Row-major (C-style) or column-major (Fortran-style) order. Attributes - T : ndarray Transpose of the array. data : buffer The array&#39;s elements, in memory. dtype : dtype object Describes the format of the elements in the array. flags : dict Dictionary containing information related to memory use, e.g., &#39;C_CONTIGUOUS&#39;, &#39;OWNDATA&#39;, &#39;WRITEABLE&#39;, etc. flat : numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for assignment examples; TODO). imag : ndarray Imaginary part of the array. real : ndarray Real part of the array. size : int Number of elements in the array. itemsize : int The memory use of each array element in bytes. nbytes : int The total number of bytes required to store the array data, i.e., ``itemsize * size``. ndim : int The array&#39;s number of dimensions. shape : tuple of ints Shape of the array. strides : tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous ``(3, 4)`` array of type ``int16`` in C-order has strides ``(8, 2)``. This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time (``2 * 4``). ctypes : ctypes object Class containing properties of the array needed for interaction with ctypes. base : ndarray If the array is a view into another array, that array is its `base` (unless that array is also a view). The `base` array is where the array data is actually stored. See Also -- array : Construct an array. zeros : Create an array, each element of which is zero. empty : Create an array, but leave its allocated memory unchanged (i.e., it contains &#34;garbage&#34;). dtype : Create a data-type. Notes -- There are two modes of creating an array using ``__new__``: 1. If `buffer` is None, then only `shape`, `dtype`, and `order` are used. 2. If `buffer` is an object exposing the buffer interface, then all keywords are interpreted. No ``__init__`` method is needed because the array is fully initialized after the ``__new__`` method. Examples -- These examples illustrate the low-level `ndarray` constructor. Refer to the `See Also` section above for easier ways of constructing an ndarray. First mode, `buffer` is None: &gt;&gt;&gt; np.ndarray(shape=(2,2), dtype=float, order=&#39;F&#39;) array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: &gt;&gt;&gt; np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) . - 하지만 우리는? . hynn? . Type: Student2 String form: 나이: 22.0 학기: 3 Docstring: &lt;no docstring&gt; . - 우리도 도움말을 작성하고 싶다. . class Student2(Student): &#39;&#39;&#39; Student2는 Student의 개선 # Student 클래스의 기능 1. 출력기능 (__repr__) 2. 연산기능 (__add__): 학기와 나이를 카운트 Examples -- &gt;&gt;&gt; hynn=Student2() &gt;&gt;&gt; hynn+1 나이: 20.5 학기: 2 # Student2에서 추가된 기능 1. 인덱싱 &#39;&#39;&#39; def __getitem__(self,index): return [self.age,self.semester][index] . hynn=Student2() . hynn? . Type: Student2 String form: 나이: 20.0 학기: 1 Docstring: Student2는 Student의 개선 # Student 클래스의 기능 1. 출력기능 (__repr__) 2. 연산기능 (__add__): 학기와 나이를 카운트 Examples -- &gt;&gt;&gt; hynn=Student2() &gt;&gt;&gt; hynn+1 나이: 20.5 학기: 2 # Student2에서 추가된 기능 1. 인덱싱 . hynn=Student2(21,1) . hynn . 나이: 21 학기: 1 . hynn? . Type: Student2 String form: 나이: 21 학기: 1 Docstring: Student2는 Student의 개선 # Student 클래스의 기능 1. 출력기능 (__repr__) 2. 연산기능 (__add__): 학기와 나이를 카운트 Examples -- &gt;&gt;&gt; hynn=Student2() &gt;&gt;&gt; hynn+1 나이: 20.5 학기: 2 # Student2에서 추가된 기능 1. 인덱싱 . self&#50640; &#45824;&#54620; &#51652;&#49892; . – 사실 이름이 self가 아니어도 된다. . class MooYaHo: def __init__(a): a.text=&#39;mooyaho&#39; . moo1=MooYaHo() . moo1.text . &#39;mooyaho&#39; . – 그런데 self를 많이 쓴다. . 숙제: MooYaHo class의 도움말에 학번을 넣고 출력 . class MooYaHo: &#39;&#39;&#39; 202016248 한재수 &#39;&#39;&#39; def __init__(self): self.text=&#39;mooyaho&#39; . moo1 = MooYaHo() . moo1 . &lt;__main__.MooYaHo at 0x18690e7a3d0&gt; . moo1.text . &#39;mooyaho&#39; . moo1? . Type: MooYaHo String form: &lt;__main__.MooYaHo object at 0x0000018690E7A3D0&gt; Docstring: 202016248 한재수 .",
            "url": "https://gkswotn12345.github.io/green/python/2021/05/24/Class%EA%B3%A0%EA%B8%89.html",
            "relUrl": "/python/2021/05/24/Class%EA%B3%A0%EA%B8%89.html",
            "date": " • May 24, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://gkswotn12345.github.io/green/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://gkswotn12345.github.io/green/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "Study with me",
          "content": "수상 . - 1학년 2학기 때 장학금 10만원… . 학점 . - 1학년 1학기: 4.38 . - 1학년 2학기: 4.50 . - 2학년 1학기: 4.00(희망), 4.42(현실)? . 프로그래밍 언어 . - R . - 파이썬 . - 잘하고 싶다… . 자격증 . - 있을까? . 토익 . - 할거임 . 대외활동 . - 해야지 . 봉사활동 . - .. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://gkswotn12345.github.io/green/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://gkswotn12345.github.io/green/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}