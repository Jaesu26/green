{
  
    
        "post0": {
            "title": "리스트(작성 중)",
            "content": "&#47532;&#49828;&#53944; &#51221;&#47148; . list.sort()&#54632;&#49688;, sorted()&#54632;&#49688; . ?.sort()함수는 list형태인 ? 의 요소를 오름차순으로 정렬한다. | ?.sort(reverse = True)함수는 내림차순으로 정렬한다. | ?.sort()함수와 sorted()함수는 거의 같다. | ?.sort()함수는 ?의 속성을 바꾸지만 sorted()함수는 ?의 속성을 바꾸지 않는다. (a.append()와 + 연산의 차이) | . a=[1,5,2,3,7,4] a . [1, 5, 2, 3, 7, 4] . a.sort() a . [1, 2, 3, 4, 5, 7] . a.sort(reverse = True) a . [7, 5, 4, 3, 2, 1] . sort(), sorted()의 key 옵션에 지정된 함수의 결과에따라 정렬한다. | lambda함수(익명 함수) 사용 --&gt; lambda 매개변수: 결과 | . b = [(1, 2), (0, 2), (1, 3), (1, 5), (0, 1), (2, 8)] c = sorted(b, key = lambda x: (x[0], -x[1])) ## x[1]앞에 있는 &#39;-&#39;기호는 현재정렬순서와 반대로이다. print(c) ##첫 번째 원소는 오름차순, 두 번째 원소는 내림차순으로 정렬 . [(0, 2), (0, 1), (1, 5), (1, 3), (1, 2), (2, 8)] . reverse()&#54632;&#49688; . ?.reverse()함수는 list형태인 ? 의 요소를 역순으로 정렬한다. | . d = [1,5,2,3,7,4] d.reverse() print(d) . [4, 7, 3, 2, 5, 1] . &#47532;&#49828;&#53944; &#52488;&#44592;&#54868; . 1&#52264;&#50896; &#47532;&#49828;&#53944; . a = [] ## 빈 리스트로 초기화 a . [] . A = [x] * n . $A = [x, x, x, ..., x, x] --&gt;$ $x$가 $n$개인 $1$차원 리스트 . a = [0]*10 ## 0리스트로 초기화 a . [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] . 2&#52264;&#50896; &#47532;&#49828;&#53944; . n = 5 list = [[0] * n for _ in range(n)] ## 0으로 채원진 2차원 리스트 . list . [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . list[0][0] = 123 . list . [[123, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . ??List = [[0] * 5 for _ in range(5) . 그런데 _ 는 뭐지? | . 사실 _ 자리에 다른 것이 들어가도 된다. 이를 테면 i | . x = [0*i for i in range(5)] x . [0, 0, 0, 0, 0] . 위에 List에서 _ 대신에 i를 넣는다고 생각하자.List = [[0] * 5 for i in range(5) . | . 위에 리스트인 x 에서는 i가 리스트 안에 0을 몇 개 생성할 지 정하는 변수였다. | 위에 리스트인 List 에서는 i가 무슨 역할을 하지?? | . 아무역할도 하지 않는다. | 0을 5개 생성하고 이를 5번 반복한다. | List를 정의할 때 부터 정해졌다. | i는 그저 for문을 쓰기 위해 필요함 --&gt; range(5)의 값을 받아낼 변수가 필요함 | 그래서 i 자리에 오는 변수는 아무짝에도 쓸모가 없다. | 아무 의미가 없어서 그냥 아무 의미 없어보이는 기호인 _를 쓴다.(내 생각) | .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%A0%95%EB%A0%AC.html",
            "relUrl": "/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%A0%95%EB%A0%AC.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "백준 문제풀기(작성 중)",
            "content": "&#49324;&#52825;&#50672;&#49328; . &#46160; &#51088;&#50672;&#49688; A&#50752; B&#44032; &#51452;&#50612;&#51652;&#45796;. &#51060;&#46412;, A+B, A-B, A*B, A/B(&#47787;), A%B(&#45208;&#47672;&#51648;)&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . a, b = map(int, input().split()) print(a+b) print(a-b) print(a*b) print(a//b) print(a%b) . 10 4 21 2 1 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . a, b = map(int, input().split()) print(a+b) . 12 . if&#47928; . &#46160; &#51221;&#49688; A&#50752; B&#44032; &#51452;&#50612;&#51276;&#51012; &#46412;, A&#50752; B&#47484; &#48708;&#44368;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . A, B = map(int, input().split()) if A&gt;B: print(&#39;&gt;&#39;) elif A&lt;B: print(&#39;&lt;&#39;) else: print(&#39;==&#39;) . &gt; . &#49884;&#54744; &#51216;&#49688;&#47484; &#51077;&#47141;&#48155;&#50500; 90 ~ 100&#51216;&#51008; A, 80 ~ 89&#51216;&#51008; B, 70 ~ 79&#51216;&#51008; C, 60 ~ 69&#51216;&#51008; D, &#45208;&#47672;&#51648; &#51216;&#49688;&#45716; F&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . def result(grade): if grade &gt;= 90 and grade &lt;= 100: print(&quot;A&quot;) elif grade &gt;= 80 and grade &lt;= 89: print(&quot;B&quot;) elif grade &gt;= 70 and grade &lt;= 79: print(&quot;C&quot;) elif grade &gt;= 60 and grade &lt;= 69: print(&quot;D&quot;) else: print(&quot;F&quot;) grade = int(input()) result(grade) . A . &#50672;&#46020;&#44032; &#51452;&#50612;&#51276;&#51012; &#46412;, &#50980;&#45380;&#51060;&#47732; 1, &#50500;&#45768;&#47732; 0&#51012; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다. . | 예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다. . | . def leap_year(year): if (year%4 ==0 and year%100 != 0) or year%400 == 0: print(1) else: print(0) year = int(input()) leap_year(year) . 1 . &#49324;&#48516;&#47732; &#44256;&#47476;&#44592; . 첫 줄에는 정수 x가 주어진다. (−1000 ≤ x ≤ 1000; x ≠ 0) 다음 줄에는 정수 y가 주어진다. (−1000 ≤ y ≤ 1000; y ≠ 0) | 점 (x, y)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다. | . def quadrant(a,b): if a&gt;0 and b&gt;0: print(1) elif a&gt;0 and b&lt;0: print(4) elif a&lt;0 and b&gt;0: print(2) elif a&lt;0 and b&lt;0: print(3) x = int(input()) y = int(input()) quadrant(x, y) . 4 . &#50508;&#46988; &#49884;&#44228; . 45분 일찍 알람 설정하기 | . h, m = map(int, input().split()) if m &gt;= 45: print(h, m-45) elif h == 0: print(23, m+15) else: print(h-1, m+15) . 23 40 . for&#47928; . N&#51012; &#51077;&#47141;&#48155;&#51008; &#46244;, &#44396;&#44396;&#45800; N&#45800;&#51012; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. &#52636;&#47141; &#54805;&#49885;&#50640; &#47582;&#52656;&#49436; &#52636;&#47141;&#54616;&#47732; &#46108;&#45796;. . n = int(input()) for i in range(1,10): print(&#39;%s * %s = %s&#39; % (n, i, n*i)) . 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 첫째 줄에 테스트 케이스의 개수 T가 주어진다. | 각 테스트 케이스마다 A+B를 출력한다. | . T = int(input()) for i in range(T): A, B = map(int, input().split()) print(A+B) . 6 . 10 . 75 . n&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, 1&#48512;&#53552; n&#44620;&#51648; &#54633;&#51012; &#44396;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 반복문 있는 버전 | . n = int(input()) sum = 0 for i in range(1, n+1): sum += i print(sum) . 55 . 반복문 없는 버전 | . n = int(input()) print(int(n * (n+1) / 2)) . 55 . sys.stdin.readline() . 본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. | 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다. | Python을 사용하고 있다면 input() 대신 sys.stdin.readline()을 사용할 수 있다. | 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우 .rstrip()을 추가로 해 주는 것이 좋다. | . import sys T = int(input()) for i in range(T): A, B = map(int, sys.stdin.readline().split()) print(A+B) . ValueError Traceback (most recent call last) &lt;ipython-input-3-173fe188e1c6&gt; in &lt;module&gt; 2 T = int(input()) 3 for i in range(T): -&gt; 4 A, B = map(int, sys.stdin.readline().split()) 5 print(A+B) ValueError: not enough values to unpack (expected 2, got 0) . error 왜 뜨지? | sys.stdin.readline()를 쓸 때마다 에러가 난다. | . &#51088;&#50672;&#49688; N&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, 1&#48512;&#53552; N&#44620;&#51648; &#54620; &#51460;&#50640; &#54616;&#45208;&#50473; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . N = int(input()) for i in range(1, N+1): print(i) . 1 2 3 4 5 . &#51088;&#50672;&#49688; N&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, N&#48512;&#53552; 1&#44620;&#51648; &#54620; &#51460;&#50640; &#54616;&#45208;&#50473; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . N = int(input()) for i in range(1, N+1): print(N-i+1) . 5 4 3 2 1 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 각 테스트 케이스마다 &quot;Case #x: &quot;를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다. | . import sys T = int(input()) for i in range(1, T+1): A, B = map(int, sys.stdin.readline().split()) print(&#39;Case #%s: %s&#39; % (i, A+B)) . Case #1: 6 . Case #2: 6 . Case #3: 8 . &#52395;&#51704; &#51460;&#50640;&#45716; &#48324; 1&#44060;, &#46168;&#51704; &#51460;&#50640;&#45716; &#48324; 2&#44060;, N&#48264;&#51704; &#51460;&#50640;&#45716; &#48324; N&#44060;&#47484; &#52237;&#45716; &#47928;&#51228; . 하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오. | . print&#54632;&#49688; &#50857;&#48277; . print(출력할 객체, end = &#39;함수가 종료될 때 실행하는 값&#39;) | print()함수에서 end값을 따로 지정하지 않으면 끝을 줄바꿈 문자로 한다. | . print(&#39;안녕&#39;, end = &#39;~~~~&#39;) print(&#39;하세요&#39;) . 안녕~~~~하세요 . N = int(input()) for i in range(N): for j in range(1, N-i): print(&quot; &quot;, end = &quot;&quot;) for k in range(i+1): print(&quot;*&quot;, end = &quot;&quot;) print(&quot; n&quot;, end = &quot;&quot;) . * ** *** **** ***** . &#51221;&#49688; N&#44060;&#47196; &#51060;&#47336;&#50612;&#51652; &#49688;&#50676; A&#50752; &#51221;&#49688; X&#44032; &#51452;&#50612;&#51652;&#45796;. &#51060;&#46412;, A&#50640;&#49436; X&#48372;&#45796; &#51089;&#51008; &#49688;&#47484; &#47784;&#46160; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 첫째 줄에 N과 X가 주어진다. (1 ≤ N, X ≤ 10,000) | 둘째 줄에 수열 A를 이루는 정수 N개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다. | X보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. X보다 작은 수는 적어도 하나 존재한다. | . N, X = map(int, input().split()) A = list(map(int, input().split())) for i in range(N): if A[i] &lt; X: print(A[i], end = &quot; &quot;) . 1 0 . while&#47928; . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 입력의 마지막에는 0 두 개가 들어온다. | . while True: A,B = map(int, input().split()) if A==0 and B==0: break else: print(A+B) . 2 . 4 . &#45908;&#54616;&#44592; &#49324;&#51060;&#53364; . 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. | 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. | 다음 예를 보자. | 26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다. | 위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다. | N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.(0&lt;=N&lt;=99 인 정수) | . n = N = int(input()) N_cycle = 0 while True: if N &lt; 10: N = int(2*str(N)) N_cycle += 1 else: N = int(str(N)[-1]+str(int(str(N)[0])+int(str(N)[-1]))[-1]) N_cycle += 1 if N == n: print(N_cycle) break . 60 . &#54632;&#49688; . N&#44060;&#51032; &#54633; . 정수 n개가 주어졌을 때, n개의 합을 구하는 함수를 작성하시오. | . def solve1(a): sum = 0 for i in range(len(a)): sum += a[i] return(sum) . a=[0,1,2,3,4] solve1(a) . 10 . def solve2(a): return(sum(a)) . a=[0,1,2,3,4] solve2(a) . 10 . &#49472;&#54532; &#45336;&#48260; . 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다. | . z = set(range(1,10001)) - {x+sum([int(a) for a in str(x)]) for x in range(1,10001)} z = list(z) z.sort() for i in range(len(z)): print(z[i]) # 출력이 너무 길어서 출력은 생략 .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "relUrl": "/python/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "파이썬 딥러닝(작성 중)",
            "content": "&#53584;&#49436;&#54540;&#47196; . 무지성 코드(예쩨 그대로 복붙 손으로) | . import tensorflow as tf W = tf.Variable(tf.ones(shape=(2,2)), name = &quot;W&quot;) b = tf.Variable(tf.zeros(shape=(2)), name = &quot;b&quot;) @tf.function def model(x): return W * x + b out_a = model([1,0]) print(out_a) . tf.Tensor( [[1. 0.] [1. 0.]], shape=(2, 2), dtype=float32) . &#52488;&#54217;&#47732;(&#44036;&#45800;&#55176;) . 평면의 단면은 직선, 부피의 단면은 평면, 그 이상은??? | 직선($ax + by + c = 0$)은 2차원의 초평면, 평면($ax + by + cz + d = 0$)은 3차원의 초평면 | $a_1x_1 + a_2x_2 + a_3x_3 + a_4x_4 + c = 0$ 는 뭐라고 불러야 돼??? --&gt; 4차원 공간에 그려짐 | 평면을 일반화하여 초평면을 만듦 | n차원의 그려진 초평면 --&gt; n-1차원 공간 | 초평면은 공간을 분할하는 역할 --&gt; 직선은 평면을 분할, 평면은 공간을 분할 | [$ ast$] n차원의 초평면은 n차원을 분할 [$ ast$] | . &#54140;&#49481;&#53944;&#47200; .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/23/%EB%94%A5%EB%9F%AC%EB%8B%9D.html",
            "relUrl": "/python/2021/06/23/%EB%94%A5%EB%9F%AC%EB%8B%9D.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "map함수(작성 완료)",
            "content": "map&#54632;&#49688; &#53945;&#51669; . 여러 개의 데이터를 한 번에 다른 형태로 변화하기 위해 사용한다. | map 함수는 원본 리스트를 변경하지 않고 새 리스트를 생성한다. | map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환해야 한다. | . map 함수는 리스트의 요소를 지정된 함수로 처리한다. | . x=list(range(5)) x . [0, 1, 2, 3, 4] . def two_times(x): return x*2 . y=two_times(x) y . [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] . z=list(map(two_times, x)) z . [0, 2, 4, 6, 8] . map&#54632;&#49688; &#49324;&#50857;&#48277; . map(함수, 반복가능한 객체) | . x = [1.1, 2.1, 3.1, 4.1] y = map(int, x) print(y) . &lt;map object at 0x0000023B6D93D040&gt; . map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환한다. $ rightarrow [ star$] 변환하지 않으면 위와 같은 결과를 출력한다. [$ star$] | print(y)하지 않고 그냥 y만 입력해도 된다. | . x = [1.1, 2.1, 3.1, 4.1] y = list(map(int, x)) y . [1, 2, 3, 4] . def minus(a): return a - 0.1 . list(map(minus, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . minus 함수는 map함수를 위해 한 번 쓰고 버려질 운명이다. 만드는게 귀찮음... | . map &#54632;&#49688;&#50640; &#46988;&#45796; &#49885; &#49324;&#50857; . x = [1.1, 2.1, 3.1, 4.1] list(map(lambda a: a - 0.1, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . input().split()&#44284; map . input()함수는 c언어의 scanf()함수와 비슷하다. | . z = input() . z . &#39;hello&#39; . input()으로 입력받은 값은 문자열이다. | . n = input() . type(n) . str . input()함수에서 안내문구를 추가할 수 도 있다. | . Q = input(&#39;숫자 하나를 입력하세요:&#39;) . Q . &#39;26&#39; . input()함수의 출력값을 문자열이 아닌 다른 자료형으로 바꾸고 싶다면? | . w = int(input(&#39;숫자 하나를 입력하세요:&#39;)) . type(w) . int . input().split(&quot;기준문자열&quot;)을 사용하면 입력값을 변수 여러 개에 저장할 수 있다. | split()에서 &quot;기준문자열&quot;이 없는 즉 default는 공백이다. | . a, b = input().split() # 입력받은 값을 공백(스페이스, 탭, 엔터 등)을 기준으로 분리 . a, b . (&#39;10&#39;, &#39;20&#39;) . c = a, b type(c) . tuple . a와b가 문자열이다. | int형으로 바꾸고 싶다면? | . a, b = int(input().split()) . TypeError Traceback (most recent call last) &lt;ipython-input-17-0de5d52cb787&gt; in &lt;module&gt; -&gt; 1 a, b = int(input().split()) TypeError: int() argument must be a string, a bytes-like object or a number, not &#39;list&#39; . int()함수를 쓰면 될 것 같았는데 오류가 나온다 | error메시지를 읽어보니 int()함수는 무조건 a string, a bytes-like object or a number 여야 한다.(not &#39;list&#39;) | a, b는 tuple인 것 같다. | 그러면 어떻게 하지? $ longrightarrow$ map()함수를 쓰면 된다. | . a, b = map(int, input().split()) # 입력받은 값을 정수로 변환 . a, b . (10, 20) . type(a) . int . type(b) . int . a, b = map(int, input().split())을 풀어서 쓰면 다음과 같은 코드이다.x = input().split() # input().split()의 결과는 문자열 리스트 m = map(int, x) # 리스트의 요소를 int형으로 변환, 결과는 맵 객체 a, b = m # 맵 객체는 변수 여러 개에 저장 가능 . | . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#54620; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . L = list(map(int, input().split())) L . [10, 8, 7, 1, 0, 3, 5, 2] . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#50668;&#47084; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . data = [] N = int(input()) for i in range(N): data.append(list(map(int,input().split()))) . data . [[1, 4, 0, 2], [17, 8, 1, 0, 4, 6], [1, 0], [0, 4, 5], [0, 0, 10]] .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "date": " • Jun 21, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "파이썬 기말시험(작성 완료)",
            "content": "import pandas as pd import numpy as np class nexon(): &#39;&#39;&#39; 202016248 통계학과 한재수 파이썬 기말시험 1번 문제에 대한 코드 &#39;&#39;&#39; def __init__(self): self.upgradestate = pd.DataFrame({&#39;day0&#39;:[0]*100}) self.prob = 0.3 self.i = 1 def attempt(self): self.attemptresult = np.random.binomial(n=1, p=self.prob, size=100) def update(self): self.upgradestate[&#39;day%s&#39; % self.i] = np.minimum(self.upgradestate[&#39;day%s&#39; % (self.i-1)] + self.attemptresult, 5) ## +5이후로는 증가하지 않는다 self.ratio = sum(self.upgradestate.loc[:,&#39;day%s&#39; % self.i] == 5) / 100 . #1-(1) test1=nexon() for test1.i in range(1,63): test1.attempt() test1.update() 100*test1.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다 . 100.0 . class nexon2(nexon): &#39;&#39;&#39; 202016248 통계학과 한재수 파이썬 기말시험 2번 문제에 대한 코드 &#39;&#39;&#39; def __init__(self): nexon.__init__(self) self.prob = 0.7 self.failstate = pd.DataFrame({&#39;day0&#39;:[0]*100}) def update(self): nexon.update(self) self.failstate[&#39;day%s&#39; % self.i] = self.failstate[&#39;day%s&#39; % (self.i-1)] + (self.attemptresult==0)*1 for j in range(100): if self.upgradestate.iloc[j,self.i] == 0: self.failstate.iloc[j,self.i] = self.failstate.iloc[j,self.i]-1 ## i-1번째 + 강화시도(0 or 1) = i번째 ## i,i-1번째 강화상태가 0이라는 의미는 i-1째에 시도한 강화가 실패했다는 의미. ## upgradestate가 0이라는 의미는 실패했다는 것이므로 실패횟수가 하나 쌓인다. ## +0에서는 실패횟수가 쌓이지 않으므로 failstate값을 하나 뺀다. if (self.upgradestate.iloc[j,self.i] == 5) and (self.attemptresult[j] == 0): ## i-1번째 + 강화시도(0 or 1) = i번째 ## i번째가 +5강화이면서 i-1번째 시도한 강화가 실패라는 의미는 ## i-1번째가 +5강화였다는 의미이다. 그러므로 i번째 실패횟수가 +1 됐을것이다. ## +5강화에서는 강화를 도전하지 않을 것이다. ## 그러므로 i번째 실패횟수를 1을 감소시킨다. self.failstate.iloc[j,self.i] = self.failstate.iloc[j,self.i]-1 ## +5에서는 강화를 시도하지 않을것이므로 ## 만약 실패했다면 failstate값을 하나 뺀다. def reset(self): for j in range(100): if (self.upgradestate.iloc[j,self.i] &gt;0) and (self.upgradestate.iloc[j,self.i] &lt; 5): ## 위에 코드는 update()에서 검증하였으므로 주석표시로 바꾼다 ## 더 정확하게 하기 위해 코드로 냅두자(update함수를 사용하지 않으면 오류가 생길수도?) if self.failstate.iloc[j,self.i] == 2: self.failstate.iloc[j,self.i] = 0 self.upgradestate.iloc[j,self.i] = 0 ## 실패스택이 2라면 실패스택을 0으로 바꾸고 강화상태를 +0으로 바꾼다 def arrangeprobt(self): if self.ratio &gt;= 0.5: self.prob = 0.9 ## +5강 비율이 50%이상이라면 전체유저의 강화 성공확률을 90%로 바꾼다. . #2-(1) test2=nexon2() for test2.i in range(1,63): test2.attempt() test2.update() test2.reset() 100*test2.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . #2-(2) test3=nexon2() for test3.i in range(1,32): test3.attempt() test3.update() test3.reset() 100*test3.ratio ## 31일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 99.0 . #2-(3) test4=nexon2() for test4.i in range(1,63): test4.attempt() test4.update() test4.reset() test4.arrangeprobt() 100*test4.ratio ## 과반수가 +5강화 일때 성공확률을 0.9로 바꾼다,62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . 3 &#45796;&#51020;&#47928;&#51109;&#51012; &#51096; &#51069;&#44256; &#52280; &#44144;&#51667;&#51012; &#54032;&#45800;&#54616;&#50668;&#46972;. (10&#51216;) . (1) tuple은 원소의 값을 임의로 바꿀 수 있다.=&gt; &#39;거짓&#39; . (2) class 에 정의된 함수(=메서드)는 self 만을 인자로 받을수 있다.=&gt; &#39;거짓&#39; .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "relUrl": "/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "date": " • Jun 18, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "깃허브 카테고리 설정(작성 중)",
            "content": "&#44611;&#54728;&#48652; &#52852;&#53580;&#44256;&#47532; . 제목 . &quot;부제목&quot; . -toc: true . -branch: master . -badges: true . -comments: true . -author: 한재수 . -categories: [python] . - 위에 내용을 아무곳에나 붙여 넣는다. 부제목은 (&gt;&quot;부제목&quot;), 제목은 (# 제목) . - categories에 해당하는 부분이 깃허브 홈페이지에서 tag에 보이는 부분이다. . &#48660;&#47196;&#44536; &#44288;&#47532; . 1_ 깃허브 가입하기 | 2_ fastai/fastpages 사용 | 3_ 깃허브 데스크탑 이용 . | (1) 주피터노트북으로 공부한다. . | (2) 깃허브와 연결된 어떤 폴더(드랍박스 안의 green)에 공부한 내용을 넣는다. | (3) 깃허브 데스크탑이라는 프로그램을 이용하여 local(내 윈도우 컴퓨터)에서 remote (github)로 변경사항을 반영한다. | (4) 2~3분 뒤에 블로그 홈페이지에 반영된다. | (5) 공부한 내용을 편집없이 주피터 노트북 파일을 올리기만 하면 블로그에 올라가서 편하다. 필요에 따라 숨기기, 비밀 포스트도 만들 수 있다. | . &#44611;, &#44611;&#54728;&#48652; . 버전 관리 시스템 | 서로 코드를 공유 | 혼자 쓰면 개인 저장소.. | . &#51452;&#54588;&#53552;&#45432;&#53944;&#48513; --&gt; remote --&gt; page (&#50504; &#50732;&#46972;&#44040; &#49688; &#46020; &#51080;&#45796;) . 깃허브 데스크탑 history에서 이제껏 했던 커밋을 볼 수 있다. 게다가 삭제된 파일을 복구할 수 도 있다. | 화면 캡쳐 프로그램으로 캡쳐를 함 --&gt; 마크다운에서 캡쳐한 이미지를 ctrl+v하면 캡쳐한 이미지가 삽입된다. | 이미지 파일을 넣은 주피터 노트북 파일을 올리면 깃허브 notebook에는 올라가지만 블로그에는 올라가지 않는다. | . &#44611;&#54728;&#48652; &#45936;&#49828;&#53356;&#53457;&#50640;&#49436; &#50724;&#47448;&#44032; &#45228;&#45716;&#45936; &#47784;&#47476;&#44192;&#45796;. gg . &#47560;&#53356;&#45796;&#50868; &#51089;&#49457;&#54616;&#47732;&#49436; &#49888;&#44592;&#54620; &#51216;&#51012; &#54616;&#45208; &#50508;&#50500;&#45256;&#45796;. . 1 앞에 띄어쓰기 안됨 | . 하나를 붙였을 뿐인데 앞에 띄어쓰기가 된다??? | | 3 이유를 모르겠음.. | . &#45236;&#44032; &#50508;&#50500;&#45240; &#47560;&#53356;&#45796;&#50868; &#50857;&#48277; . &#49688;&#49885;&#51012; &#47691;&#51080;&#44172; &#54364;&#54788;&#54616;&#44256; &#49910;&#45796;&#47732;?? . $수식$ 꼴로 나타낸다. | y = x + 1 | $y = x +1$ | . &#48145; &#52392;&#51088; &#54364;&#54788; . $수식_밑첨자$ | x_1 + x_2 = x_3 | $x_1 + x_2 = x_3$ | .",
            "url": "https://gkswotn12345.github.io/green/python/2021/05/24/%EA%B9%83%ED%97%88%EB%B8%8C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC.html",
            "relUrl": "/python/2021/05/24/%EA%B9%83%ED%97%88%EB%B8%8C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC.html",
            "date": " • May 24, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "7. Class 고급",
            "content": "&#53364;&#47000;&#49828;, &#51064;&#49828;&#53556;&#49828;, &#50724;&#48652;&#51229;&#53944; . - 오브젝트 . 클래스 오브젝트 | 인스턴스 오브젝트 | . - 클래스 (=클래스 오브젝트) . - 인스턴스 (=인스턴스 오브젝트) . &#53364;&#47000;&#49828; &#49549;&#49457; vs &#51064;&#49828;&#53556;&#49828; &#49549;&#49457; . &#50696;&#51228;1 . class Testclass1: x=0 y=0 def my_print(self): self.x += 1 Testclass1.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . f=Testclass1 . a=Testclass1() . b=f() . a.my_print() . b.my_print() . b.my_print() . a.my_print() . a.my_print() . - 신기한점: 각 인스턴스에서 instance.my_print()를 실행한 횟수를 서로 공유하는 듯 하다. . &#48516;&#49437; . - 코드를 시점별로 분석해보자. . - 분석을 위해서 커널을 재시작한다. . [시점1]: Testclass1를 선언하는 시점 . class Testclass1: x=0 y=0 def my_print(self): self.x += 1 Testclass1.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . dir(Testclass1) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;, &#39;x&#39;, &#39;y&#39;] . dir(a) . NameError Traceback (most recent call last) &lt;ipython-input-8-3af1c875b71a&gt; in &lt;module&gt; -&gt; 1 dir(a) NameError: name &#39;a&#39; is not defined . dir(b) . NameError Traceback (most recent call last) &lt;ipython-input-9-35660f044d44&gt; in &lt;module&gt; -&gt; 1 dir(b) NameError: name &#39;b&#39; is not defined . – 이 시점에는 Testclass1만이 존재한다. Testclass1를 바로 클래스 오브젝트라고 부름. . Testclass1.x . 0 . Testclass1.y . 0 . – 현재시점에서는 클래스 오브젝트의 수 1개, 인스턴스 오브젝트의 수 0개, 따라서 총 오브젝트 수는 1개임. . [시점2] 클래스에 별칭을 지정하는 시점 . f=Testclass1 . f.x . 0 . f.y . 0 . Testclass1.x . 0 . Testclass1.y . 0 . – 이 시점에서 클래스 오브젝트는 2개가 있는 것 처럼 보인다. . - 그렇다면 이 2개의 클래스 오브젝트는 컴퓨터의 어딘가에 저장이 되어 있을 것이다. . - 구체적으로는 메모리에 저장되어있을것. . - 2개의 클래스오브젝트는 서로 다른 메모리 공간에 저장되어 있을것이다. . - 진짜인가? 확인해보자. id()는 오브젝트(클래스 오브젝트, 인스턴스 오브젝트)가 저장된 메모리 주소를 확인하는 명령어이다. . id(f) . 93967322676384 . – f라는 오브젝트는 93967322676384 메모리에 저장되어 있다. . id(Testclass1) . 93967322676384 . - 어? 그런데 Testclass1의 오브젝트 역시 93967322676384 메모리에 저장되어 있다. . - 추론: 사실 93967322676384라는 메모리공간에 저장된 어떠한 것은 동일한데, 그것을 어떤사람은 Testclass1 이라고 부르고 어떤사람은 f라고 부른다. . - 이는 마치 별명이랑 비슷하다. 나라는 오브젝트를 어떤사람은 최규빈이라고 부르고, 어떤사람은 팬더라고 부른다. 부르는 이름이 2개라고 해서 나라는 오브젝트가 2개가 있는것은 아니다. . - 결국 이 시점에서 클래스 오브젝트의 수는 여전히 1개라고 볼 수 있다. (인스턴스 오브젝트의 수는 0개) . [시점3]: 클래스 오브젝트로부터 인스턴스 오브젝트를 만드는 시점 . a=Testclass1() b=f() . id(Testclass1),id(f),id(a),id(b) . (93967322676384, 93967322676384, 139694857660688, 139694848860656) . – 이 순간에는 클래스 오브젝트 1개, 인스턴스 오브젝트 2개 존재한다. 즉 총 3개의 오브젝트가 존재한다. . - 메모리주소 93967322676384 에 존재하는 오브젝트는 클래스 오브젝트이며 Testclass1 또는 f 라고 불린다. . - 메모리주소 139694857660688 에 존재하는 오브젝트는 인스턴스 오브젝트이며 a라고 불린다. . - 메모리주소 139694848860656 에 존재하는 오브젝트는 인스턴스 오브젝트이며 b라고 불린다. . Testclass1.x, Testclass1.y . (0, 0) . f.x,f.y . (0, 0) . a.x,a.y . (0, 0) . b.x,b.y . (0, 0) . [시점4] . a.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 1), (1, 1), (0, 1)) . - 특징 . a.my_print()를 실행하면 a.x 의 값이 1이 증가한다. | a.my_print()를 실행하면 f.y, a.y, b.y 의 값이 동시에 1이 증가한다. (공유가 되는 느낌) | . [시점5] . b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 2 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 2), (1, 2), (1, 2)) . [시점6] . b.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 3 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 3), (1, 3), (2, 3)) . [시점7] . a.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 4 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 4), (2, 4), (2, 4)) . [시점8] . a.my_print() . 현재 인스턴스에서 3 회 출력 전체 인스턴스에서 총 5 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 5), (3, 5), (2, 5)) . &#50696;&#51228;2 . - 아래처럼 코드를 바꿔도 잘 동작할것 같다. . class Testclass2: def __init__(self): self.x=0 self.y=0 def my_print(self): self.x += 1 Testclass2.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . c=Testclass2() . c.my_print() . AttributeError Traceback (most recent call last) &lt;ipython-input-51-5500abb1215d&gt; in &lt;module&gt; -&gt; 1 c.my_print() &lt;ipython-input-46-72dbe3bd77f6&gt; in my_print(self) 5 def my_print(self): 6 self.x += 1 -&gt; 7 Testclass2.y +=1 8 print(&#34;현재 인스턴스에서 %s 회 출력&#34; % self.x) 9 print(&#34;전체 인스턴스에서 총 %s 회 출력&#34; % self.y) AttributeError: type object &#39;Testclass2&#39; has no attribute &#39;y&#39; . – 왜 에러가 나는가? . dir(Testclass2) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;] . dir(Testclass1) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;, &#39;x&#39;, &#39;y&#39;] . - 관찰1: Testclass2에서는 Testclass1과는 다르게 x,y가 없다. . dir(c) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;, &#39;x&#39;, &#39;y&#39;] . – 관찰2: 그런데 c라는 인스턴스 오브젝트에서는 x,y가 있다. . - 추론: __init__함수는 클래스 오브젝트가 만들어지는 시점에서는 실행되지 않고, 인스텐스 오브젝트가 만들어지는 시점에 실행된다. . - 결국 __init__함수의 역할은 클래스 오브젝트에서 인스턴스 오브젝트를 만든후에 초기화를 위해서 실행하는 어떠한 일련의 명령들을 묶어놓은 것에 불과하다. . – 즉 위의 코드는 굳이 따지면 아래를 실행한 것과 동일하다. . class Testclass2: # def __init__(self): # self.x=0 # self.y=0 def my_print(self): self.x += 1 Testclass2.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . c=Testclass2() . c.x=0 c.y=0 . - 이 상황에서 . c.my_print() . 를 실행하면 . c.x += 1 Testclass2.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % c.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % c.y) . 이 실행되는데, 이때 Testclass2.y 이 정의되어 있지 않으므로 . Testclass2.y +=1 . 에서 에러가 난다. . c.my_print() . AttributeError Traceback (most recent call last) &lt;ipython-input-63-5500abb1215d&gt; in &lt;module&gt; -&gt; 1 c.my_print() &lt;ipython-input-55-66666a70bf33&gt; in my_print(self) 5 def my_print(self): 6 self.x += 1 -&gt; 7 Testclass2.y +=1 8 print(&#34;현재 인스턴스에서 %s 회 출력&#34; % self.x) 9 print(&#34;전체 인스턴스에서 총 %s 회 출력&#34; % self.y) AttributeError: type object &#39;Testclass2&#39; has no attribute &#39;y&#39; . &#50696;&#51228; 3 . - 그렇다면 아래와 같이 수정하면 어떨까? . class Testclass3: def __init__(self): self.x=0 Testclass3.y=0 def my_print(self): self.x += 1 Testclass3.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . a=Testclass3() b=Testclass3() . a.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 2 회 출력 . a.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 3 회 출력 . a.my_print() . 현재 인스턴스에서 3 회 출력 전체 인스턴스에서 총 4 회 출력 . b.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 5 회 출력 . b.my_print() . 현재 인스턴스에서 3 회 출력 전체 인스턴스에서 총 6 회 출력 . – Testclass1과 동일한 기능이 수행되는것 같다. . - 그런데 조금만 생각해보면 엉터리라는 것을 알 수 있다. 아래의 코드를 관찰하여보자. . class Testclass3: def __init__(self): self.x=0 Testclass3.y=0 def my_print(self): self.x += 1 Testclass3.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) a=Testclass3() a.my_print() a.my_print() b=Testclass3() b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 2 회 출력 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . - Testclass3는 인스턴스를 생성할때마다 y=0이 설정된다. 그래서 . b=Testclass3() . 이 시점에서 의도하지 않게 &#39;전체 인스턴스에서 출력된 횟수&#39;를 의미하는 y가 초기화되었다. . - 코드는 엉터리이지만, Testclass3은 의외로 분석할만한 가치가 있다. 특히 위의 실행결과를 시점별로 Testclass1과 비교해보면 재미있다. . - Testclass1 . ### Testclass1 ## 시점1: 클래스 오브젝트 생성 class Testclass1: x=0 y=0 def my_print(self): self.x += 1 Testclass1.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) ## 시점2: 인스턴스 오브젝트 a를 생성 a=Testclass1() ## 시점3: a에서 메소드 실행 a.my_print() ## 시점4: a에서 메소드를 한번 더 실행 a.my_print() ## 시점5: 인스턴스 오브젝트 b를 생성 b=Testclass1() ## 시점6: b에서 메소드를 실행 b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 2 회 출력 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 3 회 출력 . 시점1 시점2 시점3 시점4 시점5 시점6 . Testclass1.x | 0 | 0 | 0 | 0 | 0 | 0 | . Testclass1.y | 0 | 0 | 1 | 2 | 2 | 3 | . a.x | 값없음 | 0 | 1 | 2 | 2 | 2 | . a.y | 값없음 | 0 | 1 | 2 | 2 | 3 | . b.x | 값없음 | 값없음 | 값없음 | 값없음 | 0 | 1 | . b.y | 값없음 | 값없음 | 값없음 | 값없음 | 2 | 3 | . – Testclass3 . #### Testclass3 ## 시점1: 클래스 오브젝트 생성 class Testclass3: def __init__(self): self.x=0 Testclass3.y=0 def my_print(self): self.x += 1 Testclass3.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) ## 시점2: 인스턴스 오브젝트 a를 생성 a=Testclass3() ## 시점3: a에서 메소드 실행 a.my_print() ## 시점4: a에서 메소드를 한번 더 실행 a.my_print() ## 시점5: 인스턴스 오브젝트 b를 생성 b=Testclass3() ## 시점6: b에서 메소드를 실행 b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 2 회 출력 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . 시점1 시점2 시점3 시점4 시점5 시점6 . Testclass3.x | 값없음 | 값없음 | 값없음 | 값없음 | 값없음 | 값없음 | . Testclass3.y | 값없음 | 0 | 1 | 2 | 0 | 1 | . a.x | 값없음 | 0 | 1 | 2 | 2 | 2 | . a.y | 값없음 | 0 | 1 | 2 | 0 | 1 | . b.x | 값없음 | 값없음 | 값없음 | 값없음 | 0 | 1 | . b.y | 값없음 | 값없음 | 값없음 | 값없음 | 0 | 1 | . – Testclass3.y가 업데이트 되면 a.y, b.y도 자동으로 업데이트 된다. . 숙제: . #### Testclass3 ## 시점1: 클래스 오브젝트 생성 class Testclass3: y=0 def __init__(self): self.x=0 def my_print(self): self.x += 1 Testclass3.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) ## 시점2: 인스턴스 오브젝트 a를 생성 a=Testclass3() ## 시점3: a에서 메소드 실행 a.my_print() ## 시점4: a에서 메소드를 한번 더 실행 a.my_print() ## 시점5: 인스턴스 오브젝트 b를 생성 b=Testclass3() ## 시점6: b에서 메소드를 실행 b.my_print() . 시점1 시점2 시점3 시점4 시점5 시점6 . Testclass3.x | | | | | | | . Testclass3.y | | | | | | | . a.x | | | | | | | . a.y | | | | | | | . b.x | | | | | | | . b.y | | | | | | | . &#45348;&#51076;&#49828;&#54168;&#51060;&#49828; . &#50696;&#51228;1 . - 아래의 코드를 관찰하라. . class Testclass1: x=0 . Testclass1.x . 0 . a=Testclass1() . a.x . 0 . – Testclass1.x를 수정하면 a.x가 강제로 수정된다. . Testclass1.x=100 . a.x . 100 . - a.x를 수정한다고 하여 Testclass1.x가 강제로 수정되는 것은 아님 . a.x=200 . Testclass1.x . 100 . a.x . 200 . - 이건 왜이러지? . Testclass1.x=300 . a.x . 200 . - 아래의 상황과 비슷하다. . x=39 def nextyear(): y=x+1 print(x,y) nextyear() . 39 40 . x=39 def nextyear(): y=x+1 print(x,y) x=0 nextyear() . UnboundLocalError Traceback (most recent call last) &lt;ipython-input-29-9c5d2bc270db&gt; in &lt;module&gt; 5 print(x,y) 6 x=0 -&gt; 7 nextyear() &lt;ipython-input-29-9c5d2bc270db&gt; in nextyear() 2 x=39 3 def nextyear(): -&gt; 4 y=x+1 5 print(x,y) 6 x=0 UnboundLocalError: local variable &#39;x&#39; referenced before assignment . – [code1]은 잘 실행되던 코드다. . - [code2]는 실행안되는 코드다. . - [code2]와 [code1]의 차이점은 x=0이라는 코드가 추가로 포함되었는지 유무다. . – (헛소리) x=0 이 잘못된 코드다!! 이걸 실행하는 과정에서 문제가 생겼다!! . - (올바른소리) code1에서는 x는 global variable, code2에서는 x가 local variable 이라서 생기는 문제점이다. . x=39 def nextyear(): x=0 y=x+1 print(x,y) nextyear() . 0 1 . x . 39 . – 다시 우리의 예제로 돌아오자. . ### 시점1 class Testclass1: x=0 ### 시점2 a=Testclass1() ### 시점3 Testclass1.x=100 ### 시점4 a.x=200 ### 시점5 Testclass1.x=300 . 시점1 시점2 시점3 시점4 시점5 . Testclass1.x | 0 | 0 | 100 | 100 | 300 | . a.x | 값없음 | 0 | 100 | 200 | 200 | . a.x의 속성 | - | class | class | instance | instance | . – a.x가 클래스로부터 물려받은 속성인지 (그래서 클래스와 연결되어있는지) 아니면 instance가 독자적으로 가지고 있는 속성인지 어떻게 알 수 있을까? . class Testclass1: x=0 print(&#39;시점1&#39;,Testclass1.x) ### 시점2 a=Testclass1() print(&#39;시점2&#39;,Testclass1.x,a.x,a.__dict__) ### 시점3 Testclass1.x=100 print(&#39;시점3&#39;,Testclass1.x,a.x,a.__dict__) ### 시점4 a.x=200 print(&#39;시점4&#39;,Testclass1.x,a.x,a.__dict__) ### 시점5 Testclass1.x=300 print(&#39;시점5&#39;,Testclass1.x,a.x,a.__dict__) . 시점1 0 시점2 0 0 {} 시점3 100 100 {} 시점4 100 200 {&#39;x&#39;: 200} 시점5 300 200 {&#39;x&#39;: 200} . &#50696;&#51228;2 . x=11 ## 전역변수 ... A def f(): x=22 ## 함수 f안에 설정된 지역변수 print(x) ## 전역에 x=11 있지만 함수안에 x=22가 있으므로 x=22를 사용. --&gt; 22출력됨 def g(): print(x) ## 함수 g안에 x를 찾아봤는데 없음 --&gt; 전역에서 x를 찾음 --&gt; x=11 --&gt; 11출력함. class Testclass2: x=33 ## 클래스 변수 ... B def m1(self): x=44 ## 메소드 변수 ... C def m2(self): self.x=44 ## 인스턴스 변수 ... D . - 결과를 관찰하고 해석해보자. . print(x) . 11 . . Note: 전역변수 출력 . f() . 22 . . Note: f에서 설정된 지역변수 22가 출력됨 . x . 11 . . Note: f내의 지역변수를 사용하여도 전역변수는 변하지 않음. (함수내부에서 선언된 x=22는 함수외부에 영향을 주지못함) . g() . 11 . . Note: g에서 설정된 지역변수가 따로 없으므로 전역변수 출력 . x,Testclass2.x . (11, 33) . . Note: 전역변수 x와 클래스오브젝트에 설정된 변수 x . a=Testclass2() (x,Testclass2.x,a.x),a.__dict__ . ((11, 33, 33), {}) . . Note: 전역변수, 클래스 오브젝트내의 변수, 인스턴스내의 변수. a.__dict__의 결과로 보아 인스턴스내의 변수는 클래스 오브젝트내의 변수를 빌려쓰고 있다. . Testclass2.x=200 (x,Testclass2.x,a.x),a.__dict__ . ((11, 200, 200), {}) . . Note: 클래스오브젝트에서 변수를 고치면 인스턴스에 영향을 미침 . a.m1() (x,Testclass2.x,a.x),a.__dict__ . ((11, 200, 200), {}) . . Note: 메소드 m1내에서 선언된 x=44라는 선언은 아무것도 변화시킬수 없음. . a.m2() (x,Testclass2.x,a.x),a.__dict__ . ((11, 200, 44), {&#39;x&#39;: 44}) . . Note: 메소드 m2에 있는 self.x는 결국 a.x라는 의미이고, 이 선언은 클래스오브젝트 내의 변수와 독립적으로 인스턴스오브젝트 내에서 통용되는 변수를 선언하는 것임. 이 선언의 결과는 a.__dict__의 출력결과에서도 확인가능. . Testclass2.x=300 (x,Testclass2.x,a.x),a.__dict__ . ((11, 300, 44), {&#39;x&#39;: 44}) . . Note: 이제는 a.x와 Testclass2.x 는 분리된 상태이므로, Testclass2.x의 값을 바꾸어도 a.x에는 값의 변화가 없음. . - 뭐 어쩌라는 것임? . - 그냥 그렇다는것.. 내용을 모르고 사용한다면 예상하지 못한 오류가 발생할 수 있으므로 조심해서 사용하자. . 숙제: 전역변수(A), 클래스 변수(B), 메소드 변수(C), 인스턴스 변수(D) . 답: A&gt;B&gt;D&gt;C . &#50672;&#49328;&#51088; &#50724;&#48260;&#47196;&#46377; . - 아래의 코드를 관찰하자. . 1+1 . 2 . - 생각해보니까 1은 int class 에서 생성된 인스턴스이다. . - 코드를 관찰하니 instance와 instance를 +라는 연산이 연결하는 형태임. . class Student: def __init__(self,age=20.0,semester=1): self.age=age self.semester=semester def __add__(self,val): # val==0: 휴학 # val==1: 등록 if val==0: self.age=self.age +0.5 elif val==1: self.age=self.age+0.5 self.semester=self.semester+1 return self def __repr__(self): return &#39;나이: %s n학기: %s&#39; % (self.age,self.semester) . guebin=Student() . guebin.age . 20.0 . guebin.semester . 1 . guebin . 나이: 20.0 학기: 1 . guebin+1 . 나이: 20.5 학기: 2 . guebin+0 . 나이: 21.0 학기: 2 . guebin+0+0+0+0+1+0+1 . 나이: 24.5 학기: 4 . - 연산자 오버로드 핵심아이디어 . 클래스가 일반 파이썬 연산을 재정의하는 것 | 여기에서 연산은 단순히 더하기 빼기를 의미하는게 아니라, print(), +, [0] 와 같은 파이썬 내장문법을 모두 포괄하는 개념이라 이해하는 것이 옳다. | . guebin[0] . TypeError Traceback (most recent call last) &lt;ipython-input-192-961de20e3474&gt; in &lt;module&gt; -&gt; 1 guebin[0] TypeError: &#39;Student&#39; object is not subscriptable . class Student2(Student): def __getitem__(self,index): return [self.age,self.semester][index] . hynn=Student2() . hynn+1+1+0+0 . 나이: 22.0 학기: 3 . hynn[0] . 22.0 . hynn[1] . 3 . hynn[:] . [22.0, 3] . - 연산자 오버로딩을 이해하면 파이썬 전반에 대한 이해폭이 넓어진다. . import pandas as pd . df=pd.DataFrame({&#39;age&#39;:[20,21.5],&#39;semester&#39;:[1,2]}) . df.iloc[:,0] . 0 20.0 1 21.5 Name: age, dtype: float64 . &#46020;&#50880;&#47568; &#51089;&#49457;&#48169;&#48277; . - 넘파이의 경우 아래와 같이 도움말이 잘 작성되어 있다. . import numpy as np a=np.array([1,2,3]) a? . Type: ndarray String form: [1 2 3] Length: 3 File: ~/anaconda3/envs/py38r40/lib/python3.8/site-packages/numpy/__init__.py Docstring: &lt;no docstring&gt; Class docstring: ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using `array`, `zeros` or `empty` (refer to the See Also section below). The parameters given here refer to a low-level method (`ndarray(...)`) for instantiating an array. For more information, refer to the `numpy` module and examine the methods and attributes of an array. Parameters - (for the __new__ method; see Notes below) shape : tuple of ints Shape of created array. dtype : data-type, optional Any object that can be interpreted as a numpy data type. buffer : object exposing buffer interface, optional Used to fill the array with data. offset : int, optional Offset of array data in buffer. strides : tuple of ints, optional Strides of data in memory. order : {&#39;C&#39;, &#39;F&#39;}, optional Row-major (C-style) or column-major (Fortran-style) order. Attributes - T : ndarray Transpose of the array. data : buffer The array&#39;s elements, in memory. dtype : dtype object Describes the format of the elements in the array. flags : dict Dictionary containing information related to memory use, e.g., &#39;C_CONTIGUOUS&#39;, &#39;OWNDATA&#39;, &#39;WRITEABLE&#39;, etc. flat : numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for assignment examples; TODO). imag : ndarray Imaginary part of the array. real : ndarray Real part of the array. size : int Number of elements in the array. itemsize : int The memory use of each array element in bytes. nbytes : int The total number of bytes required to store the array data, i.e., ``itemsize * size``. ndim : int The array&#39;s number of dimensions. shape : tuple of ints Shape of the array. strides : tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous ``(3, 4)`` array of type ``int16`` in C-order has strides ``(8, 2)``. This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time (``2 * 4``). ctypes : ctypes object Class containing properties of the array needed for interaction with ctypes. base : ndarray If the array is a view into another array, that array is its `base` (unless that array is also a view). The `base` array is where the array data is actually stored. See Also -- array : Construct an array. zeros : Create an array, each element of which is zero. empty : Create an array, but leave its allocated memory unchanged (i.e., it contains &#34;garbage&#34;). dtype : Create a data-type. Notes -- There are two modes of creating an array using ``__new__``: 1. If `buffer` is None, then only `shape`, `dtype`, and `order` are used. 2. If `buffer` is an object exposing the buffer interface, then all keywords are interpreted. No ``__init__`` method is needed because the array is fully initialized after the ``__new__`` method. Examples -- These examples illustrate the low-level `ndarray` constructor. Refer to the `See Also` section above for easier ways of constructing an ndarray. First mode, `buffer` is None: &gt;&gt;&gt; np.ndarray(shape=(2,2), dtype=float, order=&#39;F&#39;) array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: &gt;&gt;&gt; np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) . - 하지만 우리는? . hynn? . Type: Student2 String form: 나이: 22.0 학기: 3 Docstring: &lt;no docstring&gt; . - 우리도 도움말을 작성하고 싶다. . class Student2(Student): &#39;&#39;&#39; Student2는 Student의 개선 # Student 클래스의 기능 1. 출력기능 (__repr__) 2. 연산기능 (__add__): 학기와 나이를 카운트 Examples -- &gt;&gt;&gt; hynn=Student2() &gt;&gt;&gt; hynn+1 나이: 20.5 학기: 2 # Student2에서 추가된 기능 1. 인덱싱 &#39;&#39;&#39; def __getitem__(self,index): return [self.age,self.semester][index] . hynn=Student2() . hynn? . Type: Student2 String form: 나이: 20.0 학기: 1 Docstring: Student2는 Student의 개선 # Student 클래스의 기능 1. 출력기능 (__repr__) 2. 연산기능 (__add__): 학기와 나이를 카운트 Examples -- &gt;&gt;&gt; hynn=Student2() &gt;&gt;&gt; hynn+1 나이: 20.5 학기: 2 # Student2에서 추가된 기능 1. 인덱싱 . hynn=Student2(21,1) . hynn . 나이: 21 학기: 1 . hynn? . Type: Student2 String form: 나이: 21 학기: 1 Docstring: Student2는 Student의 개선 # Student 클래스의 기능 1. 출력기능 (__repr__) 2. 연산기능 (__add__): 학기와 나이를 카운트 Examples -- &gt;&gt;&gt; hynn=Student2() &gt;&gt;&gt; hynn+1 나이: 20.5 학기: 2 # Student2에서 추가된 기능 1. 인덱싱 . self&#50640; &#45824;&#54620; &#51652;&#49892; . – 사실 이름이 self가 아니어도 된다. . class MooYaHo: def __init__(a): a.text=&#39;mooyaho&#39; . moo1=MooYaHo() . moo1.text . &#39;mooyaho&#39; . – 그런데 self를 많이 쓴다. . 숙제: MooYaHo class의 도움말에 학번을 넣고 출력 . class MooYaHo: &#39;&#39;&#39; 202016248 한재수 &#39;&#39;&#39; def __init__(self): self.text=&#39;mooyaho&#39; . moo1 = MooYaHo() . moo1 . &lt;__main__.MooYaHo at 0x18690e7a3d0&gt; . moo1.text . &#39;mooyaho&#39; . moo1? . Type: MooYaHo String form: &lt;__main__.MooYaHo object at 0x0000018690E7A3D0&gt; Docstring: 202016248 한재수 .",
            "url": "https://gkswotn12345.github.io/green/python/2021/05/24/note7.html",
            "relUrl": "/python/2021/05/24/note7.html",
            "date": " • May 24, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://gkswotn12345.github.io/green/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://gkswotn12345.github.io/green/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "Study with me",
          "content": "수상 . - 1학년 2학기 때 장학금 10만원… . 학점 . - 1학년 1학기: 4.38 . - 1학년 2학기: 4.50 . - 2학년 1학기: 4.00(희망), 4.33(현실)? . 프로그래밍 언어 . - R . - 파이썬 . - 잘하고 싶다… . 자격증 . - 있을까? . 토익 . - 할거임 . 대외활동 . - 해야지 . 공모전 . - . . 봉사활동 . - .. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://gkswotn12345.github.io/green/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://gkswotn12345.github.io/green/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}