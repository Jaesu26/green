{
  
    
        "post0": {
            "title": "회귀분석 10장 과제",
            "content": "10.2 . y = c(18, 17.4, 14.5, 14, 13.4, 24.4, 22.7, 12.7, 27.1, 25.4,33.5, 35.6, 26.1, 36.8, 34.9, 43.6) x1 = c(61, 72, 85, 84, 98, 53, 54, 89, 77, 88, 76, 59, 91, 65, 81, 51) x2 = rep(c(&#39;A&#39;, &#39;B&#39;), each = 8) . x2 = ifelse(x2 == &#39;A&#39;, 0, 1) . x2 . &lt;ol class=list-inline&gt;0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | &lt;/ol&gt; m = lm(y~x1+x2) summary(m) . Call: lm(formula = y ~ x1 + x2) Residuals: Min 1Q Median 3Q Max -4.7121 -1.5151 -0.1434 1.3539 4.3026 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 39.76136 3.62542 10.967 6.10e-08 *** x1 -0.30368 0.04689 -6.476 2.08e-05 *** x2 15.43382 1.37079 11.259 4.47e-08 *** Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 2.74 on 13 degrees of freedom Multiple R-squared: 0.9304, Adjusted R-squared: 0.9197 F-statistic: 86.95 on 2 and 13 DF, p-value: 2.987e-08 . $ hat{y}=39.76136-0.30368 x_1+15.43382 x_2$ . m0 = lm(y~1) . anova(m0, m) . A anova: 2 × 6 Res.DfRSSDfSum of SqFPr(&gt;F) . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 115 | 1403.10938 | NA | NA | NA | NA | . 213 | 97.59762 | 2 | 1305.512 | 86.94707 | 2.98717e-08 | . - 에제 10.2에서는 회귀모델은 유의하나 교호작용항은 p값이 0.11252로 커서 유의하지 않았다 . - 교호작용이 없는 모형에서는 모든 변수가 유의하다 . - 또한 p-value가 거의 0이므로 추정된 회귀모델은 유의하다고 할 수 있다 . 10.4 . x1 = c(2.5, 4.4, 4.5, 1.4, 4.7, 3.5, 2.5, 3.8) y = c(65, 34, 40, 80, 30, 57, 72, 48) . 1) . plot(y~x1) . - $x = 3.8$을 기준으로 2개의 구간으로 나누어 분석하는것이 좋아보인다 . - $x=3.8$ 이전 데이터들의 기울기보다 $x=3.8$ 이후 데이터들의 기울기가 눈에 띄게 더 가파르고 이전 데이터는 넓은 범위에 존재하는 반면 이후에는 3개의 데이터가 밀집되어 있기 때문이다 . 2) . - 위와 같은 이유로 $x = 3.8$을 기준으로 나누는것이 좋아보인다 . x2 = function(x) ifelse(x1 &gt; 3.8, 1, 0) . x2_ = (x1-3.8)*x2(x1) . m = lm(y~x1+x2_) summary(m) . Call: lm(formula = y ~ x1 + x2_) Residuals: 1 2 3 4 5 6 7 8 -2.421 -3.663 4.531 -1.462 -1.082 2.344 4.579 -2.826 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 99.333 5.907 16.817 1.36e-05 *** x1 -12.765 2.046 -6.238 0.00155 ** x2_ -9.173 6.201 -1.479 0.19911 Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 3.939 on 5 degrees of freedom Multiple R-squared: 0.9668, Adjusted R-squared: 0.9535 F-statistic: 72.71 on 2 and 5 DF, p-value: 0.0002015 . $ hat{y}=99.333-12.765x_1-9.173x_{2 _}$ . - $x{2 _}$에 대한 p-value가 0.19911로 0.05보다 크므로 영가설을 기각하지 못한다 . - $ beta_2 neq 0$ 라고 할 수 없다 . 10.5 . y = c(15, 16, 18, 13, 19, 16, 15, 16, 17, 15, 18, 17, 18, 19, 20, 16, 15, 19, 18, 16, 20, 19, 21, 18, 19, 17, 18, 21, 20, 17, 16, 17, 18, 17, 15, 15, 15, 18, 17, 16, 19, 21, 22, 23, 20, 18, 20, 21, 22, 19, 24, 25, 23, 25, 25, 23, 24, 22, 26, 24) x1 = rep(c(5, 10, 20, 5, 10, 20), each = 10) x2 = rep(c(&#39;A&#39;, &#39;B&#39;), each = 30) . x2 = ifelse(x2 == &#39;A&#39;, 0, 1) . x2 . &lt;ol class=list-inline&gt;0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | &lt;/ol&gt; 1) . - $y$는 불안도, $x_1$은 약의 복용량, $x_2$는 약의 종류 . $y= beta_0+ beta_1 x_1+ beta_2 x_2$ . 2) . m0 = lm(y~1) . m = lm(y~x1+x2) summary(m) . Call: lm(formula = y ~ x1 + x2) Residuals: Min 1Q Median 3Q Max -3.3786 -1.0875 -0.0571 1.0857 3.7429 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 13.55000 0.54711 24.766 &lt; 2e-16 *** x1 0.34143 0.03741 9.127 9.59e-13 *** x2 2.80000 0.46658 6.001 1.43e-07 *** Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 1.807 on 57 degrees of freedom Multiple R-squared: 0.6767, Adjusted R-squared: 0.6654 F-statistic: 59.66 on 2 and 57 DF, p-value: 1.055e-14 . $ hat{y}=13.55000+0.34143x_1+2.80000x_2$ . anova(m0, m) . A anova: 2 × 6 Res.DfRSSDfSum of SqFPr(&gt;F) . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 159 | 575.7333 | NA | NA | NA | NA | . 257 | 186.1286 | 2 | 389.6048 | 59.65627 | 1.055268e-14 | . - F통계량에 근거한 p-value가 거의 0이므로 회귀모형은 유의하다 . 3) . m = lm(y~x1+x2) summary(m) . Call: lm(formula = y ~ x1 + x2) Residuals: Min 1Q Median 3Q Max -3.3786 -1.0875 -0.0571 1.0857 3.7429 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 13.55000 0.54711 24.766 &lt; 2e-16 *** x1 0.34143 0.03741 9.127 9.59e-13 *** x2 2.80000 0.46658 6.001 1.43e-07 *** Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 1.807 on 57 degrees of freedom Multiple R-squared: 0.6767, Adjusted R-squared: 0.6654 F-statistic: 59.66 on 2 and 57 DF, p-value: 1.055e-14 . $ hat{y}=13.55000+0.34143x_1+2.80000x_2$ . - F-통계량에 근거한 p-value가 거의 0이므로 회귀모형은 유의하다 . - A안정제보다 B안정제인 경우 실험용동물의 평균불안도가 2.8 더 높다 . 4) . x12 = x1*x2 . m2 = lm(y~x1+x2+x12) summary(m2) . Call: lm(formula = y ~ x1 + x2 + x12) Residuals: Min 1Q Median 3Q Max -3.2571 -1.2143 -0.1286 0.8893 3.4857 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 15.30000 0.59828 25.573 &lt; 2e-16 *** x1 0.19143 0.04523 4.233 8.65e-05 *** x2 -0.70000 0.84609 -0.827 0.412 x12 0.30000 0.06396 4.691 1.79e-05 *** Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 1.545 on 56 degrees of freedom Multiple R-squared: 0.7679, Adjusted R-squared: 0.7555 F-statistic: 61.76 on 3 and 56 DF, p-value: &lt; 2.2e-16 . - 교호작용항(x12)의 검정통계량에 근거한 p-value가 거의 0이므로 교호작용이 있다고 할 수 있따 . 10.7 . x = c(1, 2, 3, 4, 5, 6) . p_mean = c(15/250, 20/252, 18/151, 25/204, 32/202, 40/195) . 1) . logit = function(x) log(x/(1-x)) . m_logit = lm(logit(p_mean)~x) summary(m_logit) . Call: lm(formula = logit(p_mean) ~ x) Residuals: 1 2 3 4 5 6 -0.050412 -0.017289 0.166332 -0.069607 -0.038567 0.009543 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -2.96853 0.08945 -33.19 4.92e-06 *** x 0.26741 0.02297 11.64 0.000311 *** Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.09609 on 4 degrees of freedom Multiple R-squared: 0.9713, Adjusted R-squared: 0.9642 F-statistic: 135.5 on 1 and 4 DF, p-value: 0.0003111 . . - 로짓회귀식은 $ hat{{p}^{*}}=-2.96853+ 0.26741 x$ 이다 . - 로지스틱 반응함수는 $ hat{y}= cfrac{e^{-2.96853+ 0.26741x}}{1+e^{-2.96853+ 0.26741x}}$ 이다 . . 2) . logistic = function(x) exp(-2.96853+0.26741*x) / (1+exp(-2.96853+0.26741*x)) . newdata = data.frame(x = 4) predict_ = predict(m_logit, newdata = newdata) #predict_ logistic(predict_) . 1: 0.0299936908243327 - 문제의 확률은 $0.0299936908243327$ 이다 . 3) . plot(x, logit(p_mean)) abline(m_logit, col = &#39;red&#39;) . anova(m_logit) . A anova: 2 × 5 DfSum SqMean SqF valuePr(&gt;F) . &lt;int&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . x1 | 1.25136337 | 1.251363368 | 135.5378 | 0.0003111466 | . Residuals4 | 0.03693031 | 0.009232577 | NA | NA | . - 로지스틱 회귀모형에서 F통계량에 근거한 p-value가 0.000311로 매우 작으므로 회귀모형은 유의하다 . - 로지스틱 반응함수를 적합시키는 것이 타당하다 .",
            "url": "https://jaesu26.github.io/green/r/statistics/2021/11/26/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D10%EC%9E%A5%EA%B3%BC%EC%A0%9C.html",
            "relUrl": "/r/statistics/2021/11/26/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D10%EC%9E%A5%EA%B3%BC%EC%A0%9C.html",
            "date": " • Nov 26, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "회귀분석 8장 과제",
            "content": "8.1 . x1 &lt;- c(175, 210, 192, 250, 245, 226, 260, 230, 205, 185) x2 &lt;- c(15, 18, 20, 28, 25, 21, 32, 25, 24, 19) y &lt;- c(120.4, 112.5, 95.4, 162.3, 160.2, 131.5, 157.6, 158.4, 149.6, 130.4) X &lt;- t(rbind(rep(1, length(x1)), x1, x2)) m0 &lt;- lm(y~1) . 1) . m1 &lt;- lm(y~x1+x2) summary(m1) . Call: lm(formula = y ~ x1 + x2) Residuals: Min 1Q Median 3Q Max -30.261 -9.727 6.541 10.963 12.206 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 35.3359 48.5371 0.728 0.490 x1 0.2048 0.4085 0.501 0.632 x2 2.5506 2.3334 1.093 0.311 Residual standard error: 16.18 on 7 degrees of freedom Multiple R-squared: 0.6255, Adjusted R-squared: 0.5185 F-statistic: 5.845 on 2 and 7 DF, p-value: 0.03215 . - $ hat{y}=33.3359 + 0.2048x_1 + 2.5506x_2$ . 2) . Var_b = solve(t(X)%*%X) Var_b0 = Var_b[1,1]; Var_b0 Var_b1 = Var_b[2,2]; Var_b1 Var_b2 = Var_b[3,3]; Var_b2 . 8.99974754425673 0.000637594973081464 0.0207997160628333 $Var(b_0) = 8.99974754425673 sigma^2 Var(b_1)=0.000637594973081464 sigma^2 Var(b_2)=0.0207997160628333 sigma^2$ . 3) . - b1 : 시간을 고정시킨 상태에서 온도가 1도 상승했을때 인장강도의 변화 . - b2 : 공정온도를 고정시킨 상태에서 시간이 1분 더 지났을때 인장강도의 변화 . 4) . confint(m1, level = 0.95) . A matrix: 3 × 2 of type dbl 2.5 %97.5 % . (Intercept)-79.4362406 | 150.107949 | . x1 -0.7612855 | 1.170788 | . x2 -2.9669628 | 8.068228 | . - $b_1$의 95% 신뢰구간은 (-0.7612855, 1.170788) . - $b_2$의 95% 신뢰구간은 (-2.9669628, 8.068228) . 5) . anova(m0, m1) . A anova: 2 × 6 Res.DfRSSDfSum of SqFPr(&gt;F) . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 19 | 4892.701 | NA | NA | NA | NA | . 27 | 1832.382 | 2 | 3060.319 | 5.84546 | 0.03214666 | . - p-value가 0.05보다 작으므로 영가설을 기각한다, 회귀모형은 유의하다 . 6) . predict(m1, data.frame(x1 = 200, x2 = 20), level = 0.95, interval = &#39;confidence&#39;) . A matrix: 1 × 3 of type dbl fitlwrupr . 1127.2987 | 112.8839 | 141.7135 | . - $x_1=200, ;x_2=20 text{에서 }E(y)$의 95% 신뢰구간은 (112.8839, 141.7135)이다 . 7) . q = cbind(c(0, 1, -1)) b = cbind(c(33.3359, 0.2048, 2.5506)) t = (t(q) %*% b) / sqrt(t(q) %*% solve(t(X) %*% X) %*% q * mse) abs(t) qt(0.975, 7) . A matrix: 1 × 1 of type dbl 0.867669 | . 2.36462425159278 - 검정통계량 t값이 2.36보다 작으므로 영가설을 기각하지 못한다 . - $ beta_1, beta_2$ 는 같지 않다고 할 수 없다 . 8) . predict(m1, data.frame(x1 = 240, x2 = 30), level = 0.95, interval = &#39;predict&#39;) . A matrix: 1 × 3 of type dbl fitlwrupr . 1160.9951 | 114.5839 | 207.4063 | . $x_1=240, ;x_2=30 text{에서 }y$의 95% 예측구간은 (114.5839, 207.4063)이다 . 8.10 . x1 &lt;- c(2, 2, 3, 3, 2, 2, 3, 3) x2 &lt;- c(4, 4, 4, 4, 6, 6, 6, 6) y &lt;- c(39, 42, 51, 48, 53, 49, 61, 60) X &lt;- t(rbind(rep(1, length(x1)), x1, x2)) m0 &lt;- lm(y~1) . 1) . m1 &lt;- lm(y~x1+x2); summary(m1) . Call: lm(formula = y ~ x1 + x2) Residuals: 1 2 3 4 5 6 7 8 -1.375 1.625 1.375 -1.625 1.875 -2.125 0.625 -0.375 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 0.3750 4.7405 0.079 0.940016 x1 9.2500 1.3276 6.968 0.000937 *** x2 5.3750 0.6638 8.097 0.000466 *** Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 1.877 on 5 degrees of freedom Multiple R-squared: 0.958, Adjusted R-squared: 0.9412 F-statistic: 57.06 on 2 and 5 DF, p-value: 0.000361 . - $ hat{y}=0.375 + 0.925x_1 + 5.375x_2$ . 2) . m2 &lt;- lm(y~x1); summary(m2) . Call: lm(formula = y ~ x1) Residuals: Min 1Q Median 3Q Max -7.000 -4.688 -0.250 5.250 7.250 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 27.250 11.608 2.348 0.0572 . x1 9.250 4.553 2.032 0.0885 . Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 6.439 on 6 degrees of freedom Multiple R-squared: 0.4076, Adjusted R-squared: 0.3088 F-statistic: 4.128 on 1 and 6 DF, p-value: 0.08846 . - $ hat{y}=27.25 + 9.25x_1$ . anova(m2) . A anova: 2 × 5 DfSum SqMean SqF valuePr(&gt;F) . &lt;int&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . x11 | 171.125 | 171.12500 | 4.127638 | 0.08846031 | . Residuals6 | 248.750 | 41.45833 | NA | NA | . - p-value가 0.05보다 크다 . - $x_1$은 회귀모형에서 유의하지 않은 변수이다 . 3) . m3 &lt;- lm(y~x2); summary(m3) . Call: lm(formula = y ~ x2) Residuals: Min 1Q Median 3Q Max -6.750 -3.750 0.125 4.500 6.000 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 23.500 10.111 2.324 0.0591 . x2 5.375 1.983 2.711 0.0351 * Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 5.609 on 6 degrees of freedom Multiple R-squared: 0.5505, Adjusted R-squared: 0.4755 F-statistic: 7.347 on 1 and 6 DF, p-value: 0.03508 . - $ hat{y}=23.5 + 5.375x_2$ . 4) . anova(m3) . A anova: 2 × 5 DfSum SqMean SqF valuePr(&gt;F) . &lt;int&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . x21 | 231.125 | 231.12500 | 7.34702 | 0.03508095 | . Residuals6 | 188.750 | 31.45833 | NA | NA | . - p-value가 0.05보다 작다 . - $x_2$은 회귀모형에서 유의한 변수이다 . 5) . m_beta &lt;- lm(scale(y)~scale(x1)+scale(x2)); summary(m_beta) # 표준화된 회귀모형 . Call: lm(formula = scale(y) ~ scale(x1) + scale(x2)) Residuals: 1 2 3 4 5 6 7 8 -0.17754 0.20982 0.17754 -0.20982 0.24210 -0.27438 0.08070 -0.04842 attr(,&#34;scaled:center&#34;) [1] 50.38 attr(,&#34;scaled:scale&#34;) [1] 7.745 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 9.329e-17 8.571e-02 0.000 1.000000 scale(x1) 6.384e-01 9.163e-02 6.968 0.000937 *** scale(x2) 7.419e-01 9.163e-02 8.097 0.000466 *** Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.2424 on 5 degrees of freedom Multiple R-squared: 0.958, Adjusted R-squared: 0.9412 F-statistic: 57.06 on 2 and 5 DF, p-value: 0.000361 . - $ hat{y}=0.6384w_1 + 0.7419w_2$ . 6) . anova(m_beta) . A anova: 3 × 5 DfSum SqMean SqF valuePr(&gt;F) . &lt;int&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . scale(x1)1 | 2.8529324 | 2.85293242 | 48.54610 | 0.0009365829 | . scale(x2)1 | 3.8532301 | 3.85323013 | 65.56738 | 0.0004657066 | . Residuals5 | 0.2938375 | 0.05876749 | NA | NA | . - p-value가 매우 작다 . - 회귀모형은 유의하다 . cor(X[,2:3], method = &#39;pearson&#39;) . A matrix: 2 × 2 of type dbl x1x2 . x11 | 0 | . x20 | 1 | . - $x_1$과 $x_2$의 상관계수가 $0$이므로 상관이 존재하지 않는다 . 8.15 . x1 &lt;- c(-5, 4, -1, 2, 2, 3, 3) x2 &lt;- c(5, 4, 1, -3, -2, -2, -3) y &lt;- c(11, 11, 8, 2, 5, 5, 4) m0 &lt;- lm(y~1) . 1) . m1 &lt;- lm(y~x1+x2) anova(m0, m1) . A anova: 2 × 6 Res.DfRSSDfSum of SqFPr(&gt;F) . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 16 | 73.714286 | NA | NA | NA | NA | . 24 | 3.101281 | 2 | 70.613 | 45.53796 | 0.001770023 | . - p-value가 매우 작으므로 회귀모형은 유의하다 . 2) . m2 &lt;- lm(y~x1) m3 &lt;- lm(y~x2) R_b0 = length(y) * mean(y)^2 R_b0 # R(b0) . 302.285714285714 $R( beta_0)=302.285714285714$ . anova(m0, m1) # R(b1,b2|b0) anova(m0, m2) # R(b1|b0) anova(m0, m3) # R(b2|b0) . A anova: 2 × 6 Res.DfRSSDfSum of SqFPr(&gt;F) . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 16 | 73.714286 | NA | NA | NA | NA | . 24 | 3.101281 | 2 | 70.613 | 45.53796 | 0.001770023 | . A anova: 2 × 6 Res.DfRSSDfSum of SqFPr(&gt;F) . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 16 | 73.71429 | NA | NA | NA | NA | . 25 | 57.83495 | 1 | 15.87933 | 1.372815 | 0.2941169 | . A anova: 2 × 6 Res.DfRSSDfSum of SqFPr(&gt;F) . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 16 | 73.71429 | NA | NA | NA | NA | . 25 | 3.69958 | 1 | 70.01471 | 94.62521 | 0.0001951318 | . $R( beta_1, beta_2 mid beta_0)=70.613 R( beta_1 mid beta_0)=15.87933 R( beta_2 mid beta_0)=70.01471$ . 3) . anova(m3, m1) . A anova: 2 × 6 Res.DfRSSDfSum of SqFPr(&gt;F) . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 15 | 3.699580 | NA | NA | NA | NA | . 24 | 3.101281 | 1 | 0.598299 | 0.7716799 | 0.4292997 | . - p-value가 0.429로 0.05보다 작으므로 영가설을 기각하지 못한다 . - $ beta_1$은 $0$이 아니라고 할 수 없다 . - $x_1$은 회귀모형에서 유의하지 않다 . 4) . anova(m2, m1) . A anova: 2 × 6 Res.DfRSSDfSum of SqFPr(&gt;F) . &lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . 15 | 57.834951 | NA | NA | NA | NA | . 24 | 3.101281 | 1 | 54.73367 | 70.59492 | 0.001098159 | . - p-value가 0.001이므로 $ alpha =0.05,0.01$에서 영가설을 기각한다 . - $ beta_2$는 $0$이 아니다 . - $x_2$은 회귀모형에서 유의하다 . 8.16 . $ boldsymbol{y=X beta+ epsilon, ; epsilon} sim N(0,I), ; bf{X}$는 $n times (k+1)$ . 1) . $Q_1= boldsymbol{y&#39;[I-X(X&#39;X)^{-1}X&#39;]y = y&#39;Cy}=SSE$ 이고 $df_E=n-k-1$이고 $ sigma^2=1$이다 . $ boldsymbol{V=I}$이고 $ boldsymbol{CVCV=CV}$로 멱등행렬이다 . $ begin{aligned} boldsymbol{(I-X(X&#39;X)^{-1}X&#39;)(I-X(X&#39;X)^{-1}X&#39;)}&amp;= boldsymbol{I-2X(X&#39;X)^{-1}X&#39;+X(X&#39;X)^{-1}X&#39;X(X&#39;X)^{-1}X&#39;} &amp;= boldsymbol{I-X(X&#39;X)^{-1}X&#39;} end{aligned}$ . 이므로 $ boldsymbol{I-X(X&#39;X)^{-1}X&#39;}$은 멱등행렬이다 . $r( boldsymbol{C})=tr( boldsymbol{C})=n-k-1$이므로 $Q_1$은 $ chi^2(n-k-1)$을 따른다 . 2) . $Q_2= boldsymbol{y&#39;X(X&#39;X)^{-1}X&#39;y = y&#39;By}$ 이고 $df=k+1$이고 $ sigma^2=1$이다 . $ boldsymbol{V=I}$이고 $ boldsymbol{BVBV=BV}$로 멱등행렬이다 . $ boldsymbol{(X(X&#39;X)^{-1}X&#39;)(X(X&#39;X)^{-1}X&#39;)= XB^{-1}B(X&#39;X)^{-1}X&#39;=X(X&#39;X)^{-1}X&#39;}$ . 이므로 $ boldsymbol{X(X&#39;X)^{-1}X&#39;}$은 멱등행렬이다 . $r( boldsymbol{B})=tr( boldsymbol{B} )=k+1$이므로 $Q_2$은 $ chi^2(k+1, frac{1}{2} boldsymbol{ beta&#39;X&#39;X beta})$을 따른다 . 3) . $ boldsymbol{BVC}$가 0이면 $Q_1,Q_2$는 서로 독립이다 . $ begin{aligned} boldsymbol{BVC}&amp;=[ boldsymbol{I-X(X&#39;X)^{-1}X&#39;]I} sigma^2 boldsymbol{X(X&#39;X)^{-1}X&#39;} &amp;= sigma^2[ boldsymbol{I-X(X&#39;X)^{-1}X&#39;]} boldsymbol{X(X&#39;X)^{-1}X&#39;} &amp;= sigma^2[ boldsymbol{X(X&#39;X)^{-1}X&#39;-(X(X&#39;X)^{-1}X&#39;)(X(X&#39;X)^{-1}X&#39;)]} end{aligned}$ . 그런데 $ boldsymbol{X(X&#39;X)^{-1}X&#39;}$는 멱등행렬이므로 $ boldsymbol{(X(X&#39;X)^{-1}X&#39;)(X(X&#39;X)^{-1}X&#39;)}= boldsymbol{X(X&#39;X)^{-1}X&#39;}$ . $ sigma^2[ boldsymbol{X(X&#39;X)^{-1}X&#39;-(X(X&#39;X)^{-1}X&#39;)(X(X&#39;X)^{-1}X&#39;)]}= sigma^2[ boldsymbol{X(X&#39;X)^{-1}X&#39;}- boldsymbol{X(X&#39;X)^{-1}X&#39;}]= boldsymbol{0}$ . 그러므로 $Q_1,Q_2$는 서로 독립이다 . 4) . $Q_1,Q_2$는 서로 독립이고 $ boldsymbol{ beta}= boldsymbol{0}$ 이면 $Q_1 sim chi^2(n-k-1), ;Q_2 sim chi^2(k+1, boldsymbol{0})= chi^2(k+1)$ . 이므로 $ cfrac{Q_2 big/(k+1)}{Q_1 big/(n-k-1)} sim F(k+1,n-k-1)$ 이다 .",
            "url": "https://jaesu26.github.io/green/r/statistics/2021/11/22/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D8%EC%9E%A5%EA%B3%BC%EC%A0%9C.html",
            "relUrl": "/r/statistics/2021/11/22/%ED%9A%8C%EA%B7%80%EB%B6%84%EC%84%9D8%EC%9E%A5%EA%B3%BC%EC%A0%9C.html",
            "date": " • Nov 22, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "데이터시각화 중간시험",
            "content": "- 시험문제 : https://guebin.github.io/2021STDV/2021/11/07/mid.html . - 문제에 대한 나의 풀이(틀릴 수 있음) . import pandas as pd import numpy as np from plotnine import * import matplotlib.pyplot as plt import seaborn as sns . 1 . - (a)-(c) . - (b)-(d) . 2 . x = [1, 2, 3, 4] y = [1, 2, 4, 3] . fig, axs = plt.subplots(2,2) . (ax1, ax2), (ax3, ax4) = axs . ax1.plot(x, y, &#39;o:r&#39;) ax2.plot(x, y, &#39;Xb&#39;) ax3.plot(x, y, &#39;xm&#39;) ax4.plot(x, y, &#39;.--k&#39;) . [&lt;matplotlib.lines.Line2D at 0x25605a16100&gt;] . fig . 3 . - 하니, 홍두깨, 고은애, 이창수 . 4 . - 하니, 홍두깨, 고은애 . 5 . df = pd.read_csv(&#39;https://raw.githubusercontent.com/guebin/2021DV/master/_notebooks/2021-10-25-FIFA22_official_data.csv&#39;) . df.head() . ID Name Age Photo Nationality Flag Overall Potential Club Club Logo ... SlidingTackle GKDiving GKHandling GKKicking GKPositioning GKReflexes Best Position Best Overall Rating Release Clause DefensiveAwareness . 0 212198 | Bruno Fernandes | 26 | https://cdn.sofifa.com/players/212/198/22_60.png | Portugal | https://cdn.sofifa.com/flags/pt.png | 88 | 89 | Manchester United | https://cdn.sofifa.com/teams/11/30.png | ... | 65.0 | 12.0 | 14.0 | 15.0 | 8.0 | 14.0 | CAM | 88.0 | €206.9M | 72.0 | . 1 209658 | L. Goretzka | 26 | https://cdn.sofifa.com/players/209/658/22_60.png | Germany | https://cdn.sofifa.com/flags/de.png | 87 | 88 | FC Bayern München | https://cdn.sofifa.com/teams/21/30.png | ... | 77.0 | 13.0 | 8.0 | 15.0 | 11.0 | 9.0 | CM | 87.0 | €160.4M | 74.0 | . 2 176580 | L. Suárez | 34 | https://cdn.sofifa.com/players/176/580/22_60.png | Uruguay | https://cdn.sofifa.com/flags/uy.png | 88 | 88 | Atlético de Madrid | https://cdn.sofifa.com/teams/240/30.png | ... | 38.0 | 27.0 | 25.0 | 31.0 | 33.0 | 37.0 | ST | 88.0 | €91.2M | 42.0 | . 3 192985 | K. De Bruyne | 30 | https://cdn.sofifa.com/players/192/985/22_60.png | Belgium | https://cdn.sofifa.com/flags/be.png | 91 | 91 | Manchester City | https://cdn.sofifa.com/teams/10/30.png | ... | 53.0 | 15.0 | 13.0 | 5.0 | 10.0 | 13.0 | CM | 91.0 | €232.2M | 68.0 | . 4 224334 | M. Acuña | 29 | https://cdn.sofifa.com/players/224/334/22_60.png | Argentina | https://cdn.sofifa.com/flags/ar.png | 84 | 84 | Sevilla FC | https://cdn.sofifa.com/teams/481/30.png | ... | 82.0 | 8.0 | 14.0 | 13.0 | 13.0 | 14.0 | LB | 84.0 | €77.7M | 80.0 | . 5 rows × 65 columns . (a) . df[&#39;Loaned From&#39;] . 0 NaN 1 NaN 2 NaN 3 NaN 4 NaN ... 16705 NaN 16706 NaN 16707 NaN 16708 NaN 16709 NaN Name: Loaned From, Length: 16710, dtype: object . df[&#39;Loaned From&#39;].isnull().sum() . 15578 . df[&#39;Marking&#39;] . 0 NaN 1 NaN 2 NaN 3 NaN 4 NaN ... 16705 5.0 16706 NaN 16707 NaN 16708 NaN 16709 15.0 Name: Marking, Length: 16710, dtype: float64 . df[&#39;Marking&#39;].isnull().sum() . 15818 . - 결측치가 많다 . (b) . df = df.drop([&#39;Loaned From&#39;, &#39;Marking&#39;], axis = 1) . df.isnull().sum().sum() . 5404 . (c) . df = df.dropna() . df.isnull().sum().sum() . 0 . - 5404개의 결측치가 제거되었다 . (d) . def convert_currency(value): floatvalue = 0.0 strvalue=&quot;&quot; if &quot;M&quot; in value: strvalue=value.replace(&quot;M&quot;,&quot;&quot;).replace(&quot;€&quot;,&quot;&quot;) floatvalue=float(float(strvalue)*1000000) elif &quot;K&quot; in value: strvalue=value.replace(&quot;K&quot;,&quot;&quot;).replace(&quot;€&quot;,&quot;&quot;) floatvalue=float(float(strvalue)*1000) else: floatvalue=value.replace(&quot;€&quot;,&quot;&quot;) return floatvalue . - 코드출처: https://www.kaggle.com/talhademirezen/cost-effective-youth-players-fifa22 . df[&#39;Wage&#39;] = list(map(convert_currency, df[&#39;Wage&#39;])) . df[&#39;Wage&#39;] . 0 250000.0 1 140000.0 2 135000.0 3 350000.0 4 45000.0 ... 16703 650 16704 950 16706 550 16707 700 16708 500 Name: Wage, Length: 14398, dtype: object . (e) . df[&#39;Value&#39;] = list(map(convert_currency, df[&#39;Value&#39;])) . df2 = df.groupby(by = &#39;Best Position&#39;).agg({&#39;Value&#39;:np.mean}) . - 신기한점 : 컴퓨터마다(?) &#39;Value&#39;가 object 타입인지 float 타입인지가 다른것같다 . - 나의 경우는 자료형을 변환하지 않아도 위와 같이 잘되는데 안되는 경우도 있나봄 . df2 . Value . Best Position . CAM 4.356162e+06 | . CB 3.038834e+06 | . CDM 3.539740e+06 | . CF 9.122222e+06 | . CM 5.630414e+06 | . GK 2.703686e+06 | . LB 3.051887e+06 | . LM 3.439977e+06 | . LW 6.443137e+06 | . LWB 3.451340e+06 | . RB 3.203283e+06 | . RM 2.550153e+06 | . RW 3.977832e+06 | . RWB 3.023522e+06 | . ST 3.295080e+06 | . df2 = df2.stack().reset_index() . df2 = df2.rename(columns={&#39;level_1&#39;:&#39;group1&#39;, 0:&#39;mean(Value)&#39;}) . df2 . Best Position group1 mean(Value) . 0 CAM | Value | 4.356162e+06 | . 1 CB | Value | 3.038834e+06 | . 2 CDM | Value | 3.539740e+06 | . 3 CF | Value | 9.122222e+06 | . 4 CM | Value | 5.630414e+06 | . 5 GK | Value | 2.703686e+06 | . 6 LB | Value | 3.051887e+06 | . 7 LM | Value | 3.439977e+06 | . 8 LW | Value | 6.443137e+06 | . 9 LWB | Value | 3.451340e+06 | . 10 RB | Value | 3.203283e+06 | . 11 RM | Value | 2.550153e+06 | . 12 RW | Value | 3.977832e+06 | . 13 RWB | Value | 3.023522e+06 | . 14 ST | Value | 3.295080e+06 | . df2 = df2.sort_values(by = [&#39;mean(Value)&#39;], axis = 0, ascending = False) . df2 = df2.reset_index(drop = True) . df2 . Best Position group1 mean(Value) . 0 CF | Value | 9.122222e+06 | . 1 LW | Value | 6.443137e+06 | . 2 CM | Value | 5.630414e+06 | . 3 CAM | Value | 4.356162e+06 | . 4 RW | Value | 3.977832e+06 | . 5 CDM | Value | 3.539740e+06 | . 6 LWB | Value | 3.451340e+06 | . 7 LM | Value | 3.439977e+06 | . 8 ST | Value | 3.295080e+06 | . 9 RB | Value | 3.203283e+06 | . 10 LB | Value | 3.051887e+06 | . 11 CB | Value | 3.038834e+06 | . 12 RWB | Value | 3.023522e+06 | . 13 GK | Value | 2.703686e+06 | . 14 RM | Value | 2.550153e+06 | . cnt = 0 . def z(x): global cnt cnt += 1 if cnt &lt;= 3: return &#39;True&#39; else: return &#39;False&#39; . df2[&#39;Highlight&#39;] = list(map(z, df2[&#39;mean(Value)&#39;])) . df2 . Best Position group1 mean(Value) Highlight . 0 CF | Value | 9.122222e+06 | True | . 1 LW | Value | 6.443137e+06 | True | . 2 CM | Value | 5.630414e+06 | True | . 3 CAM | Value | 4.356162e+06 | False | . 4 RW | Value | 3.977832e+06 | False | . 5 CDM | Value | 3.539740e+06 | False | . 6 LWB | Value | 3.451340e+06 | False | . 7 LM | Value | 3.439977e+06 | False | . 8 ST | Value | 3.295080e+06 | False | . 9 RB | Value | 3.203283e+06 | False | . 10 LB | Value | 3.051887e+06 | False | . 11 CB | Value | 3.038834e+06 | False | . 12 RWB | Value | 3.023522e+06 | False | . 13 GK | Value | 2.703686e+06 | False | . 14 RM | Value | 2.550153e+06 | False | . ggplot(df2) + geom_bar(aes(x = &#39;Best Position&#39;, y = &#39;mean(Value)&#39;, fill = &#39;Highlight&#39;), stat = &#39;identity&#39;) . &lt;ggplot: (160530408406)&gt; . (f) . - 문제는 alpha = 0.5로 하라고 했는데 시각화 예시는 alpha = 0.2임... . ggplot(df) + geom_point(aes(x = &#39;Dribbling&#39;, y = &#39;SlidingTackle&#39;, color = &#39;Age&#39;), alpha = 0.5, size = 0.5) + facet_wrap(&#39;Best Position&#39;) . &lt;ggplot: (160533279925)&gt; . (g) . - 하니, 홍두깨, 고은애 . (h) . df3 = df.loc[lambda df:(df[&#39;Best Position&#39;] ==&#39;CAM&#39;) | (df[&#39;Best Position&#39;] ==&#39;CB&#39;)] . - 이유는 모르겠는데 query로는 안되서 위와 같이 했음 . - 문제에는 CB가 아니라 CM인데 plot은 CB로 되어있어서 CB로 했음 + (i)문제에서도 CB라고 언급함 . ggplot(df3) + geom_point(aes(x = &#39;Dribbling&#39;, y = &#39;SlidingTackle&#39;, color = &#39;Age&#39;, size = &#39;Value&#39;), alpha = 0.2 ) + facet_wrap(&#39;Best Position&#39;) . &lt;ggplot: (160531860947)&gt; . (i) . - 홍두깨 . 6 . x = [0, 1, 4, 5] y = [0, 2, 3, 5] x2 = [5, 4.1, 1, 0] y2 = [5, 3, 0.5, 0] . df_ = pd.DataFrame({&#39;x&#39;:x ,&#39;y&#39;:y}) . df_[&#39;course&#39;] = &#39;A&#39; . df_ . x y course . 0 0 | 0 | A | . 1 1 | 2 | A | . 2 4 | 3 | A | . 3 5 | 5 | A | . df2_ = pd.DataFrame({&#39;x&#39;:x2 ,&#39;y&#39;:y2}) . df2_[&#39;course&#39;] = &#39;B&#39; . df2_ . x y course . 0 5.0 | 5.0 | B | . 1 4.1 | 3.0 | B | . 2 1.0 | 0.5 | B | . 3 0.0 | 0.0 | B | . stamina = 100 ## 집에서 출발시 체력 x_ = 0 y_ = 0 def f(x,y): global x_ global y_ global stamina stamina = stamina - (((x-x_)**2 + (y-y_)**2)**0.5) ## 두 점 사이의 거리 x_ = x y_ = y return stamina . df_[&#39;stamina&#39;] = list(map(f, df_[&#39;x&#39;], df_[&#39;y&#39;])) . df_ . x y course stamina . 0 0 | 0 | A | 100.000000 | . 1 1 | 2 | A | 97.763932 | . 2 4 | 3 | A | 94.601654 | . 3 5 | 5 | A | 92.365586 | . stamina -= 70 ## A지점 도착지점에서 B지점 출발지점까지 가는데 70이 소모됨 . df2_[&#39;stamina&#39;] = list(map(f, df2_[&#39;x&#39;], df2_[&#39;y&#39;])) . df2_ . x y course stamina . 0 5.0 | 5.0 | B | 22.365586 | . 1 4.1 | 3.0 | B | 20.172415 | . 2 1.0 | 0.5 | B | 16.189954 | . 3 0.0 | 0.0 | B | 15.071920 | . df3_ = pd.concat([df_, df2_]) ## 두 데이터프레임 합치기 . df3_ . x y course stamina . 0 0.0 | 0.0 | A | 100.000000 | . 1 1.0 | 2.0 | A | 97.763932 | . 2 4.0 | 3.0 | A | 94.601654 | . 3 5.0 | 5.0 | A | 92.365586 | . 0 5.0 | 5.0 | B | 22.365586 | . 1 4.1 | 3.0 | B | 20.172415 | . 2 1.0 | 0.5 | B | 16.189954 | . 3 0.0 | 0.0 | B | 15.071920 | . ggplot(df3_) + geom_point(aes(x = &#39;x&#39;, y = &#39;y&#39;)) + geom_line(aes(x = &#39;x&#39;, y = &#39;y&#39;, size = &#39;stamina&#39;, color = &#39;course&#39;), alpha = 0.5) . &lt;ggplot: (160530609351)&gt; . 7 . - 문제 풀고나니 느낀건데 국어를 너무 못함 &gt; 문제를 제대로 파악을 못함 . p = [&#39;A&#39;] * 2 + [&#39;B&#39;] * 2 s1 = [10, 20, 30, 4] s2 = [7, 19, 23, 4] s3 = [&#39;one&#39;, &#39;two&#39;] * 2 . data = pd.DataFrame({&#39;person&#39;:p, &#39;count&#39;:s1, &#39;goal&#39;:s2, &#39;season&#39;:s3}) . data . person count goal season . 0 A | 10 | 7 | one | . 1 A | 20 | 19 | two | . 2 B | 30 | 23 | one | . 3 B | 4 | 4 | two | . data[&#39;prob&#39;] = data[&#39;goal&#39;] / data[&#39;count&#39;] . data . person count goal season prob . 0 A | 10 | 7 | one | 0.700000 | . 1 A | 20 | 19 | two | 0.950000 | . 2 B | 30 | 23 | one | 0.766667 | . 3 B | 4 | 4 | two | 1.000000 | . data2 = data.groupby([&#39;person&#39;]).agg({&#39;count&#39;:np.sum, &#39;goal&#39;:np.sum}).reset_index().rename(columns = {&#39;count&#39;:&#39;sum&#39;, &#39;goal&#39;:&#39;goal_sum&#39;}) . data2 . person sum goal_sum . 0 A | 30 | 26 | . 1 B | 34 | 27 | . td = pd.merge(data, data2) . td . person count goal season prob sum goal_sum . 0 A | 10 | 7 | one | 0.700000 | 30 | 26 | . 1 A | 20 | 19 | two | 0.950000 | 30 | 26 | . 2 B | 30 | 23 | one | 0.766667 | 34 | 27 | . 3 B | 4 | 4 | two | 1.000000 | 34 | 27 | . td[&#39;prob2&#39;] = (td[&#39;goal_sum&#39;] / td[&#39;sum&#39;]) / 2 ## 시즌이 2개라 값이 2번 들어가서 2로 나눠줌 . td . person count goal season prob sum goal_sum prob2 . 0 A | 10 | 7 | one | 0.700000 | 30 | 26 | 0.433333 | . 1 A | 20 | 19 | two | 0.950000 | 30 | 26 | 0.433333 | . 2 B | 30 | 23 | one | 0.766667 | 34 | 27 | 0.397059 | . 3 B | 4 | 4 | two | 1.000000 | 34 | 27 | 0.397059 | . ggplot(data) + geom_bar(aes(x = &#39;person&#39;, y = &#39;prob&#39;, fill = &#39;person&#39;), stat = &#39;identity&#39;) + facet_wrap(&#39;season&#39;) . &lt;ggplot: (160530787118)&gt; . - 시즌별 성공확률은 B가 더 높다 . - 하지만 전체 성공확률을 보면? . ggplot(td) + geom_bar(aes(x = &#39;person&#39;, y = &#39;prob2&#39;, fill = &#39;person&#39;), stat = &#39;identity&#39;) . &lt;ggplot: (160532310432)&gt; . - A가 더 높은것을 확인할수있다 . - B가 100%확률을 기록했을 때 전체횟수가 모종의 이유(부상 치료 등)로 인해 4회밖에 되지않아 전체에 끼치는 영향력이 작아져 위와같은 결과가 발생했다 . - 하고 나서 생각난건데 시즌별 성공과 전체 성공 데이터프레임을 합칠필요가 없는것같다 . - 그냥 따로 하면 되지않나... 굳이 합친다고 시험에서 실수했음(2로 안나눠서 확률이 1이 넘음) . - 총점이 195점인데 몇점일까나 .",
            "url": "https://jaesu26.github.io/green/python/2021/11/08/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94%EC%A4%91%EA%B0%84%EC%8B%9C%ED%97%98.html",
            "relUrl": "/python/2021/11/08/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94%EC%A4%91%EA%B0%84%EC%8B%9C%ED%97%98.html",
            "date": " • Nov 8, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "데이터시각화 중간고사 연습문제",
            "content": "- 시험문제 : https://guebin.github.io/2021DV/2021/11/05/(A2)-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%EB%8C%80%EB%B9%84%EB%AC%B8%EC%A0%9C.html . import pandas as pd import numpy as np from plotnine import * import matplotlib.pyplot as plt import seaborn as sns . - 흠 20분 걸렸는데... 조금 느리다 . Type I. &#54532;&#47196;&#44536;&#47016; &#44396;&#54788;&#45733;&#47141; &#54217;&#44032; . np.random.seed(202016248) . x1 = np.random.normal(0, 1, 10000) x2 = np.random.normal(1, 1, 10000) . sns.histplot([x1, x2]) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . x = [1, 2, 3, 4] y = [1, 2, 4, 3] . fig, axs = plt.subplots(2,2) . (ax1, ax2), (ax3, ax4) = axs . ax1.plot(x, y, &#39;o:r&#39;) ax2.plot(x, y, &#39;Xb&#39;) ax3.plot(x, y, &#39;xm&#39;) ax4.plot(x, y, &#39;.--k&#39;) . [&lt;matplotlib.lines.Line2D at 0x1f9133fc730&gt;] . fig . Type II. &#44060;&#45392;&#51032; &#51060;&#54644; &#54217;&#44032; . (1) 하니, 홍두깨 . (2) 하니, 나애리 . Type III. &#51088;&#47308;&#48516;&#49437; &#48143; &#49884;&#44033;&#54868; &#45733;&#47141; &#51333;&#54633;&#54217;&#44032; . df = pd.read_csv(&#39;https://raw.githubusercontent.com/PacktPublishing/Pandas-Cookbook/master/data/employee.csv&#39;) df . UNIQUE_ID POSITION_TITLE DEPARTMENT BASE_SALARY RACE EMPLOYMENT_TYPE GENDER EMPLOYMENT_STATUS HIRE_DATE JOB_DATE . 0 0 | ASSISTANT DIRECTOR (EX LVL) | Municipal Courts Department | 121862.0 | Hispanic/Latino | Full Time | Female | Active | 2006-06-12 | 2012-10-13 | . 1 1 | LIBRARY ASSISTANT | Library | 26125.0 | Hispanic/Latino | Full Time | Female | Active | 2000-07-19 | 2010-09-18 | . 2 2 | POLICE OFFICER | Houston Police Department-HPD | 45279.0 | White | Full Time | Male | Active | 2015-02-03 | 2015-02-03 | . 3 3 | ENGINEER/OPERATOR | Houston Fire Department (HFD) | 63166.0 | White | Full Time | Male | Active | 1982-02-08 | 1991-05-25 | . 4 4 | ELECTRICIAN | General Services Department | 56347.0 | White | Full Time | Male | Active | 1989-06-19 | 1994-10-22 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1995 1995 | POLICE OFFICER | Houston Police Department-HPD | 43443.0 | White | Full Time | Male | Active | 2014-06-09 | 2015-06-09 | . 1996 1996 | COMMUNICATIONS CAPTAIN | Houston Fire Department (HFD) | 66523.0 | Black or African American | Full Time | Male | Active | 2003-09-02 | 2013-10-06 | . 1997 1997 | POLICE OFFICER | Houston Police Department-HPD | 43443.0 | White | Full Time | Male | Active | 2014-10-13 | 2015-10-13 | . 1998 1998 | POLICE OFFICER | Houston Police Department-HPD | 55461.0 | Asian/Pacific Islander | Full Time | Male | Active | 2009-01-20 | 2011-07-02 | . 1999 1999 | FIRE FIGHTER | Houston Fire Department (HFD) | 51194.0 | Hispanic/Latino | Full Time | Male | Active | 2009-01-12 | 2010-07-12 | . 2000 rows × 10 columns . (a) . df.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 2000 entries, 0 to 1999 Data columns (total 10 columns): # Column Non-Null Count Dtype -- -- 0 UNIQUE_ID 2000 non-null int64 1 POSITION_TITLE 2000 non-null object 2 DEPARTMENT 2000 non-null object 3 BASE_SALARY 1886 non-null float64 4 RACE 1965 non-null object 5 EMPLOYMENT_TYPE 2000 non-null object 6 GENDER 2000 non-null object 7 EMPLOYMENT_STATUS 2000 non-null object 8 HIRE_DATE 2000 non-null object 9 JOB_DATE 1997 non-null object dtypes: float64(1), int64(1), object(8) memory usage: 156.4+ KB . df.isnull().sum() . UNIQUE_ID 0 POSITION_TITLE 0 DEPARTMENT 0 BASE_SALARY 114 RACE 35 EMPLOYMENT_TYPE 0 GENDER 0 EMPLOYMENT_STATUS 0 HIRE_DATE 0 JOB_DATE 3 dtype: int64 . df.isnull().sum().sum() . 152 . df = df.dropna() . df.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 1853 entries, 0 to 1999 Data columns (total 10 columns): # Column Non-Null Count Dtype -- -- 0 UNIQUE_ID 1853 non-null int64 1 POSITION_TITLE 1853 non-null object 2 DEPARTMENT 1853 non-null object 3 BASE_SALARY 1853 non-null float64 4 RACE 1853 non-null object 5 EMPLOYMENT_TYPE 1853 non-null object 6 GENDER 1853 non-null object 7 EMPLOYMENT_STATUS 1853 non-null object 8 HIRE_DATE 1853 non-null object 9 JOB_DATE 1853 non-null object dtypes: float64(1), int64(1), object(8) memory usage: 159.2+ KB . df.isnull().sum() . UNIQUE_ID 0 POSITION_TITLE 0 DEPARTMENT 0 BASE_SALARY 0 RACE 0 EMPLOYMENT_TYPE 0 GENDER 0 EMPLOYMENT_STATUS 0 HIRE_DATE 0 JOB_DATE 0 dtype: int64 . df.isnull().sum().sum() . 0 . (b) . df_ = df.groupby(by = &#39;GENDER&#39;).agg({&#39;BASE_SALARY&#39;:np.mean}) df_ . BASE_SALARY . GENDER . Female 52474.665487 | . Male 57670.031832 | . df_ = df_.stack().reset_index() df_ . GENDER level_1 0 . 0 Female | BASE_SALARY | 52474.665487 | . 1 Male | BASE_SALARY | 57670.031832 | . (df_.query(&#39;GENDER == &quot;Female&quot;&#39;))[0].to_list() &gt; (df_.query(&#39;GENDER == &quot;Male&quot;&#39;))[0].to_list() . False . - 남자 급여평균이 더 크다 . (c) . df2 = df.groupby(by = [&#39;RACE&#39;,&#39;GENDER&#39;]).agg({&#39;BASE_SALARY&#39;:[np.mean, min, max]}) . df2 . BASE_SALARY . mean min max . RACE GENDER . American Indian or Alaskan Native Female 60238.800000 | 26125.0 | 98536.0 | . Male 60305.400000 | 26125.0 | 81239.0 | . Asian/Pacific Islander Female 63226.300000 | 26125.0 | 130416.0 | . Male 61033.906667 | 27914.0 | 163228.0 | . Black or African American Female 48965.790378 | 24960.0 | 150416.0 | . Male 51118.867374 | 26125.0 | 275000.0 | . Hispanic/Latino Female 46503.316176 | 26125.0 | 126115.0 | . Male 54767.541538 | 26104.0 | 165216.0 | . Others Female 63785.000000 | 63785.0 | 63785.0 | . Male 38771.000000 | 38771.0 | 38771.0 | . White Female 66793.352941 | 27955.0 | 178331.0 | . Male 63940.388119 | 26125.0 | 210588.0 | . - tidydata로 만들자! . df2.stack() . BASE_SALARY . RACE GENDER . American Indian or Alaskan Native Female mean 60238.800000 | . min 26125.000000 | . max 98536.000000 | . Male mean 60305.400000 | . min 26125.000000 | . max 81239.000000 | . Asian/Pacific Islander Female mean 63226.300000 | . min 26125.000000 | . max 130416.000000 | . Male mean 61033.906667 | . min 27914.000000 | . max 163228.000000 | . Black or African American Female mean 48965.790378 | . min 24960.000000 | . max 150416.000000 | . Male mean 51118.867374 | . min 26125.000000 | . max 275000.000000 | . Hispanic/Latino Female mean 46503.316176 | . min 26125.000000 | . max 126115.000000 | . Male mean 54767.541538 | . min 26104.000000 | . max 165216.000000 | . Others Female mean 63785.000000 | . min 63785.000000 | . max 63785.000000 | . Male mean 38771.000000 | . min 38771.000000 | . max 38771.000000 | . White Female mean 66793.352941 | . min 27955.000000 | . max 178331.000000 | . Male mean 63940.388119 | . min 26125.000000 | . max 210588.000000 | . df3 = df2.stack().reset_index().rename(columns={&#39;level_2&#39;:&#39;aggtype&#39;}) . df3 . RACE GENDER aggtype BASE_SALARY . 0 American Indian or Alaskan Native | Female | mean | 60238.800000 | . 1 American Indian or Alaskan Native | Female | min | 26125.000000 | . 2 American Indian or Alaskan Native | Female | max | 98536.000000 | . 3 American Indian or Alaskan Native | Male | mean | 60305.400000 | . 4 American Indian or Alaskan Native | Male | min | 26125.000000 | . 5 American Indian or Alaskan Native | Male | max | 81239.000000 | . 6 Asian/Pacific Islander | Female | mean | 63226.300000 | . 7 Asian/Pacific Islander | Female | min | 26125.000000 | . 8 Asian/Pacific Islander | Female | max | 130416.000000 | . 9 Asian/Pacific Islander | Male | mean | 61033.906667 | . 10 Asian/Pacific Islander | Male | min | 27914.000000 | . 11 Asian/Pacific Islander | Male | max | 163228.000000 | . 12 Black or African American | Female | mean | 48965.790378 | . 13 Black or African American | Female | min | 24960.000000 | . 14 Black or African American | Female | max | 150416.000000 | . 15 Black or African American | Male | mean | 51118.867374 | . 16 Black or African American | Male | min | 26125.000000 | . 17 Black or African American | Male | max | 275000.000000 | . 18 Hispanic/Latino | Female | mean | 46503.316176 | . 19 Hispanic/Latino | Female | min | 26125.000000 | . 20 Hispanic/Latino | Female | max | 126115.000000 | . 21 Hispanic/Latino | Male | mean | 54767.541538 | . 22 Hispanic/Latino | Male | min | 26104.000000 | . 23 Hispanic/Latino | Male | max | 165216.000000 | . 24 Others | Female | mean | 63785.000000 | . 25 Others | Female | min | 63785.000000 | . 26 Others | Female | max | 63785.000000 | . 27 Others | Male | mean | 38771.000000 | . 28 Others | Male | min | 38771.000000 | . 29 Others | Male | max | 38771.000000 | . 30 White | Female | mean | 66793.352941 | . 31 White | Female | min | 27955.000000 | . 32 White | Female | max | 178331.000000 | . 33 White | Male | mean | 63940.388119 | . 34 White | Male | min | 26125.000000 | . 35 White | Male | max | 210588.000000 | . ggplot(data = df3) + geom_bar(aes(x = &#39;aggtype&#39;, y = &#39;BASE_SALARY&#39;, fill = &#39;GENDER&#39;), stat = &#39;identity&#39;, position = &#39;dodge&#39;) + coord_flip() + facet_wrap(facets = &#39;RACE&#39;) . &lt;ggplot: (135580437071)&gt; .",
            "url": "https://jaesu26.github.io/green/python/2021/11/05/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94_%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C.html",
            "relUrl": "/python/2021/11/05/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EA%B0%81%ED%99%94_%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C.html",
            "date": " • Nov 5, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "R입문 중간고사",
            "content": "- 시험문제 : https://guebin.github.io/2021IR/2024/01/01/R%EC%9E%85%EB%AC%B8%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html . - 파이썬 연습겸 R입문 중간고사 문제 파이썬으로 풀어봄 . 1&#48264; &#47928;&#51228; . (a) . 2**-5 + 2**3 . 8.03125 . (b) . 33**0.5 . 5.744562646538029 . (c) . sum_ = 0 for k in range(1, 101): sum_ += 1 / ((k+1) ** 2) print(sum_) . 0.6350819297898338 . - 리스트 컴프리핸션 . sum([1/((k+1)**2) for k in range(1, 101)]) . 0.6350819297898338 . 2&#48264; &#47928;&#51228; . (a) . import numpy as np x = np.arange(-10, 10.5, 0.5) print(x) . [-10. -9.5 -9. -8.5 -8. -7.5 -7. -6.5 -6. -5.5 -5. -4.5 -4. -3.5 -3. -2.5 -2. -1.5 -1. -0.5 0. 0.5 1. 1.5 2. 2.5 3. 3.5 4. 4.5 5. 5.5 6. 6.5 7. 7.5 8. 8.5 9. 9.5 10. ] . (b) . def f(x): if abs(x) &gt; 5: return x elif abs(x) &lt; 2: return 0 else: return 5 y = list(map(f, x)) print(y) . [-10.0, -9.5, -9.0, -8.5, -8.0, -7.5, -7.0, -6.5, -6.0, -5.5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5, 10.0] . 3&#48264; &#47928;&#51228; . from math import exp def f(x): return 2*x + 3 def g(x): return exp(x) / (1 + exp(x)) def h(x): return max(x, 0) x1 = list(map(f, x)) x2 = list(map(g, x1)) x3 = list(map(h, x2)) print(x3) . [4.1399375473943306e-08, 1.12535162055095e-07, 3.059022269256247e-07, 8.315280276641321e-07, 2.2603242979035742e-06, 6.144174602214718e-06, 1.670142184809518e-05, 4.5397868702434395e-05, 0.00012339457598623172, 0.00033535013046647816, 0.0009110511944006454, 0.0024726231566347748, 0.006692850924284856, 0.017986209962091555, 0.04742587317756679, 0.11920292202211755, 0.2689414213699951, 0.5, 0.7310585786300049, 0.8807970779778824, 0.9525741268224333, 0.9820137900379085, 0.9933071490757152, 0.9975273768433652, 0.9990889488055994, 0.9996646498695335, 0.9998766054240138, 0.9999546021312976, 0.9999832985781519, 0.9999938558253978, 0.999997739675702, 0.9999991684719723, 0.9999996940977731, 0.9999998874648379, 0.9999999586006245, 0.9999999847700205, 0.9999999943972036, 0.9999999979388464, 0.999999999241744, 0.9999999997210532, 0.9999999998973812] . 4&#48264; &#47928;&#51228; . (a) . import matplotlib.pyplot as plt n = 10 l = [0]*n for i in range(1, n+1): l[i-1] = 1/(2**i) l_ = np.cumsum(l) plt.plot(list(range(n)), l_) . [&lt;matplotlib.lines.Line2D at 0x15879d61f70&gt;] . sum = 0 n = 10 x = 5 ## 예시 for i in range(n): sum += x**i print(exp(x),&quot; n&quot;, sum) . 148.4131591025766 2441406 . - 모든 x에 대해 성립해야 되는데 아니다 . 5&#48264; &#47928;&#51228; . x = a = 10 #예시 salary = a for i in range(1, 19): a *= 1.08 salary += a for j in range(20, 29): a *= 0.75 salary += a print(salary / x) . 52.53420212516463 . 6&#48264; &#47928;&#51228; . - (a) : 참 . - (b) : 거짓 . - (c) : 거짓 . - (d) : 거짓 . 7&#48264; &#47928;&#51228; . n = 100 doors = [False] * (n+1) for i in range(1, n+1): for j in range(i, n+1): if j % i == 0: if doors[j] == True: doors[j] = False else: doors[j] = True sum_ = 0 for k in range(1, n+1): if doors[k] == True: sum_ += 1 print(sum_) . 10 . 8&#48264; &#47928;&#51228; . dist = 35 dp = [0] * 456 dp2 = [0] * 456 x = np.array(range(1, 457)) / 100 for i in np.arange(10, 0, -0.5): for j in range(456): if dp2[j] == 0: dp[j] = round(dp[j] + round(x[j], 3), 3) if x[j] &gt; i and dp2[j] == 0: ## 0은 False이다 if dp[j] - round((x[j] - i), 3) &lt; dist: dp2[j] = -1 elif dp[j] - round((x[j] - i), 3) &gt;= dist: dp2[j] = 1 elif x[j] &lt;= i and dp[j] &gt;= dist and dp2[j] == 0: dp2[j] = 1 x += 1 . (a) . dp2[0] # 사망 . -1 . dp2[66] # 사망 . -1 . dp2[217] # 생존 . 1 . dp2[455] # 사망 . -1 . (b) . sum_ = 0 for k in range(456): if dp2[k] == 1: sum_ += 1 print(sum_) . 85 . - 전체 생존자는 85명 . - 고찰 . - 이것때문에 정신나감 . - 그리고 처음 dp 설정할 때 전부 0으로 해야됐는데 -1로 해서 또 정신나감 . a = np.array([0, 0]) b = [0] * 2 a[0] += 0.01 print(a[0]) . 0 . - 왜 0인지 이해가 안됨 . - 왜 0.01이 아니냐? . b[0] += 0.01 print(b[0]) . 0.01 . - ㅋㅋㅋㅋㅋㅋㅋㅋㅋ . - 넘파이 어레이는 0인데 그냥 리스트는 0.01이다 . - 이유는 모른다 . 9&#48264; &#47928;&#51228; . import pandas as pd df = pd.read_csv(&quot;https://raw.githubusercontent.com/miruetoto/yechan/master/_notebooks/round2.csv&quot;) mat = np.matrix(df) . mat.shape . (5513, 2) . (a) . plt.plot(mat[:,0], mat[:,1], &#39;.k&#39;) . [&lt;matplotlib.lines.Line2D at 0x200885d74c0&gt;] . (b) . mat[0,:] . matrix([[ 12, 313]], dtype=int64) . (c) . np.matrix([[0,-1], [-1,0]]) @ np.matrix([12,313]).T . matrix([[-313], [ -12]]) . (d) . mat2 = mat for i in range(5513): mat2[i,:] = (np.matrix([[0,-1], [-1,0]]) @ mat[i,:].T).T . (e) . plt.plot(mat2[:,0], mat2[:,1], &#39;.r&#39;) . [&lt;matplotlib.lines.Line2D at 0x200886dc190&gt;] . - 위에서 mat2 = mat이라고 했는데 그러면 안됨 . id(mat2), id(mat) . (2203309972272, 2203309972272) . - 메모리 주소가 동일해서 mat2를 바꾸면 mat도 바뀌어서 아래와 같이 된다 . plt.plot(mat[:,0], mat[:,1], &#39;.r&#39;) . [&lt;matplotlib.lines.Line2D at 0x20088745760&gt;] . - 그럼 어떻게? &gt; 깊은복사! . - mat 다시 초기화 . mat = np.matrix(df) . plt.plot(mat[:,0], mat[:,1], &#39;.k&#39;) . [&lt;matplotlib.lines.Line2D at 0x200887ad7c0&gt;] . mat3 = mat.copy() . for i in range(5513): mat3[i,:] = (np.matrix([[0,-1], [-1,0]]) @ mat[i,:].T).T . plt.plot(mat3[:,0], mat2[:,1], &#39;.r&#39;) . [&lt;matplotlib.lines.Line2D at 0x20088815970&gt;] . id(mat), id(mat3) . (2201311857904, 2201313255712) . - 메모리 주소가 다르다 . plt.plot(mat[:,0], mat[:,1], &#39;.k&#39;) . [&lt;matplotlib.lines.Line2D at 0x20088877850&gt;] . - mat3를 바꿨지만 깊은복사를 하였기에 mat에는 영향을 끼치지 않음 .",
            "url": "https://jaesu26.github.io/green/python/2021/11/04/R%EC%9E%85%EB%AC%B8_%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "relUrl": "/python/2021/11/04/R%EC%9E%85%EB%AC%B8_%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "date": " • Nov 4, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "혈압-혈당 데이터 분석",
            "content": "- 내용을 추가할수록 산으로 가는것 같음 . - 나중에 정리할 필요 매우 있음 . &#54056;&#53412;&#51648; import &#48143; &#45936;&#51060;&#53552; &#51204;&#52376;&#47532; . - 데이터 출처 : https://nhiss.nhis.or.kr/bd/ab/bdabf003cv.do . - 한글 깨짐 참고 : https://mirae-kim.tistory.com/14 . import pandas as pd import numpy as np import matplotlib.pyplot as plt import matplotlib import seaborn as sns # from scipy import stats # import plotly.express as px # from plotnine import * # import plotly.figure_factory as ff fig_dims = (10, 6) # 그래프의 출력 사이즈를 나타냄 # 그래프크기 8, 4로 했는데 너무 작았음 # 그냥 크게하자 ## 산점도 그리기 전에는 10, 6로 하고 산점도 그릴때부터는 12, 8로 하자 ## 12, 8 해봤는데 너무 크다... 그냥 10, 6이 적당한듯 sns.set(rc = {&#39;figure.figsize&#39;:fig_dims}) # plot 사이즈 및 스타일 통일 sns.set_theme() # 테마 설정 matplotlib.rcParams[&#39;font.family&#39;] = &#39;Malgun Gothic&#39; # 한글이 깨지지 않도록 설정 matplotlib.rcParams[&#39;axes.unicode_minus&#39;] = False # 한글이 깨지지 않도록 설정 . df = pd.read_csv(&#39;https://raw.githubusercontent.com/gkswotn9999/data/main/blood_data.csv&#39;, header = 0) ## 2013~2014년에 실시된 백만개의 국가건강검진_혈압혈당데이터 . df.shape ## matrix는 1000000 × 7 크기 . (1000000, 7) . df.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 1000000 entries, 0 to 999999 Data columns (total 7 columns): # Column Non-Null Count Dtype -- -- 0 SEX 1000000 non-null int64 1 BTH_G 1000000 non-null int64 2 SBP 1000000 non-null int64 3 DBP 1000000 non-null int64 4 FBS 1000000 non-null int64 5 DIS 1000000 non-null int64 6 BMI 1000000 non-null float64 dtypes: float64(1), int64(6) memory usage: 53.4 MB . - 결측치는 없다 . - 우선 열 이름을 변경하자 . - 그냥 바꾸지 말지 고민중... . df.columns = [&#39;성별&#39;, &#39;연령대&#39;, &#39;수축기혈압&#39;, &#39;이완기혈압&#39;, &#39;공복혈당&#39;, &#39;고혈압_당뇨_진료내역&#39;, &#39;BMI&#39;] # 고혈압_당뇨 보다는 고혈압_당뇨_진료내역이 더 알맞을것 같으니 나중에 바꾸자(지금은 귀찮다) # 진료여부보단 진료내역이 나은듯 # 고혈압_당뇨_진료내역 숫자로 코딩되어 있는거 바꿀지말지 고민 . df.head(6) . 성별 연령대 수축기혈압 이완기혈압 공복혈당 고혈압_당뇨_진료내역 BMI . 0 1 | 1 | 116 | 78 | 94 | 4 | 16.6 | . 1 1 | 1 | 100 | 60 | 79 | 4 | 22.3 | . 2 1 | 1 | 100 | 60 | 87 | 4 | 21.9 | . 3 1 | 1 | 111 | 70 | 72 | 4 | 20.2 | . 4 1 | 1 | 120 | 80 | 98 | 4 | 20.0 | . 5 1 | 1 | 115 | 79 | 95 | 4 | 23.1 | . - 변수별 요약통계량은 아래와 같다 . df.describe().round(2) . 성별 연령대 수축기혈압 이완기혈압 공복혈당 고혈압_당뇨_진료내역 BMI . count 1000000.00 | 1000000.00 | 1000000.00 | 1000000.00 | 1000000.00 | 1000000.00 | 1000000.0 | . mean 1.49 | 13.91 | 121.87 | 75.79 | 98.86 | 3.47 | 23.8 | . std 0.50 | 7.01 | 14.56 | 9.79 | 22.98 | 0.95 | 3.3 | . min 1.00 | 1.00 | 82.00 | 50.00 | 60.00 | 1.00 | 14.8 | . 25% 1.00 | 9.00 | 110.00 | 70.00 | 87.00 | 3.00 | 21.5 | . 50% 1.00 | 14.00 | 120.00 | 76.00 | 94.00 | 4.00 | 23.6 | . 75% 2.00 | 19.00 | 130.00 | 80.00 | 104.00 | 4.00 | 25.8 | . max 2.00 | 27.00 | 190.00 | 120.00 | 358.00 | 4.00 | 40.3 | . - 수축기혈압은 82~190의 범위를 가지고 중앙값은 120, 평균은 121.87이다 . - 이완기혈압은 50~120의 범위를 가지고 중앙값은 76, 평균은 75.79이다 . - 공복혈당은 60~358의 범위를 가지고 중앙값은 94, 평균은 98.86이다 . - BMI은 14.8~40.3의 범위를 가지고 중앙값은 23.6, 평균은 23.8이다 . - 양적변수들을 보면 중앙값과 평균이 거의 비슷한데 대칭인 분포인 것 같다 . - 각 변수에 대한 설명은 아래와 같다 . 변수명 범위 비고 . 수축기혈압 | 82-190 mmHg | 상·하위 극단값 0.05% 제거 | . 이완기혈압 | 50-120 mmHg | 〃(위와 동일함) | . 공복혈당 | 60-358 mg/dL | 〃 | . BMI | 14.8-40.3 kg/m2 | $ cfrac{w}{t^2}$키가 t미터, 몸무게가 w킬로그램〃(위와 동일함) | . 성별 숫자 . 남자 | 1 | . 여자 | 2 | . 고혈압/당뇨병 진료내역 숫자 . 고혈압/당뇨병 진료내역 있음 | 1 | . 고혈압 진료내역 있음 | 2 | . 당뇨병 진료내역 있음 | 3 | . 고혈압/당뇨병 진료내역 없음 | 4 | . - 고혈압, 당뇨 진료내역의 의미는 다음과 같다 . - 현재 고혈압을 앓고있을 수 도 있고 아니면 과거에 고혈압에 걸렸었던 것일 수 도 있다 . - 즉 현재 고혈압인 경우와 과거에 고혈압이었던 경우로 나뉘며 당뇨도 마찬가지이다 . - 앞으로 고혈압 진료내역이 있다는 말과 고혈압이 있다는 말은 편의상 동일한 의미로 사용할 것이다 . - 동일한 의미로 사용하면 안될것같다(혈압_범주를 만들어서 진짜 고혈압이 있는지 구별해야함) . - 나중에 일일이 바꾸자 . &#50672;&#47161;&#45824; &#48276;&#51452; &#48320;&#44221; . - 현재 연령대 column 이 가지는 값은 1부터 27 까지인데 이들에는 1 =&gt; 20~24, 2 부터는 24살부터 2세 간격으로 끊어진 연령대가 할당되고 마지막은 27 =&gt; 75+ 이다 . ft = df[&#39;연령대&#39;].value_counts() rft = df[&#39;연령대&#39;].value_counts() / len(df[&#39;연령대&#39;]) age_group_table = pd.DataFrame({&#39;Freq&#39;: ft, &#39;Relative freq&#39;: rft}) age_group_table.sort_index() . Freq Relative freq . 1 26699 | 0.026699 | . 2 22398 | 0.022398 | . 3 26925 | 0.026925 | . 4 30595 | 0.030595 | . 5 34984 | 0.034984 | . 6 33797 | 0.033797 | . 7 29666 | 0.029666 | . 8 30074 | 0.030074 | . 9 53811 | 0.053811 | . 10 50787 | 0.050787 | . 11 50881 | 0.050881 | . 12 49544 | 0.049544 | . 13 46303 | 0.046303 | . 14 46373 | 0.046373 | . 15 52352 | 0.052352 | . 16 53382 | 0.053382 | . 17 47760 | 0.047760 | . 18 45048 | 0.045048 | . 19 37174 | 0.037174 | . 20 33846 | 0.033846 | . 21 30824 | 0.030824 | . 22 32253 | 0.032253 | . 23 22906 | 0.022906 | . 24 22720 | 0.022720 | . 25 24530 | 0.024530 | . 26 18463 | 0.018463 | . 27 45905 | 0.045905 | . - 변수가 가지는 범주가 너무 많고 범주가 가지는 나이의 범위가 현재 2세인데 조금 더 늘려도 크게 차이가 있을 것 같지는 않다 . - 표본수가 많으므로 10세 간격으로 끊지 않고 5세 간격으로 끊어 비슷한 연령끼리 그룹화 하자 . - 애매한 것은 연령대 데이터가 31-32, 33-34, 35-36, 37-38, 39-40 이런식으로 되어있어 5개씩 나눌 수 가 없는 점이다 . - 0~4 과 5~9으로 나누면 균등해지고 좋을 것 같다 . - 혈압혈당데이터는 건강검진을 받은 사람들 중 백만명을 무작위 층화추출했다 . - 그렇기에 주기성이 없을 것이니 하나의 난수를 가지고 20~70세의 초반, 후반을 나누자 . - 5세 간격으로 끊어 편의상 0~4는 &#39;초반&#39;, 5~9는 &#39;후반&#39;으로 표기했다 . - 위의 범주를 무작위로 50%씩 나눠서 반절은 &#39;초반&#39;에 나머지 반절은 &#39;후반&#39;에 할당하자 . np.random.seed(2021) rs = np.random.binomial(n = 1, p = 0.5, size = 60000) # 최대가 53000이라 넉넉히 60000개 뽑았다 . c = 2 age = 2 cnt = 3 df.loc[df[&#39;연령대&#39;] == 1, &#39;연령대&#39;] = &#39;20대초반&#39; for idx in [4, 9, 14, 19, 24]: # 변수에 대한 설명을 보면 9~10 에 해당하는 범주의 값은 4, 9, 14, 19, 24이다 df_ = df.loc[df[&#39;연령대&#39;] == idx, &#39;연령대&#39;] df.loc[df[&#39;연령대&#39;] == idx, &#39;연령대&#39;] = rs[: len(df_)] df.loc[df[&#39;연령대&#39;] == 0, &#39;연령대&#39;] = str(c) + &#39;0대후반&#39; c += 1 df.loc[df[&#39;연령대&#39;] == 1, &#39;연령대&#39;] = str(c) + &#39;0대초반&#39; for i in range(2, 27): if cnt &lt; 3: str_ = &#39;초반&#39; else: str_ = &#39;후반&#39; df.loc[df[&#39;연령대&#39;] == i, &#39;연령대&#39;] = str(age) + &#39;0대&#39; + str_ if cnt == 5: age += 1 cnt = 0 cnt += 1 df.loc[df[&#39;연령대&#39;] == 27, &#39;연령대&#39;] = &#39;75세이상&#39; . - 연령대의 도수분포표를 그려보자 . ft = df[&#39;연령대&#39;].value_counts() rft = df[&#39;연령대&#39;].value_counts() / len(df[&#39;연령대&#39;]) . age_group_table = pd.DataFrame({&#39;Freq&#39;: ft, &#39;Relative freq&#39;: rft}) age_group_table . Freq Relative freq . 50대초반 128976 | 0.128976 | . 40대초반 128580 | 0.128580 | . 40대후반 118978 | 0.118978 | . 50대후반 111352 | 0.111352 | . 30대후반 86639 | 0.086639 | . 30대초반 84083 | 0.084083 | . 60대초반 83300 | 0.083300 | . 60대후반 66487 | 0.066487 | . 20대후반 64616 | 0.064616 | . 70대초반 54385 | 0.054385 | . 75세이상 45905 | 0.045905 | . 20대초반 26699 | 0.026699 | . - 20대 초반 &gt; 75세 이상 순서이면 좋겠다 . age_group_table.sort_index() . Freq Relative freq . 20대초반 26699 | 0.026699 | . 20대후반 64616 | 0.064616 | . 30대초반 84083 | 0.084083 | . 30대후반 86639 | 0.086639 | . 40대초반 128580 | 0.128580 | . 40대후반 118978 | 0.118978 | . 50대초반 128976 | 0.128976 | . 50대후반 111352 | 0.111352 | . 60대초반 83300 | 0.083300 | . 60대후반 66487 | 0.066487 | . 70대초반 54385 | 0.054385 | . 75세이상 45905 | 0.045905 | . &#45936;&#51060;&#53552; EDA . - 고혈압_당뇨 진료내역에 따른 특성들을 확인할 것이다(기본적으론) . &#48276;&#51452;&#54805;&#48320;&#49688; &#53456;&#49353; . &#44256;&#54792;&#50517;, &#45817;&#45544; &#51652;&#47308;&#45236;&#50669; &#48712;&#46020; . - 우선 고혈압, 당뇨 진료내역 범주의 비율을 확인했다 . ft = df[&#39;고혈압_당뇨_진료내역&#39;].value_counts() rft = df[&#39;고혈압_당뇨_진료내역&#39;].value_counts() / len(df[&#39;고혈압_당뇨_진료내역&#39;]) . DIS_table = pd.DataFrame({&#39;Freq&#39;: ft, &#39;Relative freq&#39;: rft}) DIS_table . Freq Relative freq . 4 740662 | 0.740662 | . 2 162826 | 0.162826 | . 1 53398 | 0.053398 | . 3 43114 | 0.043114 | . count_by_cut = df.groupby(&#39;고혈압_당뇨_진료내역&#39;).size() count_by_cut . 고혈압_당뇨_진료내역 1 53398 2 162826 3 43114 4 740662 dtype: int64 . plt.pie(x = count_by_cut, labels = [&#39;고혈압,당뇨&#39;, &#39;고혈압&#39;, &#39;당뇨&#39;, &#39;없음&#39;], autopct = &#39;%.2f%%&#39;) plt.show() . - 고혈압/당뇨 둘 다 진료내역 없음이 74%로 가장 많이 차지한다 . - 당뇨 진료내역만 있는 경우는 4%, 고혈압 진료내역만 있는 경우는 16%, 둘다 있는 경우는 5%이다 . - 둘 다 진료내역이 있는 경우가 당뇨 진료내역만 있는 경우보다 많은 것으로 보아 당뇨가 있는 경우 고혈압도 있는 경우가 빈번한 것 같다 . - 고혈압/당뇨 진료내역에 따른 사람들의 연령대와 성별을 확인해보자 . - 우선 고혈압/당뇨 진료내역에 따른 연령대를 확인하자 . &#44256;&#54792;&#50517;, &#45817;&#45544; &#51652;&#47308;&#45236;&#50669;&#44284; &#50672;&#47161;&#45824; &#48516;&#54624;&#54364; . # df[&#39;연령대&#39;] = pd.Categorical(df[&#39;연령대&#39;], [&#39;20대초반&#39;, &#39;20대후반&#39;, &#39;30대초반&#39;, &#39;30대후반&#39;, &#39;40대초반&#39;, &#39;40대후반&#39;, &#39;50대초반&#39;, &#39;50대후반&#39;, &#39;60대초반&#39;, &#39;60대후반&#39;, &#39;70대초반&#39;, &#39;75세이상&#39;]) . DIS_AGE_table = df.groupby([&#39;연령대&#39;, &#39;고혈압_당뇨_진료내역&#39;]).size().reset_index(name = &#39;cnt&#39;).pivot(index = &#39;고혈압_당뇨_진료내역&#39;, columns = &#39;연령대&#39;, values = &#39;cnt&#39;) # DIS_AGE_table = pd.crosstab(df[&#39;고혈압_당뇨&#39;], df[&#39;연령대&#39;], margins = True) . DIS_AGE_table . 연령대 20대초반 20대후반 30대초반 30대후반 40대초반 40대후반 50대초반 50대후반 60대초반 60대후반 70대초반 75세이상 . 고혈압_당뇨_진료내역 . 1 9 | 35 | 137 | 431 | 1358 | 2763 | 5362 | 7861 | 8818 | 9232 | 9300 | 8092 | . 2 80 | 359 | 1104 | 2936 | 7607 | 13091 | 21954 | 26180 | 24447 | 23256 | 21241 | 20571 | . 3 79 | 253 | 543 | 1233 | 2865 | 4400 | 6555 | 7371 | 6648 | 5524 | 4479 | 3164 | . 4 26531 | 63969 | 82299 | 82039 | 116750 | 98724 | 95105 | 69940 | 43387 | 28475 | 19365 | 14078 | . - 공통적으로 확인되는것은 4번의 경우가 가장 많은 것과 2번의 경우가 3번의 경우보다 더 많다는 것이다 . - 당뇨병보다는 고혈압이 흔한것 같다 . - 그리고 젊은 연령대에서는 1의 경우가 2, 3인 경우보다 더 적은데 50대 초반부터는 늙을수록 1의 경우가 3의 경우보다 더 많아진다 . - 50대 부터는 당뇨가 있는 경우 고혈압도 있는 경우가 흔한것같고 이는 연령대가 높아질수록 더 심해진다 . - 그런데 연령마다 총인원수가 다르기에 사람수로 판단하기 보다는 비율로 판단하는게 좋아보인다 . - 예로 70대초반에서 고혈압_당뇨 범주값이 1인 경우 count는 9300이고 75세이상의 경우는 8092여서 감소한것 같지만 70대초반 인구수와 75세이상 인구수가 다르기에 비율로 따져야 정확하다 . DIS_AGE_table_prob = DIS_AGE_table.apply(lambda x: x*100 / sum(x), axis = 0) # 상대도수를 구함 DIS_AGE_table_prob . 연령대 20대초반 20대후반 30대초반 30대후반 40대초반 40대후반 50대초반 50대후반 60대초반 60대후반 70대초반 75세이상 . 고혈압_당뇨_진료내역 . 1 0.033709 | 0.054166 | 0.162934 | 0.497466 | 1.056152 | 2.322278 | 4.157363 | 7.059595 | 10.585834 | 13.885421 | 17.100303 | 17.627709 | . 2 0.299637 | 0.555590 | 1.312988 | 3.388774 | 5.916161 | 11.002874 | 17.021771 | 23.511028 | 29.348139 | 34.978266 | 39.056725 | 44.812112 | . 3 0.295891 | 0.391544 | 0.645790 | 1.423147 | 2.228185 | 3.698163 | 5.082341 | 6.619549 | 7.980792 | 8.308391 | 8.235727 | 6.892495 | . 4 99.370763 | 98.998700 | 97.878287 | 94.690613 | 90.799502 | 82.976685 | 73.738525 | 62.809828 | 52.085234 | 42.827921 | 35.607245 | 30.667683 | . DIS_AGE_table_prob.T.plot.bar(stacked = True, rot = 0, figsize=(12 , 6)) . &lt;AxesSubplot:xlabel=&#39;연령대&#39;&gt; . - 일단 4(고혈압,당뇨 둘 다 없음)인 경우를 확인해보자 . - 20대초반의 99%는 4인데 나이가 들어감에 따라 비율이 감소하여 75세이상에서는 4의 경우가 30%이다 . - 1과 2의 경우는 4의 경우와 반대로 나이가 들어가면서 비율이 높아진다 . - 3의 경우는 60대후반까지는 증가하다가 그 이후부터 줄어든다 . - 요약하면 나이를 먹을수록 4는 증가하고 1,2,3은 감소한다(건강한 사람보다는 병을 앓던 사람이 많다는 의미이다) . - 고혈압_당뇨 범주마다 연령대의 비율은 어느정도인지 시각화해보자 . DIS_AGE_table_prob2 = DIS_AGE_table.apply(lambda x: x*100 / sum(x), axis = 1) # 상대도수를 구함 DIS_AGE_table_prob2.plot.bar(stacked = True, rot = 0) plt.legend(loc = &#39;center left&#39;, bbox_to_anchor = (1, 0.5)) plt.show() ## 보면 알겠지만 색깔이 중복되니 나중에 색깔 12개 골라서 지정해줘야 함 . - 막대그래프의 밑에서부터 20대초반, 20대후반, $ cdots$, 70대 초반, 75세이상이다 . - 고혈압_당뇨가 1, 2, 3인 경우는 비슷해보인다 . - 고혈압/당뇨 둘 다 진료내역이 없는 경우(4)에는 확실히 다르다 . - 고혈압/당뇨가 1, 2, 3인 경우 30대 후반까지 차지하는 비중이 낮다 . - 하지만 4인 경우에는 30대 후반까지 차지하는 비중이 높아졌다 . &#44256;&#54792;&#50517;, &#45817;&#45544; &#51652;&#47308;&#45236;&#50669;&#44284; &#49457;&#48324; &#48516;&#54624;&#54364; . - 이제 고혈압/당뇨 진료내역에 따른 성별을 확인하자 . count = df.groupby(&#39;성별&#39;).size() plt.pie(x = count, labels = [&#39;남자&#39;, &#39;여자&#39;], autopct = &#39;%.2f%%&#39;) plt.show() . - 우선 전체 백만명중 남자가 51% 여자가 49%로 둘이 비슷하다 . DIS_SEX_table = df.groupby([&#39;성별&#39;, &#39;고혈압_당뇨_진료내역&#39;]).size().reset_index(name = &#39;cnt&#39;).pivot(index = &#39;고혈압_당뇨_진료내역&#39;, columns = &#39;성별&#39;, values = &#39;cnt&#39;) . DIS_SEX_table . 성별 1 2 . 고혈압_당뇨_진료내역 . 1 27979 | 25419 | . 2 79892 | 82934 | . 3 23900 | 19214 | . 4 378456 | 362206 | . DIS_SEX_table_prob = DIS_SEX_table.apply(lambda x: x*100 / sum(x), axis = 1) # 상대도수를 구함 DIS_SEX_table_prob . 성별 1 2 . 고혈압_당뇨_진료내역 . 1 52.397094 | 47.602906 | . 2 49.065874 | 50.934126 | . 3 55.434430 | 44.565570 | . 4 51.096992 | 48.903008 | . DIS_SEX_table_prob.plot.bar(stacked = True, rot = 0) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;&gt; . - 당뇨진료내역이 있는 경우 남자의 비율이 여자보다 살짝 높고 나머지는 비슷하다 . - 성별과 고혈압/당뇨 진료내역은 연관이 없어보인다(라고 생각했었는데...) . - 위에처럼 생각했는데 표본크기가 매우커서 55%, 45%(당뇨 진료내역 있음) 정도면 차이가 있다고 할 수 있다 . - 그리고 52.4%, 47.6%(고혈압, 당뇨 진료내역 있음) 도 차이가 있다고 할 수 있다 . - 마찬가지로 고혈압 진료내역이 있는 경우도 차이가 있다고 할 수 있다 . - 결과적으로 보면 고혈압, 당뇨 진료내역이 둘다 없는 경우를 제외하면 고혈압, 당뇨 진료내역과 성별은 연관이 있다 . &#50577;&#51201;&#48320;&#49688; &#53456;&#49353; . &#44060;&#48324; &#48320;&#49688;&#51032; &#49884;&#44033;&#54868; . &#49688;&#52629;&#44592;&#54792;&#50517; . - 양적 변수인 수축기혈압, 이완기혈압, 공복혈당, BMI의 분포를 확인해보자 . sns.histplot(data = df, x = &#39;수축기혈압&#39;, binwidth = 5) ## 구간을 5씩 끊어서 관찰, 어자피 바이올린플랏 그릴거니까 kde는 false로 하자 . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 분포의 모양을 크게 눈에 띄는 봉우리가 4개(100, 110, 120, 130) 존재한다 . - 즉 몇 군데(봉우리)에 데이터가 많이 몰려있다는 의미이다 . sns.boxplot(x = df[&#39;수축기혈압&#39;]) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;&gt; . - boxplot을 보니 수축기혈압의 이상점은 160을 넘는 경우인 듯 하다 . - 분포의 모양을 자세히 확인해보자 . sns.violinplot(x = df[&#39;수축기혈압&#39;]) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;&gt; . - 성별에 따라 수축기혈압이 다른지 궁금하다 . sns.boxplot(x = &#39;성별&#39;, y = &#39;수축기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;성별&#39;, ylabel=&#39;수축기혈압&#39;&gt; . sns.violinplot(x = &#39;성별&#39;, y = &#39;수축기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;성별&#39;, ylabel=&#39;수축기혈압&#39;&gt; . df.groupby(&#39;성별&#39;)[&#39;수축기혈압&#39;].describe() . count mean std min 25% 50% 75% max . 성별 . 1 510227.0 | 124.279954 | 13.547532 | 82.0 | 115.0 | 123.0 | 132.0 | 190.0 | . 2 489773.0 | 119.363001 | 15.146169 | 82.0 | 110.0 | 119.0 | 130.0 | 190.0 | . - 남자인 경우 여자인 경우보다 평균적으로 수축기혈압이 5정도 높다 . - 신기한건 남자가 여자보다 이완기 혈압이 평균적으로 4정도 높지만 두 봉우리의 위치는 남자와 여자가 동일하다 . - 그리고 표준편차는 여자가 1.5정도 더 높다(변동성이 더 크다) &gt; 남자쪽 봉우리가 더 뾰족해서인듯 . - 이것의 의미가 성별은 관련없는 변수라는것인가?(모름) . - 그런데 고혈압, 당뇨 진료내역에 따라 수축기혈압의 분포를 살펴봤는데 이 때도 봉우리의 위치는 4개다 동일하다 . - 남자가 여자보다 혈압이 평균적으로 더 높지만 봉우리의 위치가 같은건 어떤 의미인지 깊게 생각할 필요가 있음 . - 근데 사실 궁금한건 고혈압/당뇨인 사람들은 어떤 특성을 가진 사람들인가이다 . - 고혈압/당뇨에 따라 plot을 그려보자 . sns.histplot(x = &#39;수축기혈압&#39;, binwidth = 5, hue = &#39;고혈압_당뇨_진료내역&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 고혈압, 당뇨 둘다 없는 사람은 수축기혈압이 90~140에 있는것으로 보이고 그 외에는 100~160에 있는것으로 보인다 . - 하지만 고혈압/당뇨 둘 다 진료내역이 없는 경우의 표본수가 많아 나머지는 잘 보이지 않는다 . - 고혈압/당뇨 진료내역에 따라 각각 히스토그램을 그려보자 . b = sns.FacetGrid(data = df, row = &#39;고혈압_당뇨_진료내역&#39;, height = 7) b.map(sns.histplot, &#39;수축기혈압&#39;, kde = False, binwidth = 5, color = &#39;gray&#39;) . &lt;seaborn.axisgrid.FacetGrid at 0x23d8d6f89d0&gt; . - 분포는 모두 대칭이고 종모양으로 보이며 봉우리가 많다 . - 고혈압_당뇨가 1,2인 경우는 130이 중심으로 보인다 . - 고혈압_당뇨가 3,4인 경우는 120이 중심으로 보인다 . - 이를 박스플랏을 통해 자세히 확인하자 . sns.boxplot(x = &#39;고혈압_당뇨_진료내역&#39;, y = &#39;수축기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;수축기혈압&#39;&gt; . - 고혈압/당뇨 둘다 진료내역이 없는 그룹은 수축기혈압이 낮은쪽에서는 이상점이 없다 . - 바이올린플랏을 그려 분포의 모양도 같이 확인하자 . sns.violinplot(x = &#39;고혈압_당뇨_진료내역&#39;, y = &#39;수축기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;수축기혈압&#39;&gt; . - 봉우리가 많은 이유가 고혈압_당뇨 진료내역에 따라 분포가 상이하여 그럴것 같았지만 아니었다 . - 고혈압/당뇨 진료내역이 없는 사람들의 수축기 혈압은 다른 경우 비해 몇군데에 더욱 많이 몰렸있다 . - 봉우리가 많은 분포임은 넷다 동일하다 . - 데이터를 보면 1은 고혈압 당뇨 둘 다 진료내역이 있고 2는 고혈압만 3은 당뇨만 있고 4는 둘 다 진료 내역이 없는 경우이다 . - 2와 3을 보면 2가 수축기 혈압이 평균적으로 더 높다 . - 그런데 1과 2를 보면 거의 차이가 없어보인다 . - 3과 4를 보면 당뇨 진료내역이 있는 사람들이 그렇지 않은 사람보다 평균이 조금 더 크고 분포도 더 넓게 퍼져있다 . - 고협압/당뇨 둘 다 진료내역이 없는 상황에서 당뇨 진료내역이 추가되면 수축기 혈압이 높아지고 더 넓게 분포한다 . - 하지만 고혈압 진료내역이 있는 상태라면 당뇨 진료내역의 유무는 수축기 혈압에 거의 영향을 끼치지 못하는 것으로 보인다 . - 수치로 정확히 확인해보자 . df.groupby(&#39;고혈압_당뇨_진료내역&#39;)[&#39;수축기혈압&#39;].describe() . count mean std min 25% 50% 75% max . 고혈압_당뇨_진료내역 . 1 53398.0 | 130.563972 | 14.981472 | 82.0 | 120.0 | 130.0 | 140.0 | 190.0 | . 2 162826.0 | 130.551300 | 14.851658 | 82.0 | 120.0 | 130.0 | 140.0 | 190.0 | . 3 43114.0 | 123.322146 | 13.618274 | 83.0 | 114.0 | 122.0 | 130.0 | 190.0 | . 4 740662.0 | 119.252575 | 13.484496 | 82.0 | 110.0 | 120.0 | 130.0 | 190.0 | . - 고혈압 진료내역만 있는 경우와 둘 다 진료내역이 있는 경우에 둘의 수축기 혈압 분포는 거의 똑같다 . - 표준편차는 약 15이고 평균은 약 130이다 . - 둘 다 진료내역이 없는 경우가 당뇨 진료내역만 있는 경우보다 수축기 혈압이 평균 4정도 낮다 . - 표준편차는 두 분포 모두 약 13.5이다 . - 고혈압이 있는 경우 그렇지 않은 경우보다 수축기 혈압이 평균 10정도 높다 . - 위에서 말했듯이 고혈압 진료내역이 있는 상태라면 당뇨병 진료내역과 수축기혈압은 상관이 없다 . - 하지만 고혈압이 없고 당뇨만 있는 상태라면 없는 경우보다 수축기혈압이 높다 . - 고혈압, 당뇨 진료내역 말고도 연령대별 수축기혈압에 차이가 있을 수 있다 . - 일반적으로 연령대가 높아질수록 수축기혈압이 높아진다고 한다 . - 이를 확인해볼 필요가 있다 . - 연령대별 수축기혈압의 평균을 구하고 연령대에 따른 변화를 살펴보도록 하자 . - 중앙값으로 할려했는데 평균으로 하자 . - 연령대별 중앙값이 겹치는 경우가 많음 &gt; 혈압이 똑같아 보이지만 더 높긴하다(평균으로 보면) . - 그리고 종모양이어서 평균이 더 나은것같다(대표성을 띈다) . - 결론 : 이상점에 영향을 덜받고자 중앙값을 선택했다 . df_mid = df.groupby([&#39;연령대&#39;]).agg({&#39;수축기혈압&#39;:np.median}) df_mid . 수축기혈압 . 연령대 . 20대초반 113 | . 20대후반 115 | . 30대초반 118 | . 30대후반 119 | . 40대초반 120 | . 40대후반 120 | . 50대초반 120 | . 50대후반 122 | . 60대초반 125 | . 60대후반 128 | . 70대초반 130 | . 75세이상 130 | . plt.figure(figsize = (12, 6)) sns.lineplot(x = &#39;연령대&#39;, y = &#39;수축기혈압&#39;, data = df_mid) sns.scatterplot(x = &#39;연령대&#39;, y = &#39;수축기혈압&#39;, data = df_mid, legend = False) . &lt;AxesSubplot:xlabel=&#39;연령대&#39;, ylabel=&#39;수축기혈압&#39;&gt; . - 위 plot을 보면 연령별 수축기혈압의 평균은 증가함을 알 수 있다 . - 그런데 40대초반~50대초반에서 수축기혈압의 중앙값은 120으로 동일하다 . - 이는 70대초반과 75세이상의 경우에도 마찬가지이다(130) . - 중간에 정체하는 구간을 기준으로 나눠봤을 때 구간 전보다 후가 증가폭이 더 크다($7.5 to 10$) . - 그런데 연령대 말고도 고혈압, 당뇨 진료내역마다 수축기혈압에 차이가 존재한다 . - 연령대별 고혈압, 당뇨 진료내역마다 수축기혈압의 중앙값들을 구하고 연령대에 따른 변화를 살펴보도록 하자 . df_median = df.groupby([&#39;연령대&#39;, &#39;고혈압_당뇨_진료내역&#39;])[&#39;수축기혈압&#39;].median().reset_index(name = &#39;수축기혈압&#39;) . plt.figure(figsize = (12, 6)) sns.lineplot(x = &#39;연령대&#39;, y = &#39;수축기혈압&#39;, hue = &#39;고혈압_당뇨_진료내역&#39;, data = df_median) sns.scatterplot(x = &#39;연령대&#39;, y = &#39;수축기혈압&#39;, hue = &#39;고혈압_당뇨_진료내역&#39;, data = df_median, legend = False) . &lt;AxesSubplot:xlabel=&#39;연령대&#39;, ylabel=&#39;수축기혈압&#39;&gt; . - 고혈압, 당뇨 둘 다 진료내역이 있는 경우와 고혈압만 진료내역이 있는 경우는 거의 동일한 양상을 보인다 . - 위의 경우 30대후반부터 수축기혈압의 중앙값은 130으로 동일하다 . - 당뇨 진료내역만 있는 경우 50대후반까진 수축기혈압의 중앙값이 120이다가 증가한다 . - 고혈압, 당뇨 진료내역이 둘 다 없는 경우도 증가하는 양상을 보이는데 40대초반에 살짝 감소한다 . - 그리고 40대후반부터 60대초반까지 수축기혈압 중앙값은 120으로 동일하다가 증가한다 . - 이완기 혈압도 수축기 혈압과 비슷한 양상을 보이는지 확인하자 . &#51060;&#50756;&#44592;&#54792;&#50517; . sns.histplot(data = df, x = &#39;이완기혈압&#39;, bins = 30) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 이완기 혈압도 수축기 혈압의 분포처럼 몇 군에데 데이터가 많이 몰려있는 분포(봉우리)이다 . - 짜잘한 봉우리가 많이 있긴한데 눈에 띄는 봉우리는 2개가 존재한다(쌍봉분포) . - 70에는 160000count, 80에는 230000count 정도가 존재한다 . - 왜 봉우리가 2개(70, 80)인지 75정도를 기준으로 나누어 확인해볼 필요가 있을것같다(예정) . - 연령대 때문일까? . b = sns.FacetGrid(data = df, row = &#39;연령대&#39;, height = 7) b.map(sns.histplot, &#39;이완기혈압&#39;, kde = False, bins = 30, color = &#39;gray&#39;) . &lt;seaborn.axisgrid.FacetGrid at 0x1c384a32c40&gt; . - 그렇지는 않다 . - 신기한건 30대 초반까진 70부근이 최빈값이고 그 이후부터는 80부근이 최빈값이다 . - 연령대에 따라 다르니 연령에 영향을 받는 변수에 의한 것이 아닐까?(몰라) . sns.boxplot(x = &#39;성별&#39;, y = &#39;이완기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;성별&#39;, ylabel=&#39;이완기혈압&#39;&gt; . sns.violinplot(x = &#39;성별&#39;, y = &#39;이완기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;성별&#39;, ylabel=&#39;이완기혈압&#39;&gt; . df.groupby(&#39;성별&#39;)[&#39;이완기혈압&#39;].describe() . count mean std min 25% 50% 75% max . 성별 . 1 510227.0 | 77.614977 | 9.504481 | 50.0 | 70.0 | 79.0 | 83.0 | 120.0 | . 2 489773.0 | 73.884467 | 9.727230 | 50.0 | 68.0 | 73.0 | 80.0 | 120.0 | . - 남자인 경우 여자인 경우보다 평균적으로 이완기혈압이 4정도 높다 . - 신기한건 남자가 여자보다 이완기 혈압이 평균적으로 4정도 높지만 두 봉우리의 위치는 남자와 여자가 동일하다 . - 수축기혈압의 경우 여성이 편차가 더 컸는데 이완기혈압의 경우는 비슷하다 . - 수축기 혈압 분포와 이완기 혈압 분포를 같이 놓고 비교해보자 . fig, (ax1, ax2) = plt.subplots(1,2) fig.set_figwidth(12) sns.histplot(data = df, x = &#39;수축기혈압&#39;, bins = 30, ax = ax1) sns.histplot(data = df, x = &#39;이완기혈압&#39;, bins = 30, ax = ax2) fig.tight_layout() . - 수축기 혈압 분포의 봉우리가 이완기 혈압 분포의 봉우리 개수보다 많다 . - 수축기 혈압이 이완기 혈압 분포보다 더 넓게 퍼져있다(표준 편차가 더 크다) . - 고혈압/당뇨에 따른 이완기 혈압 분포를 확인하자 . sns.histplot(x = &#39;이완기혈압&#39;, bins = 30, hue = &#39;고혈압_당뇨_진료내역&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 고혈압, 당뇨 둘 다 없는 경우 이완기혈압은 50~105에 분포하는 것으로 보이고 나머지는 60~105에 분포하는 것 같다 . - 하지만 이 역시 고혈압/당뇨 둘 다 진료내역이 없는 경우의 표본수가 많아 나머지는 잘 보이지 않는다 . - 히스토그램을 쌓아서 그린다면 보이지 않을까?(나중에) . b = sns.FacetGrid(data = df, row = &#39;고혈압_당뇨_진료내역&#39;, height = 7) b.map(sns.histplot, &#39;이완기혈압&#39;, kde = False, bins = 30, color = &#39;gray&#39;) . &lt;seaborn.axisgrid.FacetGrid at 0x23d89000280&gt; . - 4개의 분포모두 80이 중심으로 보인다 . - 이를 박스플랏을 통해 자세히 살펴보자 . sns.boxplot(x = &#39;고혈압_당뇨_진료내역&#39;, y = &#39;이완기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;이완기혈압&#39;&gt; . - 고혈압/당뇨 둘 다 진료내역이 있는 그룹은 이완기혈압이 낮은쪽에서는 이상점이 없다 . - 당뇨만 있거나 둘 다 없는 경우에 두 이완기혈압의 분포는 거의 비슷하다 . - 고혈압만 있거나 둘 다 있는 경우에 두 이완기혈압의 분포는 거의 비슷한데 고혈압만 있는경우가 이완기혈압이 조금 더 높아보인다 . sns.violinplot(x = &#39;고혈압_당뇨_진료내역&#39;, y = &#39;이완기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;이완기혈압&#39;&gt; . - 이완기 혈압도 수축기혈압과 동일한 양상을 보인다 . - 수치를 통해 정확히 확인해보면 다음과 같다 . df.groupby(&#39;고혈압_당뇨_진료내역&#39;)[&#39;이완기혈압&#39;].describe() . count mean std min 25% 50% 75% max . 고혈압_당뇨_진료내역 . 1 53398.0 | 78.366193 | 9.874400 | 50.0 | 70.0 | 80.0 | 84.0 | 120.0 | . 2 162826.0 | 80.040417 | 10.050473 | 50.0 | 72.0 | 80.0 | 86.0 | 120.0 | . 3 43114.0 | 75.679478 | 9.137214 | 50.0 | 70.0 | 76.0 | 80.0 | 120.0 | . 4 740662.0 | 74.673427 | 9.471040 | 50.0 | 70.0 | 75.0 | 80.0 | 120.0 | . - 둘 다 없는 경우보다 당뇨만 있는 경우 이완기혈압의 평균이 1정도 높다 . - 고혈압이 있으면 위의 경우보다 혈압이 평균적으로 4~5정도 높다 . - 신기한건 고혈압만 있는 경우가 고혈압, 당뇨 둘 다 있는 경우보다 사분위수와 평균이 약 2정도 더 크다 . - 결과적으로 보면 당뇨 진료내역 여부는 혈압에 영향을 별로 끼치지 못한다 . - 고혈압 진료내역이 있는 경우 수축기혈압과 이완기 혈압이 높은데 이는 당연하다(고혈압은 혈압이 높은것) . - 그리고 고혈압이 있는 경우가 그렇지 않은 경우보다 혈압이 높은데 수축기혈압의 증가폭(10)이 이완기혈압의 증가폭(5)보다 더 크다 . - 고혈압, 당뇨 진료내역 말고도 연령대별 이완기혈압에 차이가 있을 수 있다 . - 일반적으로 연령대가 높아질수록 이완기혈압이 높아진다고 한다 . - 이를 확인해볼 필요가 있다 . - 수축기혈압때처럼 연령대별 이완기혈압의 중앙값들을 구하고 연령대에 따른 변화를 살펴보도록 하자 . df_mid2 = df.groupby([&#39;연령대&#39;]).agg({&#39;이완기혈압&#39;:np.median}) df_mid2 . 이완기혈압 . 연령대 . 20대초반 70 | . 20대후반 70 | . 30대초반 74 | . 30대후반 75 | . 40대초반 75 | . 40대후반 77 | . 50대초반 78 | . 50대후반 78 | . 60대초반 78 | . 60대후반 78 | . 70대초반 78 | . 75세이상 78 | . plt.figure(figsize = (12, 6)) sns.lineplot(x = &#39;연령대&#39;, y = &#39;이완기혈압&#39;, data = df_mid2) sns.scatterplot(x = &#39;연령대&#39;, y = &#39;이완기혈압&#39;, data = df_mid2, legend = False) . &lt;AxesSubplot:xlabel=&#39;연령대&#39;, ylabel=&#39;이완기혈압&#39;&gt; . - 위 plot을 보면 이완기혈압의 중앙값은 증가함을 알 수 있다 . - 그런데 50대초반부터는 이완기혈압의 중앙값은 78로 동일하다 . - 그리고 30대후반~40대초반에 이완기혈압이 75로 동일하다 . - 중간에 정체하는 구간을 기준으로 나눠봤을 때 구간 전보다 후가 증가폭이 더 크다($5 to 3$) . - 그런데 연령대 말고도 고혈압, 당뇨 진료내역마다 이완기혈압에 차이가 존재한다 . - 연령대별 고혈압, 당뇨 진료내역마다 이완기혈압의 중앙값들을 구하고 연령대에 따른 변화를 살펴보도록 하자 . df_median2 = df.groupby([&#39;연령대&#39;, &#39;고혈압_당뇨_진료내역&#39;])[&#39;이완기혈압&#39;].median().reset_index(name = &#39;이완기혈압&#39;) . plt.figure(figsize = (12, 6)) sns.lineplot(x = &#39;연령대&#39;, y = &#39;이완기혈압&#39;, hue = &#39;고혈압_당뇨_진료내역&#39;, data = df_median2) sns.scatterplot(x = &#39;연령대&#39;, y = &#39;이완기혈압&#39;, hue = &#39;고혈압_당뇨_진료내역&#39;, data = df_median2, legend = False) . &lt;AxesSubplot:xlabel=&#39;연령대&#39;, ylabel=&#39;이완기혈압&#39;&gt; . - 이완기혈압을 연령대별로 라인플랏을 그려봤을땐 감소하는 구간이 없었다 . - 그런데 고혈압, 당뇨 진료내역에 따라 그래프를 나눠그리니 감소하는 구간이 생겼다 . - 위에서 나이가 들수록 이완기혈압이 높아진다고했는데 아니었다보다 . - 공통적으로 30대 후반까지는 이완기혈압 중앙값이 증가한다 . - 그런데 그 이후부터는 고혈압, 당뇨 둘다 없는 경우를 제외하면 이완기혈압 중앙값이 감소한다 . - 중앙값이 문제일수 있으니 평균으로 바꿔 그려보자(문제가 없었다) . - 수축기혈압은 나이가 들수록 증가하는 반면 이완기혈압은 진료내역이 없는 경우를 제외하면 증가하다가 감소한다 . &#49688;&#52629;&#44592;&#54792;&#50517;&#44284; &#51060;&#50756;&#44592;&#54792;&#50517; &#44256;&#52272; . - 위에서 수축기혈압과 이완기혈압의 분포를 살펴봤는데 고혈압 진료내역이 있지만 혈압이 낮은 사람도 있고 고혈압 진료내역이 없지만 혈압이 높은사람도 있었다 . - 고혈압 진료내역이 있지만 혈압이 정상범주안에 있는 사람은 혈압관리가 잘되고 있는것으로 간주할 수 있을 것 같다 . - 이들의 비율을 확인해보자 . - 고혈압은 우리나라 기준 수축기 혈압 140mmHg 이상이거나 이완기 혈압 90mmHg 이상인 경우라고 한다 . - 참고 : http://hqcenter.snu.ac.kr/archives/jiphyunjeon/%EA%B3%A0%ED%98%88%EC%95%95 . - 위에 고혈압 기준을 넘어가는 혈압을 가진 사람들은 고혈압으로 그렇지 않는 사람은 정상혈압으로 간주하자 . - 그런데 수축기혈압, 이완기혈압의 분포를 보면 혈압이 매우 낮은 사람도 존재함을 알 수 있다 . - 이들은 저혈압으로 간주할 수 있을 것 같다 . - 저혈압은 일반적으로 수축기 혈압 90mmHg 미만이거나 이완기 혈압 60mmHg 미만인 경우라고한다 . - 참고 : https://health.kdca.go.kr/healthinfo/biz/health/gnrlzHealthInfo/gnrlzHealthInfo/gnrlzHealthInfoView.do?cntnts_sn=4616 . def f(x, y): if x &gt;= 140 or y &gt;= 90: z = &#39;고혈압&#39; elif x &lt; 90 or y &lt; 60: z = &#39;저혈압&#39; else: z = &#39;정상혈압&#39; return z . df[&#39;혈압범주&#39;] = list(map(f, df[&#39;수축기혈압&#39;], df[&#39;이완기혈압&#39;])) . df.head() . 성별 연령대 수축기혈압 이완기혈압 공복혈당 고혈압_당뇨_진료내역 BMI 혈압범주 . 0 1 | 20대초반 | 116 | 78 | 94 | 4 | 16.6 | 정상혈압 | . 1 1 | 20대초반 | 100 | 60 | 79 | 4 | 22.3 | 정상혈압 | . 2 1 | 20대초반 | 100 | 60 | 87 | 4 | 21.9 | 정상혈압 | . 3 1 | 20대초반 | 111 | 70 | 72 | 4 | 20.2 | 정상혈압 | . 4 1 | 20대초반 | 120 | 80 | 98 | 4 | 20.0 | 정상혈압 | . count = df.groupby(&#39;혈압범주&#39;).size() . plt.pie(x = count, labels = [&#39;고혈압&#39;, &#39;저혈압&#39;, &#39;정상혈압&#39;], autopct = &#39;%.2f%%&#39;) plt.show() . - 정상혈압은 약 84%, 고혈압은 약 14%, 저혈압은 약 3% 이다 . - 저혈압보다는 고혈압이 흔한것같다 . - 고혈압 진료내역이 있는 사람이 약 22%정도였는데 7%p정도 차이가 있다 . tab = pd.crosstab(df[&#39;혈압범주&#39;], df[&#39;고혈압_당뇨_진료내역&#39;]) tab . 고혈압_당뇨_진료내역 1 2 3 4 . 혈압범주 . 고혈압 16318 | 51261 | 5696 | 62049 | . 저혈압 773 | 1518 | 1056 | 23435 | . 정상혈압 36307 | 110047 | 36362 | 655178 | . tab.apply(lambda x: x*100 / sum(x), axis = 0) . 고혈압_당뇨_진료내역 1 2 3 4 . 혈압범주 . 고혈압 30.559197 | 31.482073 | 13.211486 | 8.377506 | . 저혈압 1.447620 | 0.932284 | 2.449320 | 3.164061 | . 정상혈압 67.993183 | 67.585644 | 84.339194 | 88.458433 | . - 위를 보면 고혈압_당뇨 둘 다 없더라도 12%정도는 혈압에 문제가 있는것을 알 수 있다 . - 신기한건 고혈압 진료내역이 있는 경우인데 고혈압 진료내역이 있지만 실제 고혈압인 경우는 약 31%이고 68%는 정상혈압 나머지 1%는 저혈압이다 . tab2 = pd.crosstab(df[&#39;혈압범주&#39;], df[&#39;성별&#39;]) tab2.apply(lambda x: x*100 / sum(x), axis = 0) . 성별 1 2 . 혈압범주 . 고혈압 15.345719 | 11.643353 | . 저혈압 1.360375 | 4.051060 | . 정상혈압 83.293906 | 84.305586 | . - 남자가 여자보다 혈압이 더 높은건 고혈압 환자가 많아서였다 . - 참고로 백만명중 남자는 51% 여자는 49%이다 . &#54792;&#50517;&#48276;&#51452; &#49464;&#48516;&#54868; . - 같은 고혈압이더라도 수축기혈압만 높은지 이완기혈압만 높은지 아니면 둘 다 높은지가 다를것이다 . - 그런데 위와 같이 나누면 이를 구분할 수 없다... . - 게다가 수축기혈압은 고혈압인데 이완기혈압은 저혈압인 경우도 있다고 한다 . - 혈압범주를 세분화시키면 정확도는 올라가지만 편의성이 떨어진다 . - 세분화시킬 필요가 있을지 확인하자 . ref : https://m.health.chosun.com/svc/news_view.html?contid=2018053103892 | . - 일단 혈압범주를 세분화시킨 새로운 컬럼을 만들고 시각화 해보자 . def blood_pressure(x, y): if x &gt;= 140 and y &gt;= 90: z = &#39;HH&#39; elif x &lt; 90 and y &lt; 60: z = &#39;LL&#39; elif x &gt;= 140 and 60 &lt;= y &lt; 90: z = &#39;HN&#39; elif x &gt;= 140 and 60 &gt; y: z = &#39;HL&#39; elif 90 &lt;= x &lt; 140 and 60 &lt;= y &lt; 90: z = &#39;NN&#39; elif 90 &lt;= x &lt; 140 and 60 &gt; y: z = &#39;NL&#39; elif 90 &lt;= x &lt; 140 and y &gt;= 90: z = &#39;NH&#39; elif 90 &gt; x and 90 &lt;= y: z = &#39;LH&#39; elif 90 &gt; x and 60 &lt;= y &lt; 90: z = &#39;LN&#39; return z . - 혈압세부범주를 혈압범주로 치환하면 아래와 같다 . - HH, HN, HL, NH, LH &gt; 고혈압 . - LL, NL, LN &gt; 저혈압 . - NN &gt; 정상혈압 . - 혈압범주에서는 수축기고혈압 + 이완기저혈압이면 고혈압으로 표기했다(하지만 저혈압이기도 함) . - 혈압범주를 나누는 함수내부를 보면 if else문에서 고혈압을 먼저 판단하고 저혈압을 판단해서 그렇다 . - 하지만 혈압세부범주에서는 그럴일은 없다 . - 진료내역별 혈압세부범주를 확인해보자 . df[&#39;혈압세부범주&#39;] = list(map(blood_pressure, df[&#39;수축기혈압&#39;], df[&#39;이완기혈압&#39;])) . df.head() . 성별 연령대 수축기혈압 이완기혈압 공복혈당 고혈압_당뇨_진료내역 BMI 혈압범주 맥압 혈당범주 테스트 혈압세부범주 . 0 1 | 20대초반 | 116 | 78 | 94 | 4 | 16.6 | 정상혈압 | 38 | 정상혈당 | -38 | NN | . 1 1 | 20대초반 | 100 | 60 | 79 | 4 | 22.3 | 정상혈압 | 40 | 정상혈당 | -40 | NN | . 2 1 | 20대초반 | 100 | 60 | 87 | 4 | 21.9 | 정상혈압 | 40 | 정상혈당 | -40 | NN | . 3 1 | 20대초반 | 111 | 70 | 72 | 4 | 20.2 | 정상혈압 | 41 | 정상혈당 | -41 | NN | . 4 1 | 20대초반 | 120 | 80 | 98 | 4 | 20.0 | 정상혈압 | 40 | 정상혈당 | -40 | NN | . tab = pd.crosstab(df[&#39;혈압세부범주&#39;], df[&#39;고혈압_당뇨_진료내역&#39;]) tab . 고혈압_당뇨_진료내역 1 2 3 4 . 혈압세부범주 . HH 6348 | 23684 | 2141 | 28800 | . HL 25 | 44 | 7 | 17 | . HN 8059 | 19684 | 2503 | 16395 | . LL 12 | 37 | 42 | 1443 | . LN 5 | 33 | 24 | 952 | . NH 1886 | 7849 | 1045 | 16837 | . NL 756 | 1448 | 990 | 21040 | . NN 36307 | 110047 | 36362 | 655178 | . tab.apply(lambda x: x*100 / sum(x), axis = 0) . 고혈압_당뇨_진료내역 1 2 3 4 . 혈압세부범주 . HH 11.888086 | 14.545589 | 4.965904 | 3.888413 | . HL 0.046818 | 0.027023 | 0.016236 | 0.002295 | . HN 15.092326 | 12.088978 | 5.805539 | 2.213560 | . LL 0.022473 | 0.022724 | 0.097416 | 0.194826 | . LN 0.009364 | 0.020267 | 0.055666 | 0.128534 | . NH 3.531967 | 4.820483 | 2.423807 | 2.273237 | . NL 1.415783 | 0.889293 | 2.296238 | 2.840702 | . NN 67.993183 | 67.585644 | 84.339194 | 88.458433 | . - 그런데 위에서 확인했듯이 고혈압 진료내역이 있다고 현재도 고혈압인것은 아니다 . - 그러니 혈압범주와 혈압세부범주를 비교해보자 . - 또한 혈압범주를 혈압세부범주로 나눈것이 얼마나 유용할지도 판다하자 . tab2 = pd.crosstab(df[&#39;혈압세부범주&#39;], df[&#39;혈압범주&#39;]) tab2 . 혈압범주 고혈압 저혈압 정상혈압 . 혈압세부범주 . HH 60973 | 0 | 0 | . HL 93 | 0 | 0 | . HN 46641 | 0 | 0 | . LL 0 | 1534 | 0 | . LN 0 | 1014 | 0 | . NH 27617 | 0 | 0 | . NL 0 | 24234 | 0 | . NN 0 | 0 | 837894 | . - 우선 수축기고혈압이면서 이완기저혈압인사람은 93명이다 &gt; 백만명중에 93명이니 무시할만한 수준이다 . - 그리고 수축기저혈압이면서 이완기고혈압인 사람은 없다! . - 또한 혈압범주에서 정상이었으면 혈압세부범주에서도 정상이다 . - 저혈압인 사람중에서 둘다 저혈압인 사람은 적은데 고혈압인 사람중에서 둘다 고혈압인 사람은 50%정도이다 . - 그래서 혈압범주와 혈압세부범주는 얼마나 차이가 있는가? . - 간단히 plot을 통해 확인하자 . sns.violinplot(x = &#39;혈압세부범주&#39;, y = &#39;공복혈당&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;혈압세부범주&#39;, ylabel=&#39;공복혈당&#39;&gt; . sns.violinplot(x = &#39;혈압세부범주&#39;, y = &#39;BMI&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;혈압세부범주&#39;, ylabel=&#39;BMI&#39;&gt; . - 일단 혈압범주나 혈압세부범주를 가지고 수축기혈압이나 이완기혈압의 boxplot등을 그려보는것은 별로 유용하지 않다 . - 왜냐하면 애초애 수축기, 이완기혈압을 통해 혈압범주들을 구했기 때문이다(상관관계 매우큼) . - 또한 수축기혈압과 이완기혈압의 상관계수는 0.7이 넘는다 . - 당연히 고혈압인 사람은 혈압이 높게나오고 저혈압인 사람은 혈압이 낮게 나올것이다 . sns.violinplot(x = &#39;혈압범주&#39;, y = &#39;수축기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;혈압범주&#39;, ylabel=&#39;수축기혈압&#39;&gt; . sns.violinplot(x = &#39;혈압세부범주&#39;, y = &#39;수축기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;혈압세부범주&#39;, ylabel=&#39;수축기혈압&#39;&gt; . sns.violinplot(x = &#39;혈압범주&#39;, y = &#39;이완기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;혈압범주&#39;, ylabel=&#39;이완기혈압&#39;&gt; . sns.violinplot(x = &#39;혈압세부범주&#39;, y = &#39;이완기혈압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;혈압세부범주&#39;, ylabel=&#39;이완기혈압&#39;&gt; . - 그래서 결론은 혈압세부범주는 사용안하고 혈압범주만 사용할것이다 . - 문제가 되었던 고혈압과 저혈압을 둘다 가지고 있지만 혈압범주를 나누는 함수에서 고혈압을 먼저 처리하여 고혈압이 된 사람들은 문제가 없다 . - 왜냐하면 HL인 사람은 93명밖에 없으면 LH인 사람은 0명이기 때문이다 . - 애초애 저혈압인 사람은 3만명도 안되는데 고혈압인 사람은 12만명이 넘는다 . - 정상혈압인 사람은 혈압세부범주에서 NN인 사람으로 동일하다 . - 그리고 저혈압인 경우 HL, NL, LL 총 3가지가 있는데 대부분 HL(90%)이어서 문제 없다 . - 제일 차이가 나는건 고혈압인 경우이다(HH, HN, NH) . - HH인경우가 50%이고 HN은 30%, NH는 20%정도이다 . - 만약 둘다 고혈압인 경우와 하나만 고혈압인 경우가 많이 다르다면 고려할만 하지만 차이가 별로 없다 . - 하지만 위에서 그린 공복혈당, BMI 바이올린플랏을 보면 알수있듯이 거의 차이가 없다 . - 혈압범주를 세분화시킨건 여러개의 봉우리가 생긴원인이 이때문인지 확인하려고 한 것이다 . - 그런데 세분화시켰음에도 이는 동일하다 &gt; 그러니 혈압은 고혈압, 저혈압, 정상혈압으로만 나누자 . - 결론 : 혈압을 세분화시켜도 차이가 거의 없으니 시각화하기 편하게 3가지로만 나눈다 . &#47589;&#50517; . - 수축기혈압과 이완기혈압의 차이를 맥압이라고 하는데 수축기혈압과 이완기혈압 둘다 정상 범주에 속하더라도 맥압이 높다면 건강상에 문제가 있을 수 있다고 한다 . - 성인의 경우 35~45mmHg가 정상범주라고 한다 . - 참고 : http://assinmun.kr/m/page/view.php?no=4162&amp;code=20140925141337_5787&amp;d_code=20140925150830_7887&amp;ds_code= . - 맥압의 분포는 어떻게 되는지 살펴보도록 하겠다 . df[&#39;맥압&#39;] = df[&#39;수축기혈압&#39;] - df[&#39;이완기혈압&#39;] . df.head() . 성별 연령대 수축기혈압 이완기혈압 공복혈당 고혈압_당뇨_진료내역 BMI 혈압범주 혈당범주 맥압 . 0 1 | 20대초반 | 116 | 78 | 94 | 4 | 16.6 | 정상혈압 | 정상혈당 | 38 | . 1 1 | 20대초반 | 100 | 60 | 79 | 4 | 22.3 | 정상혈압 | 정상혈당 | 40 | . 2 1 | 20대초반 | 100 | 60 | 87 | 4 | 21.9 | 정상혈압 | 정상혈당 | 40 | . 3 1 | 20대초반 | 111 | 70 | 72 | 4 | 20.2 | 정상혈압 | 정상혈당 | 41 | . 4 1 | 20대초반 | 120 | 80 | 98 | 4 | 20.0 | 정상혈압 | 정상혈당 | 40 | . sns.histplot(data = df, x = &#39;맥압&#39;, binwidth = 5) . &lt;AxesSubplot:xlabel=&#39;맥압&#39;, ylabel=&#39;Count&#39;&gt; . - 눈에 띄는 봉우리가 2개 보인다(쌍봉 분포) . - 이완기혈압의 히스토그램을 그려봤을 때 봉우리가 2개(70, 80)였는데 10차이이다 . - 맥압의 경우 40과 50부근에 봉우리가 있는데 이역시 10차이이다 . - 맥압은 수축기혈압과 이완기혈압의 차이이므로 이완기혈압에 영향을 당연히 받는다 . - 중요한건 이완기혈압의 분포가 왜 쌍봉 분포인지를 파악하는것이다(나중에) . - 고혈압, 당뇨 진료내역에 따른 박스플랏을 그려보자 . sns.boxplot(x = &#39;고혈압_당뇨_진료내역&#39;, y = &#39;맥압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;맥압&#39;&gt; . - 고혈압, 당뇨 진료내역에 따른 수축기혈압, 이완기혈압 분포를 확인했을땐 당뇨병만 진료내역이 있는 경우와 둘 다 없는 경우의 분포가 비슷했는데 맥압의 경우는 다르다 . sns.violinplot(x = &#39;고혈압_당뇨_진료내역&#39;, y = &#39;맥압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;맥압&#39;&gt; . - 고혈압 진료내역이 있지만 현재는 혈압이 정상범주에 속해있을 수 도 있다 . - 그러니 고혈압, 당뇨 진료내역의 따른 맥압의 분포말고 건강검진을 받았을 당시의 혈압으로 구분하자 . - 혈압이 정상범주인 경우의 맥압의 분포와 그렇지 않은 경우 맥압의 분포를 비교해보자 . sns.violinplot(x = &#39;혈압범주&#39;, y = &#39;맥압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;혈압범주&#39;, ylabel=&#39;맥압&#39;&gt; . - 저혈압의 경우 종모양을 띄고있다 . - 고혈압의 경우 눈에띄는 봉우리가 4개정도 보인다 . - 바이올린플랏을 보면 정상혈압에서 유달리 눈에띄는 2개의 봉우리를 볼 수 있는데 이 때문에 맥압이 쌍봉분포의 형태를 띄는것으로 보인다 . - 고혈압인 경우 맥압이 정상혈압, 저혈압인 경우보다 높다 . - 혈압이 오르면 수축기혈압의 상승폭이 이완기혈압의 상승폭보다 높다고 해석할 수 있다(수축기혈압이 이완기혈압보다 편차가 더 컸었다) . - 한편 위의 출처에 나와있는 설명을 보면 나이가 들어감에따라 맥압이 높아진다고 한다 . - 연령대에 따른 박스플랏을 그려보자 . plt.figure(figsize = (12, 6)) sns.boxplot(x = &#39;연령대&#39;, y = &#39;맥압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;연령대&#39;, ylabel=&#39;맥압&#39;&gt; . - 연령대가 높아질수록 평균 맥압은 증가하는것으로 보인다 . plt.figure(figsize = (12, 6)) sns.violinplot(x = &#39;연령대&#39;, y = &#39;맥압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;연령대&#39;, ylabel=&#39;맥압&#39;&gt; . - 해볼것 : 연령대를 50대초반 or 60대초반을 기준으로 나누고 맥압분포 확인하기 . sns.boxplot(x = &#39;성별&#39;, y = &#39;맥압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;성별&#39;, ylabel=&#39;맥압&#39;&gt; . sns.violinplot(x = &#39;성별&#39;, y = &#39;맥압&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;성별&#39;, ylabel=&#39;맥압&#39;&gt; . df.groupby(&#39;성별&#39;)[&#39;맥압&#39;].describe() . count mean std min 25% 50% 75% max . 성별 . 1 510227.0 | 46.664977 | 9.35818 | 8.0 | 40.0 | 46.0 | 51.0 | 130.0 | . 2 489773.0 | 45.478534 | 10.20447 | 4.0 | 40.0 | 44.0 | 50.0 | 140.0 | . - 남자인 경우 여자인 경우보다 평균적으로 수축기혈압이 5정도 높았고 이완기혈압은 4정도 높았는데 맥압의 경우는 1정도 차이가 난다 . - 수축기혈압(5) - 이완기혈압(4) = 맥압(1) . - 우선 혈압은 여기까지 살펴보고 공복혈당의 분포를 확인하자 . &#44277;&#48373;&#54792;&#45817; . sns.histplot(data = df, x = &#39;공복혈당&#39;, binwidth = 5) . &lt;AxesSubplot:xlabel=&#39;공복혈당&#39;, ylabel=&#39;Count&#39;&gt; . - 오른쪽으로 꼬리가 긴 분포이다 . - 성별에 따라 공복혈당이 다른지 확인해보자 . sns.violinplot(x = &#39;성별&#39;, y = &#39;공복혈당&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;성별&#39;, ylabel=&#39;공복혈당&#39;&gt; . df.groupby(&#39;성별&#39;)[&#39;공복혈당&#39;].describe() . count mean std min 25% 50% 75% max . 성별 . 1 510227.0 | 101.141925 | 24.891629 | 60.0 | 88.0 | 96.0 | 106.0 | 358.0 | . 2 489773.0 | 96.491818 | 20.538645 | 60.0 | 86.0 | 93.0 | 101.0 | 358.0 | . - 성별에 따라 공복혈당은 비슷해보인다 수치로 확인하자 . - 남자가 여자보다 공복혈당이 평균 5정도 높고 표준편차가 4정도 높다 . - 혈압과 혈당을 보면 남자가 여자보다 살짝 높은정도를 제외하면 차이가 없다 . - $ text{남자} = text{여자} + alpha$ 와 같이 어느 한쪽으로 나머지를 나타낼 수 있어 보인다 . - 이제껏 분석한 내용을 보면 성별은 그다지 중요한 정보가 아닌것같으니 편의상 제외하자 . - 고혈압_당뇨 진료내역에 따른 공복혈당의 분포를 확인하자 . sns.boxplot(x = &#39;고혈압_당뇨_진료내역&#39;, y = &#39;공복혈당&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;공복혈당&#39;&gt; . sns.violinplot(x = &#39;고혈압_당뇨_진료내역&#39;, y = &#39;공복혈당&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;공복혈당&#39;&gt; . df.groupby(&#39;고혈압_당뇨_진료내역&#39;)[&#39;공복혈당&#39;].describe() . count mean std min 25% 50% 75% max . 고혈압_당뇨_진료내역 . 1 53398.0 | 130.447114 | 40.524698 | 60.0 | 104.0 | 122.0 | 145.0 | 358.0 | . 2 162826.0 | 99.671023 | 16.816511 | 60.0 | 90.0 | 97.0 | 106.0 | 351.0 | . 3 43114.0 | 134.759892 | 45.923753 | 60.0 | 104.0 | 124.0 | 151.0 | 358.0 | . 4 740662.0 | 94.320677 | 15.557456 | 60.0 | 86.0 | 93.0 | 100.0 | 358.0 | . - 4개의 분포 모두 공복혈당이 큰 쪽에 이상점이 매우 많다 . - 고혈압, 당뇨 둘 다 진료내역이 있는 경우와 당뇨 진료내역이 있는 경우의 분포는 당뇨만 있는 경우가 조금 더 넓게 퍼진것을 빼면 동일하다 . - 분포의 중심은 125인것으로 보인다 . - 고혈압, 당뇨 둘 다 진료내역이 없는 경우와 고혈압만 있는 경우의 분포는 고혈압만 있는 경우가 조금 더 넓게 퍼진것을 빼면 동일하다 . - 분포의 중심은 95인것으로 보인다 . - 당뇨가 있다면 공복혈당이 평균적으로 30정도 높다 . - 위의 그림을 통해 공복혈당의 분포는 당뇨병의 진료내역이 좌지우지하는것으로 보인다(고혈압 진료내역은 거의 영향을 끼치지 못함) . sns.boxplot(x = &#39;혈압범주&#39;, y = &#39;공복혈당&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;혈압범주&#39;, ylabel=&#39;공복혈당&#39;&gt; . sns.violinplot(x = &#39;혈압범주&#39;, y = &#39;공복혈당&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;혈압범주&#39;, ylabel=&#39;공복혈당&#39;&gt; . - 고혈압인 경우 공복혈당이 고혈압이 아닌경우보다 더 높은것으로 보인다 . - 고혈압이 있는 사람들중 공복혈당이 높은 사람이 많다 . &#44277;&#48373;&#54792;&#45817; &#44256;&#52272; . - 위에서 공복혈당 분포를 살펴봤는데 당뇨 진료내역이 있지만 공복혈당이 낮은 사람도 있고 당뇨 진료내역이 없지만 공복혈당이 높은사람도 있었다 . - 당뇨 진료내역이 있지만 공복혈당이 정상범주안에 있는 사람은 혈당조절을 잘하고 있는것으로 간주할 수 있을 것 같다 . - 이들의 비율을 확인해보자 . - 당뇨병의 진단에 있어 혈당치의 기준은 공복 혈당치 126 mg/dL 이상(고혈당)이라고 한다 . - 참고 : https://www.diabetes.or.kr/general/class/index.php?idx=5 . - 위에서 기준을 넘어가는 혈당을 가진 사람들은 고혈당으로 그렇지 않는 사람은 정상혈당으로 간주하자 . - 공복혈당이 너무 낮으면(60 mg/dL이하) 저혈당으로 간주하나 거의 최소값이 60 mg/dL임으로 무시하자 . def g(x): if x &gt;= 126: y = &#39;고혈당&#39; else: y = &#39;정상혈당&#39; return y . df[&#39;혈당범주&#39;] = list(map(g, df[&#39;공복혈당&#39;])) . df.head() . 성별 연령대 수축기혈압 이완기혈압 공복혈당 고혈압_당뇨_진료내역 BMI 혈압범주 혈당범주 . 0 1 | 20대초반 | 116 | 78 | 94 | 4 | 16.6 | 정상혈압 | 정상혈당 | . 1 1 | 20대초반 | 100 | 60 | 79 | 4 | 22.3 | 정상혈압 | 정상혈당 | . 2 1 | 20대초반 | 100 | 60 | 87 | 4 | 21.9 | 정상혈압 | 정상혈당 | . 3 1 | 20대초반 | 111 | 70 | 72 | 4 | 20.2 | 정상혈압 | 정상혈당 | . 4 1 | 20대초반 | 120 | 80 | 98 | 4 | 20.0 | 정상혈압 | 정상혈당 | . count = df.groupby(&#39;혈당범주&#39;).size() . plt.pie(x = count, labels = [&#39;고혈당&#39;, &#39;정상혈당&#39;], autopct = &#39;%.2f%%&#39;) plt.show() . - 정상혈당은 약 93%, 고혈당은 약 7% 이다 . tab = pd.crosstab(df[&#39;혈당범주&#39;], df[&#39;고혈압_당뇨_진료내역&#39;]) tab.apply(lambda x: x*100 / sum(x), axis = 0) . 고혈압_당뇨_진료내역 1 2 3 4 . 혈당범주 . 고혈당 44.911794 | 5.178534 | 47.938025 | 2.412976 | . 정상혈당 55.088206 | 94.821466 | 52.061975 | 97.587024 | . - 위를 보면 고혈압_당뇨 둘 다 없는경우 2.5%정도는 혈당에 문제가 있는것을 알 수 있다 . - 앞서 봤던 고혈압(12%)에 비하면 매우 적은 수치이다 . - 고혈압만 있는 경우 고혈당인 경우는 5%정도로 고혈압 당뇨 둘다 없는경우와 비슷한 수치이다 . - 당뇨 진료내역이 있는 경우 고혈당인 경우는 47%정도이다 . - 고혈압 진료내역이 있는 경우 고혈압인 경우는 31%정도였다 . - 이와 비교하면 고혈압에서 정상혈압에 속하는 것보다 고혈당에서 정상혈당에 속하는것이 흔치않음을 알 수 있다 . - 전체 인구를 혈압, 혈당에 따라 나타내 확인하자 . tab = pd.crosstab(df[&#39;혈압범주&#39;], df[&#39;혈당범주&#39;]) tab*100 / 1000000 . 혈당범주 고혈당 정상혈당 . 혈압범주 . 고혈압 1.7877 | 11.7447 | . 저혈압 0.0918 | 2.5864 | . 정상혈압 5.2159 | 78.5735 | . - 전체 중 고혈당은 8%, 고혈압은 12%이다 . - 혈압, 혈당 모두 정상인 사람은 78%이다 . - 결론 : 당뇨가 고혈압보다 흔하며 당뇨인 사람중 고혈압인 비율보다 고혈압인 사람중 당뇨인 비율이 더 낮다 . &#54792;&#50517;, &#54792;&#45817; &#48276;&#51452; vs &#44256;&#54792;&#50517;, &#45817;&#45544; &#51652;&#47308;&#45236;&#50669; . - 한가지 의문점이 든다 . - 위에서 봤듯이 고혈압, 당뇨 진료내역이 있다고 현재도 고혈압, 당뇨인것은 아니다 . - 그러면 고혈압, 당뇨 진료내역은 쓸모있는지가 의문이다 . - 그냥 혈압, 혈당 범주로 대체하면 될것같다 . - 고혈압, 당뇨 진료내역에 따라 수축기혈압에 차이가 있었다 . - 그런데 이 차이가 그냥 고혈압에 의한것이라면?? . - 나는 고혈압 진료내역이 있으면 혈압이 정상범주더라도 높은쪽에 위치할것이라 생각했다 . - 이것이 틀리다면 굳이 애매모호한 고혈압 진료내역 대신에 혈압범주를 사용하는것이 좋을것이다(당뇨도 마찬가지) . - 그런데 고혈압 진료내역만 있는 사람중 31%만 고혈압이다...(당뇨도 비슷하다) . - 게다가 여태까지 시각화한 plot을 보면 혈압에는 당뇨가 영향을 거의 못끼치며 혈당에는 고혈압이 영향을 거의 끼치지 못한다 . - 그러니 앞으로는 고혈압, 당뇨 진료내역 대신 혈압, 혈당 범주를 통해 시각화하자 . - 아...... . - 아니었다 . sns.boxplot(data =df.query(&#39;혈압범주 == &quot;정상혈압&quot;&#39;), y = &#39;수축기혈압&#39;, x = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;수축기혈압&#39;&gt; . sns.boxplot(data =df.query(&#39;혈압범주 == &quot;고혈압&quot;&#39;), y = &#39;수축기혈압&#39;, x = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;수축기혈압&#39;&gt; . sns.boxplot(data =df.query(&#39;혈압범주 == &quot;저혈압&quot;&#39;), y = &#39;수축기혈압&#39;, x = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;수축기혈압&#39;&gt; . sns.boxplot(data =df.query(&#39;혈압범주 == &quot;정상혈압&quot;&#39;), y = &#39;이완기혈압&#39;, x = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;이완기혈압&#39;&gt; . sns.boxplot(data =df.query(&#39;혈압범주 == &quot;고혈압&quot;&#39;), y = &#39;이완기혈압&#39;, x = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;이완기혈압&#39;&gt; . sns.boxplot(data =df.query(&#39;혈압범주 == &quot;저혈압&quot;&#39;), y = &#39;이완기혈압&#39;, x = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;이완기혈압&#39;&gt; . sns.boxplot(data =df.query(&#39;혈압범주 == &quot;고혈압&quot;&#39;), y = &#39;맥압&#39;, x = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;맥압&#39;&gt; . sns.boxplot(data =df.query(&#39;혈압범주 == &quot;정상혈압&quot;&#39;), y = &#39;맥압&#39;, x = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;맥압&#39;&gt; . sns.boxplot(data =df.query(&#39;혈압범주 == &quot;저혈압&quot;&#39;), y = &#39;맥압&#39;, x = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;맥압&#39;&gt; . sns.lineplot(data =df.query(&#39;혈압범주 == &quot;정상혈압&quot;&#39;), y = &#39;수축기혈압&#39;, x = &#39;연령대&#39;, hue = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;연령대&#39;, ylabel=&#39;수축기혈압&#39;&gt; . sns.lineplot(data =df.query(&#39;혈압범주 == &quot;정상혈압&quot;&#39;), y = &#39;이완기혈압&#39;, x = &#39;연령대&#39;, hue = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;연령대&#39;, ylabel=&#39;이완기혈압&#39;&gt; . sns.boxplot(data =df.query(&#39;혈당범주 == &quot;고혈당&quot;&#39;), y = &#39;공복혈당&#39;, x = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;공복혈당&#39;&gt; . sns.boxplot(data =df.query(&#39;혈당범주 == &quot;정상혈당&quot;&#39;), y = &#39;공복혈당&#39;, x = &#39;고혈압_당뇨_진료내역&#39;) . &lt;AxesSubplot:xlabel=&#39;고혈압_당뇨_진료내역&#39;, ylabel=&#39;공복혈당&#39;&gt; . - 위 plot들을 보면 진료내역이 영향을 끼치는것으로 보인다 . - 예컨대 현재 정상혈압 범주안에 들더라도 고혈압 진료내역이 있으면 혈압이 비교적 높다(당뇨도 마찬가지) . - 이제 BMI의 분포를 확인하자 . BMI . sns.histplot(data = df, x = &#39;BMI&#39;, hue = &#39;성별&#39;, bins = 30) . &lt;AxesSubplot:xlabel=&#39;BMI&#39;, ylabel=&#39;Count&#39;&gt; . - 종모양인 것 같지만 오른쪽으로 꼬리가 조금 길다 . - BMI도 다른 양적변수와 마찬가지로 남자가 여자보다 조금 더 높은것을 제외하면 동일하다 . - 수축기혈압과 이완기혈압의 경우는 혈압범주에 따라 박스플랏을 그리는것과 같은 시각화를 하지 않았다 . - 왜냐면 혈압범주를 나눈기준이 혈압(수축기, 이완기)이기에 당연히 고혈압은 수축기혈압이 높고 저혈압은 수축기혈압이 낮기 때문이고 이는 이완기혈압 그리고 당뇨와 공복혈당 경우에도 동일하다 . - 하지만 BMI는 그렇지 않으니 BMI의 분포를 혈압범주, 혈당범주에 따라 시각화해보자 . sns.boxplot(x = &#39;혈압범주&#39;, y = &#39;BMI&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;혈압범주&#39;, ylabel=&#39;BMI&#39;&gt; . df.groupby(&#39;혈압범주&#39;)[&#39;BMI&#39;].describe() . count mean std min 25% 50% 75% max . 혈압범주 . 고혈압 135324.0 | 25.242038 | 3.448873 | 14.8 | 22.9 | 25.0 | 27.3 | 40.3 | . 저혈압 26782.0 | 21.835046 | 2.736182 | 14.8 | 19.9 | 21.6 | 23.5 | 38.0 | . 정상혈압 837894.0 | 23.634720 | 3.213817 | 14.8 | 21.4 | 23.4 | 25.6 | 40.3 | . - 고혈압은 정상혈압보다 BMI가 평균적으로 1.6 크다 . - 정상혈압은 저혈압보다 BMI가 평균적으로 1.8 크다 . sns.boxplot(x = &#39;혈당범주&#39;, y = &#39;BMI&#39;, data = df) . &lt;AxesSubplot:xlabel=&#39;혈당범주&#39;, ylabel=&#39;BMI&#39;&gt; . df.groupby(&#39;혈당범주&#39;)[&#39;BMI&#39;].describe() . count mean std min 25% 50% 75% max . 혈당범주 . 고혈당 70954.0 | 25.168695 | 3.396526 | 14.8 | 22.9 | 24.9 | 27.1 | 40.3 | . 정상혈당 929046.0 | 23.699806 | 3.266234 | 14.8 | 21.4 | 23.5 | 25.7 | 40.3 | . - 고혈당인 경우 정상혈당보다 BMI가 평균적으로 1.5정도 크다 . - 여기까지 개별 양적변수에 대한 분포를 확인했다 . - 그런데 수축기혈압과 이완기혈압같이 두 변수사이에 관계가 있을 수 있다 . - 그렇기에 산점도를 그려 변수사이에 관계를 확인해보자 . &#46160; &#48320;&#49688;&#51032; &#49884;&#44033;&#54868; . &#49345;&#44288;&#44288;&#44228; &#54665;&#47148; . - 우선 양적변수간의 상관관계 행렬을 그려보자 . corr_df = df.loc[:, (&#39;수축기혈압&#39;, &#39;이완기혈압&#39;, &#39;맥압&#39;, &#39;공복혈당&#39;, &#39;BMI&#39;)] . corr_matrix = corr_df.corr(method = &#39;pearson&#39;) # 상관관계 행렬 . corr_matrix . 수축기혈압 이완기혈압 맥압 공복혈당 BMI . 수축기혈압 1.000000 | 0.743006 | 0.743398 | 0.186501 | 0.304383 | . 이완기혈압 0.743006 | 1.000000 | 0.104699 | 0.138717 | 0.275492 | . 맥압 0.743398 | 0.104699 | 1.000000 | 0.138498 | 0.176977 | . 공복혈당 0.186501 | 0.138717 | 0.138498 | 1.000000 | 0.173688 | . BMI 0.304383 | 0.275492 | 0.176977 | 0.173688 | 1.000000 | . sns.heatmap(corr_matrix, annot = True, cbar = False) . &lt;AxesSubplot:&gt; . - 수축기혈압과 이완기혈압은 상관계수가 0.74로 높다 . - 혈압과 혈당끼리는 상관관계가 강하지 않다 . - BMI와 혈압과는 약한 양의 상관관계가 있다 . - BMI는 혈당보다는 혈압에 영향을 더 받는다 . - 신기한게 맥압은 수축기혈압과 이완기혈압의 차이여서 이완기혈압과의 상관관계가 당연히 크다고 생각했는데 아니었다 . - 맥압과 이완기혈압의 상관계수는 0.1이다(서로 상관이 없는 수준이다) . - 그런데 맥압 = 수축기혈압 - 이완기혈압이니 유의한 변수는 아니다 . - 이제 두 변수 사이의 관계를 시각화하자 . def jitter(values, i): return values + np.random.normal(i, 0.5, len(values)) . sns.scatterplot(x = jitter(df.수축기혈압, 1), y = jitter(df.이완기혈압, 1), alpha = 0.01, s = 20) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;이완기혈압&#39;&gt; . - 문제가 있는데 관측치(점의 개수)가 너무 많아 시각화가 제대로 되지 않는다 . - 전체의 1%(10000개) 정도만 무작위 추출하여 산점도를 그려보자 . - 참고 : https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sample.html . np.random.seed(2021) df_s = df.sample(frac = 0.01) . ft = df_s[&#39;고혈압_당뇨_진료내역&#39;].value_counts() rft = df_s[&#39;고혈압_당뇨_진료내역&#39;].value_counts() / len(df_s[&#39;고혈압_당뇨_진료내역&#39;]) DIS_table2 = pd.DataFrame({&#39;Freq&#39;: ft, &#39;Relative freq&#39;: rft}) DIS_table2 . Freq Relative freq . 4 7336 | 0.7336 | . 2 1664 | 0.1664 | . 1 560 | 0.0560 | . 3 440 | 0.0440 | . - 원본과 비율이 거의 동일하다 . - 새로운 데이터프레임을 사용해 시각화하자 . &#49688;&#52629;&#44592;&#54792;&#50517;&#44284; &#51060;&#50756;&#44592;&#54792;&#50517; . sns.scatterplot(x = &#39;수축기혈압&#39;, y = &#39;이완기혈압&#39;, alpha = 0.2, s = 20, data = df_s) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;이완기혈압&#39;&gt; . - 수축기혈압은 90~140, 이완기 혈압은 60~90사이에 데이터가 많이 몰려있다 . - 사실 시각화의 목적은 고혈압_당뇨 진료내역에 따른 사람들의 특성을 알고싶은 것이었다 . - 그렇기에 고혈압_당뇨 진료내역을 색깔변수로 하여 산점도를 그려보자 . Test . - 정상인들은 분석에서 제외할까?? . - 정상인은 솔직히 안궁금함 . - 문제점알았다 &gt; 그래프 겁나 작다 지금보니까 사이즈 키워야됨 . - 문제점2 : 어케 할지 모르겠다 . - 그리고 투명도는 변수로 설정을 못함.. . markers = {1:&#39;.&#39;, 2:&#39;X&#39;} sns.scatterplot(x = &#39;수축기혈압&#39;, y = &#39;이완기혈압&#39;, style = &#39;성별&#39;, markers = markers, palette = &#39;deep&#39;, s = 50, alpha = 0.2, data = df_s) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;이완기혈압&#39;&gt; . palette2 = [&#39;steelblue&#39;,&#39;darkorange&#39;] sns.scatterplot(x = &#39;수축기혈압&#39;, y = &#39;이완기혈압&#39;, hue = &#39;혈압범주&#39;,size=&#39;BMI&#39;,alpha = 0.2, data = df_s) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;이완기혈압&#39;&gt; . sns.scatterplot(x = &#39;수축기혈압&#39;, y = &#39;이완기혈압&#39;, hue = &#39;혈당범주&#39;,size=&#39;BMI&#39;, alpha = 0.2, data = df_s) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;이완기혈압&#39;&gt; . - 혈당범주문제점 7%만 당뇨라 그래프상에서 눈에 안띔 . sns.scatterplot(x = &#39;수축기혈압&#39;, y = &#39;이완기혈압&#39;, hue = &#39;혈당범주&#39;,size=&#39;BMI&#39;, alpha = 0.2, data = df_s) . sns.lmplot(x = &#39;수축기혈압&#39;, y = &#39;이완기혈압&#39;, hue = &#39;고혈압_당뇨_진료내역&#39;, scatter_kws = {&#39;alpha&#39;:0.5, &#39;s&#39;:20}, height = 7, data = df_s) . &lt;seaborn.axisgrid.FacetGrid at 0x23db4144220&gt; . sns.lmplot(x = &#39;공복혈당&#39;, y = &#39;BMI&#39;, hue = &#39;혈압범주&#39;, scatter_kws = {&#39;alpha&#39;:0.3, &#39;s&#39;:20}, height = 7, data = df_s) . &lt;seaborn.axisgrid.FacetGrid at 0x23db46aef70&gt; . sns.lmplot(x = &#39;이완기혈압&#39;, y = &#39;맥압&#39;, hue = &#39;혈압범주&#39;, scatter_kws = {&#39;alpha&#39;:0.3, &#39;s&#39;:20}, height = 7, data = df_s) . &lt;seaborn.axisgrid.FacetGrid at 0x23da727d640&gt; . sns.scatterplot(x = &#39;이완기혈압&#39;, y = &#39;맥압&#39;, hue = &#39;혈압범주&#39;, alpha=0.3,s=20, data = df_s) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;맥압&#39;&gt; . sns.lmplot(x = &#39;수축기혈압&#39;, y = &#39;맥압&#39;, hue = &#39;혈압범주&#39;, scatter_kws = {&#39;alpha&#39;:0.3, &#39;s&#39;:20}, height = 7, data = df_s) . &lt;seaborn.axisgrid.FacetGrid at 0x23da18d7940&gt; . sns.lmplot(x = &#39;수축기혈압&#39;, y = &#39;BMI&#39;, hue = &#39;혈압범주&#39;, scatter_kws = {&#39;alpha&#39;:0.3, &#39;s&#39;:20}, height = 7, data = df_s) . &lt;seaborn.axisgrid.FacetGrid at 0x23d8e04aa30&gt; . sns.lmplot(x = &#39;맥압&#39;, y = &#39;공복혈당&#39;, hue = &#39;혈압범주&#39;, scatter_kws = {&#39;alpha&#39;:0.3, &#39;s&#39;:20}, height = 7, data = df_s) . &lt;seaborn.axisgrid.FacetGrid at 0x23db495b430&gt; . sns.lmplot(x = &#39;수축기혈압&#39;, y = &#39;BMI&#39;, hue = &#39;혈당범주&#39;, scatter_kws = {&#39;alpha&#39;:0.3, &#39;s&#39;:20}, height = 7, data = df_s) . &lt;seaborn.axisgrid.FacetGrid at 0x23db78d5760&gt; . test . - 양적 변수 히스토그램 그릴 때 성별에 따라 나눠서 볼꺼면 히스토그램 색깔로 구별하는게 3배는 나은듯 . sns.histplot(data = df, x = &#39;이완기혈압&#39;, bins = 30) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;고혈압&quot;&#39;), x = &#39;이완기혈압&#39;, bins = 30) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 고혈압 환자는 90부근에 몰려있음(43000명 정도) , 70부근은 거의 없고 80부근에는 18000명정도 . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;&#39;), x = &#39;이완기혈압&#39;, bins = 30) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 이완기혈압이 70, 80에 몰려있는것은 대부분 정상혈압을 가진사람들에 의한것 . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 이완기혈압 &lt; 75&#39;), x = &#39;이완기혈압&#39;,bins = 15) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 이완기혈압 &gt;= 75&#39;), x = &#39;이완기혈압&#39;,bins = 15) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 이완기혈압 &lt; 75&#39;), x = &#39;수축기혈압&#39;,bins = 15) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 이완기혈압 &gt;= 75&#39;), x = &#39;수축기혈압&#39;,bins = 15) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 이완기혈압은 70과 80에서 최빈값을 가진다 . - 정상혈압인 사람을 이완기혈압 75를 기준으로 나눴다(70, 80을 비교하려고) . - 이완기혈압이 75보다 작은 사람들은 수축기혈압 110에서 최빈값을 가진다 . - 이완기혈압이 75보다 큰 사람들은 수축기혈압 120, 130에서 최빈값을 가진다 . - 이완기혈압 75보다 작은 사람들의 수축기혈압분포는 종모양(단봉분포)으로 110에서 최빈값을 가진다 . - 이완기혈압이 75보다 큰 사람들의 수축기혈압분포는 쌍봉분포로 120과 130에서 봉우리를 가진다 . - 즉 이완기혈압이 70과 80에서 봉우리를 가진건 수축기혈압과 관계가 있다 . - 정상혈압인 사람중에서 이완기혈압이 70인 사람들의 수축기혈압은 110을 기준으로 종모양 . - 정상혈압인 사람중에서 이완기혈압이 70보다 10 더 높은 80인 사람들의 수축기혈압은 쌍봉분포 . - 수축기혈압이 왜 쌍봉분포인지는 더 살펴볼필요가 있음 . - 예컨대 나이때문에 차이가 있을 수 있다 . - 물론 이완기혈압이 쌍봉분포인것은 나이때문이 아니었지만... . - 수축기혈압은 110, 120, 130에서 봉우리를 가진다 . - 110인 경우는 이완기혈압이 70인 경우이고 120, 130인 경우는 이완기혈압이 80인 경우이다 . - 정상혈압을 가진사람들의 수축기혈압와 이완기혈압의 분포는 각각 중심이 110, 70인 종모양인 분포라고 해석할 수 있다 . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 이완기혈압 &lt; 75&#39;), x = &#39;맥압&#39;,bins = 15) . &lt;AxesSubplot:xlabel=&#39;맥압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 이완기혈압 &gt;= 75&#39;), x = &#39;맥압&#39;,bins = 15) . &lt;AxesSubplot:xlabel=&#39;맥압&#39;, ylabel=&#39;Count&#39;&gt; . b = sns.FacetGrid(data = df, row = &#39;연령대&#39;, height = 7) b.map(sns.histplot, &#39;수축기혈압&#39;, kde = False, bins = 30, color = &#39;gray&#39;) . &lt;seaborn.axisgrid.FacetGrid at 0x1c386dfa880&gt; . sns.histplot(data = df, x = &#39;BMI&#39;, hue = &#39;성별&#39;, binwidth = 0.5) . &lt;AxesSubplot:xlabel=&#39;BMI&#39;, ylabel=&#39;Count&#39;&gt; . - 성별에 따라 그려보니 차이가 확연함!! . - 이완기혈압, 수축기혈압 분포의 봉우리도 성별때문일 수 있겠음 . - 남자(24)가 여자(21.5)보다 BMI가 더 크다 . sns.histplot(data = df, x = &#39;이완기혈압&#39;, hue = &#39;성별&#39;, binwidth = 2) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 이완기혈압이 남자는 70보다 80부근에 더 많고 여자는 반대의 경향이다 . - 그리고 60부근은 남자(40000)가 여자(20000)의 2배이다 . sns.histplot(data = df, x = &#39;수축기혈압&#39;, hue = &#39;성별&#39;, binwidth = 5) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df, x = &#39;BMI&#39;, binwidth = 1) . &lt;AxesSubplot:xlabel=&#39;BMI&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 이완기혈압 &gt;= 75&#39;), x = &#39;BMI&#39;, hue = &#39;성별&#39;, binwidth = 1) . &lt;AxesSubplot:xlabel=&#39;BMI&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 이완기혈압 &lt; 75&#39;), x = &#39;BMI&#39;, hue = &#39;성별&#39;, binwidth = 1) . &lt;AxesSubplot:xlabel=&#39;BMI&#39;, ylabel=&#39;Count&#39;&gt; . - 이완기혈압이 75보다 작은 사람들과 큰 사람들과의 BMI 분포 최빈값의 차이는 1정도이다(22, 23) . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 수축기혈압&gt;= 115&#39;), x = &#39;BMI&#39;, hue = &#39;성별&#39;, binwidth = 1) . &lt;AxesSubplot:xlabel=&#39;BMI&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 수축기혈압&gt;= 125&#39;), x = &#39;BMI&#39;, hue = &#39;성별&#39;, binwidth = 1) . &lt;AxesSubplot:xlabel=&#39;BMI&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 125&gt;=수축기혈압&gt;= 115&#39;), x = &#39;BMI&#39;, hue = &#39;성별&#39;, binwidth = 1) . &lt;AxesSubplot:xlabel=&#39;BMI&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 105&lt;수축기혈압&lt; 115&#39;), x = &#39;BMI&#39;, hue = &#39;성별&#39;, binwidth = 1) . &lt;AxesSubplot:xlabel=&#39;BMI&#39;, ylabel=&#39;Count&#39;&gt; . - 성별에 따라 차이가 심하네... . - 이게 처음에 성별에 따른 고혈압 확인했을 때 차이가 있었는데 이 때문인듯 . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 이완기혈압 &gt;= 75&#39; ), x = &#39;수축기혈압&#39;, hue = &#39;성별&#39;, binwidth = 3) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 수축기혈압이 120과 130에서 최빈값을 가지는건 성별때문은 아닌듯 . - 남자 여자 둘 다 120, 130에서 최빈값을 가짐 . - 물론 남자의 경우 평균 1.5배 count가 더 많긴 하다 . - 수축기혈압이 120, 130에서 봉우리를 가지는건 이완기혈압이 80부근에서 봉우리를 가져서이다 . - 수축기혈압이 120과 130에서 봉우리를 가진다 &gt; 이완기혈압이 75보다 작은 사람중에서 남자가 더 많다 . - 이완기혈압이 75보다 낮은 남자 중에서 BMI가 23~24인 경우 수축기혈압 130에 22~23인 경우 수축기혈압 120에 기여를 한다 . - BMI 1차이가 수축기혈압 10의 차이? . - 그럼 BMI 작은 사람은 수축기혈압도 작냐? . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot; and 105&lt;수축기혈압&lt; 115&#39;), x = &#39;BMI&#39;, hue = &#39;성별&#39;, binwidth = 1) . &lt;AxesSubplot:xlabel=&#39;BMI&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;and 성별==1 and 125&lt;수축기혈압 &lt;135&#39; ), x = &#39;이완기혈압&#39; ,binwidth = 3) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 수축기혈압 130 부근에 몰린 사람들은 이완기혈압이 80 부근에 몰린다 . - 70부근에는 별로 없다 . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;and 성별==1 and 115&lt;수축기혈압 &lt;125&#39; ), x = &#39;이완기혈압&#39; ,binwidth = 3) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 수축기혈압 130 부근에 몰린 사람들은 이완기혈압이 80 부근에 몰린다 . - 70부근에는 2번째로 많다 . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;and 성별==1 and 115&lt;수축기혈압 &lt;125&#39; ), x = &#39;이완기혈압&#39;, hue =&#39;혈당범주&#39; ,binwidth = 2) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;and 성별==1 and 125&lt;수축기혈압 &lt;135 and 고혈압_당뇨_진료내역==4&#39; ), x = &#39;이완기혈압&#39; ,binwidth = 2) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;and 성별==1 and 115&lt;수축기혈압 &lt;125 and 고혈압_당뇨_진료내역==4&#39; ), x = &#39;이완기혈압&#39; ,binwidth = 2) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;and 성별==1 and 115&lt;수축기혈압 &lt;125 and 고혈압_당뇨_진료내역==4&#39; ), x = &#39;맥압&#39; ,binwidth = 2) . &lt;AxesSubplot:xlabel=&#39;맥압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;and 성별==1 and 125&lt;수축기혈압 &lt;135 and 고혈압_당뇨_진료내역==4&#39; ), x = &#39;맥압&#39; ,binwidth = 2) . &lt;AxesSubplot:xlabel=&#39;맥압&#39;, ylabel=&#39;Count&#39;&gt; . - 수축기혈압 120부근이면 맥압이 40에 몰리고 130부근이면 50에 몰린다 . - 그리고 둘 다 이완기혈압은 80부근에 몰린다 . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;and 성별==1 and 110&lt;수축기혈압&lt;115 and 고혈압_당뇨_진료내역==4&#39; ), x = &#39;맥압&#39; ,binwidth = 2) . &lt;AxesSubplot:xlabel=&#39;맥압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;and 성별==1 and 수축기혈압&lt;110 and 고혈압_당뇨_진료내역==4&#39; ), x = &#39;맥압&#39; ,binwidth = 2) . &lt;AxesSubplot:xlabel=&#39;맥압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;and 성별==1 and 수축기혈압&lt;=99 and 고혈압_당뇨_진료내역==4&#39; ), x = &#39;맥압&#39; ,binwidth = 2) . &lt;AxesSubplot:xlabel=&#39;맥압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;혈압범주==&quot;정상혈압&quot;and 성별==1 and 110&gt;=수축기혈압&gt;=100 and 고혈압_당뇨_진료내역==4&#39; ), x = &#39;맥압&#39; ,binwidth = 2) . &lt;AxesSubplot:xlabel=&#39;맥압&#39;, ylabel=&#39;Count&#39;&gt; . - 이렇게 할거면 그냥 for문으로 돌리면 된긴한다(나중에 정리할 땐 for문으로) . - 예컨데 수축기혈압을 5씩 구간화 하고 맥압의 분포 살펴보기 . - 이완기혈압이 왜 쌍봉분포? &gt; 수축기혈압이 110부근인 사람은 이완기혈압 70, 수축기혈압이 120, 130 부근인 사람은 이완기혈압 80 . - 그러면 수축기혈압은 왜 120, 130에 봉우리가 있음?(왜 쌍봉분포?) . - 일단 수축기혈압이 120인 사람은 BMI가 22~23, 수축기혈압이 130인 사람은 BMI가 23~24임 . - 그리고 수축기혈압이 120인 사람은 맥압이 40부근에 몰리고 수축기혈압이 130인 사람은 맥압이 50부근에 몰림 . - 근데 생각해보니 이건 당연한데 수축기혈압이 120, 130인 사람은 이완기혈압이 80부근에 몰린다고 했기 때문임(맥압=수축기혈압-이완기혈압) . - 갑자기 궁금한게 생겼는데 왜 수축기혈압이 10이나 더 높은데 이완기혈압은 비슷함?? . - 몰라..... . - 처음 주어진 변수가 7개라 한정적이다 . - 위의 이유를 주어진 데이터로 파악하지 못할 수 도 있음 &gt; 그럴것같음 . - BMI때문이라고 하기에는... 그럼 왜 BMI 분포는 종모양? . - 만약 수축기혈압 120인 사람과 수축기혈압이 130인 사람의 차이가 없다면 주어진 데이터로 파악을 못하는것 . - 일단 차이가 있긴함, 위에서 말했듯이 BMI가 1정도 차이남 . - BMI를 구간화시켜서 수축기혈압 분포 그려보자ㅡ(pd.cut) . Test &#45149; . - Tip : 고혈압, 당뇨 요인들 찾아보셈 . - 고혈압, 당뇨 둘 다 진료내역이 없는 경우가 너무 많아 그림이 제대로 보이지 않는다(초록점은 보이지 않음) . - 고혈압, 당뇨 둘 다 진료내역이 없는 경우는 따로 그리자 . df_s2 = df_s.loc[df_s[&#39;고혈압_당뇨_진료내역&#39;] != 4, :] . df_s3 = df_s.loc[df_s[&#39;고혈압_당뇨_진료내역&#39;] == 4, :] . fig, (ax1, ax2) = plt.subplots(1,2) fig.set_figwidth(12) palette2 = [&#39;green&#39;, &#39;steelblue&#39;, &#39;red&#39;] sns.scatterplot(data = df_s2, x = &#39;수축기혈압&#39;, y = &#39;이완기혈압&#39;, hue = &#39;고혈압_당뇨_진료내역&#39;, alpha = 0.2, s = 20, palette = palette2, ax = ax1) sns.scatterplot(data = df_s3, x = &#39;수축기혈압&#39;, y = &#39;이완기혈압&#39;, hue = &#39;고혈압_당뇨_진료내역&#39;, alpha = 0.2, s = 20, palette = [&#39;gray&#39;], ax = ax2) fig.tight_layout() . - 고혈압, 당뇨병 둘다 없는 사람들의 경우 수축기혈압은 80~140, 이완기 혈압은 50~90사이에 데이터가 많이 몰려있다 . - 우선 고혈압_당뇨가 2(고혈압만)인 경우와 1(둘 다 있음)인 경우 비슷한 산점도를 보인다 . - 그런데 고혈압_당뇨가 3(당뇨만)인 경우 고혈압_당뇨가 1,2인 경우보다 이완기혈압과 수축기혈압이 낮은쪽에 점이 위치하고 있음을 알 수 있다 . sns.lmplot(x = &#39;수축기혈압&#39;, y = &#39;이완기혈압&#39;, hue = &#39;고혈압_당뇨&#39;, scatter_kws = {&#39;alpha&#39;:0.5, &#39;s&#39;:20}, height = 7, data = df_s2) . &lt;seaborn.axisgrid.FacetGrid at 0x1f1a05badc0&gt; . - 추세선을 그려보니 고혈압,당뇨 진료내역과는 별개로 수축기혈압과 이완기혈압은 양의 상관관계 보인다 . - 맥압을 size변수로 설정하면 좋을것 같다 . fig, (ax1, ax2) = plt.subplots(1,2) fig.set_figwidth(12) palette2 = [&#39;green&#39;, &#39;steelblue&#39;, &#39;red&#39;] sns.scatterplot(data = df_s2, x = &#39;수축기혈압&#39;, y = &#39;이완기혈압&#39;, hue = &#39;고혈압_당뇨&#39;, size = &#39;맥압&#39;, alpha = 0.4, palette = palette2, ax = ax1) sns.scatterplot(data = df_s3, x = &#39;수축기혈압&#39;, y = &#39;이완기혈압&#39;, hue = &#39;고혈압_당뇨&#39;, size = &#39;맥압&#39;, alpha = 0.4, palette = [&#39;steelblue&#39;], ax = ax2) fig.tight_layout() . &#49688;&#52629;&#44592;&#54792;&#50517;&#44284; &#44277;&#48373;&#54792;&#45817; . fig, (ax1, ax2) = plt.subplots(1,2) fig.set_figwidth(12) palette2 = [&#39;green&#39;, &#39;steelblue&#39;, &#39;red&#39;] sns.scatterplot(data = df_s2, x = &#39;수축기혈압&#39;, y = &#39;공복혈당&#39;, hue = &#39;고혈압_당뇨&#39;, alpha = 0.4, s = 20, palette = palette2, ax = ax1) sns.scatterplot(data = df_s3, x = &#39;수축기혈압&#39;, y = &#39;공복혈당&#39;, hue = &#39;고혈압_당뇨&#39;, alpha = 0.4, s = 20, palette = [&#39;steelblue&#39;], ax = ax2) fig.tight_layout() . - 고혈압, 당뇨 둘 다 없는 경우 산점도를 보면 공복혈당은 60~140 수축기혈압은 90~150사이에 대부분의 데이터가 존재한다 . - 당뇨는 없고 고혈압만 있는 경우 확실히 당뇨가 있는 경우보다 공복혈당이 낮은곳에 데이터가 분포함을 확인할 수 있다 . - 고혈압만 있는 경우는 고혈압, 당뇨 둘 다 없는 경우의 산점도와 비슷하다 . - 당뇨가 있다면 추가로 고혈압이 있다고해서 산점도가 달라지지는 않는것으로 보이며 둘이 비슷하다 . sns.lmplot(x = &#39;수축기혈압&#39;, y = &#39;공복혈당&#39;, hue = &#39;고혈압_당뇨&#39;, scatter_kws = {&#39;alpha&#39;:0.3, &#39;s&#39;:20}, height = 7, data = df_s2) . &lt;seaborn.axisgrid.FacetGrid at 0x1f1a0ac6370&gt; . - 추세선을 그려보면 당뇨유무에 따른 차이가 확실히 보인다 . - 당뇨가 없다면 공복혈당은 확실히 낮다 . - 당뇨는 혈당으로 판단하기에 당연한 결과이긴 하다 . &#49688;&#52629;&#44592;&#54792;&#50517;&#44284; BMI . fig, (ax1, ax2) = plt.subplots(1,2) fig.set_figwidth(12) palette2 = [&#39;green&#39;, &#39;steelblue&#39;, &#39;red&#39;] sns.scatterplot(data = df_s2, x = &#39;수축기혈압&#39;, y = &#39;BMI&#39;, hue = &#39;고혈압_당뇨&#39;, alpha = 0.4, s = 20, palette = palette2, ax = ax1) sns.scatterplot(data = df_s3, x = &#39;수축기혈압&#39;, y = &#39;BMI&#39;, hue = &#39;고혈압_당뇨&#39;, alpha = 0.4, s = 20, palette = [&#39;steelblue&#39;], ax = ax2) fig.tight_layout() . - 고혈압, 당뇨 둘 다 없는 경우 산점도를 보면 BMI은 17~30 수축기혈압은 90~150사이에 대부분의 데이터가 존재하며 병이 있는 경우보다 BMI와 수축기혈압이 낮은곳에 더 많은 데이터가 분포한다 . - 산점도를 보면 당뇨만 있는 경우 수축기혈압이 낮은 곳에 데이터가 분포하고 있으며 BMI도 고혈압이 있는 경우보다 낮은 곳에 분포함을 알 수 있다 . - 당뇨만 있는 경우 수축기혈압은 90~140, BMI는 17~30사이에 데이터가 몰려있다 . - 고혈압이 있는 경우에는 수축기혈압은 100~160, BMI는 17~33사이에 데이터가 몰려있다 . - 고혈압만 있는 경우와 둘 다 있는 경우의 산점도는 서로 유사하다 . sns.lmplot(x = &#39;수축기혈압&#39;, y = &#39;BMI&#39;, hue = &#39;고혈압_당뇨&#39;, scatter_kws = {&#39;alpha&#39;:0.3, &#39;s&#39;:20}, height = 7, data = df_s2) . &lt;seaborn.axisgrid.FacetGrid at 0x1f1a0150f70&gt; . - 추세선을 그려보면 약한 양의 상관관계가 있긴하다 . - 당뇨만 있는 경우 추세선의 기울기 조금더 가파르다 . - 당뇨만 있는 경우의 데이터가가 고혈압이 있는 경우의 데이터보다 덜 퍼져있어서 그런것으로 보인다 . &#51060;&#50756;&#44592;&#54792;&#50517;&#44284; &#44277;&#48373;&#54792;&#45817; . fig, (ax1, ax2) = plt.subplots(1,2) fig.set_figwidth(12) palette2 = [&#39;green&#39;, &#39;steelblue&#39;, &#39;red&#39;] sns.scatterplot(data = df_s2, x = &#39;이완기혈압&#39;, y = &#39;공복혈당&#39;, hue = &#39;고혈압_당뇨&#39;, alpha = 0.4, s = 20, palette = palette2, ax = ax1) sns.scatterplot(data = df_s3, x = &#39;이완기혈압&#39;, y = &#39;공복혈당&#39;, hue = &#39;고혈압_당뇨&#39;, alpha = 0.4, s = 20, palette = [&#39;steelblue&#39;], ax = ax2) fig.tight_layout() . - 고혈압, 당뇨 둘 다 없는 경우 산점도를 보면 공복혈당은 60~140 이완기혈압은 50~90사이에 대부분의 데이터가 존재한다 . - 당뇨는 없고 고혈압만 있는 경우 확실히 당뇨가 있는 경우보다 공복혈당이 낮은곳에 데이터가 분포함을 확인할 수 있다 . - 고혈압만 있는 경우는 고혈압, 당뇨 둘 다 없는 경우의 산점도와 비슷하다 . - 당뇨가 있다면 추가로 고혈압이 있다고해서 산점도가 달라지지는 않는것으로 보이며 둘이 비슷하다 . sns.lmplot(x = &#39;이완기혈압&#39;, y = &#39;공복혈당&#39;, hue = &#39;고혈압_당뇨&#39;, scatter_kws = {&#39;alpha&#39;:0.3, &#39;s&#39;:20}, height = 7, data = df_s2) . &lt;seaborn.axisgrid.FacetGrid at 0x1f1a0b72a00&gt; . - 추세선을 그려보면 당뇨유무에 따른 차이가 확실히 보인다 . - 당뇨가 없다면 공복혈당은 확실히 낮다 . - 이완기혈압은 혈압의 일종이며 상관관계도 높기에 수축기혈압과 거의 동일한 양상을 보였다 . &#51060;&#50756;&#44592;&#54792;&#50517;&#44284; BMI . fig, (ax1, ax2) = plt.subplots(1,2) fig.set_figwidth(12) palette2 = [&#39;green&#39;, &#39;steelblue&#39;, &#39;red&#39;] sns.scatterplot(data = df_s2, x = &#39;이완기혈압&#39;, y = &#39;BMI&#39;, hue = &#39;고혈압_당뇨&#39;, alpha = 0.4, s = 20, palette = palette2, ax = ax1) sns.scatterplot(data = df_s3, x = &#39;이완기혈압&#39;, y = &#39;BMI&#39;, hue = &#39;고혈압_당뇨&#39;, alpha = 0.4, s = 20, palette = [&#39;steelblue&#39;], ax = ax2) fig.tight_layout() . - 고혈압, 당뇨 둘 다 없는 경우 산점도를 보면 BMI은 16~30 이완기혈압은 55~90사이에 대부분의 데이터가 존재하며 병이 있는 경우보다 BMI와 이완기혈압이 낮은곳에 더 많은 데이터가 분포한다 . - 산점도를 보면 당뇨만 있는 경우 이완기혈압이 낮은 곳에 데이터가 분포하고 있으며 BMI도 고혈압이 있는 경우보다 낮은 곳에 분포함을 알 수 있다 . - 당뇨만 있는 경우 이완기혈압은 60~90, BMI는 17~28사이에 데이터가 몰려있다 . - 고혈압이 있는 경우에는 이완기혈압은 60~100, BMI는 17~33사이에 데이터가 몰려있다 . - 고혈압만 있는 경우와 둘 다 있는 경우의 산점도는 서로 유사하다 . sns.lmplot(x = &#39;이완기혈압&#39;, y = &#39;BMI&#39;, hue = &#39;고혈압_당뇨&#39;, scatter_kws = {&#39;alpha&#39;:0.3, &#39;s&#39;:20}, height = 7, data = df_s2) . &lt;seaborn.axisgrid.FacetGrid at 0x1f1a0e99d30&gt; . - 추세선을 그려보면 약한 양의 상관관계가 있긴하다 . - 당뇨만 있는 경우 추세선의 기울기 조금더 가파르다 . - 당뇨만 있는 경우의 데이터가가 고혈압이 있는 경우의 데이터보다 덜 퍼져있어서 그런것으로 보인다 . - 이완기혈압과 BMI의 산점도는 수축기혈압과 BMI의 산점도와 비슷한 양상을 보였다 . &#44277;&#48373;&#54792;&#45817;&#44284; BMI . fig, (ax1, ax2) = plt.subplots(1,2) fig.set_figwidth(12) palette2 = [&#39;green&#39;, &#39;steelblue&#39;, &#39;red&#39;] sns.scatterplot(data = df_s2, x = &#39;공복혈당&#39;, y = &#39;BMI&#39;, hue = &#39;고혈압_당뇨&#39;, alpha = 0.3, s = 20, palette = palette2, ax = ax1) sns.scatterplot(data = df_s3, x = &#39;공복혈당&#39;, y = &#39;BMI&#39;, hue = &#39;고혈압_당뇨&#39;, alpha = 0.3, s = 20, palette = [&#39;steelblue&#39;], ax = ax2) fig.tight_layout() . - 우선 고혈압, 당뇨가 없는 산점도를 보면 BMI는 16~33, 공복혈당은 60~130인 구간에 대부분의 데이터가 존재함을 알 수 있다 . - 당뇨 진료내역 유무에 따라 공복혈당에는 큰 차이가 있다 . - 고혈압만 있는 경우에 그렇지않은 경우보다 BMI가 더 넓게 퍼져있다 . - 당뇨만 있는 경우에는 BMI가 조금 더 좁게 퍼져있는 것으로 보인다 . sns.lmplot(x = &#39;공복혈당&#39;, y = &#39;BMI&#39;, hue = &#39;고혈압_당뇨&#39;, scatter_kws = {&#39;alpha&#39;:0.3, &#39;s&#39;:20}, height = 7, data = df_s2) . &lt;seaborn.axisgrid.FacetGrid at 0x1f1a24b1b50&gt; . - 추세선을 그려보면 당뇨 진료내역만 있는 경우에는 약한 양의상관관계가 있는 것으로 보여진다 . - 그 외에 경우에는 BMI와 공복혈당은 관계가 없는 것으로 보인다 . 할 만한 시각화 | . - 고혈압/당뇨 범주에 따라 상관계수 행렬을 그려보자 . - 연령대별 혈압, 혈당, bmi 같은 것을 라인플랏을 그리자(박스플랏이랑 겹쳐도 괜찮을듯) . ref : https://www.pharmnews.com/news/articleView.html?idxno=82020 | . - bmi도 저체중, 정상, 과체중, 비만으로 나눠보자 . - 연령대별 전체, 남성, 여성의 수축기혈압(양적변수) 변화 . - catplot을 사용하여 고혈압/당뇨에 따른 FacetGrid를 그려보자(했음) . - 스토리와 흐름, motivation 이 중요함 . - 이런 그림을 왜그리고 또 이건 왜했는지 . - 왜 이런 시각화나 분석을 하고 다음에는 이러한 시각화나 분석을 했는지 등 . - 수축기혈압 분포를 그려보니 봉우리가 많았음 . - 고혈압/당뇨 진료내역에 따라 분포가 달라 그러한 것 같아 이에 따른 boxplot그림 . - 그런데 각 분포마다 여러개의 봉우리가 있었음 . - 뭐 때문에 그런걸까? . - 여러개 히스토그램의 x축이 동일하면 가로로 그리는 것 보다 세로로 그리는것이 분포비교에 더 좋음 . - BMI 저체중, 정상, 과체중, 비만으로 쪼개서 분석해보기 . 고민 | . - 고혈압 진료내역이 있지만 고혈압인 사람도 있고 아닌 사람도 있다 . - 그래서 혈압범주라는 새로운 열을 만들어서 고혈압인 사람과 그렇지 않은 사람으로 나눴다(범주형 변수) . - 그런데 고혈압 진료내역이 있지만 고혈압인 사람과 진료내역이 없지만 고혈압인 사람과 혈압차이가 있을까? . - 반대로 고혈압 진료내역이 있지만 고혈압이 아닌 사람과 진료내역이 없지만 고혈압이 아닌 사람과 혈압차이가 있을까? . - 이는 혈당에도 적용가능하다 . - 위를 확인할 필요가 있다(위의 기준으로 나눠 혈압 boxplot확인하기) . - 그런데 고혈압 진료내역과 혈압과는 연관이 있었다 . - 고혈압 진료내역이 있으면 평균적으로 혈압이 더 높았다(고혈압이 없어도 고혈압인 사람이 있고 고혈압이어도 고혈압이 아닌 사람이 있음에도) . - 위를 정리하자면 고혈압 진료내역이 있으면 없는 사람보다 혈압이 더 높다 . - 이것이 고혈압인데 고혈압인 사람으로부터 차이가 생기는건지 고혈압인데 고혈압은 아니지만 과거 영향으로 정상범주혈압안에서 높은쪽에 속하여 차이가 생기는지 확인하자 . - 그리고 또 동시에 고혈압범주이면서 고혈당인 사람과 고혈압인 사람 or 고혈당인 사람과 차이가 있는지도 확인할 필요가 있을 것 같다(일단 비율에는 차이가 있더라...) . - 고혈압범주에 속하는 사람들중 고혈압, 당뇨 진료내역이 차지하는 비중도 확인해보자(이미 했는지는 확인해야함) &gt; 했네 . - 당뇨도 마찬가지 . NHIS &#45936;&#51060;&#53552; &#52280;&#44256; . - 접속한 디렉토리보다 root 위치에 있는 파일은 못읽음 . - 그래서 C:/Sources에 있는 파일 위치 C:/Users/한재수 로 옮김 . - 판다스 한글 깨짐 참고 : https://wisenrich.com/%ED%8C%90%EB%8B%A4%EC%8A%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%94%84%EB%A0%88%EC%9E%84-%ED%95%9C%EA%B8%80-%EA%B9%A8%EC%A7%90-%ED%98%84%EC%83%81-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95%EC%9D%80/ . df = pd.read_csv(&#39;C:/Users/한재수/NHIS_OPEN_GJ_2016.csv&#39;,encoding=&#39;euc-kr&#39;,header=0) . df.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 1000000 entries, 0 to 999999 Data columns (total 34 columns): # Column Non-Null Count Dtype -- -- 0 기준년도 1000000 non-null int64 1 가입자일련번호 1000000 non-null int64 2 성별코드 1000000 non-null int64 3 연령대코드(5세단위) 1000000 non-null int64 4 시도코드 1000000 non-null int64 5 신장(5Cm단위) 999103 non-null float64 6 체중(5Kg단위) 999103 non-null float64 7 허리둘레 999807 non-null float64 8 시력(좌) 999700 non-null float64 9 시력(우) 999701 non-null float64 10 청력(좌) 999734 non-null float64 11 청력(우) 999734 non-null float64 12 수축기혈압 999912 non-null float64 13 이완기혈압 999911 non-null float64 14 식전혈당(공복혈당) 999952 non-null float64 15 총콜레스테롤 999957 non-null float64 16 트리글리세라이드 999956 non-null float64 17 HDL콜레스테롤 999953 non-null float64 18 LDL콜레스테롤 997369 non-null float64 19 혈색소 999947 non-null float64 20 요단백 995101 non-null float64 21 혈청크레아티닌 999955 non-null float64 22 (혈청지오티)AST 999958 non-null float64 23 (혈청지오티)ALT 999957 non-null float64 24 감마지티피 999957 non-null float64 25 흡연상태 999787 non-null float64 26 음주여부 0 non-null float64 27 구강검진 수검여부 1000000 non-null int64 28 치아우식증유무 0 non-null float64 29 결손치유무 0 non-null float64 30 치아마모증유무 0 non-null float64 31 제3대구치(사랑니)이상 0 non-null float64 32 치석 401763 non-null float64 33 데이터공개일자 1000000 non-null int64 dtypes: float64(27), int64(7) memory usage: 259.4 MB . df.isnull().sum() . 기준년도 0 가입자일련번호 0 성별코드 0 연령대코드(5세단위) 0 시도코드 0 신장(5Cm단위) 897 체중(5Kg단위) 897 허리둘레 193 시력(좌) 300 시력(우) 299 청력(좌) 266 청력(우) 266 수축기혈압 88 이완기혈압 89 식전혈당(공복혈당) 48 총콜레스테롤 43 트리글리세라이드 44 HDL콜레스테롤 47 LDL콜레스테롤 2631 혈색소 53 요단백 4899 혈청크레아티닌 45 (혈청지오티)AST 42 (혈청지오티)ALT 43 감마지티피 43 흡연상태 213 음주여부 1000000 구강검진 수검여부 0 치아우식증유무 1000000 결손치유무 1000000 치아마모증유무 1000000 제3대구치(사랑니)이상 1000000 치석 598237 데이터공개일자 0 dtype: int64 . df=df.drop([&#39;음주여부&#39;,&#39;치아우식증유무&#39;,&#39;결손치유무&#39;,&#39;치아마모증유무&#39;,&#39;제3대구치(사랑니)이상&#39;,&#39;치석&#39;],axis = 1) . df=df.dropna() . sns.histplot(data=df, x=&#39;수축기혈압&#39;,binwidth=5,hue=&#39;성별코드&#39;) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df, x = &#39;이완기혈압&#39;, bins = 30) . &lt;AxesSubplot:xlabel=&#39;이완기혈압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;이완기혈압&gt;75&#39;), x = &#39;수축기혈압&#39;,binwidth=1) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;Count&#39;&gt; . - 근데 생각해봤는데 그냥 특정 부분에 너무너무 많이많이 몰려있음 . - 혈압은 사람이 재는데 기계가 혈압을 정해주는게 아니라 사람이 봐가면서 정하는건가? . - 약간 시력검사 숟가락으로 눈가리고 하는것처럼 . - 혈압높다싶으면 빡세개 가고 . - 그니까 혈압이 한 120부근임 122일수도 있고 123일수도있고 121일수도 있어 . - 근데 그냥 어자피 130까지 올라갈것도 아니니까 그냥 120으로 퉁치는건가? . - 그리고 혈압 좀 높은데? 싶으면 130까지 올려보고 여기까지 한계인가 보네 하면 131이든 132이든 그냥 130으로 하는거지 . - 글고 왜 혈압은 소수점 없냐? 기계가 재면 소수점까지 재야되는거 아니냐? . - 압력이면 실수아닌가? . - 아님 말고^^ . - 만약에 위에 말이 맞으면 수축기혈압은 그냥 정규분포임은 아니네 . - 어찌됐든 120과 130으로 나뉘기는 한다 . sns.histplot(data = df.query(&#39;이완기혈압&gt;75&#39;), x = &#39;수축기혈압&#39;, hue=&#39;흡연상태&#39;,binwidth=3) . &lt;AxesSubplot:xlabel=&#39;수축기혈압&#39;, ylabel=&#39;Count&#39;&gt; . sns.histplot(data = df.query(&#39;이완기혈압&gt;75&#39;), x = &#39;허리둘레&#39;, binwidth=10) . &lt;AxesSubplot:xlabel=&#39;허리둘레&#39;, ylabel=&#39;Count&#39;&gt; . - 흡연이랑 수축기혈압이랑 1도 연관없다 . - 그리고 음주여부는 다 결측치여서 제거함 . pd.Series(df.columns) . 0 기준년도 1 가입자일련번호 2 성별코드 3 연령대코드(5세단위) 4 시도코드 5 신장(5Cm단위) 6 체중(5Kg단위) 7 허리둘레 8 시력(좌) 9 시력(우) 10 청력(좌) 11 청력(우) 12 수축기혈압 13 이완기혈압 14 식전혈당(공복혈당) 15 총콜레스테롤 16 트리글리세라이드 17 HDL콜레스테롤 18 LDL콜레스테롤 19 혈색소 20 요단백 21 혈청크레아티닌 22 (혈청지오티)AST 23 (혈청지오티)ALT 24 감마지티피 25 흡연상태 26 구강검진 수검여부 27 데이터공개일자 dtype: object . def t(x): if x&lt;=125: y=1 else: y=2 return y . df[&#39;test&#39;]=list(map(t, df[&#39;수축기혈압&#39;])) . sns.histplot(data = df.query(&#39;이완기혈압&gt;75 and 허리둘레 &lt;200&#39;), x = &#39;허리둘레&#39;,hue=&#39;test&#39;,binwidth=2) . &lt;AxesSubplot:xlabel=&#39;허리둘레&#39;, ylabel=&#39;Count&#39;&gt; . - 허리둘레랑 혈압 관련있는듯 . - 그럼 수축기혈압이 2개로 나뉜게 그냥 BMI때문이라 해도 되냐? . sns.boxplot(data = df.query(&#39;이완기혈압&gt;75&#39;), x = &#39;test&#39;, y=&#39;허리둘레&#39;) . &lt;AxesSubplot:xlabel=&#39;test&#39;, ylabel=&#39;허리둘레&#39;&gt; . - 차이 없는데? . - 아니야 히스토그램 보면 차이를 느낄수있음 . df.query(&#39;이완기혈압&gt;75 and 1==test&#39;)[&#39;허리둘레&#39;].describe() . count 188157.000000 mean 81.408600 std 12.738658 min 2.000000 25% 75.000000 50% 81.000000 75% 87.000000 max 999.000000 Name: 허리둘레, dtype: float64 . df.query(&#39;이완기혈압&gt;75 and 2==test&#39;)[&#39;허리둘레&#39;].describe() . count 324288.000000 mean 84.723832 std 9.920170 min 33.000000 25% 79.000000 50% 84.000000 75% 90.000000 max 999.000000 Name: 허리둘레, dtype: float64 . - 수축기혈압이 130인 사람은 허리둘레가 중심이 84인 분포를 따르고 수축기혈압이 120인 사람은 허리둘레가 중심이 81인 분포를 따름 . - 근데 위 설명은 뭔가 부실한듯 . - 그렇게 따지면 수축기혈압이 110인 사람이랑 100인 사람이랑 비교해도 그럴거아니냐 . - 왜 하필 수축기혈압이 120, 130에 집중적으로 몰린건지는 설명이 잘 안됨 . - 수축기혈압이 110인 사람이 100인 사람이랑 허리둘레 비교해도 위에 처럼 나올텐데 수축기혈압이 110이랑 100에 몰리지는 않았잖음 . - 아닌가? 그냥 허리둘레 때문이 맞나? . - 뭔가 범주형 변수로 인해 구분되는거면 깔끔한데 양적변수로 구분돼서 안깔끔한것 같다 .",
            "url": "https://jaesu26.github.io/green/python/visualization/2021/10/01/%ED%98%88%EC%95%95%ED%98%88%EB%8B%B9%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D.html",
            "relUrl": "/python/visualization/2021/10/01/%ED%98%88%EC%95%95%ED%98%88%EB%8B%B9%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D.html",
            "date": " • Oct 1, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "자료구조 덱(deque)",
            "content": "&#45937;(deque) . - 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료 구조의 한 형태 . - 두 개의 포인터를 사용하여 양쪽에서 삭제와 삽입을 발생 시킬 수 있음 &gt; 큐와 스택을 합친 형태 . - 참고: 자료구조 덱 . &#45937;(deque) &#49324;&#50857; . - 파이썬에서 deque는 from collections import deque를 실행한 후 deque()통해 구현할 수 있다 . - deque.append(x)를 통해 덱에 x를 오른쪽(뒤)에 push한다 . - deque.appendleft(x)를 통해 덱에 x를 왼쪽(앞)에 push한다 . - deque.pop()를 통해 덱에서 뒤의 원소를 pop한다 . - deque.popleft()를 통해 덱에서 앞의 원소를 pop한다 . - 참고: deque in python . &#50696;&#51228; . from collections import deque ## 덱(deque)를 사용하기 위해 deque라이브러리 import deque = deque([1, 2, 3, 4, 5]) ## 큐(queue) 자료구조 생성 &gt; deque([1, 2, 3, 4, 5]) deque.append(1) ## 덱의 뒤에 1 추가 &gt; deque([1, 2, 3, 4, 5, 1]) deque.appendleft(2) ## 덱의 앞에 2 추가 &gt; deque([2, 1, 2, 3, 4, 5, 1]) deque.popleft() ## 덱에서 앞의 원소를 추출함 &gt; deque([1, 2, 3, 4, 5, 1]) deque.pop() ## 덱에서 뒤의 원소를 추출함 &gt; deque([1, 2, 3, 4, 5]) deque . deque([1, 2, 3, 4, 5]) .",
            "url": "https://jaesu26.github.io/green/python/data%20structure/2021/09/19/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%8D%B1.html",
            "relUrl": "/python/data%20structure/2021/09/19/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%8D%B1.html",
            "date": " • Sep 19, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "행렬(matrix)",
            "content": "- 참고 교재1 : SAS와 R을 활용한 선형회귀분석(자유아카데미) . - 참고 교재2 : 통계수학강의(자유아카데미) . - 행렬의 기초를 간단히 정리하자 . &#54665;&#47148; . - 벡터와 행렬은 볼드체로 적어야 함 . - 행렬의 원소는 볼드체 사용 안함 &gt; 행렬의 원소가 벡터 또는 행렬이면 볼드체 사용 . - 행렬의 기본인 벡터를 알고가자 . - 열벡터($ boldsymbol{a}$) : $m times 1$ 행렬 &gt; 보통 벡터라고 하면 열벡터임 . - 행벡터($ boldsymbol{a&#39;}$) : $1 times n$ 행렬 . - 스칼라 : 원소가 하나인 행렬 . - ${ bf 0}$ : 모든 원소가 $0$인 벡터 . - ${ bf 1}$ : 모든 원소가 $1$인 벡터 . - $ boldsymbol{e_i}$ : $i$번째 원소만 $1$이고 나머지 원소는 모두 $0$인 벡터 . &#54665;&#47148;&#51032; &#51333;&#47448; . - 행렬(matrix)은 다음과 같이 $m$ 개의 행(row) 과 $n$ 개의 열(column) 을 $mn$ 개의 숫자로 채운 모양 . $$ boldsymbol{A} = begin{pmatrix} a_{11} &amp; a_{12} &amp; cdots &amp; a_{1n} a_{21} &amp; a_{22} &amp; cdots &amp; a_{2n} vdots &amp; vdots &amp; ddots &amp; vdots a_{m1} &amp; a_{m2} &amp; cdots &amp; a_{mn} end{pmatrix}$$ - 정사각행렬(square matrix) : $m=n$ 인 행렬 . - 대각행렬(diagonal matrix, $ boldsymbol{D}$) : 정사각행렬 중에 대각원소를 제외한 모든 원소가 $0$인 행렬 . - 단위행렬(identity matrix, $ boldsymbol{I}$) : 대각행렬 중에 대각의 원소가 모두 $1$인 행렬 &gt; $ boldsymbol{I_m}$(차수가 $m$) . - 위삼각행렬(upper triangular matrix) : 대각원소와 그 오른쪽 위의 원소를 제외한 나머지 원소는 모두 $0$인 행렬 . - 아래삼각행렬(lower triangular matrix) : 대각원소와 그 왼쪽 아래의 원소를 제외한 나머지 원소는 모두 $0$인 행렬 . - 전치행렬(transpose matrix) : 행과 열이 바뀐 행렬 &gt; $m times n$ 행렬의 전치행렬은 $n times m$ 이 되고 $ boldsymbol{A&#39;}$ 또는 $A^T$ 로 표현 . - 대칭행렬(symmetric matrix) : $ boldsymbol{A = A^T}$ . &#54665;&#47148;&#51032; &#50672;&#49328; . - 행렬의 덧셈 뺄셈은 교재 참고 . &#54665;&#47148;&#51032; &#44273; . - 각 행렬은 행벡터 또는 열벡터로 분할될 수 있음 . - 행렬의 곱 $ boldsymbol{AB}$ 는 행렬 $ boldsymbol A$ 가 $m$ 개의 행벡터로 분할되어 있고 행렬 $ boldsymbol B$ 가 $n$ 개의 열벡터로 분할되어 있다고 할 때 곱의 계산을 나타낸 것 &gt; 교재 참고 . $$ boldsymbol{AB}= begin{pmatrix} { boldsymbol{a_{1 , cdot}}} ,&#39; { boldsymbol{a_{2 , cdot}}} ,&#39; vdots { boldsymbol{a_{m , cdot}}} ,&#39; end{pmatrix} big( boldsymbol{b_{ , cdot ,1}}, , boldsymbol{b_{ , cdot ,2}}, , cdots, , boldsymbol{b_{ , cdot , n}} big) = begin{pmatrix} { boldsymbol{a_{1 , cdot}}} ,&#39; boldsymbol{b_{ , cdot ,1}} &amp; { boldsymbol{a_{1 , cdot}}} ,&#39; boldsymbol{b_{ , cdot ,2}} &amp; cdots &amp; { boldsymbol{a_{1 , cdot}}} ,&#39; boldsymbol{b_{ , cdot ,n}} { boldsymbol{a_{2 , cdot}}} ,&#39; boldsymbol{b_{ , cdot ,1}} &amp; { boldsymbol{a_{2 , cdot}}} ,&#39; boldsymbol{b_{ , cdot ,2}} &amp; cdots &amp; { boldsymbol{a_{2 , cdot}}} ,&#39; boldsymbol{b_{ , cdot ,n}} vdots &amp; vdots &amp; ddots &amp; vdots { boldsymbol{a_{m , cdot}}} ,&#39; boldsymbol{b_{ , cdot ,1}} &amp; { boldsymbol{a_{m , cdot}}} ,&#39; boldsymbol{b_{ , cdot ,2}} &amp; cdots &amp; { boldsymbol{a_{m , cdot}}} ,&#39; boldsymbol{b_{ , cdot ,n}} end{pmatrix}$$ . . - ${ boldsymbol{a_{1 , cdot}}} ,&#39; boldsymbol{b_{ , cdot ,1}}$ 부터 ${ boldsymbol{a_{m , cdot}}} ,&#39; boldsymbol{b_{ , cdot ,n}}$ 까지 각각은 스칼리임 . - 위 식에서 행렬 $ boldsymbol{A}$ 가 $p$ 개의 열벡터로 행렬 $ boldsymbol{B}$ 가 $p$ 개의 행벡터로 분할되어 있다고 하자 . - 그러면 행렬의 곱 $ boldsymbol{AB}$ 는 아래와 같이도 표현 가능함 . $$ boldsymbol{AB}= big( boldsymbol{a_{ , cdot ,1}}, , boldsymbol{a_{ , cdot ,2}}, , cdots, , boldsymbol{a_{ , cdot , p}} big) begin{pmatrix} { boldsymbol{b_{1 , cdot}}} ,&#39; { boldsymbol{b_{2 , cdot}}} ,&#39; vdots { boldsymbol{b_{p , cdot}}} ,&#39; end{pmatrix} = boldsymbol{a_{ , cdot ,1}}{ boldsymbol{b_{1 , cdot}}} ,&#39; + cdots + boldsymbol{a_{ , cdot ,p}}{ boldsymbol{b_{p , cdot}}} ,&#39;$$ . . - $ boldsymbol{a_{ , cdot ,1}}{ boldsymbol{b_{1 , cdot}}} ,&#39;$ 부터 $ boldsymbol{a_{ , cdot ,p}}{ boldsymbol{b_{p , cdot}}} ,&#39;$ 까지 각각은 $p times p$ 행렬임 . &#45824;&#44033;&#54633;(trace) . - 정사각행렬의 특성을 나타내는 수치 . - 행렬의 대각원소의 합 . - $tr( boldsymbol{A}) = sum limits_{i=1}^{m}a_{ii}$ . &#45824;&#44033;&#54633;&#51032; &#49457;&#51656; . - $tr( boldsymbol{A}) = tr( boldsymbol{A&#39;})$ . - $tr( boldsymbol{AB}) = tr( boldsymbol{BA})$ . - 나머지는 간단하니 교재 참고 . &#50669;&#54665;&#47148; . . - 행렬식(determinant) : $ begin{vmatrix} boldsymbol{A} end{vmatrix}$ or $det( boldsymbol{A})$ . - 행렬 $ begin{vmatrix} boldsymbol{A} end{vmatrix}$ 가 $m times m$ 일 때 $| boldsymbol{A}|= sum limits_{i=1}^{m}(-1)^{i+1}a_{1i} begin{vmatrix} boldsymbol{M_{1i}} end{vmatrix}$ . - $ boldsymbol{M_{ij}}$ 는 행렬 $ boldsymbol{A}$ 에서 $i$ 번째 행과 $j$ 번째 열을 제외한 $(m-1) times(m-1)$ 부분행렬 . - $ boldsymbol{A_{ij}} = (-1)^{i+j} boldsymbol{M_{ij}} longrightarrow boldsymbol{A_{ij}}$ 를 원소 $a_{ij}$ 의 여인수라고 함 . - 행렬 $ boldsymbol{A}$ 의 역행렬의 $(i,j)$ 번째 원소 $ boldsymbol{{(A^{-1})}_{ij}} = cfrac{1}{ begin{vmatrix} boldsymbol{A} end{vmatrix}}(-1)^{i+j} begin{vmatrix} boldsymbol{M_{ij}} end{vmatrix}$ . - 대각행렬, 위삼각행렬, 아래삼각행렬의 행렬식은 대각선 원소들의 곱 . - 특이행렬(singular matrix) : 행렬식이 $0$인 행렬 . - 정칙행렬(nonsingular matrix) : 행렬식이 $0$이 아닌 행렬 . . &#54665;&#47148;&#49885;&#51032; &#49457;&#51656; . - 스칼라 $ alpha$ 와 $m times m$ 행렬 $ boldsymbol{A,B}$ 에 대하여 다음이 성립 . $det( boldsymbol{A}) = det( boldsymbol{A&#39;})$ . | $det( alpha boldsymbol{A}) = alpha^{m}(det( boldsymbol{A}))$ . | $ boldsymbol{A}$ 가 대각행렬이면 $det( boldsymbol{A}) = a_{11} times a_{22} times cdots times a_{mm}$ . | 행렬 $det( boldsymbol{AB}) = det( boldsymbol{A}) times det( boldsymbol{B})$ . | 정사각행렬 $ boldsymbol{P, ,Q}$ 에 대하여 $ begin{vmatrix} begin{pmatrix} boldsymbol{P} &amp; boldsymbol{0} boldsymbol{X} &amp; boldsymbol{Q} end{pmatrix} end{vmatrix} = begin{vmatrix} boldsymbol{P} end{vmatrix} cdot begin{vmatrix} boldsymbol{Q} end{vmatrix}$ . | . $n$ &#52264; &#50672;&#47549;&#48169;&#51221;&#49885;&#51032; &#54644; . - $n$ 개의 미지수 $(x_1,x_2, cdots,_n)&#39;=x$에 대하여 $n$ 차 연립방정식을 생각해보자 . $$a_{11}x_1 + a_{12}x_2+ cdots+a_{1n}x_n=d_1 a_{21}x_1 + a_{22}x_2+ cdots+a_{2n}x_n=d_2 quad vdots a_{n1}x_1 + a_{n2}x_2+ cdots+a_{nn}x_n=d_n$$- 위의 $n$ 차 연립방정식은 다음과 같이 표현이 가능 $ to boldsymbol{Ax} = boldsymbol{d}$ . - 만약 $ boldsymbol{A^-1}$이 존재하면 $ boldsymbol{A^{-1}Ax} = boldsymbol{A^{-1}d} Longrightarrow boldsymbol{x} = boldsymbol{A^{-1}d}$ . &#50669;&#54665;&#47148;&#51032; &#49457;&#51656; . - 스칼라 $ alpha$ 와 $m times m$ 정칙행렬 $ boldsymbol{A,B}$ 에 대하여 다음을 만족 . $( alpha boldsymbol{A})^{ boldsymbol{-1}}= alpha^{-1} boldsymbol{A^{-1}}$ . | $( boldsymbol{A&#39;})^{ boldsymbol{-1}}=( boldsymbol{A^{-1}})&#39;$ . | $ begin{vmatrix} boldsymbol{A^{-1}} end{vmatrix}= begin{vmatrix} boldsymbol{A} end{vmatrix}^{-1}$ . | $ boldsymbol{A} = diag(a_{11},a_{22}, cdots,a_{mm}) Longrightarrow boldsymbol{A^{-1}} = diag(a_{11}^{ ,-1},a_{22}^{ ,-1}, cdots,a_{mm}^{ ,-1})$ . | $( boldsymbol{AB})^{ boldsymbol{-1}}= boldsymbol{B^{-1}} boldsymbol{A^{-1}}$ . | 정칙행렬 $ boldsymbol{P}, boldsymbol{Q}$ 에 대하여 $ begin{pmatrix} boldsymbol{P} &amp; 0 0 &amp; boldsymbol{Q} end{pmatrix}^{ boldsymbol{-1}} = begin{pmatrix} boldsymbol{P^{-1}} &amp; 0 0 &amp; boldsymbol{Q^{-1}} end{pmatrix}$ . | &#51649;&#44368;&#54665;&#47148; . - 직교행렬(orthogonal matrix) : 정사각행렬 중에 전치행렬이 역행렬인 행렬 $ longrightarrow boldsymbol{A&#39;} = boldsymbol{A^{-1}}$ . &#51649;&#44368;&#54665;&#47148;&#51032; &#51312;&#44148; . $${a_j}&#39;a_j = begin{cases} 1 &amp; text{for $i=j$} 0 &amp; text{for $i neq j$} end{cases}$$ . - 각 열벡터는 길이가 $1$이고 다른 열벡터와 직교한다 &gt; 정규직교벡터 . - $ boldsymbol{P}$ 가 직교행렬이면 $ begin{vmatrix} boldsymbol{PP&#39;} end{vmatrix} = { begin{vmatrix} boldsymbol{P} end{vmatrix}}^{2} = 1$ 이므로 직교행렬의 행렬식은 $ pm 1$ . &#47729;&#46321;&#54665;&#47148; . - 멱등행렬(idempotent matrix) : $ boldsymbol{A}^2= boldsymbol{AA}= boldsymbol{A}$ 를 만족하는 행렬 . - 멱등행렬의 대표적인 예(회귀분석) &gt; $ boldsymbol{H} = boldsymbol{X{(X{ ,&#39;}X)}^{-1}X{ ,&#39;}}$ . - 다양한 예는 교재 참고 . 2&#52264;&#54805;&#49885; . - 2차형식(quadratic form) : 대칭행렬을 사이에 두고 양옆에 같은 벡터가 곱해지는 형태($ boldsymbol{x&#39;Ax}$) . (&#51456;)&#51221;&#48512;&#54840;&#54665;&#47148; . - 모든 벡터 $ boldsymbol{x} neq 0$ 에 대하여 각 조건을 만족시키는 대칭행렬 $ boldsymbol{A}$ 는 다음과 같이 정의함 . $ boldsymbol{x&#39;Ax} &gt; 0$ 이면 $ boldsymbol{A}$ : 양의 정부호행렬(positive definite matrix) &gt; 양정치 . | $ boldsymbol{x&#39;Ax} geq 0$ 이면 $ boldsymbol{A}$ : 양의 준정부호행렬(positive semi-definite matrix) &gt; 양반정치 . | &#54665;&#47148;&#51032; &#44228;&#49688; . &#44256;&#50976;&#44050;&#44284; &#44256;&#50976;&#48289;&#53552; .",
            "url": "https://jaesu26.github.io/green/math/2021/09/16/%ED%96%89%EB%A0%AC.html",
            "relUrl": "/math/2021/09/16/%ED%96%89%EB%A0%AC.html",
            "date": " • Sep 16, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "Boole's inequality and Bonferroni's inequality",
            "content": "Boole&#39;s inequality . - Boole의 부등식: $P bigg( bigcup limits_{i=1}^{ infty} A_i bigg) leq sum limits_{i=1}^{ infty}P(A_i)$ . Boole&#51032; &#48512;&#46321;&#49885; &#51613;&#47749; . - $B_1=A_1, ,B_2=A_2 cap A^c_1, , cdots, ,B_i = A_i cap bigg( bigcup limits_{j=1}^{i-1}A_j bigg)^c$ . - 사건 $B_i$는 사건 $A_i$에는 속하면서 사건 $A_j ,(1 leq j &lt;i$)에는 속하지 않는다 . - 그렇기에 $B_i$와 $B_j(i neq j)$는 서로 배반 사건임 &gt; 배반 사건이므로 $P( cup B_i) = sum P(B_i)$ . - 그리고 $ cup A_i= cup B_i$ 임을 알 수 있음 . - 또 $B_i subset A_i$ 이므로 $P( cup A_i)= P( cup B_i)= sum P(B_i) leq sum P(A_i)$ 가 성립한다 . Bonferroni&#39;s inequality . - Bonferroni의 부등식: $P bigg( bigcap limits^{k}_{i=1}A_i bigg) geq 1 - sum limits_{i=1}^{k}P(A_i^c)$ . Bonferroni&#51032; &#48512;&#46321;&#49885; &#51613;&#47749; . - 드 모르간의 법칙: $ bigg( bigcap limits_{i=1}^{k}A_i bigg)^c = bigcup limits_{i=1}^{k}A^c_i longrightarrow bigcap limits_{i=1}^{k}A_i= bigg( bigcup limits_{i=1}^{k}A^c_i bigg)^c$ . $P bigg( bigcap limits^{k}_{i=1}A_i bigg) geq 1 - sum limits_{i=1}^{k}P(A_i^c) qquad therefore bigcap limits_{i=1}^{k}A_i= bigg( bigcup limits_{i=1}^{k}A^c_i bigg)^c$ . | $P bigg( bigg( bigcup limits_{i=1}^{k}A^c_i bigg)^c bigg) geq 1 - sum limits_{i=1}^{k}P(A_i^c) qquad therefore P(A^c)=1-P(A)$ . | $1-P bigg( bigcup limits_{i=1}^{k}A^c_i bigg) geq 1 - sum limits_{i=1}^{k}P(A_i^c)$ . | $P bigg( bigcup limits_{i=1}^{k}A^c_i bigg) leq sum limits_{i=1}^{k}P(A_i^c) qquad therefore$ $A^c_i$ 대신 $A_i$ 사용해도 상관없음 . | $P bigg( bigcup limits_{i=1}^{k}A_i bigg) leq sum limits_{i=1}^{k}P(A_i) longrightarrow $ 이 식이 성립하는지 수학적 귀납법을 사용하여 증명하자 . | . - $k=1$일 때 $P(A_1) leq P(A_1)$이므로 성립한다 . - $k=n$일 때 성립한다 가정하고 $k=n+1$일 때도 성립하는지 확인하자 . $P bigg( bigcup limits_{i=1}^{n+1}A_i bigg)= P bigg( bigg( bigcup limits_{i=1}^{n}A_i bigg) cup A_{n+1} bigg) = P bigg( bigcup limits_{i=1}^{n}A_i bigg)+P(A_{n+1})-P bigg( bigg( bigcup limits_{i=1}^{n}A_i bigg) cap A_{n+1} bigg)$ . | $P bigg( bigcup limits_{i=1}^{n+1}A_i bigg) leq P bigg( bigcup limits_{i=1}^{n}A_i bigg) + P(A_{n+1}) qquad therefore P bigg( bigg( bigcup limits_{i=1}^{n}A_i bigg) cap A_{n+1} bigg) geq 0$ . | $P bigg( bigcup limits_{i=1}^{n+1}A_i bigg) leq P bigg( bigcup limits_{i=1}^{n}A_i bigg) + P(A_{n+1}) leq sum limits_{i=1}^{n}P(A_i)+P(A_{n+1})= sum limits_{i=1}^{n+1}P(A_i)$ . | . - 따라서 $k=n+1$일 때도 성립한다 . - 수학적 귀납법에 의해 모든 유한개의 사건 $k$에 대해 $P bigg( bigcap limits^{k}_{i=1}A_i bigg) geq 1 - sum limits_{i=1}^{k}P(A_i^c)$ 가 성립함 . - ref: https://dawoum.ddns.net/wiki/Boole%27s_inequality .",
            "url": "https://jaesu26.github.io/green/statistics/math/2021/09/12/%EB%B6%80%EC%9A%B8-%EB%B3%B8%ED%8E%98%EB%A5%B4%EB%8B%88-%EB%B6%80%EB%93%B1%EC%8B%9D.html",
            "relUrl": "/statistics/math/2021/09/12/%EB%B6%80%EC%9A%B8-%EB%B3%B8%ED%8E%98%EB%A5%B4%EB%8B%88-%EB%B6%80%EB%93%B1%EC%8B%9D.html",
            "date": " • Sep 12, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "포함배제의 원리",
            "content": "- 수통 과제에 포함배제의 원리 증명이 있는데 헷갈려서 따로 정리함 . &#54252;&#54632;&#48176;&#51228;&#51032; &#50896;&#47532;(&#54869;&#47456;&#51032; &#44221;&#50864;) . - 임의의 유한개의 사건 $A_1, cdots, A_k in S$ 에 대하여 아래가 성립함 . $P Big( bigcup limits^{K}_{i=1}A_i Big) = sum limits_{i=1}^{k}P(A_i) - sum limits_{1 leq i &lt; j leq k}^{k}P(A_i cap A_j) + cdots+(-1)^{k-1}P Big( bigcap limits_{i=1}^{k}A_i Big)$ | . - 이제 증명을 해보자 &gt; 수학적 귀납법을 활용할 것 임 . - $n = 1$일 때 식이 성립함을 증명 &gt; $n=k$일 때 성립한다 가정하고 $n=k+1$일 때 식이 성립함을 증명 . - $n=k$일 때 성립하면 $n=k+1$일 때도 성립한다고 했음 &gt; $n = 1$일 때 성립하면 $n=2$일 때도 성립 &gt; $n = 1$일 때 식이 성립함&gt; $n=2$일 때 식이 성립 . - 이제 $n=2$일 때 성립하면 $n=3$일 때도 성립 &gt;$n = 2$일 때 식이 성립함 &gt; $n=3$일 때 식이 성립 . - 이런식으로 나아가면 모든 자연수에 대해서 성립함을 알 수 있음 . - $n=1$대신 $n=a$로 바뀐다면 $a$이후의 자연수에 대해서 성립함을 알 수 있음 . &#54252;&#54632;&#48176;&#51228;&#51032; &#50896;&#47532; &#51613;&#47749; . - $A cap B = C to C cap A = C, ; C cap B = C,C cup A = A, ; C cup B = B$ &gt; 당연하지만 알아두자 . - $n=1$일 때 $P(A_1) = P(A_1)$이므로 성립함 . - 이제 $n=k$일 때 성립한다 가정하고 $n=k+1$일 때 성립하는지 살펴보자 . $P bigg( bigcup limits_{i=1}^{k+1}A_i bigg) = P bigg( bigg( bigcup limits_{i=1}^{k}A_i bigg) bigcup A_{k+1} bigg) quad therefore text{나열해서 보면 당연한 소리} = P bigg( bigcup limits_{i=1}^{k}A_i bigg) + P(A_{k+1}) - P bigg( bigg( bigcup limits_{i=1}^{k}A_i bigg) bigcap A_{k+1} bigg) therefore P(X cup Y) = P(X)+P(Y)-P(X cap Y), quad X to bigcup limits^k_{i=1}A_i, ;Y to A_{k+1} =P bigg( bigcup limits_{i=1}^{k}A_i bigg) + P(A_{k+1}) - P bigg( bigcup limits_{i=1}^{k} big(A_i cap A_{k+1} big) bigg) therefore text{집합의 분배법칙,} ; P bigg( bigcup limits_{i=1}^{k} X_i bigg) = sum limits_{i=1}^{k}P(X_i) - sum limits_{1 leq i &lt; j leq k}^{k}P(X_i cap X_j) + cdots+(-1)^{k-1}P bigg( bigcap limits_{i=1}^{k}X_i bigg) = bigg { sum limits_{i=1}^{k}P(A_i) - sum limits_{1 leq i &lt; j leq k}^{k}P(A_i cap A_j) + cdots+(-1)^{k-1}P bigg( bigcap limits_{i=1}^{k}A_i bigg) bigg } +P(A_{k+1})- bigg { sum limits_{i=1}^{k}P(A_i cap A_{k+1}) - sum limits_{1 leq i &lt; j leq k}^{k}P((A_i cap A_{k+1}) cap A_j) + cdots+(-1)^{k-1}P bigg( bigcap limits_{i=1}^{k}(A_i cap A_{k+1}) bigg) bigg } = sum limits_{i=1}^{k}P(A_i) - sum limits_{1 leq i &lt; j leq k}^{k}P(A_i cap A_j) + cdots+(-1)^{k-1}P bigg( bigcap limits_{i=1}^{k}A_i bigg) +P(A_{k+1})- sum limits_{i=1}^{k}P(A_i cap A_{k+1}) + sum limits_{1 leq i &lt; j leq k}^{k}P((A_i cap A_{k+1}) cap A_j) - cdots+(-1)^{k+1-1}P bigg( bigcap limits_{i=1}^{k+1}A_i bigg) therefore- ,(-1)^{k-1}P bigg( bigcap limits_{i=1}^{k}(A_i cap A_{k+1}) bigg) = (-1)^{k+1-1}P bigg( bigcap limits_{i=1}^{k+1}A_i bigg) = sum limits_{i=1}^{k+1}P(A_i) - sum limits_{1 leq i &lt; j leq k+1}^{k+1}P(A_i cap A_j) + cdots+(-1)^{k+1-1}P bigg( bigcap limits_{i=1}^{k+1}A_i bigg) therefore text{그러므로 $n=k+1$일 때도 성립한다}$ | . - 마지막 부분이 이해가 안될 수 도 있음 . - 일단 $ sum limits_{i=1}^{k}P(A_i)$ 와 $P(A_{k+1})$를 더해서 $ sum limits_{i=1}^{k+1}P(A_i)$가 되는것은 알 것임 . - 그건 맞다고 치자 &gt; 그 다음부터는 뭐임?? . - $- sum limits_{1 leq i &lt; j leq k+1}^{k+1}P(A_i cap A_j)$ &gt; 이건 어떻게 도출됨?? . - 아래식을 보자 . - $ - sum limits_{1 leq i &lt; j leq k}^{k}P(A_i cap A_j)- sum limits_{i=1}^{k}P(A_i cap A_{k+1}) = - sum limits_{1 leq i &lt; j leq k+1}^{k+1}P(A_i cap A_j)$ . - 위 식이 성립하는 것만 이해하면 전부다 이해 가능 &gt; 왜 성립함? &gt; 그냥 나열해보면 성립하는 것을 알 수 있음 &gt; 설명을 더 해보자 . - $P bigg( bigcup limits^{K}_{i=1}A_i bigg)$에서 $P bigg( bigcup limits^{K+1}_{i=1}A_i bigg)$로 업그레이드(?)시킬 수 있다는 것은 $n=k$가 성립하면 $n=k+1$일 때 도 성립한다는 뜻 . - 잘보면 왼쪽식에서 오른쪽식으로 나아가기 위해서는 사건$A_{k+1}$과 연관된 식이 있어야 함 . - 예컨데 $k=3$이라고 해보자 . - $ sum limits_{1 leq i &lt; j leq 3}^{3}P(A_i cap A_j)=P(A_1 cap A_2)+P(A_1 cap A_3)+P(A_2 cap A_3) ; cdots text{식 (1)}$ . - 여기서 $k$대신 $k+1$을 넣어보자 . - $ sum limits_{1 leq i &lt; j leq 3+1}^{3+1}P(A_i cap A_j)=P(A_1 cap A_2)+P(A_1 cap A_3)+P(A_1 cap A_4)+P(A_2 cap A_3)+P(A_2 cap A_4)+P(A_3 cap A_4)$ . - 즉 우리에겐 $n=k$일 때는 존재하지 않는 사건 $A_{k+1}$과 연관된 식인 $P(A_1 cap A_4)+P(A_2 cap A_4)+P(A_3 cap A_4) ; cdots text{식 (2)}$가 있어야 $n=k+1$일 때의 식으로 나아갈 수 있음 &gt; 이 식이 바로 $- sum limits_{i=1}^{k}P(A_i cap A_{k+1})$ . - 식 (1)과 식 (2)가 합쳐져서 $n=k+1$일 때의 식을 만들어 내는 것임 . - $ sum limits_{i=1}^{k}P(A_i) - sum limits_{1 leq i &lt; j leq k}^{k}P(A_i cap A_j) + cdots+(-1)^{k-1}P bigg( bigcap limits_{i=1}^{k}A_i bigg)$ &gt; 식 (1)의 역할, $P(A_{k+1})- sum limits_{i=1}^{k}P(A_i cap A_{k+1}) + sum limits_{1 leq i &lt; j leq k}^{k}P((A_i cap A_{k+1}) cap A_j) - cdots+(-1)^{k+1-1}P bigg( bigcap limits_{i=1}^{k+1}A_i bigg)$ &gt; 식 (2)의 역할 . - 위의 두 식($n leq k$까지의 정보와 $n=k+1$일 때의 정보)이 합쳐져서 $P bigg( bigcup limits^{K+1}_{i=1}A_i bigg)= sum limits_{i=1}^{k+1}P(A_i) - sum limits_{1 leq i &lt; j leq k+1}^{k+1}P(A_i cap A_j) + cdots+(-1)^{k+1-1}P bigg( bigcap limits_{i=1}^{k+1}A_i bigg)$ ($n leq k$까지의 정보)가 되는 것임 .",
            "url": "https://jaesu26.github.io/green/statistics/math/2021/09/11/%ED%8F%AC%ED%95%A8%EB%B0%B0%EC%A0%9C%EC%9D%98%EC%9B%90%EB%A6%AC.html",
            "relUrl": "/statistics/math/2021/09/11/%ED%8F%AC%ED%95%A8%EB%B0%B0%EC%A0%9C%EC%9D%98%EC%9B%90%EB%A6%AC.html",
            "date": " • Sep 11, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "자료구조 큐(queue)",
            "content": "&#53328;(queue) . - 큐(queue)는 기본적인 자료 구조 + 스택(stack)과 반대되는 개념 . - 큐는 먼저 집어 넣은(push) 데이터가 먼저 나오는(pop) FIFO(First In First Out)구조로 되어 있음 &gt; 식당에서 줄 기다리기 &gt; 먼저 줄을 선 사람이 먼저 줄에서 나감( =식당으로 들어감) . - 참고: 자료구조 큐 . &#53328;(queue) &#49324;&#50857; . - 파이썬에서 queue은 from collections import deque를 실행한 후 deque()통해 구현할 수 있다 . - queue.append(x)를 통해 큐에 x를 오른쪽(뒤)에 push한다 . - queue.popleft()를 통해 큐에서 앞의 원소(왼쪽)를 pop한다 . - 참고: queue in python . &#50696;&#51228; . from collections import deque ## 큐(queue)를 사용하기 위해 deque라이브러리 import queue = deque() ## 큐(queue) 자료구조 생성 &gt; deque([]) queue.append(1) ## 큐에 1 추가 &gt; deque([1]) queue.append(2) ## 큐에 2 추가 &gt; deque([1, 2]) queue.popleft() ## 큐에서 앞의 원소를 추출함 &gt; 선입선출 구조 &gt; deque([2]) queue . deque([2]) .",
            "url": "https://jaesu26.github.io/green/python/data%20structure/2021/09/05/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%81%90.html",
            "relUrl": "/python/data%20structure/2021/09/05/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%81%90.html",
            "date": " • Sep 5, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "수리통계학",
            "content": "- 2학기 수업에서 배우는 수리통계학에 대해 정리할 것임 . - 중요한 내용은 따로 정리하여 다른 주피터 노트북 파일로 만들 수 도 있음 . &#54869;&#47456;&#51060;&#47200; . - 확률모형 &gt; 동전 던지기와 같이 가능성(chance)에 의존 . &#54364;&#48376;&#44277;&#44036;&#44284; &#49324;&#44148; . - 표본공간(sample space) : 모든 관찰 가능한 결과들의 집합 &gt; $S$ 또는 $ Omega$ . - 사건(event) : 표본공간의 일부분(부분집합) &gt; $A, B$ 등 영어 알파벳 대문자 . - 실험(experiment) 또는 시행 (trial) : 어떤 현상의 관찰결과를 얻기위한 과정 . 예시 | . - 동전의 앞면을 H, 뒷면을 T라 할 때 동전을 2회 던지는 실험을 시행하자 . - 표본공간 $S = {HH, HT, TH, TT }$ . - 1회 앞면이 나오는 사건 $A = {HT, TH }$ . - 2회 뒷면이 나오는 사건 $B = {TT }$ . 정의 | . - 사건 $A$와 $B$가 동시에 속하는 사건 &gt; $A$와 $B$의 공통부분(intersection) &gt; $A cap B$ . - 사건 $A$ 또는 $B$에 속하는 사건 &gt; $A$와 $B$의 합(union) &gt; $A cup B$ . - $A cap B$ = $ phi$ &gt; 두 사건 $A$와 $B$는 상호배반(mutually exclusive) . - 사건 $A$에 포함되지 않은 모든 $S$의 원소의 집합 &gt; $A$의 여사건(complement) &gt; $A^c$ . 사건에 대한 분배법칙과 드 모르간 법칙 | . - $(A cup B)^c = A^c cap B^c$ &gt; 드 모르간(De Morgan) 법칙 . - $(A cap B)^c = A^c cup B^c$ &gt; 드 모르간 법칙 . - $A cup (B cap C) = (A cup B) cap (A cup C)$ &gt; 분배법칙 . - $A cap (B cup C) = (A cap B) cup (A cap C)$ &gt; 분배법칙 . &#54869;&#47456;&#51032; &#51221;&#51032; . - 확률은 함수임 . 고전적 정의 | . - 표본공간이 유한 개($N$)의 결과로 구성되고 모든 가능한 실험결과들이 일어날 가능성이 동일한경우 $M$개의 실험결과로 이루어진 사건 $A$의 확률 $P(A) = dfrac{M}{N}$ . 상대도수의 극한 | . - 실험을 독립적으로 n회 반복했을 때 사건 $A$의 발생횟수를 m이라 하면 실험이 무한히 반복되면 $P(A) = dfrac{m}{n}$ . &#54869;&#47456; &#44277;&#47532; . 1. 임의의 사건 $A$에 대해 $P(A) geq 0$ . 2. $P(S)=1$ . 3. 표본공간 $S$에 정의된 사건열 $A_1, A_2, cdots$가 있다고 할 때 모든 $i neq j$에 대하여 $A_i cap A_j = phi$이면 $P bigg( bigcup limits_{i=1}^{ infty} A_i bigg) = P(A_1 cup A_2 cup A_3 cup cdots) = sum limits_{i=1}^{ infty} P(A_i)$ . - 3번째 공리는 쉽게 말하자면 서로소인 두 사건 $A$와 $B$에 대해 $P(A) + P(B) = p(A cup B)$이다 + 집합열 이해 안되면 통계수학 책 참고하셈 . - 확률 &gt; 표본공간의 부분집합의 모임(특별한 성질 만족)을 정의역으로 하면서 확률공리를 만족하는 함수 . 정리 | . - 증명은 교재 참고 . 1. $P(A^c) = 1- P(A)$ . 2. $P( phi) = 0$ . 3. $A subset B$이면 $P(A) leq P(B)$ . 4. $P(A cup B)=P(A)+P(B)-P(A cap B)$ . - 정리 4번 사건 3개 버전 . - $P(A cup B cup C) = P(A) + P(B) + P(C) - P(A cap B) - P(B cap C) - P(C cap A) + P(A cap B cap C)$ &gt; 벤 다이어그램을 그려보면 간단히 알 수 있음 . &#51312;&#44148;&#48512; &#54869;&#47456; . - 사건$A$와 $B$가 표본공간 $S$상에 정의되어 있으며 $P(B) &gt; $일 때 $B$가 일어났다는 가정하에 사건 $A$가 일어날 조건부 확률은$P(A mid B) = cfrac{P(A cap B)}{P(B)}$로 정의됨 . - 조건부 확률도 확률 공리를 만족함 . &#51204;&#54869;&#47456; &#44277;&#49885;(total probability) . - 사건 $B_1, B_2, cdots,B_k$ 는 상호배반이며 $(B_1 cap B_j = phi, ;i neq j), ; bigcup limits_{i=1}^{k}B_{i}=S$라고 하자 . - 이때 임의의 사건 $A$에 대하여 $P(A) = sum limits_{i=1}^{k}P(B_i)P(A mid B_i)$가 성립함 . - 증명: $P(A) = P(A cap S) = P bigg[A cap bigg( bigcup limits_{i=1}^{k}B_i bigg) bigg] = sum limits_{i=1}^{k}P(A cap B_i)= sum limits_{i=1}^{k}P(B_i)P(A mid B_i)$ . &#48288;&#51060;&#51592; &#51221;&#47532;(Bayes&#39; theorem) . - 사건 $B_1, B_2, cdots,B_k$ 는 상호배반이며 $(B_1 cap B_j = phi, ;i neq j), ; bigcup limits_{i=1}^{k}B_{i}=S$라고 하자 . - 이때 사건 $A$가 일어났다는 조건하에서 사건 $B_j$가 일어날 확률은 $P(B_j mid A)= cfrac{P(B_j)P(A mid B_j)}{ sum limits_{i=1}^{k}P(B_i)P(A mid B_i)}$ . - 증명(전확률 공식 사용): $P(B_j mid A)= cfrac{P(A cap B_j)}{P(A)}= cfrac{P(B_j)P(A mid B_j)}{P(A)}= cfrac{P(B_j)P(A mid B_j)}{ sum limits_{i=1}^{k}P(B_i)P(A mid B_i)}$ . - $P(B_1), cdots,P(B_k)$는 $B$의 사전확률(prior probability) . - 사건 $A$가 일어났다는 정보가 추가됨 &gt; $P(B_1 mid A), cdots,P(B_k mid A)$는 $B$의 사후확률(posteriori probability) . &#49324;&#44148;&#51032; &#46021;&#47549; . - 두 사건 $A$와 $B$가 $P(A cap B) = P(A) cdot P(B)$를 만족시키면 서로 독립(independent)이라고 함 . &#44221;&#50864;&#51032; &#49688; . &#49692;&#50676;(permutation) . - 서로 다른 n개의 원소 중에서 r개를 선택하여 순서 있게 놓는 것(${_n rm P_r}$) . &#51312;&#54633; . - 서로 다른 n개의 원소 중에서 순서에 관계없이 r개를 선택하는 것($_n rm C_r$) . &#51060;&#54637;&#51221;&#47532; . - $(a+b)^n = sum limits_{k=0}^{n} dbinom{n}{k}a^{k} b^{n-k}$ . &#44057;&#51008; &#44163;&#51060; &#51080;&#45716; &#49692;&#50676; . - $ dbinom{n}{ ;r_1 ; r_2 ; cdots ;r_k ;} = cfrac{n!}{r_1! ; r_2! ; cdots ; r_k!}$ . &#45796;&#54637;&#51221;&#47532; . - $(a_1+a_2+ cdots+a_k)^n= sum limits_{r_1, cdots,r_k in mathbb N}^{r_1+ cdots+r_k=n} dbinom{n}{ ;r_1 ; r_2 ; cdots ;r_k ;} ,a_1^{r_1} ,a_2^{r_2} cdots a_k^{r_k}$ . &#54869;&#47456;&#48320;&#49688; . - 확률변수(random variable) : 실험결과를 표현하는 수치적인 양 . - 확률변수의 값은 실험결과에 따라 정해지므로 비결정적(non-deterministic) . - 확률분포(probability distribution) : 확률변수의 값들이 나올 가능성 . &#54869;&#47456;&#48320;&#49688;&#51032; &#51221;&#51032; . - 확률변수 $ to$ 표본공간 $S$에 정의된 실수값을 가지는 함수(real-valued function) . - 이산형(discrete) - 가질 수 있는 값이 유한개 (finite) 또는 셀 수 있는 무한개(countably infinite)인 확률변수 . - 연속형(continuous) - 가질 수 있는 값의 범위가 실직선상의 어떤 구간인 확률변수 . - 혼합형 - ex) $ {1, 2, (5, 10) }$ . &#54869;&#47456;&#44277;&#44036;(probability space) . - 확률 공간($ Omega, mathcal{F}, Pr)$ 은 전체 측도가 $1$인 측도 공간이다 . - 측도는 집합에 크기를 부여하기 위해 만든 개념으로 가산집합에 실수로 가는 함수를 부여한 것 . - 확률적인 현상에서 확률공간의 측도는 확률을 정의한다 . - 확률공간이 같다는건 $ Omega$가 동일하고 (주사위 던지기 $ Omega= {1,2,3,4,5,6 }$) . - $ mathcal{F}$가 동일하고(예컨대 짝수, 홀수에만 관심이 있어서 $ mathcal{F}= { phi, {1,3,5 }, {2,4,6 }, Omega }$) . - $Pr$이 동일하다는 것(예컨대 짝수, 홀수가 나올 가능성이 다른 주사위라 확률측도가 다음과 같다) . $$ begin{aligned} Pr( phi)&amp;=0.0 Pr( {1,3,5 })&amp;=0.4 Pr( {2,4,6 })&amp;=0.6 Pr( Omega)&amp;=1.0 end{aligned}$$ . - 참고 : https://ko.wikipedia.org/wiki/%ED%99%95%EB%A5%A0_%EA%B3%B5%EA%B0%84 . &#54364;&#48376;&#44277;&#44036; . - 확률실험에서 발생할 수 있는 모든 결과들의 집합을 표본공간(Sample Space) 이라고 한다 . - 표본공간은 $S$ 또는 $ Omega$ 기호로 나타낸다 . - $ Omega= { omega_1, omega_2, cdots, omega_n }$는 가능한 모든 결과를 포함하고 각 원소끼리는 배반이다 . - 예컨대 동전던지기 실험에서 표본공간은 다음과 같이 나타낼 수 있음 &gt; $ Omega= {H,T }$ . - 참고 : https://en.wikipedia.org/wiki/Sample_space . &#49324;&#44148;&#44277;&#44036; . - 표본공간 $ Omega$의 $ sigma$-field를 사건공간(event space) 이라 한다 . - 사건공간의 원소를 사건이라고 한다 . - 사건 : 표본공간의 부분집합 . - 사건공간($ mathcal{F}$) : 사건의 집합 $ Longleftrightarrow$ 표본공간의 $ sigma$-field . - 동전던지기의 경우 사건은 $ phi, {H }, {T }, Omega$이므로 사건공간 중 하나를 다음과 같이 나타낼 수 있음 . - $ mathcal{F}= { phi, {H }, {T }, Omega }$ &gt; $ mathcal{F}$의 원소 하나하나가 사건에 해당함 . - 사건공간 중 하나라고 표현한건 $ sigma$-field 정의에 의해 사건공간은 여러개가 될 수 있기 때문 . - 예컨대 주사위 던지기의 경우에서 주사위의 특정값이 아닌 단지 짝인지 홀인지에만 관심이 있으면 $ mathcal{F}= { phi, {1,3,5 }, {2,4,6 }, Omega }$로 설정해도 된다 . - 참고 : https://en.wikipedia.org/wiki/%CE%A3-algebra . &#54869;&#47456;&#52769;&#46020; . - 측도공간 $( Omega, mathcal{F})$에 대해서 어떤 함수 $ Pr( cdot): mathcal{F} to mathbb{R}$가 다음 세 조건(확률 공리)을 만족하면 $ Pr$을 확률측도라고 한다 . 1. $ Pr(A) geq 0, quad forall A in mathcal{F}$ . 2. $ Pr( Omega)=1$ . 3. Countable, pairwise disjoint set $ {A_1,A_2, cdots mid A_i in mathcal{F} }$에 대하여 $ Pr bigg( bigcap limits_{i=1}^{ infty}A_i bigg)= sum limits_{i=1}^{ infty} Pr(A_i)$ . - 예컨대 동전던지기의 사건공간이 $ mathcal{F}= { phi, {H }, {T }, Omega }$ 라면 위의 조건을 만족하는 확률측도를 아래와 같이 만들 수 있다 . $$ begin{aligned} Pr( phi)&amp;=0.0 Pr( {H })&amp;=0.5 Pr( {T })&amp;=0.5 Pr( Omega)&amp;=1.0 end{aligned}$$ . - 그러나 확률측도는 위의 세 조건인 Kolmogorov axioms를 만족하기만 하면 되기에 확률측도는 하나가 아니다 . - 예컨대 아래와 같이 확률측도를 만들 수 도 있다는 것 . $$ begin{aligned} Pr( phi)&amp;=0.0 Pr( {H })&amp;=0.4 Pr( {T })&amp;=0.6 Pr( Omega)&amp;=1.0 end{aligned}$$ . - 참고로 함수 $ Pr$의 정의역은 $ mathcal{F}$이고 치역은 $ {s in R:0 leq s leq 1 }$이다 . - 참고 : https://gem763.github.io/probability%20theory/%ED%99%95%EB%A5%A0%EC%9D%98-%EC%9D%B4%ED%95%B4.html . - 그런데 $ Pr$이랑 $P$랑 다른거야? &gt; https://stats.stackexchange.com/questions/108441/which-notation-and-why-textp-pr-textprob-or-mathbbp . &#54869;&#47456;(probability) . - 확률공간 $( Omega, mathcal{F}, Pr)$과 특정사건 $A in mathcal{F}$에 대하여 $Pr(A)$을 사건 $A$의 확률이라고 한다 . &#54869;&#47456;&#48128;&#46020;&#54632;&#49688;(pdf) &#48143; &#45572;&#51201;&#48516;&#54252;&#54632;&#49688;(cdf) . &#54869;&#47456;&#48128;&#46020;&#54632;&#49688;(probability density function, pdf) . &#51060;&#49328;&#54805;&#51032; &#44221;&#50864; pdf&#51032; &#51312;&#44148; . 1. 모든 실수 $x$에 대하여 $f(x) geq 0$ . 2. 확률변수 $X$가 가질 수 있는 값 $x_1, ,x_2, , cdots$ 에 대하여 $f(x_i)&gt;0$ 이며 $ sum f(x_i)=1$ . - $f(x)$는 $P(X=x)=f(x)$ 를 만족하고 확률질량함수(probability mass function, pmf)라고도 함 . &#50672;&#49549;&#54805;&#51032; &#44221;&#50864; pdf&#51032; &#51312;&#44148; . 1. 모든 실수 $x$에 대하여 $f(x) geq 0$ . 2. $ int^{ infty}_{- infty}f(x) ,dx = 1$ . - 연속형 확률변수는 가질 수 있는 값이 셀 수 없는 무한개이므로 가능한 값 하나하나에 확률을 부여하지 않음 . - 대신에 구간에 확률을 부여함 . - $P(X=x)=0$ 이고 $- infty &lt; a &lt; b &lt; infty longrightarrow int_{a}^{b}f(x) ,dx=P(a leq X leq b)$ . &#45572;&#51201;&#48516;&#54252;&#54632;&#49688;(cumulative distribution function, cdf) . - 누적분포함수 $F(x) = P(X leq x)$ . - $X sim f(x)$ : 확률변수 $X$가 확률밀도함수 $f(x)$를 가리킴 . - $X sim F(x)$ : 확률변수 $X$가 누적분포함수 $F(x)$를 가리킴 . - $P(a&lt; X leq b) = F(b) - F(a)$ . - $f(x) = dfrac{d}{dx}F(x)$ . &#45572;&#51201;&#48516;&#54252;&#54632;&#49688;&#51032; &#51312;&#44148; . 1. $ lim limits_{x to- infty}F(x)=0$ . 2. $ lim limits_{x to infty}F(x)=1$ . 3. $ lim limits_{h to0+}F(x+h)=F(x) longrightarrow$ 우연속 함수 . 4. $a&lt;b$ 이면 $F(a) leq F(b)$ . &#44208;&#54633; &#48143; &#51312;&#44148;&#48512; &#54869;&#47456;&#48516;&#54252; . &#44208;&#54633; &#54869;&#47456;&#48516;&#54252; . - 여러 개의 확률변수들을 한번에 고려하는 경우에 사용 &gt; ex) 아빠와 아들의 키를 함께 고려 . - 확률벡터 &gt; $ boldsymbol{X} = (X_1, ,X_2, , cdots, ,X_k)$ . - 두 확률변수 $X$와 $Y$의 결합 확률밀도함수 $f_{ ,X, ,Y}(x,y)$ . - 이산형인 경우 : $f_{ ,X, ,Y}(x,y)=P(X=x, ,Y=y)$ . - 연속형인 경우 : 임의의 영역 $A$에 대하여 $P[(X, ,Y) in A]= iint_{ ,A}f_{ ,X, ,Y}(x,y) ,dxdy$ 를 만족하는 $f_{ ,X, ,Y}(x,y)$ . - 통계수학 교재의 통계학에서의 적분과 미분적분학 교재의 적분 공부하기 . &#44208;&#54633; &#45572;&#51201;&#48516;&#54252;&#54632;&#49688; . - 결합 누적분포함수 : $F(x_1, ,x_2, , cdots, ,x_k) = P(X_1 leq x_1, ,X_2 leq x_2, , cdots, ,X_k leq x_k)$ . - $f(x_1, ,x_2, , cdots, ,x_k) = cfrac{ partial^k}{ partial x_1 cdots partial x_k}F(x_1, ,x_2, , cdots, ,x_k)$ . &#51452;&#48320; &#54869;&#47456;&#48516;&#54252; . - 결합분포가 주어졌다고 하자 그런데 각 변수만의 분포가 필요할 수 있음 . - 결합 확률밀도함수 $f_{X,Y}(x,y)$가 주어졌을 때 $f_X(x), ;f_Y(y)$를 주변 확률밀도함수라고 함 . - 주변 확률밀도함수 &gt; marginal probability density function . 이산형인 경우 | . $$f_X(x) = sum limits_{ text{모든 $y$}}f_{X,Y}(x,y), quad f_Y(y) = sum limits_{ text{모든 $x$}}f_{X,Y}(x,y)$$ . 연속형인 경우 | . $$f_X(x) = int^{ infty}_{- infty}f_{X,Y}(x,y) ,dy, quad f_Y(y) = int^{ infty}_{- infty}f_{X,Y}(x,y) ,dx$$ . - 여러개의 확률변수에 대해서도 확장 가능함 . &#51312;&#44148;&#48512; &#54869;&#47456;&#48516;&#54252; . - 조건부 확률의 확률변수 버전 . - 어떤 몇 개의 확률변수 값이 주어졌을 때 다른 확률변수들의 분포 . - $X=x$가 주어졌을 때 $Y mid X=x$의 조건부 확률밀도함수는 $f_{Y mid x}(y mid x)$ 이다 . - 편의상 $Y mid X = x Longleftrightarrow Y mid x$ . - 조건부 확률밀도함수 &gt; conditional probability density function . $$f_{Y mid X=x}(y mid x)= cfrac{f_{X,Y}(x,y)}{f_X(x)} qquad text{단, } f_X(x)&gt;0$$ . &#46021;&#47549;&#54869;&#47456;&#48320;&#49688; . - 두 확률변수 $X$와 $Y$는 임의의 실구간 $A$와 $B$에 대하여 $$ P(X in A, ,Y in B)=P(X in A) cdot P(Y in B)$$ 가 성립할 때 서로 독립(independent)이라고 함 . - 위의 정리를 확률밀도함수를 사용하여 나타내보자 . - 두 확률변수 $X$와 $Y$가 서로 독립일 필요충분조건은 $$f_{X,Y}(x,y)=f_X(x) cdot f_Y(y)$$ . - 두 확률변수 $X$와 $Y$의 독립여부 파악하는 방법! . 1. 결합 확률밀도함수를 통해 $X$와 $Y$의 주변 확률밀도함수를 구한다 . 2. 그리고 $f_{X,Y}(x,y)=f_X(x) cdot f_Y(y)$가 성립하는지 확인한다 . . Tip: 쉬운방법은 $f_{X,Y}(x,y)$가 $X$만의 함수와 $Y$만의 함수로 인수분해 되는지 파악하는 것 . &#44592;&#45843;&#44050; . - 확률변수 $X$의 확률밀도함수가 $f(x)$일 때 $X$의 기댓값(expectation)은 $$E(X)= begin{cases} sum limits_{ text{모든 }x_i}x_{i}f(x_i) quad text{이산형인 경우} int_{- infty}^{ infty}xf(x) ,dx quad text{연속형인 경우} end{cases}$$ . - 단 $E(|X|)&lt; infty$ . - 확률변수 $X$의 기댓값이 아닌 $2X+3$이나 $X^2$ 같은 확률변수의 기댓값이 궁금할 수 있다 . - $Y=g(X)$의 확률밀도함수를 $f_Y(y)$라고 하면 $$E_X[g(X)]=E_Y(Y)= begin{cases} sum limits_{ text{모든 }y_i}y_{i}f_{Y}(y_i) quad text{이산형인 경우} int_{- infty}^{ infty}yf_{Y}(y) ,dy quad text{연속형인 경우} end{cases}$$ . - 만약 $X$의 확률밀도함수를 알고 있으면 $Y$의 확률밀도함수를 구할 필요가 없다 . $$E_X[g(X)]=E_Y(Y)= begin{cases} sum limits_{ text{모든 }x_i}g(x_{i})f_{X}(x_i) quad text{이산형인 경우} int_{- infty}^{ infty}g(x)f_{X}(x) ,dx quad text{연속형인 경우} end{cases}$$ . - $Y=g(X)$의 기댓값을 구하는 데는 위의 두 가지 방법이 가능함 . &#44592;&#45843;&#44050;&#51032; &#49457;&#51656; . - $E(c)=c$ . - $E(aX+b)=aE(X)+b$ . - 두 확률변수 $X$와 $Y$가 서로 독립인 경우 . - $E(XY)=E(X) cdot E(Y)$ . - $E(g(X)h(Y)]=E[g(X)] cdot E[h(Y)]$ . &#48516;&#49328;&#44284; &#44277;&#48516;&#49328; . $$Var(X)=E[X-E(X)]^2=E(X^2)-[E(X)]^2 sigma_{X}= sqrt{Var(X)}$$ - 두 확률변수 $X,Y$의 공분산은 다음과 같다 . $$ begin{aligned}Cov(X,Y)&amp;=E[(X-EX)(Y-EY)] &amp;=E(XY)-E(X)E(Y) end{aligned}$$ &#48516;&#49328;&#51032; &#49457;&#51656; . 1. $Var(aX+b)=a^2Var(X)$ . 2. 확률변수들이 서로 독립이면 $Var bigg( sum limits^{n}_{i=1}X_{i} bigg)= sum limits^{n}_{i=1}Var(X_i)$ . 3. $Cov(X,X)=Var(X)$ . 4. 두 확률변수가 서로 독립이면 $Cov(X,Y)=0$ . 5. $Cov(aX+b,cY+d)=acCov(X,Y)$ . 6. $Var bigg( sum limits^{n}_{i=1}X_{i} bigg)= sum limits^{n}_{i=1}Var(X_{i})+2 mathop{ sum sum} limits_{j&lt;k}Cov(X_j,X_k)$ . &#51312;&#44148;&#48512; &#44592;&#45843;&#44050; . $$E(Y mid X=x)=E_Y(Y)= begin{cases} sum limits_{ text{모든 }y_i}y_{i}f_{Y mid x}(y_i mid x) quad X,Y text{가 이산형인 경우} int_{- infty}^{ infty}yf_{Y mid x}(y mid x) ,dy quad X,Y text{가 연속형인 경우} end{cases}$$ . - (이중 기댓값 정리) 두 확률변수 $X,Y$에 대하여 $E[E(Y mid X)]=E(Y)$ 가 성립함 . - 확률변수 $X$와 $Y$가 독립이면 $E(Y mid x)=E(Y), ;E(X mid y)=E(X) to$ 사건의 독립 확률변수 버전 . - 조건부 분산 : $Var(Y mid x)=E[ {Y-E(Y mid x) }^2 mid x] = E(Y^2 mid x)-[E(Y mid x)]^2$ . - 분산 분해 : $Var(Y) = E[Var(Y mid X)]+Var[E(Y mid X)]$ . - 조건부 분산($E[Var(Y mid X)]$)이 무조건부 분산($Var(Y))$보다 평균적으로 더 작음 . - $Var(E(Y mid X)) leq Var(Y) longrightarrow$ 개별 개체의 산포보다 그룹별 평균의 산포가 작음 . &#54869;&#47456;&#48512;&#46321;&#49885; . - 마코프 확률부등식 : 실함수 $u(X) &gt; 0$라고 할 때 $P[u(X) geq c] leq dfrac{E[u(X)]}{c}$ . - 체비셰프 부등식 : $P(|X- mu| &lt; k sigma) geq 1- dfrac{1}{k^2}$ . - 코시-슈바르츠 부등식 : $[E(XY)]^2 leq E(X^2) cdot E(Y^2)$ . &#54364;&#48376;&#48516;&#54252; &#48143; &#44536;&#51032; &#44540;&#49324; . &#45824;&#49688;&#51032; &#48277;&#52825;&#44284; &#51473;&#49900;&#44537;&#54620;&#51221;&#47532; . &#54869;&#47456; &#49688;&#47156; . - 확률변수의 열 $X_1,X_2, cdots,X_n, cdots$과 확률변수 $X$가 같은 확률공간에 정의된다고 하자 . - 확률변수의 열을 모르면 다음을 참고하자 : https://www.probabilitycourse.com/chapter7/7_2_2_sequence_of_random_variables.php . - 만약 임의의 $ epsilon&gt;0$에 대해 $ lim limits_{n to infty}P(|X_n-X| geq epsilon)=0$ 또는 $ lim limits_{n to infty}P(|X_n-X|&lt; epsilon)=1$ 이라면 . - $X_n$이 $X$로 확률적으로 수렴한다고 하고 $X_n{ xrightarrow{~~p~~}} X$로 표기 : 확률 수렴(convergence in probability) . - 확률 수렴이 무엇인지 뭔가 직관적으로 와닿지 않는다 . - 일단 수열의 수렴을 생각해보자 . - 예컨데 $1, dfrac{1}{2}, dfrac{1}{4}, dfrac{1}{8}, cdots $ 와 같은 수열이 있다고 하자 . - 위의 수열을 다음과 같이 나타낼 수 있음 &gt; $a_n= dfrac{1}{2^n}, ;n in mathbb{N}$ . - 여기서 $n to infty$ 이면 $a_n to 0$임을 알 수 있다 . - 즉 $n$이 커지면 어떠한 상수 $a$로 수렴한다는 것 . - 수열 대신 확률변수의 열인 경우도 똑같이 생각하면 된다 . - 예컨대 다음과 같은 확률변수의 열이 있다고 해보자 . - $X_1,X_2, cdots,X_n$ . - 그런데 $X_1 sim EXP(1), ; X_2 sim EXP(2), ; cdots, ;X_n sim EXP(n)$ 라고 하자 . - 즉 $X_n sim EXP(n)$, 예컨대 $n=3$이면 $X_3 sim EXP(3)$ . - 참고로 $EXP(n)$에서 $n$은 포아송분포의 모수 $ lambda$를 의미한다 . - 만약 $n to infty$ 이면 $X_n to 0$가 되고 이는 $X_n xrightarrow{~~p~~}0$ . $$ begin{aligned} lim limits_{n to infty} P(|X_n-X| geq epsilon)&amp;= lim limits_{n to infty} P(|X_n-0| geq epsilon) &amp;= lim limits_{n to infty} P(X_n geq epsilon) quad (X_n geq 0 text{ as } X_n sim EXP(n)) &amp;= lim limits_{n to infty} 1-F_{X_n}( epsilon) &amp;= lim limits_{n to infty} 1-(1-e^{-n epsilon}) &amp;= lim limits_{n to infty} e^{-n epsilon} &amp;=0, quad forall epsilon geq 0 end{aligned}$$- 따라서 $X_n xrightarrow{~~p~~}0$ . - 다시 말하자면 확률변수의 열 $X_1,X_2, cdots,X_n$은 zero random variable $X$로 확률 수렴한다 . - 참고 : https://www.probabilitycourse.com/chapter7/7_2_5_convergence_in_probability.php . - 근데 문득 궁금한점이 생겼다 . - $X_1,X_2, cdots,X_n$은 같은 확률공간에 존재하는건가? . - $ Omega, mathcal{F}$는 같다 . - 그런데 $ Pr$은? . - $ Pr$이 같다면 예컨대 $ Pr(1&lt;X&lt;2)$가 $X_1,X_2, cdots,X_n$에 대해서 같아야 하는거 아닌가? . - 하지만 $X_1,X_2, cdots,X_n$ 각각의 pdf는 다르기에 $ Pr(1&lt;X&lt;2)$도 다르다 . - 그럼 같은 확률공간이 아닌건가? . - 아니면 임의의 실수 $a$에 대해서 $ Pr(a)=0$이니까 똑같나? . - 그냥 내가 확률공간의 의미를 잘못알고 있는 걸수도... . - 위에 대한 나의 생각 : $ Pr$은 $ mathcal{F}$를 $[0,1]$로 맵핑하는 함수다 &gt; 예컨대 동전던지기의 경우 $ Pr( {H })= dfrac{1}{2}$ . - $ Pr(1&lt;X&lt;2)$에서 $1&lt;X&lt;2$는 $ mathcal{F}$ 중에서 하나의 사건에 해당한다(?) . - $ Pr$은 $1&lt;X&lt;2$를 $f_X(x)$ 그래프 상에서 전체면적($1$) 대비 $1&lt;x&lt;2$ 아래의 면적의 차지 비율에 맵핑한다 . - 예컨대 정규분포의 경우 $ Pr(0&lt;X&lt; infty) = 0.5$이다 . - 위의 경우 $ Pr$은 $ mathcal{F}$를 $f_X(x)$ 그래프 상에서 전체면적($1$) 대비 $ mathcal{F}$에 해당하는 아래의 면적의 차지 비율에 맵핑한다 . - 즉 $X_1,X_2, cdots,X_n$ 각각의 pdf는 다르기에 $ Pr(1&lt;X&lt;2)$도 다르지만 $ Pr$ 함수의 규칙은 같으므로 같은 확률공간에 있다고 한다(?) . &#45824;&#49688;&#51032; &#48277;&#52825; . - 평균이 $ mu&lt; infty$인 확률밀도함수 $f(x)$로부터 랜덤표본 $X_1,X_2, cdots,X_n$을 얻었다면 $ overline{X_n} xrightarrow{~~p~~} mu$가 성립 : 대수의 법칙(law of large numbers) . &#48516;&#54252; &#49688;&#47156; . - 확률변수의 열 $X_1,X_2, cdots,X_n, cdots$이 누적분포함수 $F_{X_1},F_{X_2}, cdots,F_{X_n}, cdots$을 각각 갖고 $X sim F_X$라고 하자 . - 만약 함수 $F_X$가 연소긴 모든 점 $x$에서 $ lim limits_{n to infty}F_{X_n}=F_X(x)$가 만족된다면 . - $X_n$이 $X$로 분포 수렴한다고 말하고 $X_n{ xrightarrow{~~d~~}} X$로 표기 : 분포 수렴(convergence in distribution) .",
            "url": "https://jaesu26.github.io/green/statistics/2021/09/03/%EC%88%98%EB%A6%AC%ED%86%B5%EA%B3%84%ED%95%99.html",
            "relUrl": "/statistics/2021/09/03/%EC%88%98%EB%A6%AC%ED%86%B5%EA%B3%84%ED%95%99.html",
            "date": " • Sep 3, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "이진 탐색(Binary search)",
            "content": "&#51060;&#51652; &#53456;&#49353;(Binary search) . - 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘 . - 처음 중간의 값을 임의의 값으로 선택하고 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 사용 . - 처음 선택한 중앙값이 만약 찾는 값보다 크면 그 값은 새로운 최댓값이 되며 작으면 그 값은 새로운 최솟값이 됨 . - 검색 원리상 정렬된 리스트에만 사용할 수 있다는 단점이 있지만 검색이 반복될 때마다 목표값을 찾을 확률은 두 배가 되므로 속도가 빠르다는 장점 &gt; $O(logN)$ . - 참고: 이진 탐색 . &#51060;&#51652; &#53456;&#49353; &#44396;&#54788; . - 정렬된 array에서 target의 위치를 이진 탐색으로 찾는 코드를 구현하자 . - 이 코드를 통해 1~100 숫자(arr)에서 88(target)을 찾는 과정을 살펴보자 . def binary_search(arr, target): arr.sort() ## 리스트를 오름차순으로 정렬 low = 0 high = len(arr) - 1 ## arr의 첫번째 인덱스(low)부터 마지막 인덱스(high)까지 탐색 while low &lt;= high: mid = (high + low) // 2 print(&#39;low: {} nhigh: {} nmid: {}&#39;.format(low, high, mid)) if arr[mid] == target: ## 원하는 값을 찾으면 mid(인덱스)를 반환 return mid elif arr[mid] &gt; target: ## 원하는 값이 중간점보다 작은 경우 왼쪽 부분 탐색 high = mid - 1 else: low = mid + 1 ## 원하는 값이 중간점보다 큰 경우 오른쪽 부분 탐색 return False ## 원하는 값이 arr에 없는 경우 . arr = list(range(1, 101)) target = 88 binary_search(arr, target) . low: 0 high: 99 mid: 49 low: 50 high: 99 mid: 74 low: 75 high: 99 mid: 87 . 87 . - 우리가 찾는 target인 88은 arr의 87번째 인덱스 값이라고 한다 . arr[87] . 88 . - 진짜임 . - 어떤 과정을 거쳐서 87번째 인덱스라는 것을 알려준 것일까? . - arr은 1부터 100까지의 값임 . 1. 1 2 3 $ cdots$ 98 99 100 &gt; low는 0이고 high는 99이므로 mid는 49임 . 2. arr[mid(49)] = 50는 target(88)보다 작으므로 arr[mid(49)+1] ~ arr[high(99)] 를 탐색하면 target(88)이 존재할 것임 . 3. 51 52 53 $ cdots$ 98 99 100 &gt; low는 50이고 high는 99이므로 mid는 74임 . 4. arr[mid(74)]는 target(88)보다 작으므로 arr[mid(74)+1] ~ arr[high(99)] 를 탐색하면 target(88)이 존재할 것임 . 5. 76 77 78 $ cdots$ 98 99 100 &gt; low는 75이고 high는 99이므로 mid는 87임 . 6. arr[mid(87)]는 target(88)과 동일하므로 mid(87)를 return한다 . &#51060;&#51652; &#53456;&#49353; &#49884;&#44036; &#48373;&#51105;&#46020; . - 시간 복잡도는 $O(logN)$이다 . - 위에서 1~100사이에서 target을 찾는 과정을 살펴봤음 . - 탐색 범위를 $N$이라고 한다면 처음에는 $N$만큼 탐색함 . - 그 다음에는 $ frac{N}{2}$만큼 탐색함 . - 또 그 다음에는 $ frac{N}{4}$만큼 탐색함 . - 이를 살펴보면 탐색 범위는 $N, frac{N}{2}, frac{N}{4}, cdots , 1$ . - 시간 복잡도는 알고리즘의 의해 수행되는 기본 연산의 개수를 보면 알 수 있음 . - 연산 횟수(탐색 반복 횟수)를 $k$라고 하면 처음 탐색($k=1$)때의 탐색 범위는 $N$, 두번째 탐색($k=2$)때의 탐색 범위는 $ frac{N}{2}$이며 이를 계속하면 탐색 범위는 $1$이 됨 . - 위의 관계식을 통해 $N times( frac{1}{2})^{k} = 1$임을 알 수 있고 이를 정리하면 $k=log_{2}N$임 . - Big O 표기법에서 로그의 밑은 영향이 없으므로 이진 탐색의 시간 복잡도는 $O(logN)$이라고 할 수 있음 &gt; 이해 안되면 통계수학 big O 표기법 다시 보기 .",
            "url": "https://jaesu26.github.io/green/python/algorithm/2021/08/31/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89.html",
            "relUrl": "/python/algorithm/2021/08/31/%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89.html",
            "date": " • Aug 31, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "자료구조 스택(stack)",
            "content": "&#49828;&#53469;(stack) . - 스택(stack)은 기본적인 자료 구조 . - 스택은 자료를 넣고(push) 자료를 빼는(pop) 입구가 같은 선형 구조(LIFO - Last In First Out)으로 되어 있음 . - 참고: 자료구조 스택 . &#49828;&#53469;(stack) &#49324;&#50857; . - 파이썬에서 stack은 list를 통해 구현할 수 있다 . - stack.append(x)를 통해 스택에 x를 오른쪽(뒤)에 push한다 . - stack.pop()을 통해 스택의 마지막 원소를 pop한다 . &#50696;&#51228; - &#51228;&#47196; . 문제 출처: 백준 10773번 | . - 스택(stack)의 기본적인 push와 pop을 이요하면 된다 . - 0이 입력되면 pop하고 그 외에 수가 입력되면 push한다 . K = int(input()) stack = list() ## stack = []와 동일 for _ in range(K): num = int(input()) if num == 0: stack.pop() else: stack.append(num) print(sum(stack)) . 0 .",
            "url": "https://jaesu26.github.io/green/python/data%20structure/2021/08/30/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8A%A4%ED%83%9D.html",
            "relUrl": "/python/data%20structure/2021/08/30/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8A%A4%ED%83%9D.html",
            "date": " • Aug 30, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "자료구조 힙(heap)",
            "content": "&#55193;(heap) . - 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리 자료구조 . - 힙 속성 &gt; A가 B의 부모노드(parent node) 이면 A의 키(key)값과 B의 키값 사이에는 대소관계가 성립 . - 최대 힙: 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙 . - 최소 힙: 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙 . - 키(key)값의 대소관계는 오로지 부모노드와 자식노드 간에만 성립하며 특히 형제 사이에는 대소관계가 정해지지 않음 . - 대개 자식노드 개수가 최대 2개인 이진 힙(binary heap)을 사용함 . - 데이터의 최대값(최대 힙) or 최소값(최소 힙)을 찾는데 $O(1)$이 소요됨 &gt; 루트노드에 저장되어 있으므로 . - 데이터의 삽입과 삭제는 $O(logN)$이 소요됨 . - 참고: 자료구조 힙 . &#55193;(heap) &#49324;&#50857; . - 파이썬의 heapq 모듈은 최소 힙이다 . - 힙(Heap) 구조 그림으로 보기 &gt; 힙 구조 &gt; 이거 보면 무조건 이해 가능 . - 힙을 코드로 구현하기 전에 필요한 함수를 공부하자 . - heapq.heappush(heap, item) &gt; item을 heap에 추가함 . - heapq.heappop(heap) &gt; heap에서 가장 작은 원소(루트 노드)를 pop(추출)하고 비어 있으면 IndexError . - heapq.heapify(x) &gt; 리스트 x를 heap 자료 구조로 변환함 . - 참고: heapq . &#50696;&#51228;: &#52852;&#46300; &#54633;&#52404; &#45440;&#51060; . 문제 출처: 백준 15903번 | . - 카드 더미의 최소값 2개를 뽑은다음 두 숫자를 두 수의 합으로 바꿔주는 것을 반복하면 됨 . - 최소값 2개를 뽑으면 되니 Heap을 사용하자 . - Heap에서 최소값 추출은 $O(1)$ 삽입과 삭제는 $O(logN)$이므로 다른 구조보다 효율적으로 문제를 해결할 수 있음 . import heapq n, m = map(int, input().split()) cards = list(map(int, input().split())) heapq.heapify(cards) ## list인 cards를 Heap구조로 변홤함 for _ in range(m): two_card_sum = heapq.heappop(cards) + heapq.heappop(cards) ## 최소값 2개(제일 작은 값과 두 번째로 작은 값)를 뽑음 heapq.heappush(cards, two_card_sum) ## 두 수를 두 수의 합으로 바꿔줌 heapq.heappush(cards, two_card_sum) ## 그리고 cards 에 push한다 print(sum(cards)) . 19 .",
            "url": "https://jaesu26.github.io/green/python/data%20structure/2021/08/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%9E%99.html",
            "relUrl": "/python/data%20structure/2021/08/26/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%9E%99.html",
            "date": " • Aug 26, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "R 프로그래밍",
            "content": "참고: R 프로그래밍 - 허명회 지음 . - R 프로그래밍에 대해 복습할 겸 간단히 정리 + 파이썬에서 할 필요없이 그냥 처음부터 R로 만들었으면 됐음...... . 2&#51109; - &#48289;&#53552;(vector) . - 데이터 컨테이너의 기본형 . &#48289;&#53552; . import rpy2 %load_ext rpy2.ipython . The rpy2.ipython extension is already loaded. To reload it, use: %reload_ext rpy2.ipython . %%R x &lt;- 1 is.vector(x) . [1] TRUE . - x는 길이가 1인 벡터 = 스칼라 . %%R print(pi) print(pi, 16) . [1] 3.141593 [1] 3.141592653589793 . - π는 숫자가 예약되어 있는 스칼라 . %%R M &lt;- matrix(1:12, nrow = 4, ncol = 3, byrow = T) M . [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 [3,] 7 8 9 [4,] 10 11 12 . - M은 행렬 &gt; 벡터의 2차원 배열 . &#51064;&#45937;&#49905; . %%R f &lt;- c(1, 1, 2, 3, 5, 8, 13, 21) f[5] . [1] 5 . %%R f[1:5] . [1] 1 1 2 3 5 . %%R f[-c(1,4)] . [1] 1 2 5 8 13 21 . %%R f[c(1,2,4)] . [1] 1 1 3 . seq()&#50752; rep() &#54632;&#49688; . - seq(a, b, by = c)는 a부터 b까지 c간격으로 등차수열 생성 . %%R seq(0, 10, 2.5) . [1] 0.0 2.5 5.0 7.5 10.0 . - seq(a, b, length = n)는 a부터 b까지 길이가 n인 일정 간격 수열을 생성 . %%R seq(0, 10, length = 11) . [1] 0 1 2 3 4 5 6 7 8 9 10 . - rep(x, times = k)는 x의 각 요소가 k의 각 요소씩 반복된 벡터 . %%R rep(NA, 5) . [1] NA NA NA NA NA . %%R rep(c(1, 2), 3) . [1] 1 2 1 2 1 2 . %%R rep(c(1, 2, 3), c(3, 2, 1)) . [1] 1 1 1 2 2 3 . - rep(x, each = k)는 x의 각 요소가 각각 k번 반복된 벡터 . %%R rep(c(1, 2), each = 3) . [1] 1 1 1 2 2 2 . &#54596;&#53552;&#47553; . - 조건에 부합하는 데이터 값만 추출 . %%R x &lt;- 1:10 x[x %% 2 == 1] . [1] 1 3 5 7 9 . %%R subset(x, x %% 2 == 0) . [1] 2 4 6 8 10 . ifelse() &#54632;&#49688; . - ifelse(x, yes, no)는 x가 True이면 yes를 값으로 하고 False이면 no를 값으로 배출 . %%R x &lt;- 1:10 x1 &lt;- ifelse(x %% 2 == 0, x, 2*x) cbind(x, x1) . x x1 [1,] 1 2 [2,] 2 2 [3,] 3 6 [4,] 4 4 [5,] 5 10 [6,] 6 6 [7,] 7 14 [8,] 8 8 [9,] 9 18 [10,] 10 10 . names() &#54632;&#49688; . - names(x)는 벡터x의 개별 요소에 이름을 부여함 . %%R era &lt;- c(5, 4 ,3, 4 ,5, 6) era . [1] 5 4 3 4 5 6 . - paste()함수는 2개의 문자열 벡터를 sep인수로 붙인다 . %%R names(era) &lt;- paste(&quot;y&quot;, 2001:2006, sep = &quot;-&quot;) era . y-2001 y-2002 y-2003 y-2004 y-2005 y-2006 5 4 3 4 5 6 . 3&#51109; - &#54665;&#47148;(matrix) . - $p$개의 길이 $n$인 벡터를 열에 배치함 . &#54665;&#47148; . %%R n &lt;- 100 p &lt;- 3 x &lt;- rnorm(n*p) A &lt;- matrix(x, nrow = n, ncol = p) A[1:6, ] . [,1] [,2] [,3] [1,] -0.5272115 -0.09766999 0.9157430 [2,] -0.4910666 0.27630674 -0.4863826 [3,] -0.7199871 -1.37864849 -0.1378880 [4,] -0.2978141 1.21144373 -1.1352895 [5,] -0.9412001 -1.05635910 1.0677189 [6,] -0.4909131 0.92592424 -1.8697058 . - 콤마(,)앞은 행, 콤마(,)뒤는 열 . %%R A[1:6, 1:2] . [,1] [,2] [1,] -0.5272115 -0.09766999 [2,] -0.4910666 0.27630674 [3,] -0.7199871 -1.37864849 [4,] -0.2978141 1.21144373 [5,] -0.9412001 -1.05635910 [6,] -0.4909131 0.92592424 . - 필터링을 통해 인덱싱도 가능 . %%R A[A[,3] &gt; 0 &amp; A[,2] &gt; 0, ] . [,1] [,2] [,3] [1,] -1.632001082 0.95386709 0.34696994 [2,] -0.388047387 0.75046872 0.61005479 [3,] -1.325637032 0.85805657 0.48388600 [4,] 1.027718630 1.93877622 0.04144039 [5,] -0.926911907 0.57212123 1.66361085 [6,] 2.120355231 0.25362934 0.64836355 [7,] 1.038120371 0.01903657 0.04071902 [8,] -0.973632914 0.35330337 0.35594054 [9,] 1.799568590 1.98855528 0.50952846 [10,] 0.633299053 1.03079130 0.23844919 [11,] -0.178793903 0.66631102 1.11482316 [12,] 1.307643075 0.14501150 0.41404295 [13,] 0.005313813 2.02583488 0.33820766 [14,] -0.280283865 1.04242405 1.33195196 [15,] 0.270559357 0.05230981 0.35938639 [16,] -1.485066480 0.41976340 0.59734787 [17,] -0.076204339 0.97655368 1.99341983 [18,] 2.316420281 0.05287762 0.27840240 [19,] -0.661999001 0.28495938 1.43514281 [20,] -0.713879760 0.15816804 0.71605743 [21,] -0.095003851 1.13276296 0.74928887 [22,] 0.087418924 1.66296778 0.47576952 [23,] -1.055728878 0.56180370 1.26128539 [24,] 1.153290080 0.27938929 0.58182072 [25,] 1.348495993 0.30003159 1.17131650 [26,] -0.815336296 0.74215461 0.03795627 . - t(A) 함수는 행렬 A의 전치행렬을 구해줌 . %%R B &lt;- matrix(1:9, 3, 3) B . [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 . %%R t(B) . [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 [3,] 7 8 9 . - solve()함수는 역행렬을 구해줌 . %%R C &lt;- matrix(c(16 ,4, 1, 4, 4, 1, 1, 1, 1), 3, 3) C . [,1] [,2] [,3] [1,] 16 4 1 [2,] 4 4 1 [3,] 1 1 1 . %%R solve(C) . [,1] [,2] [,3] [1,] 0.08333333 -0.08333333 0.0000000 [2,] -0.08333333 0.41666667 -0.3333333 [3,] 0.00000000 -0.33333333 1.3333333 . - %*%는 행렬곱 . %%R solve(C) %*% C . [,1] [,2] [,3] [1,] 1.000000e+00 -5.551115e-17 -1.387779e-17 [2,] 1.665335e-16 1.000000e+00 5.551115e-17 [3,] 0.000000e+00 0.000000e+00 1.000000e+00 . - 참고로 $AA^{-1} = I$ . - $I$는 단위행렬 . apply() &#54632;&#49688; . - apply(A, 1 or 2, f) &gt; 행렬A의 행(1) or 열(2)에 함수 f를 적용 . - c(1, 2)는 행과 열에 적용 &gt; 각 원소 . %%R M &lt;- matrix(1:12, 3, 4) M . [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 . - apply에서 옵션을 1(행)로 하니 전치된 행렬을 반환함 . %%R max_ = apply(M, 2, max) apply(M, 1, &quot;-&quot;, max_) . [,1] [,2] [,3] [1,] -2 -1 0 [2,] -2 -1 0 [3,] -2 -1 0 [4,] -2 -1 0 . %%R max_ = apply(M, 2, max) t(apply(M, 1, &quot;-&quot;, max_)) . [,1] [,2] [,3] [,4] [1,] -2 -2 -2 -2 [2,] -1 -1 -1 -1 [3,] 0 0 0 0 . - apply에서 옵션을 2(열)로 하니 문제 없어보임 . %%R max_ = apply(M, 1, max) apply(M, 2, &quot;-&quot;, max_) . [,1] [,2] [,3] [,4] [1,] -9 -6 -3 0 [2,] -9 -6 -3 0 [3,] -9 -6 -3 0 . - 옵션을 c(1, 2)로 하니 각 원소에서 -1을 수행함 . %%R apply(M, 1:2, &quot;-&quot;, 1) . [,1] [,2] [,3] [,4] [1,] 0 3 6 9 [2,] 1 4 7 10 [3,] 2 5 8 11 . - 행렬의 각 열에 대해 최소값 0과 최대값 1이 되도록 변환 . %%R n &lt;- 5 p &lt;- 4 M &lt;- matrix(rnorm(n*p), n, p) M . [,1] [,2] [,3] [,4] [1,] 0.39140070 0.41656975 0.3387848 0.15505716 [2,] 1.82931560 -1.25805693 -1.3580300 0.08618929 [3,] -0.07224563 -0.01837199 1.1249997 0.16007225 [4,] 1.05756759 -0.33926353 0.8730712 -0.51535640 [5,] 1.35992572 0.06295887 0.2480695 -2.54631691 . %%R min_ &lt;- apply(M, 2, min) max_ &lt;- apply(M, 2, max) M.1 &lt;- t(apply(M, 1, &quot;-&quot;, min_)) M.2 &lt;- t(apply(M.1, 1, &quot;/&quot;, max_-min_)) M.2 . [,1] [,2] [,3] [,4] [1,] 0.2438240 1.0000000 0.6833647 0.9981469 [2,] 1.0000000 0.0000000 0.0000000 0.9727005 [3,] 0.0000000 0.7402754 1.0000000 1.0000000 [4,] 0.5941503 0.5486557 0.8985399 0.7504318 [5,] 0.7531555 0.7888420 0.6468306 0.0000000 . rownames()&#50752; colnames() &#54632;&#49688; . - 행렬의 행과 열에 이름을 붙임 . %%R n &lt;- 10 x &lt;- matrix(round(rnorm(n*4, 50, 10)), n, 4) ## 평균이 50, 표준편차가 10인 정규분포에서 난수 40개 추출 rownames(x) &lt;- paste(&quot;S&quot;, 1:n, sep = &quot;&quot;) colnames(x) &lt;- c(&quot;math&quot;, &quot;engl&quot;, &quot;science&quot;, &quot;arts&quot;) x . math engl science arts S1 48 63 48 42 S2 40 46 45 60 S3 48 47 65 54 S4 29 53 56 35 S5 42 63 42 46 S6 30 67 57 55 S7 59 44 41 47 S8 44 48 40 60 S9 45 67 43 58 S10 66 54 72 73 . 4&#51109; - &#47532;&#49828;&#53944;(list) . - R에서 가장 일반적인 데이터 형태 . %%R members &lt;- list(leaders = c(&quot;gang&quot;, &quot;iu&quot;), assisstants = &quot;kang&quot;) members . $leaders [1] &#34;gang&#34; &#34;iu&#34; $assisstants [1] &#34;kang&#34; . - class(X) 함수는 X의 type을 알려줌 . %%R class(members) . [1] &#34;list&#34; . - names()함수로 요소의 라벨을 확인 + 변경 가능 . %%R print(names(members)) names(members)[2] &lt;- &quot;workers&quot; print(names(members)) . [1] &#34;leaders&#34; &#34;assisstants&#34; [1] &#34;leaders&#34; &#34;workers&#34; . &#47532;&#49828;&#53944;&#50640; &#51217;&#44540;&#54616;&#44592; . - [[ ]] 사용 . %%R members[[1]] . [1] &#34;gang&#34; &#34;iu&#34; . - [ ]은 sublist . - [[ ]]은 벡터이고 [ ]은 리스트임 . %%R members[1] . $leaders [1] &#34;gang&#34; &#34;iu&#34; . - 요소 이름 사용 . %%R members[[&quot;leaders&quot;]] . [1] &#34;gang&#34; &#34;iu&#34; . - $ 기호 사용 &gt; 개인적으로 제일 편함 . %%R members$leaders . [1] &#34;gang&#34; &#34;iu&#34; . - 리스트 내 자료 값 변경도 가능 . %%R members$leaders[1] &lt;- &quot;park&quot; members . $leaders [1] &#34;park&#34; &#34;iu&#34; $workers [1] &#34;kang&#34; . lapply()&#50752; sapply() &#54632;&#49688; . - matrix에서 apply() 함수를 사용하듯이 리스트에선 lapply()와 sapply() 함수를 사용 . - lapply(list, fun)는 list 내 요소들에 함수 fun을 적용하여 결과를 리스트로 출력 &gt; sapply() 는 벡터로 출력 . %%R salaries &lt;- list(leaders = c(250, 200), assistant = 100, members = c(300, 200, 180, 120 ,100)) salaries . $leaders [1] 250 200 $assistant [1] 100 $members [1] 300 200 180 120 100 . - lapply() 사용 . %%R lapply(salaries, mean) . $leaders [1] 225 $assistant [1] 100 $members [1] 180 . - sapply() 사용 . - 벡터로 출력이 불가능할 때는 lapply() 처럼 list로 출력함 . %%R sapply(salaries, mean) . leaders assistant members 225 100 180 . 5&#51109; - &#45936;&#51060;&#53552; &#54532;&#47112;&#51076;(data frame) . - matrix는 요소가 숫자만 가능했다면 data frame은 문자열과 같은 다른 type도 가능함 . - 데이터 프레임은 리스트의 일종 . - 리스트는 각 변수마다 길이가 달라도 되지만 데이터 프레임은 각 변수마다 길이가 같아야 함(열의 길이가 동일) . %%R course.id &lt;- c(1, 2, 3, 4 ,5, 6 ,7, 8, 9 ,10) mid &lt;- c(8, 22, 25, 25 ,21, 12, 12, 29, 40, 25) final &lt;- c(11, 24, 31, 13 ,34 ,26, NA ,36, 34 ,38) exams &lt;- data.frame(course.id, mid, final) exams . course.id mid final 1 1 8 11 2 2 22 24 3 3 25 31 4 4 25 13 5 5 21 34 6 6 12 26 7 7 12 NA 8 8 29 36 9 9 40 34 10 10 25 38 . %%R is.list(exams) . [1] TRUE . %%R colnames(exams) . [1] &#34;course.id&#34; &#34;mid&#34; &#34;final&#34; . %%R names(exams) . [1] &#34;course.id&#34; &#34;mid&#34; &#34;final&#34; . %%R length(exams) . [1] 3 . - [row, column]으로 인덱싱 . %%R exams[exams$mid &gt; 20, ] . course.id mid final 2 2 22 24 3 3 25 31 4 4 25 13 5 5 21 34 8 8 29 36 9 9 40 34 10 10 25 38 . %%R exams[exams$mid &gt; 20, &#39;final&#39;] ## exams[exams$mid &gt; 20, 3] 과 동일함 . [1] 24 31 13 34 36 34 38 . - 데이터 프레임의 각 열은 수치 벡터이므로 연산 가능 . %%R mean(exams[, &quot;mid&quot;]) . [1] 21.9 . %%R mean(exams$final) . [1] NA . - 값이 NA로 나옴 &gt; 7번 학생이 기말시험을 결시함 . - 그럼 어떻게 평균을 구하지? &gt; na.rm = T 옵션을 통해 NA를 제외한 데이터만 사용할 수 있음 . %%R mean(exams$final, na.rm = T) . [1] 27.44444 . - 만약 시험을 결시한 경우 0점 처리 한다면? &gt; is.na() 함수를 통해 NA인 경우 True를 아닌 경우 False를 생성하여 처리 가능 . %%R is.na(exams$final) . [1] FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE . %%R exams$final[is.na(exams$final)] &lt;- 0 ## is.na가 True인 경우만 0으로 변경 exams . course.id mid final 1 1 8 11 2 2 22 24 3 3 25 31 4 4 25 13 5 5 21 34 6 6 12 26 7 7 12 0 8 8 29 36 9 9 40 34 10 10 25 38 . %%R mean(exams$final) . [1] 24.7 . &#46160; &#45936;&#51060;&#53552; &#54532;&#47112;&#51076;&#51032; &#48337;&#54633; . - exams 변수는 중간 기말 성적이 기록되어 있음 . - 새로운 변수 book은 과제와 프로젝트 점수가 student_name의 순서로 정렬되어 있음 . - 이 둘을 합쳐보자 . %%R student_name &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;) homework &lt;- c(22, 34, 31, 24, 37, 36, 37, 28, 37, 34) project &lt;- c(NA, 7, NA, NA, 17 ,10, 8, NA ,4, NA) course.id &lt;- c(8, 10, 5, 1, 4, 2, 3 ,9 ,7 ,6) book &lt;- data.frame(student_name, homework, project, course.id) book . student_name homework project course.id 1 a 22 NA 8 2 b 34 7 10 3 c 31 NA 5 4 d 24 NA 1 5 e 37 17 4 6 f 36 10 2 7 g 37 8 3 8 h 28 NA 9 9 i 37 4 7 10 j 34 NA 6 . - NA는 자료의 수치 연산을 불가능하게 하므로 앞서 했던것처럼 is.na()를 통해 0점 처리하자 . %%R book$project[is.na(book$project)] &lt;- 0 book . student_name homework project course.id 1 a 22 0 8 2 b 34 7 10 3 c 31 0 5 4 d 24 0 1 5 e 37 17 4 6 f 36 10 2 7 g 37 8 3 8 h 28 0 9 9 i 37 4 7 10 j 34 0 6 . - 2개의 데이터 프레임을 통합하고자 할 때 확인할 것은 각 데이터 프레임에서 개체들의 정렬순서 . 1. 2개의 프레임에서 순서가 같은 경우 열 묶음(cbind)를 한다 &gt; cbind(exams, book) . - 하지만 course.id의 순서가 다르므로 불가능 . 2. 2개의 프레임에서 그 순서가 다른 경우 공통 개체 식별자(key)를 찾아 정의 &gt; merge() 함수가 key 변수를 찾아줌 . %%R class_record &lt;- merge(exams, book, by = &#39;course.id&#39;) class_record . course.id mid final student_name homework project 1 1 8 11 d 24 0 2 2 22 24 f 36 10 3 3 25 31 g 37 8 4 4 25 13 e 37 17 5 5 21 34 c 31 0 6 6 12 26 j 34 0 7 7 12 0 i 37 4 8 8 29 36 a 22 0 9 9 40 34 h 28 0 10 10 25 38 b 34 7 . - 위와 같이 key 변수의 이름(위에서는 course.id)이 두 데이터 프레임에서 동일한 경우 by를 사용 &gt; 그렇지 않은 경우에는 by.x와 by.y를 사용 . - 학생들의 총 점수 합계를 구하여 데이터 프레임에 새 변수로 추가해보자 . %%R class_record$total &lt;- apply(class_record[ ,c(2, 3, 5, 6)], 1, sum) class_record . course.id mid final student_name homework project total 1 1 8 11 d 24 0 43 2 2 22 24 f 36 10 92 3 3 25 31 g 37 8 101 4 4 25 13 e 37 17 92 5 5 21 34 c 31 0 86 6 6 12 26 j 34 0 72 7 7 12 0 i 37 4 53 8 8 29 36 a 22 0 87 9 9 40 34 h 28 0 102 10 10 25 38 b 34 7 104 . 6&#51109; - &#51064;&#51088;&#50752; &#45936;&#51060;&#53552; &#50836;&#50557;(factors and summaries) . - R에서 factor는 범주형 변수(벡터) 또는 비연속적 변수(벡터)를 지칭 . &#51064;&#51088;&#50752; &#53580;&#51060;&#48660; . %%R set.seed(1) ## 시드 넘버 설정 alpha &lt;- sample(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 25, replace = T) ## &#39;A&#39;, &#39;B&#39;, &#39;C&#39; 중에서 무작위로 25개를 중복을 허용하여 뽑는다 f &lt;- factor(alpha) ## alpha를 범주형 변수로 바꿈 . %%R alpha . [1] &#34;A&#34; &#34;C&#34; &#34;A&#34; &#34;B&#34; &#34;A&#34; &#34;C&#34; &#34;C&#34; &#34;B&#34; &#34;B&#34; &#34;C&#34; &#34;C&#34; &#34;A&#34; &#34;A&#34; &#34;A&#34; &#34;B&#34; &#34;B&#34; &#34;B&#34; &#34;B&#34; &#34;C&#34; [20] &#34;A&#34; &#34;C&#34; &#34;A&#34; &#34;A&#34; &#34;A&#34; &#34;A&#34; . %%R f . [1] A C A B A C C B B C C A A A B B B B C A C A A A A Levels: A B C . - 문자열인 alpha와 인자 벡터인 f가 같아 보이지만 다름 . - factor는 Levels이 존재하여 데이터 분류에 용이함 . - str() 함수는 데이터를 요약하여 보여줌 . %%R z &lt;- sample(1:5, 25, replace = T) g &lt;- factor(z) str(data.frame(f = f, g = g)) . &#39;data.frame&#39;: 25 obs. of 2 variables: $ f: Factor w/ 3 levels &#34;A&#34;,&#34;B&#34;,&#34;C&#34;: 1 3 1 2 1 3 3 2 2 3 ... $ g: Factor w/ 5 levels &#34;1&#34;,&#34;2&#34;,&#34;3&#34;,&#34;4&#34;,..: 2 1 3 3 4 3 1 4 5 1 ... . - table()은 빈도표를 만듦 . - addmargins()는 빈도표의 주변 합을 테이블에 추가함 . %%R table(f) . f A B C 11 7 7 . %%R table(f, g) ## f와 g의 인덱스를 보고 만듦 ex) f[x] = &#39;A&#39;이고 g[x] = 3이라면 (&#39;A&#39;, 3)위치의 값을 +1하는 식으로 만듦 . g f 1 2 3 4 5 A 2 2 2 2 3 B 0 0 1 4 2 C 5 0 1 0 1 . %%R addmargins(table(f)) . f A B C Sum 11 7 7 25 . %%R addmargins(table(f, g)) . g f 1 2 3 4 5 Sum A 2 2 2 2 3 11 B 0 0 1 4 2 7 C 5 0 1 0 1 7 Sum 7 2 4 6 6 25 . tapply()&#50752; aggregate()&#47196; &#45936;&#51060;&#53552; &#50836;&#50557; . - tapply(x, f, fun)는 x를 f의 수준 별로 쪼개서 fun을 적용함 . %%R set.seed(2) x &lt;- round(rnorm(25, 50, 10)) data.frame(x = x, f = f) . x f 1 41 A 2 52 C 3 66 A 4 39 B 5 49 A 6 51 C 7 57 C 8 48 B 9 70 B 10 49 C 11 54 C 12 60 A 13 46 A 14 40 A 15 68 B 16 27 B 17 59 B 18 50 B 19 60 C 20 54 A 21 71 C 22 38 A 23 66 A 24 70 A 25 50 A . %%R tapply(x, f, mean) . A B C 52.72727 51.57143 56.28571 . %%R tapply(x, f, function(t){max(t)-min(t)}) . A B C 32 43 22 . - function()은 사용자 정의 함수임 . - 한 줄일 경우 { }생략 가능 . - 쪼갬의 대상이 벡터가 아니라 데이터 프레임인 경우에는 split()과 sapply()를 함께 이용 . %%R split(data.frame(x = x, z = z), f) . $A x z 1 41 2 3 66 3 5 49 4 12 60 4 13 46 5 14 40 5 20 54 5 22 38 1 23 66 1 24 70 3 25 50 2 $B x z 4 39 3 8 48 4 9 70 5 15 68 4 16 27 5 17 59 4 18 50 4 $C x z 2 52 1 6 51 3 7 57 1 10 49 1 11 54 1 19 60 1 21 71 5 . %%R s &lt;- split(data.frame(x = x, z = z), f) class(s) . [1] &#34;list&#34; . %%R sapply(s, apply, 2, mean) . A B C x 52.727273 51.571429 56.285714 z 3.181818 4.142857 1.857143 . - aggregate(x, list(f, g), fun)은 x를 f와 g의 조합으로 쪼개서 fun을 적용함 . %%R aggregate(data.frame(x = x, z = z)$x, list(f, g), sum) . Group.1 Group.2 x 1 A 1 104 2 C 1 272 3 A 2 91 4 A 3 136 5 B 3 39 6 C 3 51 7 A 4 109 8 B 4 225 9 A 5 140 10 B 5 97 11 C 5 71 . - tapply()는 쪼갤 기준이 하나 . - aggregate()는 쪼갤 기준이 여러개(list) . cut() &#54632;&#49688; . - cut(x, breaks)는 수치형 벡터 x를 breaks로 쪼개서 factor 변수로 만듦(구간화) . - 만약 기준 변수가 factor가 아니라면 factor로 만듦 . %%R set.seed(21) x &lt;- runif(100, 0, 10) y &lt;- 5 + 0.5*(x-5) + rnorm(100) ## x와 y는 선형관계 ## rnorm(100)은 오차항 ## y = 0.5x + 2.5 + ϵ, ϵ ~ (0, σ^2) &gt; 이 예제에서 σ = 1 chr_ &lt;- c(&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;) x_cut &lt;- cut(x, chr_) class(x_cut) . [1] &#34;factor&#34; . %%R #collapse cbind(x, x_cut, y) . x x_cut y [1,] 7.8611493 8 5.8484239 [2,] 2.5244560 3 5.5363467 [3,] 6.9925230 7 5.7855895 [4,] 1.8446075 2 3.0701969 [5,] 9.5961383 10 7.8832415 [6,] 9.1868340 10 8.1071017 [7,] 1.0180455 2 2.9864533 [8,] 1.7219168 2 2.4578035 [9,] 9.8600368 10 8.3377913 [10,] 8.4939610 9 7.9089234 [11,] 6.6754012 7 5.3797472 [12,] 9.3521022 10 8.1040078 [13,] 0.5818433 1 0.6879865 [14,] 6.1861583 7 3.9159120 [15,] 1.7491846 2 5.1402481 [16,] 0.3767539 1 3.4828244 [17,] 5.2531317 6 4.6426963 [18,] 2.8218425 3 5.8392804 [19,] 4.9904520 5 4.6111098 [20,] 6.3382510 7 4.0824480 [21,] 0.1139965 1 2.7712999 [22,] 6.0785656 7 4.4010011 [23,] 7.7559853 8 6.8674062 [24,] 9.2397118 10 5.3672191 [25,] 2.9170673 3 4.4595508 [26,] 7.8907624 8 6.5321374 [27,] 5.6849721 6 5.5335596 [28,] 7.7843508 8 7.2240144 [29,] 7.1323253 8 5.3871303 [30,] 6.6904867 7 6.1411056 [31,] 9.3470991 10 8.2857154 [32,] 5.0646019 6 5.3948908 [33,] 7.4506019 8 5.9543859 [34,] 8.3835263 9 6.4948175 [35,] 8.6907475 9 6.9123283 [36,] 1.9311168 2 2.5977567 [37,] 2.1633194 3 3.2196540 [38,] 6.5042346 7 4.6125672 [39,] 3.3516604 4 3.3604589 [40,] 5.0765589 6 6.3485251 [41,] 6.5283937 7 5.5058359 [42,] 9.6557667 10 7.9341482 [43,] 5.1466067 6 5.3867516 [44,] 0.6165677 1 2.8618869 [45,] 1.5101646 2 4.3833361 [46,] 6.3556589 7 5.1196960 [47,] 1.0296050 2 4.5507614 [48,] 7.7269430 8 6.3010251 [49,] 4.1022537 5 4.5727020 [50,] 8.7023337 9 4.7613394 [51,] 7.7204222 8 5.5493224 [52,] 6.4981737 7 2.8052970 [53,] 6.3036461 7 5.6330273 [54,] 8.3020059 9 6.2963228 [55,] 1.3049793 2 3.1880598 [56,] 8.8185301 9 7.4033842 [57,] 2.4005341 3 3.0404586 [58,] 6.4817896 7 6.7420367 [59,] 2.3344643 3 4.7393166 [60,] 0.6940427 1 3.6027870 [61,] 0.3330366 1 1.2110536 [62,] 9.2247471 10 8.0552446 [63,] 3.4175140 4 2.3384819 [64,] 9.3834557 10 6.9384556 [65,] 5.1071478 6 4.7610120 [66,] 1.3198211 2 3.3786786 [67,] 8.1901787 9 5.2400199 [68,] 9.2262677 10 6.9904067 [69,] 9.4890694 10 6.7926696 [70,] 5.5827285 6 5.3886124 [71,] 5.2419521 6 4.8028737 [72,] 5.3472914 6 4.5898834 [73,] 9.6766790 10 7.4056243 [74,] 5.2833101 6 5.4971212 [75,] 5.3193106 6 5.1386437 [76,] 6.2043358 7 6.8507949 [77,] 9.2198573 10 6.2252412 [78,] 2.2786153 3 2.7543007 [79,] 9.2766458 10 6.6875929 [80,] 9.2997805 10 8.4412031 [81,] 5.2228023 6 5.4902407 [82,] 9.9086911 10 8.9550287 [83,] 0.6460298 1 2.5542380 [84,] 8.6259344 9 8.0880172 [85,] 4.8062732 5 5.2246315 [86,] 5.3615727 6 6.8357290 [87,] 4.1513448 5 3.3840167 [88,] 2.2846328 3 3.5953298 [89,] 9.8195084 10 5.8097139 [90,] 6.5597644 7 4.6645165 [91,] 5.8016786 6 6.2954982 [92,] 1.4083867 2 2.4986595 [93,] 6.9767447 7 5.0349142 [94,] 7.4802064 8 7.2367931 [95,] 9.5334043 10 6.6016713 [96,] 1.3104292 2 1.5242489 [97,] 6.4997197 7 6.4960776 [98,] 7.0777577 8 5.0707520 [99,] 0.9994111 1 2.6955059 [100,] 0.6916488 1 3.5104340 . - (x, y)의 산점도에 x의 구간별 평균을 막대로 넣어 구간별 평균의 이동을 산출해보자 . %%R y_local &lt;- aggregate(y, list(x_cut), mean) ## x_cut은 1~10까지 존재 &gt; 1부터 10까지 x_cut별로 따로 모아 그에 해당하는 y 데이터의 평균을 구함 y_local . Group.1 x 1 (0,1] 2.597557 2 (1,2] 3.252382 3 (2,3] 4.148030 4 (3,4] 2.849470 5 (4,5] 4.448115 6 (5,6] 5.436146 7 (6,7] 5.198160 8 (7,8] 6.197139 9 (8,9] 6.638144 10 (9,10] 7.384560 . %%R plot(x, y, ylim = c(0, 10), main = &quot;x vs y&quot; ) segments(0:9, y_local$x, 1:10, y_local$x, lwd = 2) ## segments 함수는 x좌표와 y좌표를 입력받아 line을 그려줌 abline(v = 1:9, lty = &quot;dotted&quot;) ## abline 함수는 line을 그려줌, v는 수직선의 위치 . - 참고: abline 함수 . - 참고: segments 함수 . &#51025;&#50857; . - 나중에 + R입문 중간고사 내용도 . 8&#51109; - &#51077;&#52636;&#47141;(input and output) . - read.table read.csv(&#39;파일 위치&#39;) &gt; 텍스트 파일 or csv 파일을 읽어 내부 저장소에 dataframe으로 만듦 . - getwd() &gt; 현재의 작업 디렉토리를 알려줌 . - setwd(&#39;위치&#39;) &gt; 작업 디렉토리를 입력한 위치로 변경 . - dir() &gt; 현재 작업 디렉토리에 있는 파일들의 리스트를 보여줌 . - write.table write.csv()은 특정 데이터 프레임을 작업 디렉토리에 텍스트 파일 or csv 파일로 입력함 . - 파일을 읽을 때 stringAdFactors = F 옵션을 적용하면 문자열 변수가 자동으로 factor 형이 되는 것을 막아줌 . - sink()함수를 통해 결과값을 텍스트 파일로 저장할 수 있음 &gt; sink function . scan()&#54632;&#49688; . - scan() &gt; 비정형의 문자열 데이터를 읽을 때 유용 . - what 은 읽어 들일 데이터 값 형식 numeric, logical, character . - 책 따라 하는데 scan함수가 제대로 작동되지 않아 찾아보니 quote = &quot;&quot; 로 하지 않아서라고 함 &gt; 참고: https://pythonq.com/so/r/29317 . - quote = &quot;&quot; 옵션을 적용하지 않으면 Read 1 item을 반환 &gt; 빈칸을 기준으로 문자열을 쪼개지 않았다는 뜻 &gt; 그런데 sep = &quot; n&quot; 으로 하면 Read 20 item임 . - 원인을 알았는데 내가 yesterday노래 가사 텍스트 파일을 만들 때 맨 앞에 &quot; 기호를 실수로 추가했었음 &gt; &quot; 기호를 없애니 잘 동작함 . %%R lyrics &lt;- scan(&quot;yesterday.txt&quot;, what = &quot;character&quot;) ## quote = &quot;&quot; 옵션을 적용 안해도 잘 동작함 . R[write to console]: Read 126 items . %%R str(lyrics) . chr [1:126] &#34;Yesterday,&#34; &#34;all&#34; &#34;my&#34; &#34;troubles&#34; &#34;seemed&#34; &#34;so&#34; &#34;far&#34; &#34;away.&#34; ... . %%R head(lyrics, 10) . [1] &#34;Yesterday,&#34; &#34;all&#34; &#34;my&#34; &#34;troubles&#34; &#34;seemed&#34; [6] &#34;so&#34; &#34;far&#34; &#34;away.&#34; &#34;Now&#34; &#34;it&#34; . - 빈칸을 구분자로 인식하여 문자열을 쪼개어 읽어옴 + 줄 단위로 읽고 싶다면 sep = &quot; n&quot; . %%R lyrics_2 &lt;- scan(&quot;yesterday.txt&quot;, what = &quot;character&quot;, sep = &quot; n&quot;) . R[write to console]: Read 20 items . %%R str(lyrics_2) . chr [1:20] &#34;Yesterday, all my troubles seemed so far away.&#34; ... . %%R head(lyrics_2, 5) . [1] &#34;Yesterday, all my troubles seemed so far away.&#34; [2] &#34;Now it looks as though they&#39;re here to stay.&#34; [3] &#34;oh, I believe in yesterday.&#34; [4] &#34;Suddenly, I&#39;m not half the man I used to be.&#34; [5] &#34;There&#39;s a shadow hanging over me.&#34; . cat() &#54632;&#49688; . - print함수와 비슷하나 여러개의 출력이 가능하고 출력이 공백 없이 이어짐 . %%R print(&quot;a&quot;) print(&quot;b&quot;) . [1] &#34;a&#34; [1] &#34;b&#34; . %%R cat(&quot;a&quot;) cat(&quot;b&quot;) . ab . 9&#51109; - &#47928;&#51088;&#50676; &#51089;&#50629; . grep() &#54632;&#49688; . - grep(pattern, x)는 x에서 pattern이 있는 곳을 알려줌 . %%R grep(&quot;Yesterday&quot;, lyrics) . [1] 1 63 105 . %%R grep(&quot;yesterday&quot;, lyrics) . [1] 22 40 62 84 104 126 . - &quot;Yesterday&quot;는 1 ,63 ,105번째 요소에 있고 &quot;yesterday&quot;는 22, 40 ,62, 84, 104, 126번째 요소에 있음을 알려줌 . - 이번에는 &quot;?&quot;를 찾아보자 . - grep(&quot;?&quot;, lyrics)를 하면 될 것 같지만 아님 . %%R #collapse-output grep(&quot;?&quot;, lyrics) # %%R 셀에서는 collapse-output이 안됨......(아님말고) . [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 [91] 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 [109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 . - &quot;?&quot;는 정규표현식 기호로 사용되게 원래의 물음표 기호를 사용하고자 하면 &quot; &quot;을 앞에 넣어줘야함 &gt; 나중에 정규표현식 공부하자 . %%R grep(&quot; ?&quot;, lyrics) . [1] 47 89 . nchar() &#54632;&#49688; . - nchar(x)는 문자열 x의 길이를 알려줌(빈칸 포함) . %%R nchar(&quot;yesterday&quot;) . [1] 9 . - 문자열 벡터에도 적용 가능함 . %%R nchar(lyrics) . [1] 10 3 2 8 6 2 3 5 3 2 5 2 6 7 4 2 5 3 1 7 2 10 9 3 3 [26] 4 3 3 1 4 2 3 7 1 6 7 4 3 3 9 4 9 3 3 3 2 3 1 5 5 [51] 3 8 4 1 4 9 6 3 1 4 3 10 9 4 3 4 2 4 4 2 5 3 1 4 1 [76] 5 2 4 5 3 1 7 2 10 3 3 3 2 3 1 5 5 3 8 4 1 4 9 6 3 [101] 1 4 3 10 9 4 3 4 2 4 4 2 5 3 1 4 1 5 2 4 5 3 1 7 2 [126] 12 .",
            "url": "https://jaesu26.github.io/green/r/2021/08/20/R%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html",
            "relUrl": "/r/2021/08/20/R%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html",
            "date": " • Aug 20, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "파이썬 scipy.stats",
            "content": "- 확률분포를 scipy.stats를 통해 그리는데 익숙하지 않아 기본 사용에 대해 알아볼 거임 . - 참고: scipy.stats . - 참고: scipy 확률분포 . &#54869;&#47456;&#48516;&#54252; &#53364;&#47000;&#49828; . - scipy.stats를 통해 확률분포를 그려보자 . - 우선 확률분포에 대한 클래스 객체를 생성해야 함 . - 각 확률분포의 파라미터는 scipy.stats.이름을 통해 확인하자 . 종류 이름 확률분포 . 이산 | bernoulli | 베르누이 분포 | . 이산 | binom | 이항 분포 | . 이산 | poisson | 포아송 분포 | . 이산 | geom | 기하 분포 | . 이산 | nbinom | 음이항 분포 | . 이산 | hypergeom | 초기하 분포 | . 이산 | multinomial | 다항 분포 | . 연속 | norm | 정규 분포 | . 연속 | uniform | 균일 분포 | . 연속 | expon | 지수 분포 | . 연속 | gamma | 감마 분포 | . 연속 | t | t 분포 | . 연속 | chi2 | 카이제곱 분포 | . 연속 | f | f 분포 | . 연속 | beta | 베타 분포 | . &#47784;&#49688; &#51648;&#51221; . - 확률분포의 모수는 종류별로 다르므로 문서를 참고하자 . - 하지만 대부분 확률분포가 공통적으로 가지는 모수가 있음 . 모수 이름 의미 . loc | 기댓값 | . scale | 표준편차 | . &#54869;&#47456;&#48516;&#54252; methods . - 확률분포 클래스 객체가 가지는 method가 있음 . - 정규분포를 예로 들어 ppf에 대한 설명을 해보면 norm.ppf(0.5)는 정규분포에서 $50$분위수에 해당하는 $x$값으로 $0$이다 . 메서드 기능 . pmf | 확률질량함수 | . pdf | 확률밀도함수 | . cdf | 누적분포함수 | . ppf | 누적분포함수의 역함수(백분위 함수) | . sf | 생존함수 = 1 $-$ 누적분포함수 | . isf | 생존함수의 역함수 | . rvs | 무작위 표본 생성 | . &#54869;&#47456;&#48516;&#54252; plot . &#51221;&#44508; &#48516;&#54252; pdf . - 정규 분포 pdf를 그려보자 . import numpy as np import matplotlib.pyplot as plt from scipy.stats import norm xx = np.linspace(-5, 5, 1000) for scale in (0.5, 1.0, 2.0): plt.plot(xx, norm(0, scale).pdf(xx), label = &#39;μ = 0, σ = &#39; + str(scale), lw = 2, alpha = 0.8) plt.plot(xx, norm(-2, 0.5).pdf(xx), label = &#39;μ = -2, σ = 0.5&#39;, lw = 2, alpha = 0.8) plt.xticks(np.arange(-5, 6)) plt.yticks(np.arange(0.0, 1.2, 0.2)) plt.title(&quot;normal distribution pdf&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$f(x)$&quot;) plt.grid() plt.legend() plt.show() . &#51221;&#44508; &#48516;&#54252; cdf . - 정규 분포 cdf를 그려보자 . - cdf에 대한 내용 정리 예정 . import numpy as np import matplotlib.pyplot as plt from scipy.stats import norm xx = np.linspace(-5, 5, 1000) for scale in (0.5, 1.0, 2.0): plt.plot(xx, norm(0, scale).cdf(xx), label = &#39;μ = 0, σ = &#39; + str(scale), lw = 2, alpha = 0.8) plt.plot(xx, norm(-2, 0.5).cdf(xx), label = &#39;μ = -2, σ = 0.5&#39;, lw = 2, alpha = 0.8) plt.xticks(np.arange(-5, 6)) plt.yticks(np.arange(0.0, 1.2, 0.2)) plt.title(&quot;normal distribution cdf&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$f(x)$&quot;) plt.grid() plt.legend() plt.show() .",
            "url": "https://jaesu26.github.io/green/python/statistics/2021/08/10/scipy-stats.html",
            "relUrl": "/python/statistics/2021/08/10/scipy-stats.html",
            "date": " • Aug 10, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "가설검정",
            "content": "- 대표적인 확률분포에 대한 간단한 정리를 마친 후 작성할 예정임 &gt; 시작 . - 참고: Statistics: Unlocking the power of data, Robin Lock 외 4인 . &#51473;&#49900;&#44537;&#54620;&#51221;&#47532;(central limit theorem) . - 동일한 확률분포를 가진 독립확률변수 $n$개의 평균의 분포는 충분히 크다면($n geq 30$이면) 정규분포에 가까워짐 . - 앞으로 많은 가설검정에서 사용될 예정 . - 나중에 증명 추가 . &#54217;&#44512;&#50640; &#45824;&#54620; &#52628;&#47200; . - 양적 자료에서 관심 있는 모수는 종종 모집단 평균 $ mu$이다 . - ex) 우리나라 사람들의 평균 맥박수가 어느정도 되는지 궁금함 &gt; 평균에 대한 가설검증 . &#54364;&#48376; &#54217;&#44512;&#50640; &#45824;&#54620; &#51473;&#49900;&#44537;&#54620;&#51221;&#47532; . - 평균이 $ mu$이고 표준편차가 $ alpha$인 모집단에서 표본 크기 $n$이 충분히 클 때 표본 평균의 분포는 근사적으로 평균이 $ mu$이고 표준편차는 $ cfrac{ alpha}{ sqrt{n}}$인 정규분포를 따름 . - 하지만 위의 내용을 그대로 사용할 수 없음 . 모집단의 표준편차 $ alpha$를 모른다 &gt; 표본의 표준편차 $s$를 $ alpha$대신 사용 . | 추정된 표준오차 $ cfrac{s}{ sqrt{n}}$에 기반하여 표준화한 통계량의 분포는 표준정규분포를 따르지 않음 &gt; t 분포를 따름(t 분포 참고) . | &#54364;&#48376;&#51032; &#54364;&#51456;&#54200;&#52264;&#47484; &#49324;&#50857;&#54624; &#46412; &#54364;&#48376; &#54217;&#44512;&#51032; &#48516;&#54252; . - 평균이 $ mu$인 모집단에서 표본 크기 $n$인 무작위 표본을 뽑을 때 표본 평균의 분포는 중심이 $ mu$이고 표준오차는 $ cfrac{s}{ sqrt{n}}$으로 추정 . - 표본 평균을 표준화하면 자유도 $n-1$인 t 분포를 근사적으로 따름 . - 표본 크기 $n$이 커질수록 t분포는 표준정규분포와 가까워짐 . import numpy as np import scipy as sp import scipy.stats import matplotlib.pyplot as plt . x = np.linspace(-5, 5, 100) rv_norm = sp.stats.norm(loc=0, scale=1) rv_t10 = sp.stats.t(df=10) rv_t5 = sp.stats.t(df=5) rv_t1 = sp.stats.t(df=1) norm_pdf = rv_norm.pdf(x) t10_pdf = rv_t10.pdf(x) t5_pdf = rv_t5.pdf(x) t1_pdf = rv_t1.pdf(x) legend = [&#39;z-dist&#39;, &#39;t(df=1)&#39;, &#39;t(df=5)&#39;, &#39;t(df=10)&#39;] plt.figure(figsize = (10, 6)) plt.plot(x, norm_pdf) plt.plot(x, t1_pdf) plt.plot(x, t5_pdf) plt.plot(x, t10_pdf) plt.title(&quot;z-dist, t-dist(df=1, 5, 10)&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$p(x)$&quot;) plt.grid() plt.legend(legend) plt.show() . - 위의 plot을 보면 자유도가 커질수록 t분포가 표준정규분포에 가까워짐을 알 수 있음 . - 나중에 plot그리는데 사용되는 lib와 사용법 추가 예정 . t &#48516;&#54252; &#49324;&#50857; &#51312;&#44148; . - 표본 크기 $n geq30$이면 문제 없음 . - 만약 표본 크기 $n$이 작다면? &gt; 모집단이 정규분포를 따라야 함 . - 근데 모집단이 정규분포 따르는지 모른다 &gt; 대신에 표본이 정규분포를 따르는지 확인하자 &gt; shapiro.test 실시 . - 표본에 이상점이 있거나 비대칭이면 t 분포 사용$ times$ . - 표본이 정규분포를 따르는 것 같다 &gt; $ bar{x}$의 분포는 정규분포를 따른다 &gt; t-test 실시해도 괜찮다 . &#54217;&#44512;&#50640; &#45824;&#54620; t&#44160;&#51221; . - 영가설 $H_0: mu= mu_0$를 검정하는 t-통계량은 다음과 같음 . - $t= cfrac{ bar{x}- mu_0}{ frac{s}{ sqrt{n}}}$ . - $ bar{x}$는 표본 평균, $s$는 표본에서 계산한 표준편차 . - p-값을 통해 영가설을 기각할지 기각하지 못하는지를 결정 &gt; 가설검정 용어(영가설, p-값 등등)에 대해 나중에 정리 예정 . - 검증의 p-값은 자유도가 $n-1$인 t분포에서 대안가설에 적절한 꼬리쪽의 비율을 계산 . &#54217;&#44512;&#50640; &#45824;&#54620; t&#44160;&#51221; &#50696;&#51228; . 문제 | . - 사람의 평균 체온이 $36.5^{°} mathrm{C}$인지 검정하기 위해 건강한 사람 50명의 체온을 재었다 . - 임의로 데이터를 설정하여 평균 체온 데이터는 평균이 36.3, 표준편차는 0.5인 정규분포에서 추출했음 . - 임의로 뽑은 표본을 살펴보니 $ bar{x} = 36.35, ;s=0.5$이다 . - 위의 데이터는 사람의 평균 체온이 $36.5^{°} mathrm{C}$와는 다르다는 증거인지 유의수준 $ alpha=0.05$ 에서 검정하자 . 해결 과정 | . - $H_0: mu=36.5, ;H_a: mu neq36.5$ . - 표본 크기가 충분하고 표본에 대한 히스토그램을 보면 정규분포를 따르는 것으로 보인다 . import rpy2 import os os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; %load_ext rpy2.ipython . The rpy2.ipython extension is already loaded. To reload it, use: %reload_ext rpy2.ipython . import matplotlib.pyplot as plt import numpy as np ## 예시 샘플 np.random.seed(2021) sample = np.random.normal(loc = 36.3, scale = 0.5, size = 50) plt.hist(sample) plt.title(&#39;body heat data&#39;) plt.show() %R -i sample . - 샤피로 윌크 검정을 통해 정규성을 정확히 확인하자 . %%R shapiro.test(sample) . Shapiro-Wilk normality test data: sample W = 0.98456, p-value = 0.7524 . - p-값이 크므로 영가설(표본은 정규분포를 따름)을 기각할 수 없으므로 표본의 정규성을 가정 . - t통계량을 직접 구해도 됨 &gt; $t= cfrac{ bar{x}- mu_0}{ frac{s}{ sqrt{n}}} = cfrac{36.35-36.5}{ frac{0.5}{ sqrt{50}}}=-2.12$ . - 하지만 매번 직접 구하기 귀찮으므로 R을 통해 구해보도록 하자 + p-값도 구해줌 . - 사실 파이썬으로도 가능하지만 내가 모르는 관계로 R로 하고 나중에 따로 공부하자 . %%R print(mean(sample)) ## 평균 print(sd(sample)) ## 분산 . [1] 36.35498 [1] 0.5006206 . %%R t.test(sample, mu = 36.5, alternative = &#39;two.sided&#39;, conf.level = 0.95) . One Sample t-test data: sample t = -2.0483, df = 49, p-value = 0.04591 alternative hypothesis: true mean is not equal to 36.5 95 percent confidence interval: 36.21271 36.49726 sample estimates: mean of x 36.35498 . - p-값을 보면 0.04591로 유의수준인 0.05보다 작음 &gt; 영가설을 기각한다 . - 따라서 표본에 따르면 사람의 평균 체온은 $36.5^{°} mathrm{C}$와 다르다고 할 수 있다 . - 임의로 만든 표본은 평균이 36.3인 정규분포에서 추출한 것이므로 올바르게 추론한 것을 알 수 있음 . &#54217;&#44512; &#52264;&#51060; &#48516;&#54252; . - 단일 평균에 대한 t검정과 차이점은 표본이 하나인가 둘인가이다 . - 평균 차이에 대한 t검정에서 관심있는 모수는 $ mu_1 - mu_2$이다 . - 평균이 $ mu_1$과 $ mu_2$인 모집단에서 표본크기가 $n_1$과 $n_2$인 무작위 표본을 얻었을 때 표본 평균 차이 $ bar{x_1}- bar{x_2}$의 분포는 중심이 모집단 평균 차이$ mu_1- mu_2$이고 표준오차는 $ sqrt{ frac{{s_1}^{2}}{n_1}+ frac{{s_2}^2}{n_2}}$이다 . - 표본 평균 차이를 표준화한 값은 t분포를 따르며 자유도는 근사적으로 $n_1+n_2-2$ . - $n_1 &lt;30$ or $n_2&lt;30$인 경우 표본 크기가 작으며 이 경우에는 모집단이 정규분포를 따라야 함 . - 평균 차이를 검정할 땐 두 집단이 서로 독립인지 아닌지가 중요함 &gt; 독립여부에 따라 검정 방법이 달라짐 . - 여기서는 독립표본에 대해 얘기할 것 임 . - 두 집단의 분산의 동질성이 중요함 &gt; 평균 차이 검정을 하기 전에 분산의 동질성 검정을 수행함 . - 분산이 같은 경우 student&#39;s t-test를 사용하고 분산이 다른 경우 Welch&#39;s t test사용함 . &#54217;&#44512; &#52264;&#51060;&#50640; &#45824;&#54620; t&#44160;&#51221; . - 영가설 $H_0: mu_1- mu_2=0$를 검정하는 t-통계량은 다음과 같음 . - $t= cfrac{( bar{x_1}- bar{x_2})-0}{ sqrt{ frac{{s_1}^2}{n_1}+ frac{{s_2}^2}{n_2}}}$ . - $ bar{x_1}$과 $ bar{x_2}$는 표본 평균, $s_1$과 $s_2$는 표본의 표준편차 . &#54217;&#44512; &#52264;&#51060;&#50640; &#45824;&#54620; t&#44160;&#51221; &#50696;&#51228; . 문제 | . - 남자의 평균 체온$( bar{x_1})$과 여자의 평균 체온$( bar{x_2})$이 다른지 검정하기 위해 각각 건강한 사람 50명의 체온을 재었다 . - 임의로 데이터를 설정하여 남자의 평균 체온 데이터는 평균이 36.5, 표준편차는 0.4인 정규분포에서 추출했음 . - 임의로 데이터를 설정하여 여자의 평균 체온 데이터는 평균이 36.45, 표준편차는 0.5인 정규분포에서 추출했음 . - 임의로 뽑은 표본을 보니 $ bar{x_1} = 36.54, ; bar{x_2} = 36.5, ; s_1=0.4, ;s_2=0.53$이다 . - 위의 데이터는 남자와 여자의 평균 체온이 서로 다르다는 증거인지 유의수준 $ alpha=0.05$ 에서 검정하자 . 해결 과정 | . - $H_0: mu_1- mu_2 = 0, ;H_a: mu_1 neq mu_2$ . - 표본 크기가 충분하고 표본에 대한 히스토그램을 보면 정규분포를 따르는 것으로 보인다 . - 남자 모집단과 여자 모집단에서 표본을 추출했으므로 두 표본은 서로 독립이다 . import rpy2 import os os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; %load_ext rpy2.ipython . C: anaconda3 envs py38r40 lib site-packages rpy2 robjects packages.py:366: UserWarning: The symbol &#39;quartz&#39; is not in this R namespace/package. warnings.warn( . import matplotlib.pyplot as plt import numpy as np ## 예시 샘플 np.random.seed(2021) man_heat = np.random.normal(loc = 36.5, scale = 0.4, size = 50) woman_heat = np.random.normal(loc = 36.45, scale = 0.5, size = 50) fig, ax = plt.subplots(1, 2, figsize = (10, 4)) ax[0].hist(man_heat) ax[1].hist(woman_heat) ax[0].set_title(&#39;man body heat data&#39;) ax[1].set_title(&#39;woman body heat data&#39;) plt.show() %R -i man_heat,woman_heat . - 두 표본이 정규성을 따르는지 정확히 확인하자 . %%R shapiro.test(man_heat) . Shapiro-Wilk normality test data: man_heat W = 0.98456, p-value = 0.7524 . %%R shapiro.test(woman_heat) . Shapiro-Wilk normality test data: woman_heat W = 0.96223, p-value = 0.1102 . - 둘다 p-값이 크므로 정규성을 가정하자 . - 평균 차이 검정을 하기전에 우선 두 표본의 분산이 동일한지 검정하자 . - var.test는 두 집단의 분산이 동일한지 비교함 ratio(두 집단 분산의 비율)이 1이 아니라면 두 집단의 분산이 다르다는 증거임 . %%R print(mean(man_heat)) print(sd(man_heat)) print(mean(woman_heat)) print(sd(woman_heat)) . [1] 36.54399 [1] 0.4004965 [1] 36.52622 [1] 0.5260057 . %%R var.test(man_heat, woman_heat, ratio = 1, alternative = &quot;two.sided&quot;, conf.level = 0.95) . F test to compare two variances data: man_heat and woman_heat F = 0.57972, num df = 49, denom df = 49, p-value = 0.05916 alternative hypothesis: true ratio of variances is not equal to 1 95 percent confidence interval: 0.3289758 1.0215715 sample estimates: ratio of variances 0.5797175 . - 두 집단의 분산이 같은지 검정하니 p-값이 0.05보다 크기 때문에 다르다고 할만한 충분한 증거가 없으므로 동일하다 가정함 . - 분산이 각각 0.4와 0.5인 집단에서 표본을 추출하여 원래는 분산이 다르지만 표본크기가 작기 때문에 0.1의 차이를 판단하지 못하였음 . - 아무튼 var.test 결과는 분산이 동일하다 나왔으므로 두 집단의 분산이 동일하다 생각하고 평균 차이를 검정하자 . %%R t.test(man_heat, woman_heat, alternative = &#39;two.sided&#39;, var.equal = T, conf.level = 0.95) . Two Sample t-test data: man_heat and woman_heat t = 0.19001, df = 98, p-value = 0.8497 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: -0.1677758 0.2033056 sample estimates: mean of x mean of y 36.54399 36.52622 . - 검정결과를 보면 p-값이 0.05보다 크므로 영가설을 기각하지 못함 &gt; 남자와 여자의 평균체온을 다르다고 할 수 없음 . - 실제 데이터는 평균이 36.5와 36.45로 다르지만 표본의 크기가 충분하지 않아 이를 잡아내지 못함 . - 표본 크기가 50이 아니라 더욱 커진다면 위의 차이를 알아낼 수 있음 . &#45824;&#51025;&#54364;&#48376;&#50640; &#45824;&#54620; &#54217;&#44512; &#52264;&#51060; t&#44160;&#51221; . - 위에서 두 개의 개별 표본일 때 평균 차이 검정을 했음 . - 하지만 자료가 짝으로 주어졌다면 위와 동일한 방법으로 검정을 수행하면 안됨 . - 짝 자료 &gt; 동일한 피실험체를 두 가지 다른 조건에서 측정한 데이터 ex) 개별 사람의 왼손과 오른손 악력, 약을 복용하기 전과 후의 혈압 . - 조건이 동일하다면 동일한 피실험체가 아니어도 가능함 &gt; ex) 일란성 쌍둥이의 IQ . - 짝 자료에 대한 평균 차이 검정은 우선 각 짝 자료의 차이를 계산한 후 차이에 대한 평균 $ bar{x_d}$, 표준편차 $s_d$, 표본 크기 $n_d$를 계산 . - $t = cfrac{ bar{x_d} - 0}{ frac{s_d}{ sqrt{n_d}}}$를 자유도가 $n_d-1$인 t분포에서 검정함 . &#45824;&#51025; &#54364;&#48376;&#50640; &#45824;&#54620; &#54217;&#44512; &#52264;&#51060; t&#44160;&#51221; &#50696;&#51228; . 문제 | . - 소설을 읽을 때 스토리 스포일러를 포함한 경우와 그렇지 않은 경우에 대해 즐거움의 등급(점수)차이가 있는지 유의수준 $ alpha=0.05$ 에서 검정하자 . - 등급이 높을 수록 스토리가 더 재밌었다는 것을 의미함 . - 12개 스토리의 각 버전은 최소 30명이 읽고 1~10등급으로 등급을 매겼음 . - 스포일러 유 &gt; 4.7, 5.1, 7.9, 7.0, 7.1, 7.2, 7.1, 7.2, 4.8, 5.2, 4.6, 6.7 . - 스포일러 무 &gt; 3.8, 4.9, 7.4, 7.1, 6.2, 6.1, 6.7, 7.0, 4.3, 5.0, 4.1, 6.1 . 해결 과정 | . - 12개의 스토리를 동일한 조건(무작위 샘플링)을 지닌 사람이 두 가지 처리(스포일러 유무)를 받아 읽고 등급을 평가함 &gt; 대응 표본 . import rpy2 import os os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; %load_ext rpy2.ipython . C: anaconda3 envs py38r40 lib site-packages rpy2 robjects packages.py:366: UserWarning: The symbol &#39;quartz&#39; is not in this R namespace/package. warnings.warn( . %%R install.packages(&#39;ggplot2&#39;) library(ggplot2) . Please select a CRAN mirror for use in this session . R[write to console]: trying URL &#39;https://cran.seoul.go.kr/bin/windows/contrib/4.0/ggplot2_3.3.5.zip&#39; R[write to console]: Content type &#39;application/zip&#39; R[write to console]: length 4129414 bytes (3.9 MB) R[write to console]: downloaded 3.9 MB . package &#39;ggplot2&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: tmp Rtmp0OKRvu downloaded_packages . %%R with_spoiler &lt;- c(4.7, 5.1, 7.9, 7.0, 7.1, 7.2, 7.1, 7.2, 4.8, 5.2, 4.6, 6.7) original &lt;- c(3.8, 4.9, 7.4, 7.1, 6.2, 6.1, 6.7, 7.0, 4.3, 5.0, 4.1, 6.1) diff &lt;- with_spoiler - original diff_df &lt;- as.data.frame(diff) ggplot(diff_df, aes(x = diff)) + xlab(&#39;Difference&#39;) + geom_dotplot(binwidth = 0.1) . - 짝 자료 차이에 대한 점도표를 보면 정규분포를 부정할 만한 비대칭이나 이상점은 없어보임 . %%R shapiro.test(diff) . Shapiro-Wilk normality test data: diff W = 0.95506, p-value = 0.7116 . - 샤피로 윌크 검정도 해보니 정규분포임을 가정해도 괜찮아 보임 . %%R t.test(with_spoiler, original, paired = T, alternative = &#39;two.sided&#39;, conf.level = 0.95) . Paired t-test data: with_spoiler and original t = 4.8997, df = 11, p-value = 0.0004719 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 0.2708052 0.7125281 sample estimates: mean of the differences 0.4916667 . - R에서 대응 표본에 대한 검정을 하려면 paried = T 옵션을 적용한다 . - p-값이 0.0004719로 매우 작으므로 영가설을 기각하자 &gt; 스포일러 유무에 따른 재미의 등급은 차이가 있다! . &#47784;&#48516;&#49328;&#50640; &#45824;&#54620; &#52628;&#47200; . - 모집단이 얼마나 퍼져있는지에 대해 궁금할 수 있음 . - ex) 공장에서 생산하는 과자의 무게 . - 과자의 무게 변동이 큰지 작은지에 대한 검정이 모분산에 대한 검정이다 . &#45800;&#51068; &#47784;&#48516;&#49328;&#50640; &#45824;&#54620; &#44160;&#51221; . - 우선 단일 모분산에 대한 검정에는 $ chi^2$분포가 사용됨 &gt; 왜? . - 카이제곱분포를 떠올려보면 다음과 같음 . - $n$개의 서로 독립인 확률표본이 평균 $ mu$ 분산 $ sigma^2$인 정규분포에서 추출되었다고 하자 . - 모평균이 알려져 있지 않은 상황에서는 $ mu$ 대신 $ bar{X}$를 사용함 . $$ begin{aligned} sum Z_{i}^{2}&amp;= left( cfrac{X_1- bar{X_n}}{ sigma} right)^2 + left( cfrac{X_2- bar{X_n}}{ sigma} right)^2+ cdots+ left( cfrac{X_n- bar{X_n}}{ sigma} right)^2 &amp;= cfrac{1}{ sigma^2} sum(X_i- bar{X_n})^2 [10pt] &amp;= chi^2_{n-1} end{aligned}$$ - 그런데 $s^2= cfrac{1}{n-1} sum(X_i- bar{X_n})^2$ 이므로 $ chi^2_{n-1}= cfrac{(n-1)s^2}{ sigma^2}$ 이다 . - 따라서 $ cfrac{(n-1)s^2}{ sigma^2}$의 표본분포는 자유도가 $n-1$인 $ chi^2_{n-1}$분포를 하고 있다 . - $X^2$분포가 어떻게 생겼는지 그래프를 그려서 확인해보자 . import numpy as np import matplotlib.pyplot as plt from scipy.stats import chi2 fig, ax = plt.subplots(figsize = (14, 7)) x = np.linspace(0, 8, 1000) for df in np.arange(1, 6): ax.plot(x, chi2(df).pdf(x), label = &#39;k = &#39; + str(df)) major_xticks = np.arange(0.0, 9.0, 2.0) minor_xticks = np.arange(0.5, 8.0, 0.5) major_yticks = np.arange(0, 1.2, 0.2) minor_yticks = np.arange(0.05, 1.0, 0.05) ax.set_title(&quot;$X^2$ distribution(df = 1, 2, 3, 4, 5)&quot;) ax.set_ylim(0, 1) ax.set_xlim(0, 8) ax.set_xticks(major_xticks) ax.set_xticks(minor_xticks, minor = True) ax.set_yticks(major_yticks) ax.set_yticks(minor_yticks, minor = True) ax.set_xlabel(&quot;$x$&quot;, fontsize = 14) ax.set_ylabel(&quot;$f(x)$&quot;, fontsize = 14, rotation = 0, labelpad = 20) ax.tick_params(axis = &#39;both&#39;, labelsize = 15, length = 10, direction = &#39;in&#39;) ax.tick_params(axis = &#39;both&#39;, which = &#39;minor&#39;, length = 5, direction = &#39;in&#39;) ax.grid() ax.legend() . &lt;matplotlib.legend.Legend at 0x27715b34250&gt; . - 정규분포와 t분포와 다르게 오른쪽으로 꼬리가 긴 분포이다 . - $ cfrac{(n-1)s^2}{ sigma^2}$의 표본분포는 위의 그래프처럼 자유도에 따라 달라짐 . - 단일모분산을 검정하는 검정통계량은 다음과 같음 . $$ chi^2_{n-1}= cfrac{(n-1)s^2}{ sigma^2}$$ . - 가설 $H_0 : sigma^2 = sigma_0^2$ 에 대한 검정은 대안가설 부호에 따라 다름 . $$ begin{aligned}H_a &amp;: sigma^2&gt; sigma_0^2 longrightarrow chi^2&lt; chi^{2}_{ alpha} H_a &amp;: sigma^2&lt; sigma_0^2 longrightarrow chi^2&gt; chi^2_{1- alpha} H_a &amp;: sigma^2 neq sigma_0^2 longrightarrow chi^2&lt; chi^2_{1- frac{ alpha}{2}} ; or ; chi^2&gt; chi^2_{ frac{ alpha}{2}} end{aligned}$$ - 이때 $ chi^2_{ alpha}$은 분포의 오른쪽 확률이 $ alpha$임을 나타낸다 . - 위가 성립하면 귀무가설 $H_0$를 기각한다 . &#45800;&#51068; &#47784;&#48516;&#49328;&#50640; &#45824;&#54620; &#44160;&#51221; &#50696;&#51228; . - 임의로 샘플을 만들고 모분산에 대해 검정해보자 . import numpy as np np.random.seed(2021) data = np.random.normal(0, 2, 10) . - 평균이 0이고 분산이 4인 정규분포에서 10개의 샘플을 뽑았다 . - 샘플을 가지고 $ alpha = 0.05$에서 모분산이 3를 넘는지 검정해보자 . $$H_0 : sigma^2 = 3 H_a : sigma^2 &gt; 3$$ . var_0 = 3 n = len(data) df = n - 1 s = np.std(data, ddof = 1) chi_square = (n-1) * (s**2) / var_0 ## 검정통계량 . s ## 표분편차는 1.52 . 1.5249196358322268 . - 검정통계량(chi2)이 $ chi^2_{0.05}$ 보다 크면 영가설을 기각할 수 있다 . from scipy.stats import chi2 X_square = chi2.ppf(0.95, df) ## 카이제곱분포의 오른쪽 영역이 0.05(왼쪽 영어은 0.95)가 되게하는 x 값 ## 누적분포의 역함수(ppf)를 통해 구한다 . X_square . 16.918977604620448 . chi_square . 6.9761396872400745 . X_square &lt; chi_square . False . - 검정통계량이 기각역보다 크지 않으므로 영가설을 기각할 수 없다 . - 따라서 모분산은 3보다 크다고 말할 수 없다 . - 분산이 4인 정규분포에서 샘플을 뽑았지만 영가설을 기각하지 못했음 . - 표본크기가 10으로 작아 변동성이 커 샘플의 분산이 2.32 이기 때문임 . - 표본크기가 더 크다면 영가설을 기각할 수 있을 것이다 . &#46160; &#47784;&#51665;&#45800;&#48516;&#49328; &#52264;&#51060;&#50640; &#45824;&#54620; &#44160;&#51221; . - 두 모집단의 분산을 비교하는데에는 F분포를 사용함 &gt; 왜? .",
            "url": "https://jaesu26.github.io/green/python/r/statistics/2021/07/27/%EA%B0%80%EC%84%A4%EA%B2%80%EC%A0%95.html",
            "relUrl": "/python/r/statistics/2021/07/27/%EA%B0%80%EC%84%A4%EA%B2%80%EC%A0%95.html",
            "date": " • Jul 27, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "파이썬에서 R실행",
            "content": "&#54028;&#51060;&#50028;&#50640;&#49436; R&#49892;&#54665;&#54616;&#44592; . 1. 아나콘다에 접속한 후 Anaconda Installers에서 64-Bit Graphical Installer(477MB)설치 . 2. Anaconda Prompt (anaconda3) 실행 . 3. 아래와 같이 입력 . (base) C: Users 한재수&gt; conda create -n py38r40 python=3.8 . (base) C: Users 한재수&gt; conda activate py38r40 . (py38r40) C: Users 한재수&gt; conda install jupyter lab . (py38r40) C: Users 한재수&gt; pip install rpy2 . (py38r40) C: Users 한재수&gt; R . 4. R에서 아래와 같이 입력 . &gt; install.packages(&quot;IRcernel&quot;) . &gt; IRcernel::installspec() . &gt; R.home() ## 나오는 경로 복사 . &gt; q() ## R 종료 . 5. 다시 프롬프트로 돌아와서 주피터랩 실행 . (py38r40) C: Users 한재수&gt; jupyter lab . 6. R세팅은 끝났고 파이썬에서 R을 사용하려면 아래와 같이 입력(주피터랩 킬 때마다 한 번씩만 입력) . import os . os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; ## R.HOME 에서 복사한 경로 . import rpy2 . %load_ext rpy2.ipython . 7. R사용 . 셀 마다 %R or %%R 입력하여 사용 . import os . os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; ## R.HOME 에서 복사한 경로 . import rpy2 . %load_ext rpy2.ipython . C: anaconda3 envs py38r40 lib site-packages rpy2 robjects packages.py:366: UserWarning: The symbol &#39;quartz&#39; is not in this R namespace/package. warnings.warn( . %R q &lt;- c(1, 2, 3) %R print(q) Q = [1, 2, 3] print(Q) . [1] 1 2 3 [1, 2, 3] . %%R x &lt;- c(1, 2, 3, 4, 5, 8, 9, 11) y &lt;- c(5, 1, 7, 12, 11, 5, 7, 21) model &lt;- lm(y ~ x) summary(model) . Call: lm(formula = y ~ x) Residuals: Min 1Q Median 3Q Max -6.3741 -4.4232 0.9096 3.2796 6.4840 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 2.9958 3.4644 0.865 0.420 x 1.0473 0.5469 1.915 0.104 Residual standard error: 5.185 on 6 degrees of freedom Multiple R-squared: 0.3793, Adjusted R-squared: 0.2759 F-statistic: 3.667 on 1 and 6 DF, p-value: 0.104 . - %R -i 을 통해 파이썬에서 정의한 변수를 R에서 사용할 수 있음 . import numpy as np data = np.random.rand(50) %R -i data . %%R hist(data) .",
            "url": "https://jaesu26.github.io/green/python/r/2021/07/26/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EC%84%9C-R%EC%8B%A4%ED%96%89.html",
            "relUrl": "/python/r/2021/07/26/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EC%84%9C-R%EC%8B%A4%ED%96%89.html",
            "date": " • Jul 26, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "변수 이름",
            "content": "&#48320;&#49688; &#51460;&#51076;&#47568; . - 변수를 줄임말로 쓸 때가 있는데 뭐인지 헷갈리는 변수를 정리할 거임 . - 나중에 변수 줄임말 말고도 변수명을 어떻게 정할지에 대한 내용도 정리할 수 도 있음 . - rtn &gt; return . - tmp &gt; temporary variable . - num &gt; number . - lib &gt; library . - lin &gt; linear . - rv &gt; random variable . - aes &gt; aesthetic . - axes &gt; axis(축)의 복수형 . - param(s) &gt; parameter(s) . - loc &gt; location . - pch &gt; point character . - fig &gt; figure . - ax &gt; axes . - alg &gt; algebra(대수학) . - cnt &gt; count . - ec &gt; edgecolor . - fc &gt; facecolor . - h &gt; horizontal . - v &gt; vertical . - cpy &gt; copy . - tb &gt; table . - autopct &gt; autopercentage . - ptr &gt; pointer . &#48320;&#49688; &#51460;&#51076;&#47568;&#51008; &#50500;&#45768;&#51648;&#47564; &#50500;&#47924;&#53948; &#51460;&#51076;&#47568;&#51076; . - WLLN &gt; Weak Law of Large Numbers(큰 수의 약한 법칙) . - MLE &gt; maximum likelihood estimate(최대우도추정량) . &#48320;&#49688; &#51060;&#47492; &#51667;&#44592; . - 모음을 생략하여 짓기 count &gt; cnt, return &gt; rtn . - 임시 변수는 _ 붙이기 &gt; tmp_ .",
            "url": "https://jaesu26.github.io/green/variable%20name/2021/07/26/%EB%B3%80%EC%88%98-%EC%9D%B4%EB%A6%84.html",
            "relUrl": "/variable%20name/2021/07/26/%EB%B3%80%EC%88%98-%EC%9D%B4%EB%A6%84.html",
            "date": " • Jul 26, 2021"
        }
        
    
  
    
        ,"post20": {
            "title": "적률생성함수",
            "content": "&#51201;&#47456;&#51060;&#46976; . - 확률변수의 특징을 설명 . - 확률변수 $X$의 $k$차 중심적률(central moment)을 $ mu_{k}$라 하면 $ mu_{k} = E[(X- mu)^{k}]$ . - $ mu_{1} = E(X) - mu = 0$ &gt; 확률변수 $X$의 $1$차 중심적률은 $0$ . - $ mu_{2} = E[(X- mu)^{2}]$ &gt; 확률변수 $X$의 $2$차 중심적률은 분산 . - $ mu_{3} = E[(X- mu)^{3}]$ &gt; 확률변수 $X$의 $3$차 중심적률은 왜도 . - $ mu_{4} = E[(X- mu)^{4}]$ &gt; 확률변수 $X$의 $4$차 중심적률은 첨도 . - 일반적인 확률 변수 $X$의 적률(moment)은 비중심(non-central)적률을 나타냄 $ longrightarrow$ $ mu&#39;_{k} = E[X^k]$ . - $ mu&#39;_{k} = E[X^k] = begin{cases} text{이산확률변수 : } sum limits_{x}x^{k}f(x) text{연속확률변수 : } int_{- infty}^{ infty}x^{k}f(x)dx end{cases}$ . - $ mu&#39;_{1} = mu$ . - $ sigma^{2} = mu_{2} = mu&#39;_{2} - ( mu&#39;_{1})^{2}$ . - 모평균$ mu$는 확률변수 $X$의 1차 비중심적률 . - 모분산$ sigma^{2}$은 확률변수 $X$의 2차 비중심적률에서 1차 비중심적률의 제곱을 뺀 값 . - 참고 자료: 통계수학 강의 . &#51201;&#47456;&#49373;&#49457;&#54632;&#49688;(moment generating function, mgf) . - 특정 확률 분포의 적률을 생성하는 함수 . - 적률을 계산하려면 연속확률변수의 경우 적분을 하게 되는데 어렵거나 불가능한 경우도 있음 &gt; 적률생성함수를 통해 계산 가능 . - 임의의 확률변수 $X$의 기댓값이 존재한다면 $X$의 적률생성함수 $M_{X}(t) = E(e^{tX}), ; t in mathbb{R}$ . - $M_{X}(t) = E(e^{tX}) = begin{cases} text{이산확률변수 : } sum limits_{x}e^{tx}f(x) text{연속확률변수 : } int_{- infty}^{ infty}e^{tx}f(x)dx end{cases}$ . - 확률변수 $X$의 기댓값을 구하는데 $X$가 아니라 $x$가 사용되네?? . - $X$의 기댓값은 $X$가 가질 수 있는 값인 $x$들을 통해 구한다 . - 사실 $x$말고 $k$라고 하든지 $a$라고 하든지 다른 변수를 사용해도 됨 &gt; 마치 적분할 때 $ int x ,dx = int t , dt = int a ,da$ 인 것 처럼 . - 중요한건 확률변수가 가질 수 있는 값들을 가지고 기댓값을 구한다는 것 &gt; 당연한 소리 . - 확률변수 $X$가 가질 수 있는 모든값들을 구하고 이것들의 평균을 구하면 그게 확률변수의 기댓값(당연함) . - 참고: $X$는 확률변수, $x$는 확률변수 $X$가 가지는 값 &gt; 이산확률변수는 $P(X=x)$, 연속확률변수는 $P(A leq X leq B)$ . - 적률생성함수는 항상 존재하는 것이 아님 . $e^{tX}$가 $t=0$근방에서 적분이 가능해야 함 $ ; ;$ . | $ forall , t in mathbb{R}, ; ;E(e^{tX}) &lt; infty $ . | &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; &#53945;&#51669; . - 두 확률변수의 mgf가 일치하면 두 확률변수는 같은 분포를 가짐 . - 적률생성함수를 $k$번 미분하고 $t=0$을 대입하면 확률변수 $X$의 $k$차 비중심 적률이다 &gt; 왜??? . &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; k&#48264; &#48120;&#48516; $ longrightarrow$ k&#52264; &#48708;&#51473;&#49900; &#51201;&#47456; . - $M_{X}(t) = E(e^{tX})$ . - $ cfrac{d^{k}M_{X}(0)}{dt^{k}} = E(X^{k})$ . - 매클로린 급수를 사용하자 . - $e^{tX} = sum limits_{k = 0}^{ infty} cfrac{X^k}{k!}(e^{tX})^{(k)}(0) = cfrac{t^{0}}{0!}X^{0}+ cfrac{t^1}{1!}X^1+ cfrac{t^2}{2!}X^2+ cfrac{t^3}{3!}X^3+ dots$ . - 양변에 기댓값을 취하면... . - $M_X(t)=E(e^{tX}) = 1 + tE(X) + cfrac{t^2}{2!}E(X^2) + cfrac{t^3}{3!}E(X^3)+ dots$ . - 이제 양변을 t에 대해 미분하자 . - $ cfrac{dM_X(t)}{dt} = 0 + E(X) + tE(X^2) + cfrac{t^2}{2}E(X^3)+ dots$ . - 이제 $t=0$을 대입하면... . - $ cfrac{dM_X(0)}{dt} = E(X)$ &gt; 1번 미분하니 1차 적률이 구해짐 . - 그럼 한 번 더 미분하면 2차 적률? &gt; ㅇㅇ . - $ cfrac{d^2M_X(t)}{dt^2} = 0 + 0 + E(X^2) + tE(X^3)+ dots$ . - 참고: $E(X)$는 $t$에 대하여 상수임 . - 이제 $t=0$을 대입하면 . - $ cfrac{d^2M_X(0)}{dt^2} = E(X^2)$ . - 정말로 2번 미분하니 2차 적률이 구해졌다.. . 확률 분포에 대해 정리할 때 기댓값과 분산을 과정없이 결과만 적었었음 . | 적률생성함수를 통해 여러가지 확률 분포의 기댓값과 분산을 구해보자 . | . &#44512;&#51068; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 균일 분포의 확률 밀도 함수: $f(x) = cfrac{1}{b-a}$ . - 균일 분포의 적률생성함수 . $ begin{aligned}M_X(t) &amp;= E(e^{tX}) [10pt] &amp;= int_{a}^{b}e^{tx} frac{1}{b-a}dx longrightarrow text{확률변수$X$가 $a$부터 $b$까지의 값을 가진다는 뜻} [10pt] &amp;= frac{1}{b-a} left[ frac{1}{t}e^{tx} right]_{a}^{b} [10pt] &amp;= frac{e^{t}(e^{b}-e^{a})}{t(b-a)} end{aligned}$ . - 균일 분포의 기댓값 &gt; 적률생성함수를 통해 구하는 것보다 1차 적률의 정의를 통해 구하는 것이 더 쉬움 . $ begin{aligned}E(X) &amp;= int_{a}^{b} frac{1}{b-a}x ;dx [10pt] &amp;= frac{1}{b-a} left[ frac{x^2}{2} right]_{a}^{b} [10pt] &amp;= frac{b^{2}-a^{2}}{2(b-a)} [10pt] &amp;= frac{a+b}{2} end{aligned}$ . - 균일 분포의 분산 &gt; 적률의 정의를 통해 구하자 &gt; 우선 2차 비중심 적률을 구하자 . $ begin{aligned}E(X^2) &amp;= int_{a}^{b} frac{1}{b-a}x^2 ;dx [10pt] &amp;= frac{1}{b-a} left[ frac{x^3}{3} right]_{a}^{b} [10pt] &amp;= frac{b^{3}-a^{3}}{3(b-a)} [10pt] &amp;= frac{a^2+ab+b^2}{3} end{aligned}$ . $ begin{aligned}Var(X) &amp;= E(X^2) - [E(X)]^2 [10pt] &amp;= cfrac{a^2+ab+b^2}{3} - bigg( cfrac{a+b}{2} bigg)^2 [10pt] &amp;= cfrac{4(a^2+ab+b^2) ,- 3(a^2+2ab+b^2)}{12} [10pt] &amp;= frac{(b-a)^2}{12} end{aligned}$ . &#44592;&#54616; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 기하 분포의 확률 질량 함수: $f(x) = q^{x-1}p, ; q=1-p, ; x = 1, 2, 3, dots$ . - 첫째항이 $a$, 공비가 $r$인 무한등비수열의 합: $ frac{a}{1-r}, ; |r|&lt;1$ . - 기하 분포의 적률생성함수 . $ begin{aligned}M_X(t) &amp;= E(e^{tX}) [10pt] &amp;= sum limits_{x=1}^{ infty}e^{tx}q^{x-1}p [10pt] &amp;= frac{p}{q} sum limits_{x=1}^{ infty}(qe^{t})^{x}, quad -1 &lt; qe^t &lt; 1 [10pt] &amp;= frac{pqe^t}{q(1-qe^t)} [10pt] &amp;= frac{pe^t}{1-qe^t}, quad t&lt;-ln(1-p) end{aligned}$ . - 기하 분포의 기댓값 . - 몫의 미분: $ bigg { cfrac{f(x)}{g(x)} bigg }&#39; = cfrac{f&#39;(x)g(x)-f(x)g&#39;(x)}{(g(x))^2}$ . $ begin{aligned}E(X) &amp;= frac{dM_X(t)}{dt} [10pt] &amp;= frac{pe^{t}(1-qe^t)-pe^{t}(-qe^t)}{(1-qe^t)^2} [10pt] &amp;= frac{pe^t}{(1-qe^t)^2} , quad text{$t=0$ 대입} [10pt] &amp;= frac{p}{(1-q)^2} [10pt] &amp;= frac{1}{p} end{aligned}$ . - 기하 분포의 분산 . $ begin{aligned}E(X^2) &amp;= frac{d^2M_X(t)}{dt^2} [10pt] &amp;= frac{pe^{t}(1-qe^t)^2- 2pe^{t}(1-qe^{t})(-qe^t)}{(1-qe^t)^4} [10pt] &amp;= frac{pe^{t}(1-qe^t)((1-qe^t)+2qe^t)}{(1-qe^t)^4} [10pt] &amp;= frac{pe^{t}(1+qe^t)}{(1-qe^t)^3}, quad text{$t=0$ 대입} [10pt] &amp;= frac{p(1+q)}{(1-q)^3} [10pt] &amp;= frac{1+q}{p^2} end{aligned}$ . $ begin{aligned}Var(X) &amp;= E(X^2) - [E(X)]^2 [10pt] &amp;= frac{1+q}{p^2} - big( frac{1}{p} big)^2 [10pt] &amp;= frac{q}{p^2} end{aligned}$ . &#51060;&#54637; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 이항 분포의 확률 질량 함수: $f(x) ,= , _{n} rm C_{x} ,p^{x} ,(1-p)^{n-x}$ . - 이항 분포는 서로 독립이고 동일한 베르누이 분포를 따르는 확률변수들을 n개 합한 것임 . - 베르누이 분포의 확률 질량 함수 $f(x) = p^{x}(1-p)^{1-x}, ; x = 0, 1$ . - 베르누이 분포의 기댓값 . $ begin{aligned}E(X) &amp;= sum limits_{x=0}^{1}xp^{x}(1-p)^{1-x} [10pt] &amp;= 0 cdot (1-p) + 1 cdot p [10pt] &amp;= p end{aligned}$ . - 베르누이 분포의 분산 . $ begin{aligned}E(X^2) &amp;= sum limits_{x=0}^{1}x^2p^x(1-p)^{1-x} [10pt] &amp;= 0 cdot (1-p) + 1 cdot p [10pt] &amp;= p end{aligned}$ . $ begin{aligned}Var(X) &amp;= E(X^2)-[E(X)]^2 [10pt] &amp;= p - p^2 [10pt] &amp;= p(1-p) end{aligned}$ . - 확률변수 $X, Y$에 대해 $E(X + Y)= E(X) + E(Y)$ . - 확률변수 $X, Y$가 독립이면 $Var(X + Y) = Var(X) + Var(Y)$ . - 참고: 확률변수의 합 특징 . - 이항 분포의 기댓값 &gt; 이항 분포의 정의를 통해 구함: 베르누이 분포를 따르는 확률변수들의 합 . $ begin{aligned}E(X) &amp;= E bigg( sum limits_{i=1}^{n}X_i bigg) = sum limits_{i=1}^{n}E(X_i) [10pt] &amp;= E(X_1) + E(X_2) + dots+E(X_{n-1})+E(X_n) [10pt] &amp;= overbrace{p + dots + p}^{n rm times} = np end{aligned}$ . - 이항 분포의 분산 --&gt; 기댓값과 마찬가지 . $ begin{aligned}Var(X) &amp;= Var bigg( sum limits_{i=1}^{n}X_i bigg) = sum limits_{i=1}^{n}Var(X_i) [10pt] &amp;= Var(X_1)+Var(X_2)+ dots+Var(X_{n-1})+Var(X_n) [10pt] &amp;= overbrace{p(1-p)+ dots+p(1-p)}^{n rm times} = np(1-p) end{aligned}$ . - 이항 정리 . - $(x+y)^n = sum limits_{k=0}^{n} binom{n}{k}x^{n-k}y^{k}$ . - 이항 분포의 적률생성함수 . $ begin{aligned}M_{X}(t) &amp;= E(e^{tX}) [10pt] &amp;= sum limits_{x=0}^{n} binom{n}{x}e^{tx}p^{x} ,(1-p)^{n-x} [10pt] &amp;= sum limits_{x=0}^{n} binom{n}{x}(pe^{t})^{x} ,(1-p)^{n-x} [10pt] &amp;= (1-p+pe^{t})^n end{aligned}$ . - 이항 분포의 기댓값 &gt; 적률생성함수 미분해서 구하기 . - 합성함수의 미분 . - $ big {f(g(x)) big }&#39; = g&#39;(x)f&#39;(g(x))$ . $ begin{aligned}E(X) &amp;= frac{dM_X(t)}{dt} [10pt] &amp;= npe^t(1-p+pe^t)^{n-1}, quad text{$t=0$ 대입} [10pt] &amp;= np end{aligned}$ . - 곱의 미분 . - $ big {f(x)g(x) big }&#39;=f&#39;(x)g(x)+f(x)g&#39;(x)$ . - 이항 분포의 분산 &gt; 적률생성함수 미분해서 구하기 . $ begin{aligned}E(X^2) &amp;= frac{d^2M_X(t)}{dt^2} [10pt] &amp;= npe^{t} cdot(1-p+pe^t)^{n-1}+npe^{t} cdot (n-1)pe^{t}(1-p+pe^{t})^{n-2}, quad text{$t=0$ 대입} [10pt] &amp;=np+np^{2}(n-1) [10pt] &amp;= np-np^2+n^2p^2 end{aligned}$ . $ begin{aligned}Var(X) &amp;= E(X^2)-[E(X)]^2 [10pt] &amp;= np-np^2+n^2p^2-(np)^2 [10pt] &amp;= np-np^2 [10pt] &amp;=np(1-p) end{aligned}$ . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 테일러 급수 공부해라 구더기야 + 극좌표계도(희망) 하기 싫어.......... . - 테일러 급수: 초월함수를 특정 값의 근방에서 멱함수로 근사시킴 &gt; 개사기임 . - $a$에서 $f$의 테일러 급수 . $ begin{aligned}f(x) &amp;= sum limits_{n=0}^{ infty} frac{f^{(n)}(a)}{n!}(x-a)^{n} [10pt] &amp;= f(a) + frac{f&#39;(a)}{1!}(x-a)+ frac{f&#39;&#39;(a)}{2!}(x-a)^2+ frac{f&#39;&#39;&#39;(a)}{3!}(x-a)^3+ cdots end{aligned}$ . - $a=0$인 특별한 경우 매클로린 급수라고 함 . $ begin{aligned}f(x) &amp;= sum limits_{n=0}^{ infty} frac{f^{(n)}(0)}{n!}x^n [10pt] &amp;= f(0) + frac{f&#39;(0)}{1!}x+ frac{f&#39;&#39;(0)}{2!}x^2+ frac{f&#39;&#39;&#39;(0)}{3!}x^3+ cdots end{aligned}$ . - $e^x$의 매클로린 급수 . - $e^x = sum limits^{ infty}_{n=0} cfrac{x^n}{n!}$ . - 포아송 분포의 확률 질량 함수: $f(x) = cfrac{e^{- lambda} lambda^{x}}{x!}$ . - 포아송 분포의 적률생성함수 . $ begin{aligned}M_X(t) &amp;= E(e^{tX}) [10pt] &amp;= sum limits_{x=0}^{ infty}e^{tx} frac{e^{- lambda} lambda^{x}}{x!} [10pt] &amp;=e^{- lambda} sum limits_{x=0}^{ infty} frac{( lambda e^{t})^{x}}{x!} quad text{$ therefore lambda e^t to x, quad x to n$ 으로 바꾸면 $e^x$의 매클로린 급수이다} [10pt] &amp;= e^{- lambda} cdot e^{ lambda e^{t}} [10pt] &amp;= e^{ lambda(e^{t}-1)} end{aligned}$ . - 포아송 분포의 기댓값 . - $e^{- lambda}$ 는 변수가 아니므로 $e^{ lambda e^{t}}$ 에 대해서만 미분하면 된다 . - $y =e^{t}, ; frac{d}{dy}(y) = e^{t}$ . $ begin{aligned}E(X) &amp;= frac{dM_X(t)}{dt} [10pt] &amp;=e^{- lambda} cdot(e^{ lambda y})&#39; [10pt] &amp;= e^{- lambda} cdot lambda e^{ lambda y} cdot frac{d}{dy}(y) [10pt] &amp;= e^{- lambda} cdot lambda e^{ lambda e^{t}} cdot e^{t}, quad text{$t=0$ 대입} [10pt] &amp;= lambda cdot e^{- lambda} cdot e^{ lambda} [10pt] &amp;= lambda end{aligned}$ . - 포아송 분포의 분산 . $ begin{aligned}E(X^2) &amp;= frac{d^2M_X(t)}{dt^2} [10pt] &amp;= lambda e^{- lambda} cdot big([ lambda e^{ lambda e^{t}} cdot e^{t}] cdot [e^{t}] + [e^{ lambda e^{t}}] cdot[e^{t}] big), quad text{$t=0$ 대입} [10pt] &amp;= lambda e^{- lambda}( lambda e^{ lambda}+e^{ lambda}) [10pt] &amp;= lambda^{2}+ lambda end{aligned}$ . $ begin{aligned}Var(X) &amp;= E(X^2)-[E(X)]^{2} [10pt] &amp;= lambda^{2}+ lambda - lambda^{2} [10pt] &amp;= lambda end{aligned}$ . &#51648;&#49688; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 지수 분포의 확률 밀도 함수: $f(x) = lambda e^{- lambda x}, ; x&gt;0$ . - $ lambda$는 포아송 분포의 모수로 단위 시간당 사건의 평균 발생 횟수 . - 지수 분포의 적률생성함수 . $ begin{aligned}M_{X}(t) &amp;= E(e^{tX}) [10pt] &amp;= int_{0}^{ infty}e^{tx} cdot lambda e^{- lambda x} ,dx [10pt] &amp;= lambda int_{0}^{ infty}e^{tx} cdot e^{- lambda x} ,dx [10pt] &amp;= lambda int_{0}^{ infty}e^{(t- lambda)x} ,dx [10pt] &amp;= frac{ lambda}{t- lambda} cdot left[e^{(t- lambda) x} right]_{0}^{ infty}, ; ; ;(t&lt; lambda) [10pt] &amp;= frac{ lambda}{ lambda - t} end{aligned}$ . - 지수 분포의 기댓값 . $ begin{aligned}E(X) &amp;= frac{dM_X(t)}{dt} [10pt] &amp;= frac{ lambda}{( lambda - t)^2}, quad text{$t=0$ 대입} [10pt] &amp;= frac{1}{ lambda} end{aligned}$ . - 지수 분포의 분산 . $ begin{aligned}E(X^2) &amp;= frac{d^2M_X(t)}{dt^2} [10pt] &amp;= - frac{-2 lambda( lambda-t) }{( lambda-t)^4} [10pt] &amp;= frac{2 lambda}{( lambda - t)^3}, quad text{$t=0$ 대입} [10pt] &amp;= frac{2}{ lambda^2} end{aligned}$ . $ begin{aligned}Var(X) &amp;= E(X^2) - [E(X)]^2 [10pt] &amp;= frac{2}{ lambda^2} - bigg( frac{1}{ lambda} bigg)^2 [10pt] &amp;= frac{1}{ lambda^2} end{aligned}$ . &#48288;&#53440; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 베타 분포의 확률 밀도 함수: $f(x)= cfrac{1}{B( alpha, beta)}x^{ alpha-1}(1-x)^{ beta-1}, quad 0 leq x leq1, ;( alpha , beta&gt;0)$ . - 베타 분포의 적률생성함수 . $ begin{aligned}M_t(x)&amp;=E(e^{tX}) [10pt] &amp;= int_{0}^{1} frac{1}{B( alpha, beta)}e^{tx}x^{ alpha-1}(1-x)^{ beta-1} ;dx [10pt] &amp;= int_{0}^{1} frac{1}{B( alpha, beta)} left( sum limits_{k=0}^{ infty} frac{t^k x^{k-1}}{k!} right)x^{ alpha-1}(1-x)^{ beta-1} ;dx [10pt] &amp;= sum limits_{k=0}^{ infty} int_{0}^{1} frac{1}{B( alpha, beta)} frac{t^k}{k!}x^{ alpha+k-1}(1-x)^{ beta-1} ;dx [10pt] &amp;= sum limits_{k=0}^{ infty} left[ int_{0}^{1} frac{B( alpha +k, beta)}{B( alpha, beta)} frac{1}{B( alpha+k, beta)} frac{t^k}{k!}x^{ alpha+k-1}(1-x)^{ beta-1} ;dx right] [10pt] &amp;=1+ sum limits_{k=1}^{ infty} left[ frac{B( alpha +k, beta)}{B( alpha, beta)} frac{t^k}{k!} int_{0}^{1} frac{1}{B( alpha+k, beta)}x^{ alpha+k-1}(1-x)^{ beta-1} ;dx right] [10pt] &amp;=1+ sum limits_{k=1}^{ infty} left[ frac{ Gamma( alpha +k)}{ Gamma( alpha+ beta+k)} frac{ Gamma( alpha + beta)}{ Gamma( alpha)} frac{t^k}{k!} right] [10pt] &amp;=1+ sum limits_{k=1}^{ infty} left[ prod limits_{i=0}^{k-1} frac{ Gamma( alpha +i)}{ Gamma( alpha+ beta+i)} frac{t^k}{k!} right] end{aligned}$ . - 베타 분포의 기댓값 &gt; 적률생성함수를 통해 구하는 것보다 1차 적률의 정의를 통해 구하는 것이 더 쉬움 . - 베타 분포의 $f(x)$를 적분하면 $1$이다 . - 그런데 $f(x)$가 아닌 $xf(x)$를 적분함 &gt; $x^{ alpha-1} to x^{ alpha}$ . - 원래는 성공횟수가 ${ alpha-1}$, 실패횟수가${ beta-1}$인 베타분포인데 성공횟수가 ${ alpha}$, 실패횟수가${ beta-1}$로 바뀌었음 . - 그런데 어자피 베타분포는 확률 밀도 함수이므로 정의역구간을 적분하면 $1$이므로 상관없다 &gt; 하지만 바뀐 베타분포의 상수(베타 함수)가 아닌 기존 베타분포의 상수가 곱해져있는데??? . - 어자피 상수는 적분에 영향을 주지 못하니까 상수항은 임의로 맞춰주면 된다 . $ begin{aligned}E(X) &amp;= int_{0}^{1}x frac{1}{B( alpha, beta)}x^{ alpha-1}(1-x)^{ beta-1} ;dx [10pt] &amp;= frac{1}{B( alpha, beta)} int_{0}^{1}x^{ alpha}(1-x)^{ beta-1} ;dx quad text{$ therefore frac{1}{B( alpha+1, beta)}$을 곱해주어 베타 분포를 만들자} [10pt] &amp;= frac{B( alpha+1, beta)}{B( alpha, beta)} int_{0}^{1} frac{1}{B( alpha+1, beta)}x^{ alpha}(1-x)^{ beta-1} ;dx [10pt] &amp;= frac{B( alpha+1, beta)}{B( alpha, beta)} cdot 1 &amp;= frac{ Gamma( alpha + beta)}{ Gamma( alpha) Gamma( beta)} cdot frac{ Gamma( alpha+1) Gamma( beta)}{ Gamma( alpha + beta+1)} quad text{$ therefore$ 감마함수의 성질: $ Gamma( alpha+1) = alpha Gamma( alpha)$} [10pt] &amp;= frac{ Gamma( alpha + beta)}{ Gamma( alpha) Gamma( beta)} cdot frac{ alpha Gamma( alpha) Gamma( beta)}{( alpha+ beta) Gamma( alpha + beta)} [10pt] &amp;= frac{ alpha}{ alpha+ beta} end{aligned}$ . - 베타 분포의 분산 &gt; 적률의 정의를 통해 구하자 &gt; 우선 2차 비중심 적률을 구하자 . - 베타 분포의 기댓값을 구할 때와 같은 방법을 사용하자 . $ begin{aligned}E(X^2) &amp;= int_{0}^{1}x^{2} frac{1}{B( alpha, beta)}x^{ alpha-1}(1-x)^{ beta-1} ;dx [10pt] &amp;= frac{1}{B( alpha, beta)} int_{0}^{1}x^{ alpha+1}(1-x)^{ beta-1} ;dx quad text{$ therefore frac{1}{B( alpha+2, beta)}$을 곱해주어 베타 분포를 만들자} [10pt] &amp;= frac{B( alpha+2, beta)}{B( alpha, beta)} int_{0}^{1} frac{1}{B( alpha+2, beta)}x^{ alpha+1}(1-x)^{ beta-1} ;dx [10pt] &amp;= frac{B( alpha+2, beta)}{B( alpha, beta)} cdot 1 [10pt] &amp;= frac{ Gamma( alpha + beta)}{ Gamma( alpha) Gamma( beta)} cdot frac{ Gamma( alpha+2) Gamma( beta)}{ Gamma( alpha + beta+2)} quad text{$ therefore Gamma( alpha+1) = alpha Gamma( alpha)$} [10pt] &amp;= frac{ Gamma( alpha + beta)}{ Gamma( alpha) Gamma( beta)} cdot frac{ alpha( alpha+1) Gamma( alpha) Gamma( beta)}{( alpha+ beta+1)( alpha+ beta) Gamma( alpha + beta)} [10pt] &amp;= frac{ alpha( alpha+1)}{( alpha+ beta)( alpha+ beta+1)} end{aligned}$ . $ begin{aligned}Var(X) &amp;= E(X^2) - [E(X)]^2 [10pt] &amp;= frac{ alpha( alpha+1)}{( alpha+ beta)( alpha+ beta+1)} - bigg( frac{ alpha}{ alpha+ beta} bigg)^{2} [10pt] &amp;= frac{ alpha}{ alpha+ beta} bigg( frac{ alpha+1}{ alpha+ beta+1}- frac{ alpha}{ alpha+ beta} bigg) [10pt] &amp;= frac{ alpha}{ alpha+ beta} bigg( frac{( alpha+1)( alpha+ beta)}{( alpha+ beta)( alpha+ beta+1)}- frac{ alpha( alpha+ beta+1)}{( alpha+ beta)( alpha+ beta+1)} bigg) [10pt] &amp;= frac{ alpha}{ alpha+ beta} cdot frac{ beta}{( alpha+ beta)( alpha+ beta+1)} [10pt] &amp;= frac{ alpha beta}{( alpha+ beta)^{2}( alpha+ beta+1)} end{aligned}$ . &#44048;&#47560; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 감마 분포의 확률 밀도 함수: $f(x) = cfrac{1}{ beta^{ alpha} Gamma( alpha)}x^{ alpha - 1}e^{- frac{x}{ beta}},(x, alpha, beta geq 0)$ . - 감마 함수: $ Gamma( alpha) = int_{0}^{ infty}x^{ alpha-1}e^{-x}dx, , alpha geq 0$ . - 감마 함수를 살짝 변형하면 $ int_{0}^{ infty} cfrac{1}{ Gamma( alpha)}x^{ alpha-1}e^{-x}dx = 1$ . - 위의 식을 감마 분포의 적률생성함수를 구하는데 사용할 것임 . - 감마 분포의 적률생성함수 &gt; $t=0$ 근방임을 잊지말자 . $ begin{aligned}M_X(t) &amp;= E(e^{tX}) [10pt] &amp;= int_{0}^{ infty} frac{1}{ beta^{ alpha} Gamma( alpha)}x^{ alpha - 1}e^{- frac{x}{ beta}}e^{tx} ;dx quad text{$ therefore$ 감마함수의 적분을 이용하기 위해 치환} [10pt] &amp;= frac{1}{ beta^ alpha} int_{0}^{ infty} frac{1}{ Gamma( alpha)}x^{ alpha - 1}e^{ Big(t- frac{1}{ beta} Big)x} ;dx quad text{$ therefore bigg(t- frac{1}{ beta} bigg)x=-y, quad dx= frac{ beta}{1- beta t}dy$} [10pt] &amp;= frac{1}{ beta^ alpha} int_{0}^{ infty} frac{1}{ Gamma( alpha)} bigg( frac{ beta}{1- beta t}y bigg)^{ alpha - 1}e^{-y} frac{ beta}{1- beta t} ;dy quad text{$ therefore x= frac{ beta}{1- beta t}y, ;x=0 to y=0, ;x= infty to y= infty, ; bigg(t&lt; frac{1}{ beta} bigg)$} [10pt] &amp;= frac{1}{ beta^ alpha} bigg( frac{ beta}{1- beta t} bigg)^{ alpha} int_{0}^{ infty} frac{1}{ Gamma( alpha)}y^{ alpha - 1}e^{-y} ;dy quad text{$ therefore int_{0}^{ infty} frac{1}{ Gamma( alpha)}y^{ alpha-1}e^{-y}dy = 1$, 위에 참고} [10pt] &amp;= bigg( frac{1}{1- beta t} bigg)^{ alpha}, quad t&lt; frac{1}{ beta} end{aligned}$ . - 감마 분포의 기댓값 . $ begin{aligned}E(X) =&amp; frac{dM_X(t)}{dt} [10pt] &amp;= alpha bigg( frac{1}{1- beta t} bigg)^{ alpha-1} cdot frac{d}{dt} bigg( frac{1}{1- beta t} bigg) [10pt] &amp;= alpha bigg( frac{1}{1- beta t} bigg)^{ alpha-1} cdot frac{ beta}{(1- beta t)^2} [10pt] &amp;= frac{ alpha beta}{(1- beta t)^{ alpha+1}}, quad text{$t=0$ 대입} [10pt] &amp;= alpha beta end{aligned}$ . . - 감마 분포의 분산 . $ begin{aligned}E(X^2) &amp;= frac{d^2M_X(t)}{dt^2} [10pt] &amp;= alpha beta frac{ beta( alpha+1)(1- beta t)^{ alpha}}{(1- beta t)^{2 alpha+2}} [10pt] &amp;= frac{ alpha beta^{2}( alpha+1)}{(1- beta t)^{ alpha+2}}, quad text{$t=0$ 대입} [10pt] &amp;= alpha beta^{2}( alpha+1) end{aligned}$ . $ begin{aligned}Var(X) &amp;= E(X^2) - [E(X)]^2 [10pt] &amp;= alpha beta^{2}( alpha+1) - ( alpha beta)^{2} [10pt] &amp;= alpha beta^{2}( alpha+1)- alpha^2 beta^2 [10pt] &amp;= alpha beta^2 end{aligned}$ . . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 카이제곱 분포의 확률 밀도 함수: $f(x) = dfrac{1}{2^ frac{k}{2} Gamma big( frac{k}{2} big)}x^{ frac{k}{2}-1}e^{- frac{x}{2}}$ . - $k$는 자유도 . - 감마 분포에서 $ alpha= frac{k}{2}, beta = 2$인 경우 카이제곱 분포라고 했음 . - 그렇기에 감마분포의 평균, 분산, 적률생성함수에 $ alpha= frac{k}{2}, beta = 2$를 대입하여 카이제곱 분포의 평균, 분산, 적률생섬함수를 구할 수 있음(내 생각) . - 카이제곱 분포의 적률생성함수 . $ begin{aligned}M_X(t) &amp;= bigg( frac{1}{1- beta t} bigg)^{ alpha}, quad t&lt; frac{1}{ beta}, quad text{$ alpha= frac{k}{2}, ; beta = 2$ 대입} [10pt] &amp;= bigg( frac{1}{1-2t} bigg)^ frac{k}{2} end{aligned}$ . - 카이제곱 분포의 기댓값 . - $E(X) = alpha beta= k, quad text{$ alpha= frac{k}{2}, ; beta = 2$ 대입}$ . - 카이제곱 분포의 분산 . - $Var(X) = alpha beta^2=2k, quad text{$ alpha= frac{k}{2}, ; beta = 2$ 대입}$ . &#51221;&#44508; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 정규 분포의 확률 밀도 함수: $f(x) = cfrac{1}{ sqrt{2 pi sigma^{2}}}e^{- dfrac{(x- mu)^{2}}{2 sigma^{2}}}$ . - 완전제곱식 생성: $x^2-ax= big(x- frac{a}{2} big)^2- frac{a^2}{4}$ . - 정규 분포의 적률생성함수 . $ begin{aligned}M_X(t) &amp;= E(e^{tX}) [10pt] &amp;= int_{- infty}^{ infty}e^{tx} frac{1}{ sqrt{2 pi sigma^{2}}}e^{- dfrac{(x- mu)^{2}}{2 sigma^{2}}} ;dx [10pt] &amp;= int_{- infty}^{ infty} frac{1}{ sqrt{2 pi sigma^{2}}}e^{- dfrac{x^2-2( mu+ sigma^{2}t)x+ mu^2}{2 sigma^{2}}} ;dx [10pt] &amp;= int_{- infty}^{ infty} frac{1}{ sqrt{2 pi sigma^{2}}}e^{- dfrac{(x- mu- sigma^{2}t)^2-( mu+ sigma^2t)^2+ mu^2}{2 sigma^{2}}} ;dx [10pt] &amp;=e^{ mu t+ frac{ sigma^2 t^2}{2}} cdot int_{- infty}^{ infty} frac{1}{ sqrt{2 pi sigma^{2}}}e^{- dfrac{(x- mu- sigma^{2}t)^2}{2 sigma^2}} ;dx [10pt] &amp;=e^{ mu t+ frac{ sigma^2 t^2}{2}} quad text{$ therefore$ 평균이 $ mu+ sigma^{2}t$이고 표준편차가 $ sigma$인 정규분포이므로 적분값은 $1$} end{aligned}$ . . - 정규 분포의 기댓값 . $ begin{aligned}E(X) &amp;= frac{dM_X(t)}{dt} [10pt] &amp;= ( mu + sigma^2 t)e^{ mu t+ frac{ sigma^2 t^2}{2}}, quad text{$t=0$ 대입} [10pt] &amp;= mu end{aligned}$ . . - 정규 분포의 분산 . $ begin{aligned}E(X^2) &amp;= frac{d^2M_X(t)}{dt^2} [10pt] &amp;= sigma^{2}e^{ mu t+ frac{ sigma^2 t^2}{2}}+( mu+ sigma^2 t)^2e^{ mu t+ frac{ sigma^2 t^2}{2}}, quad text{$t=0$ 대입} [10pt] &amp;= sigma^2+ mu^2 end{aligned}$ . $ begin{aligned}Var(X)&amp;=E(X^2)-[E(X)]^2 [10pt] &amp;= sigma^2+ mu^2-( mu)^2 [10pt] &amp;= sigma^2 end{aligned}$ . .",
            "url": "https://jaesu26.github.io/green/statistics/2021/07/23/%EC%A0%81%EB%A5%A0%EC%83%9D%EC%84%B1%ED%95%A8%EC%88%98.html",
            "relUrl": "/statistics/2021/07/23/%EC%A0%81%EB%A5%A0%EC%83%9D%EC%84%B1%ED%95%A8%EC%88%98.html",
            "date": " • Jul 23, 2021"
        }
        
    
  
    
        ,"post21": {
            "title": "동적 계획법",
            "content": "&#46041;&#51201; &#44228;&#54925;&#48277; . - 다이나믹 프로그래밍 참고: 동적 계획법 . - 다이나믹 프로그래밍((Dynamic Programming)으로도 불림 . - 큰 문제를 작은 문제로 나눠서 푸는 방법 . - 분할 정복과 유사하지만.. . 동적 계획법 분할 정복 . 공통점 | 큰 문제를 작은 문제로 나눠서 해결 | 큰 문제를 작은 문제로 나눠서 해결 | . 차이점 | 작은 문제가 반복됨 | 작은 문제가 반복되지 않음 | . - 나중에 분할 정복에 대해서도 다뤄보자 . &#45796;&#51060;&#45208;&#48121; &#54532;&#47196;&#44536;&#47000;&#48141; &#51312;&#44148; . 작은 문제들의 반복 . | 같은 문제는 구할 때마다 정답이 같음 . | &#45796;&#51060;&#45208;&#48121; &#54532;&#47196;&#44536;&#47000;&#48141; &#44396;&#54788; . - 모든 작은 문제는 단 한번만 풀어야 함 . - 정답을 구한 작은 문제는 어딘가에 저장 . - 큰 문제를 해결할 때 미리 구한 작은 문제의 정답을 사용 . 피보나치 수열을 다이나믹 프로그래밍으로 구현해보자 | . Top-down . - 큰 문제를 해결할 때 작은 문제가 해결되지 않았으면 작은 문제를 해결하여 큰 문제를 해결 . - 재귀 함수로 구현하는 경우가 대부분 Top-down 방법 . - 메모이제이션 기법 사용 --&gt; 미리 구한 작은 문제의 정답을 어딘가에 저장 . fibonacci = {0:0, 1:1} ## 메모이제이션을 위한 딕셔러니 선언 ## 리스트도 가능 def fibo_top_down(n): if n in fibonacci: return fibonacci[n] fibonacci[n] = fibo_top_down(n-1) + fibo_top_down(n-2) return fibonacci[n] . fibo_top_down(10) . 55 . Bottom-up . - 작은 문제부터 차근차근 해결하여 큰 문제를 해결 . - 반복문 사용 . def fibo_bottom_up1(n): if n &lt;= 1: return n fir_fibo = 0 sec_fibo = 1 for _ in range(n-1): next_fibo = fir_fibo + sec_fibo ## 2번째 피보나치 값 = 0번째 피보나치 값 + 1번째 피보나치 값(n번째 피보나치 값 = n-2번째 피보나치 값 + n-1번째 피보나치 값) fir_fibo = sec_fibo ## 0번째 피보나치 값을 1번째 피보나치 값으로 업데이트 sec_fibo = next_fibo ## 1번째 피보나치 값을 2번째 피보나치 값으로 업데이트 ## 다시 for문 시작으로 돌아가서 1번째 피보나치 값과 2번째 피보나치 값을 통해 3번째 피보나치 값을 구함(이를 n-1번 반복) ## for 문의 역할은 점화식을 통해 0번째와 1번째의 피보나치 값을 가지고 n번째의 피보나치 값을 구한다 return next_fibo . fibo_bottom_up1(10) . 55 . - 또 다른 방법 . - 미리 dp라는 list를 생성 . x = 100 ## 문제 조건에 맞춰서 dp = [-1] * x ## 리스트 초기화 def fibo_bottom_up2(n): ## 굳이 함수를 사용하지 않아도 상관 없음 dp[0] = 0 dp[1] = 1 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] . fibo_bottom_up2(10) . 55 . - bottom-up 방식으로 구현한 위의 두개 코드의 차이점은? . - fibo(9)와 fibo(10)을 구할 때 처음 코드는 fibo_bottom_up1(9)과 fibo_bottom_up1(10) 총 함수를 2번 사용 . - 사실 fibo_bottom_up1(10)을 구했다면 fibo_bottom_up1(9)도 당연히 알지만 각각을 따로 두 번 구했다 . - 첫번째 코드의 경우 다이나믹 프로그래밍은 이미 구한 작은 문제 정답은 또 구하지 않기로 했지만 그렇지 않은 모습 . - 하지만 두번째 코드는 fibo_bottom_up2(10)을 구했다면 dp[0] ~ dp[10]까지 값이 채워져 있기에 fibo_bottom_up2(9)를 하지 않고 dp[9]를 통해 fibo(9)를 구할 수 있음 . - 결론: 두번째 코드 쓰세요 .",
            "url": "https://jaesu26.github.io/green/python/algorithm/2021/07/19/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html",
            "relUrl": "/python/algorithm/2021/07/19/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html",
            "date": " • Jul 19, 2021"
        }
        
    
  
    
        ,"post22": {
            "title": "파이썬 기본 연산 시간 복잡도(Big O)",
            "content": "&#49884;&#44036; &#48373;&#51105;&#46020; . - 컴퓨터 프로그램의 입력값과 연산 수행 시간의 함수 관계 . - 보통 Big O 표기법으로 나타냄 . Big O &#54364;&#44592;&#48277; . - 알고리즘의 시간 복잡도를 나타내는 척도 . - 두 함수 $f$와 $g ,(g&gt;0)$에 대해 상수 $k&lt; infty$가 존재해서 $x in A subset mathbb{R}$인 $x$에 대하여 $| frac{f(x)}{g(x)}|&lt;K$이면 $f(x)=O(g(x))$임 . - 쉽게 말하면 $f$나 $g$나 고만고만하다는 뜻 . - $f(x) = 2x, ,g(x) = x$이면 $| frac{f(x)}{g(x)}| = 2&lt; infty$이므로 $f(x) = O(g(x))$임 &gt; $f$나 $g$나 비슷함 . - 만약 $h(x) = x^2$이면 $| frac{h(x)}{g(x)}| = |x|$이고 $x to infty$이면 $| frac{h(x)}{g(x)}| to infty$이므로 $h(x) neq O(g(x))$임 &gt; $h$와 $g$는 급이 다름 . &#50672;&#49328; &#49884;&#44036; &#48373;&#51105;&#46020; . - 자료형별 연산의 시간 복잡도를 나타내자 . &#47532;&#49828;&#53944;(list) . - l은 리스트(list) . - k는 상수 . - 참고: 파이썬 자료형별 연산 시간 복잡도 . Operation Example Complexity Class Notes . index | l[n] | $O(1)$ | | . store | l[n] = 0 | $O(1)$ | store는 변수 저장 | . length | len(l) | $O(1)$ | | . append | l.append(5) | $O(1)$ | | . pop | l.pop() | $O(1)$ | same as l.pop(-1) | . clear | l.clear() | $O(1)$ | similar to l = [] | . slice | l[a:b] | $O(b-a)$ | $l[1:5] to O(l)$, $l[ ; ; : ; ; ] to O(len(l)-0)=O(N)$ | . extend | l.extend(...) | $O(len( dots))$ | depends only on len of extension | . construction | list(...) | $O(len( dots))$ | depends on length of ... iterable | . check ==, != | l1 == l2 | $O(N)$ | | . insert | l[a:b] = ... | $O(N)$ | | . delete | del l[n] | $O(N)$ | depends on n; $O(N)$ in worst case | . containment | x in/not in l | $O(N)$ | linearly searches list | . copy | l.copy() | $O(N)$ | Same as $l[ ; ;: ; ;]$ which is $O(N)$ | . remove | l.remove(...) | $O(N)$ | | . pop | l.pop(n) | $O(N)$ | $O(N-i)$: l.pop(0): $O(N)$ (see above) | . extreme value | min(l)/max(l) | $O(N)$ | linearly searches list for value | . reverse | l.reverse() | $O(N)$ | | . iteration | for v in l: | $O(N)$ | Worst: no return/break in loop | . sort | l.sort() | $O(N Log N)$ | key/reverse mostly does not change | . multiply | $k times l$ | $O(kN)$ | $5 times l$ is $O(N)$: $len(l) times l$ is $O(N^2)$ | . &#51665;&#54633;(set) . - 리스트에 비해 시간 복잡도가 작음 . Operation Example Complexity Class Notes . Length | len(s) | $O(1)$ | | . Add | s.add(5) | $O(1)$ | | . Containment | x in/not in s | $O(1)$ | compare to list/tuple - $O(N)$ | . Remove | s.remove(..) | $O(1)$ | compare to list/tuple - $O(N)$ | . Discard | s.discard(..) | $O(1)$ | | . Pop | s.pop() | $O(1)$ | popped value &quot;randomly&quot; selected | . Clear | s.clear() | $O(1)$ | similar to s = set() | . Construction | set(...) | $O(len(...))$ | depends on length of ... iterable | . check ==, != | s != t | $O(len(s))$ | same as len(t); False in O(1) if the lengths are different | . &lt;=/&lt; | s &lt;= t | $O(len(s))$ | issubset | . &gt;=/&gt; | s &gt;= t | $O(len(t))$ | issuperset s &lt;= t == t &gt;= s | . Union | s | t | $O(len(s)$+$len(t))$ | | . Intersection | s &amp; t | $O(len(s)$+$len(t))$ | | . Difference | s - t | $O(len(s)$+$len(t))$ | | . Symmetric Diff | s ^ t | $O(len(s)$+$len(t))$ | | . Iteration | for v in s: | $O(N)$ | Worst: no return/break in loop | . Copy | s.copy() | $O(N)$ | | . &#54644;&#49884;(dictionary) . - 시간 복잡도가 대부분 $O(1)$이다 . - 같은 함수라면 리스트 대신 딕셔너리를 사용하는 것이 시간 복잡도 면에서 우월함 . Operation Example Complexity Class Notes . Index | d[k] | $O(1)$ | | . Store | d[k] = v | $O(1)$ | | . Length | len(d) | $O(1)$ | | . Delete | del d[k] | $O(1)$ | | . get/setdefault | d.get(k) | $O(1)$ | | . Pop | d.pop(k) | $O(1)$ | | . Pop item | d.popitem() | $O(1)$ | popped item &quot;randomly&quot; selected | . Clear | d.clear() | $O(1)$ | similar to s = {} or = dict() | . View | d.keys() | $O(1)$ | same for d.values() | . Construction | dict(...) | $O(len(...))$ | depends # (key,value) 2-tuples | . Iteration | for k in d: | $O(N)$ | all forms: keys, values, items, Worst: no return/break in loop | .",
            "url": "https://jaesu26.github.io/green/python/algorithm/2021/07/15/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B8%B0%EB%B3%B8%EC%97%B0%EC%82%B0-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84.html",
            "relUrl": "/python/algorithm/2021/07/15/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B8%B0%EB%B3%B8%EC%97%B0%EC%82%B0-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84.html",
            "date": " • Jul 15, 2021"
        }
        
    
  
    
        ,"post23": {
            "title": "문자열 처리",
            "content": "format &#54632;&#49688; . - 문자열을 포매팅(formatting)하는데 사용 . - 포매팅: 문자열의 원하는 위치에 특정 변수를 삽입 . - 아래 예제를 보자 . &#39;이름:{},나이:{},성별:{}&#39;.format(&#39;홍길동&#39;,&#39;21&#39;,&#39;남&#39;) . &#39;이름:홍길동,나이:21,성별:남&#39; . - 순서대로 홍길동, 21, 남이 {}에 삽입됨 . - 구구단도 쉽게 출력할 수 있음 . i = 2 for j in range(1, 10): print(&#39;{} X {} = {}&#39;.format(i, j, i*j)) . 2 X 1 = 2 2 X 2 = 4 2 X 3 = 6 2 X 4 = 8 2 X 5 = 10 2 X 6 = 12 2 X 7 = 14 2 X 8 = 16 2 X 9 = 18 . [$ star$]&#49548;&#49688;&#51216; &#51088;&#47551;&#49688; &#54364;&#54788;[$ star$] . - 알고리즘 문제를 풀다보면 특정 소수점 자릿수까지 출력을 요구할 때가 있음 . - 계산 결과를 소수점 셋째 자리 까지 표현하려면? . a = 10 b = 3 a / b . 3.3333333333333335 . - 소수점 셋째 짜리 까지 표현하고 싶음 . - format 함수 사용! . a = 10 b = 3 print(&#39;{:.3f}&#39;.format(a / b)) . 3.333 . - round 함수도 되는데? . - round(x, a) --&gt; x를 소수점 a번째 까지 나타냄 . a = 10 b = 3 round(a / b, 3) . 3.333 . - 아래와 같은 경우는? . a = 10 b = 2 a / b . 5.0 . - format 함수 . a = 10 b = 2 print(&#39;{:.3f}&#39;.format(a / b)) . 5.000 . - round 함수 . a = 10 b = 2 round(a / b, 3) . 5.0 . - format 함수는 소수점 셋째 자리까지 나타낸 반면 round 함수는 첫째 자리까지 나타냄 . round 함수를 사용할 때 주의할 점 | . - 파이썬에서는 사사오입의 원칙을 따라 반올림할 자리가 5이면 반올림을 할 때 짝수면 내림, 홀수면 올림 한다 . round(2.5) . 2 . round(-1.5) . -2 . - 오사오입의 원칙으로 반올림 하려면? --&gt; 함수를 따로 만들자 . def round2(number): if number &gt;= 0: if number - int(number) &gt;= 0.5: a = 1 else: a = 0 return int(number) + a else: if int(number) - number &gt; 0.5: a = -1 else: a = 0 return int(number) + a . round2(2.5) . 3 . round2(-1.5) . -1 . - 사사오입의 원칙으로 반올림을 하는 이유는 데이터의 대부분이 .5로 끝나는 자료라면 이를 반올림하면 0.5만큼의 오차가 생기기 때문 . 결론: 원하는 자릿수 까지 나타내려면 round 함수 대신 format 함수를 쓰자 | . join &#54632;&#49688; . - 문자열로 이루어진 리스트를 기준 문자열로 합쳐 문자열로 만듦 . - &#39;구분자&#39;.join(list) . - 구분자에는 문자열, list에는 문자열을 원소로 가지는 리스트가 들어감 . a = [&#39;12&#39;, &#39;45&#39;, &#39;48&#39;] . &#39;-&#39;.join(a) . &#39;12-45-48&#39; . &#39;&#39;.join(a) . &#39;124548&#39; . replace &#54632;&#49688; . - 특정 문자를 다른 문자로 대체 . - &#39;문자열&#39;.replace(&#39;기존 문자&#39;, &#39;바꿀 문자&#39;) . a = &#39;hello world&#39; . a.replace(&#39;h&#39;, &#39;H&#39;) . &#39;Hello world&#39; . a.replace(&#39;&#39;, &#39;!&#39;) . &#39;!h!e!l!l!o! !w!o!r!l!d!&#39; . - 문자열에서는 빈칸도 하나의 문자로 취급 . split &#54632;&#49688; . - 문자열을 구분자를 기준으로 쪼갬 . - &#39;문자열&#39;.split(&#39;구분자&#39;) . a = &#39;!h!e!l!l!o! !w!o!r!l!d!&#39; . a.split(&#39;!&#39;) . [&#39;&#39;, &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;&#39;] . upper &#54632;&#49688; . - 문자열에서 모든 소문자를 대문자로 바꿈 . - &#39;문자열&#39;.upper(&#39;구분자&#39;) . a = &#39;hello world&#39; . a.upper() . &#39;HELLO WORLD&#39; . str.isupper() . - str이 대문자로만 이루어져 있으면 True를 아니면 False를 반환 . string = &#39;ABC&#39; string2 = &#39;AbC&#39; . string.isupper() . True . string2.isupper() . False . lower &#54632;&#49688; . - 문자열에서 모든 대문자를 소문자로 바꿈 . - &#39;문자열&#39;.lower(&#39;구분자&#39;) . a = &#39;HELLO WORLD&#39; . a.lower() . &#39;hello world&#39; . str.islower() . - str이 소문자로만 이루어져 있으면 True를 아니면 False를 반환 . string = &#39;abc&#39; string2 = &#39;aBc&#39; . string.islower() . True . string2.islower() . False . count &#54632;&#49688; . - 문자열에서 특정 문자 or 문자열의 개수를 반환함 . - &#39;문자열&#39;.count(&#39;찾는 문자&#39;, 시작 인덱스, 끝 인덱스) . - 시작 인덱스 $ leq$ 문자열 $&lt;$ 끝 인덱스 . a = &#39;HELLO WORLD&#39; . a.count(&#39;L&#39;) . 3 . a.count(&#39;L&#39;, 0, 9) . 2 . a.count(&#39;L&#39;, 0, 10) . 3 . chr &#54632;&#49688; . - 아스키 코드를 문자로 변환함 . - chr(아스키코드) . - 아스키 코드 참고: https://ko.wikipedia.org/wiki/ASCII . chr(65) . &#39;A&#39; . ord &#54632;&#49688; . - 문자를 아스키 코드로 변환함 . - ord(&#39;문자&#39;) . ord(&#39;A&#39;) . 65 .",
            "url": "https://jaesu26.github.io/green/python/2021/07/09/%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/2021/07/09/%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%95%A8%EC%88%98.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post24": {
            "title": "그리디 알고리즘",
            "content": "&#44536;&#47532;&#46356; &#50508;&#44256;&#47532;&#51608;(&#50837;&#49900;&#51137;&#51060; &#50508;&#44256;&#47532;&#51608;, Greedy Algorithm)&#51060;&#46976;? . - 다이나믹 프로그래밍이 모든 경우를 확인 한다는 점에서 고안된 알고리즘 . - 매 선택마다 가장 최적인 답을 선택하여 결론을 도출 --&gt; 알파고: 자신 차례마다 가장 승률이 높은 수를 선택 . - but, 매 선택마다 최적이지만 결과가 최적이라는 보장 없음 . - 마시멜로 실험: 당장은 1개, 기다리면 2개 --&gt; 최적해: 기다리고 2개 먹기 . - 하지만 그리디 알고리즘은 지금 최적의 선택인 1개를 선택 --&gt; 최적해 아님 . &#44536;&#47084;&#47732; &#50612;&#46500; &#44221;&#50864;&#50640; &#51096; &#46041;&#51089;&#54616;&#45716;&#44032;? . - 탐욕 선택 속성(greedy choice property): 한번의 선택이 다음 선택과는 무관 . - 최적 부분 구조(optimal substructure): 매 순간의 최적해 --&gt; 문제에 대한 최적해 . &#44536;&#47532;&#46356; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . - 백준 - 설탕 배달: https://www.acmicpc.net/problem/2839 . - 설탕 N kg을 3kg, 5kg봉지에 담아야 하는데 봉지의 수를 최소화 . 최적 부분 구조: 매 순간 봉지의 수를 최소화하려는 행위(3kg 봉지 보다 5kg 봉지 사용)는 문제에 대한 최적해(봉지의 수 최소화) . | 탐욕 선택 속성: 전에 5kg 봉지를 선택하든 3kg 봉지를 선택하든 상관없이 현재 남아있는 무게를 가지고만 판단하여 선택 . | - 그리디 알고리즘: 5kg 봉지로만 담는 것이 최선 . - 만약 5kg 봉지로만 담는 것이 불가능하면? . - 5kg 봉지를 하나 줄이고 3kg 봉지를 사용함 . - 이를 반복함 --&gt; 만약 담는 것이 불가능하면 -1 return . 설탕 배달(그리디 알고리즘) | . - 설탕의 무게는 N kg . 5kg 봉지 선택(최적 판단) . | 5kg 봉지 선택(최적 판단) . | 5kg 봉지만 계속 선택 --&gt; total: k 번 선택(최적 판단) . | 만약 남은 무게가 예컨데 4kg 이라 5kg 봉지에 담지 못한다면 3kg 선택(최적 판단) . | 3kg 에 담고나면 1kg 이 남음 --&gt; 어느 봉지에도 담지 못함 . | 5kg 봉지를 k - 1번 선택하고 3kg 봉지를 선택 . | 5kg 봉지를 0번 선택할 때 까지 반복 --&gt; 이 경우에도 답이 없다면 해가 존재하지 않음 . | N = int(input()) def sugar(n): k = n // 5 l = n % 5 for i in range(k+1): if l == 0: return k break elif l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 21 . - 설탕 무게가 101kg 일시 5kg 19개, 3kg 2개를 선택 .",
            "url": "https://jaesu26.github.io/green/python/algorithm/2021/07/09/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "relUrl": "/python/algorithm/2021/07/09/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post25": {
            "title": "DFS와 BFS 알고리즘",
            "content": "&#44618;&#51060; &#50864;&#49440; &#53456;&#49353;(Depth First Search, DFS) . - 모든 정점을 한번만 방문 . - 시작 노드에서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색 . - 방문할 노드와 방문한 노드를 기준으로 탐색 . - 특정 노드가 방문할 노드 --&gt; 탐색, 방문한 노드 --&gt; 지나감 . - 그래프나 트리는 dictionary로 생성 . - stack 구조 와 재귀 함수로 구현 가능 . DFS &#51109;&#51216; . - 단지 현 경로상의 노드들만을 기억하면 되므로 저장공간의 수요가 비교적 적음 . - 목표노드가 깊은 단계에 있을 경우 해를 빨리 구함 . DFS &#45800;&#51216; . - 해가 없는 경로에 깊이 빠질 가능성 존재 . - 얻어진 해가 최단 경로가 된다는 보장이 없음 --&gt; 목표에 이르는 경로가 다수일 때 해에 다다르면 탐색을 끝내버림 --&gt; 이때 얻어진 해는 최적이 아닐 수 있음 . DFS 참고: 깊이 우선 탐색 | . DFS &#53076;&#46300; &#44396;&#54788; . - tree 구조 . - stack 자료 구조 활용: 후입선출(한쪽면이 막힌 원통) . - 노드: [A], [B], [C], [D], [E], [F], [G], [H], [I], [J] . - 분기: [A, B, E], [A, B, F, I], [A, C, G], [A, D, H, I] . tree = {&#39;A&#39;: [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;], ## A는 B, C, D와 연결됨 &#39;B&#39;: [&#39;A&#39;, &#39;E&#39;, &#39;F&#39;], ## B는 A, E, F와 연결됨 &#39;C&#39;: [&#39;A&#39;, &#39;G&#39;], ## C는 A, G와 연결됨 &#39;D&#39;: [&#39;A&#39;, &#39;H&#39;], ## D는 A, H와 연결됨 &#39;E&#39;: [&#39;B&#39;], ## E는 B와 연결됨 &#39;F&#39;: [&#39;B&#39;, &#39;I&#39;], ## F는 B, I와 연결됨 &#39;G&#39;: [&#39;C&#39;], ## G는 C와 연결됨 &#39;H&#39;: [&#39;D&#39;, &#39;J&#39;], ## H는 D, J와 연결됨 &#39;I&#39;: [&#39;F&#39;], ## I는 F와 연결됨 &#39;J&#39;: [&#39;H&#39;]} ## J는 H와 연결됨 . &#47532;&#49828;&#53944; &#54876;&#50857; . - 파이썬에서 리스트는 stack구조여서 DFS에 활용 가능 . - list.pop(i)은 성능이 떨어짐, i번째 이후 원소들을 한 칸씩 앞으로 땡겨야하기 때문 --&gt; $O(N)$ . - 비고: $O(N-i) to O(N)$ 최악의 경우(0번째 인덱스) . - list.pop()은 마지막 원소만 pop하므로 $O(1)$ . - list.pop()--&gt; 맨 마지막에 넣었던 노드를 가져옴: stack구조와 동일(후입선출) . def DFS_list(graph, start_node): visited = [] ## 방문한 노드 stack = [] ## 방문할 노드 stack.append(start_node) ## 방문할 노드에 시작 노드 추가 while stack: ## 방문할 노드가 있다면(리스트에 원소가 있으면 True) node = stack.pop() ## 마지막 노드 추가(스택 구조 사용) if node not in visited: ## 만약 아직 방문한 노드가 아니라면 visited.append(node) ## 이제 방문했으니까 방문한 노드에 추가 stack.extend(reversed(graph[node])) ## 방문한 노드에 연결된 노드를 탐색해보자 print(visited) print(stack) print(&#39;-&#39;) ## 방문과정 확인 return visited ## 방문한 노드를 반환 DFS_list(tree, &#39;A&#39;) ## 마지막은 return 값 . [&#39;A&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;E&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;E&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;I&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;I&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;] [&#39;D&#39;, &#39;C&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;] [&#39;D&#39;, &#39;G&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;] [&#39;D&#39;, &#39;G&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;] [&#39;D&#39;, &#39;C&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;] [&#39;D&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;] [&#39;H&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;] [&#39;H&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;] [&#39;J&#39;, &#39;D&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;] [&#39;J&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] [&#39;H&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] [] - . [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] . - return 결과를 보면 DFS 방식임을 알 수 있다 . &#54644;&#49884; &#53580;&#51060;&#48660; &#54876;&#50857; . - if node not in visited: --&gt; visited가 list인 경우 $O(N)$의 시간복잡도를 가짐 . - visited도 해시 테이블(key: value 관계인 자료형: 파이썬의 dictionary)로 구현하면 $O(1)$로 효율$ uparrow$ . - 해시 테이블에 관한 좋은 영상 &gt; https://www.youtube.com/watch?v=HraOg7W3VAM . def DFS_Hash_Table(graph, start_node): visited = {} ## 방문한 노드 stack = [] ## 방문할 노드 stack.append(start_node) ## 방문할 노드에 시작 노드 추가 while stack: ## 방문할 노드가 있다면(리스트에 원소가 있으면 True) node = stack.pop() ## 마지막 노드 추가(스택 구조 사용) if node not in visited: ## 만약 아직 방문한 노드가 아니라면 visited[node] = True ## 이제 방문했으니까 방문한 노드에 추가 stack.extend(reversed(graph[node])) ## 방문한 노드에 연결된 노드를 탐색해보자 return list(visited.keys()) ## 방문한 노드를 반환 DFS_list(tree, &#39;A&#39;) ## 마지막은 return 값 . [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] . - list를 활용한 코드와 return 결과는 동일하다 . - 시간복잡도면에서 list를 활용한 것 보다 Hash Table을 사용한 것이 성능이 우월하다 . - return 결과를 보면 DFS 방식임을 알 수 있다 . &#51116;&#44480;&#54632;&#49688; &#54876;&#50857; . def DFS_recursive(graph, start_node, visited = {}): visited[start_node] = True for node in graph[start_node]: if node not in visited: DFS_recursive(graph, node, visited) ## 간단히 설명 -&gt; 처음 시작 노드는 &#39;A&#39; -&gt; &#39;A&#39;를 visited에 추가 &#39;A&#39;의 node는 [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;] ## -&gt; &#39;B&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;B&#39;를 start_node로 하여 visited에 추가 -&gt;&#39;B&#39;의 node는 [&#39;A&#39;, E&#39;, &#39;F&#39;] ## -&gt; &#39;A&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;E&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;E&#39;를 start_node로 하여 visited에 추가 -&gt; &#39;E&#39;의 node는 [&#39;B&#39;] ## -&gt; &#39;B&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;B&#39;의 node로 &#39;A&#39;, &#39;E&#39; 방문 했고 이제 &#39;F&#39;만 남았음 ## -&gt; &#39;F&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;F&#39;를 start_node로 하여 visited에 추가 -&gt; &#39;F&#39;의 node는 [&#39;B&#39;, &#39;I&#39;] ## -&gt; &#39;B&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;I&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;I&#39;를 start_node로 하여 visited에 추가 -&gt; &#39;I&#39;의 node는 [F] ## -&gt; &#39;F&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;A&#39;의 node인 [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]중 &#39;B&#39;를 방문 끝냈으므로 &#39;B&#39;를 탐색했던 것처럼 나머지 &#39;C&#39;와 &#39;D&#39;도 탐색하면 끝임 return list(visited.keys()) DFS_recursive(tree, &#39;A&#39;) . [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] . - 재귀함수를 사용하여 방문한 노드를 visited에 추가한다 . - return 결과를 보면 DFS 방식임을 알 수 있다 . &#45320;&#48708; &#50864;&#49440; &#53456;&#49353;(Breadth First Search, BFS) . - 모든 정점을 한번만 방문 . - 시작 노드에서 인접한 다음 분기로 넘어가면서 탐색 . - 넘어갈 분기가 없으면 하위 노드를 탐색 . - 방문할 노드와 방문한 노드를 기준으로 탐색 . - 특정 노드가 방문할 노드 --&gt; 탐색, 방문한 노드 --&gt; 지나감 . - 그래프나 트리는 dictionary로 생성 . - queue 구조로 구현 가능 . BFS &#51109;&#51216; . - 출발노드에서 목표노드까지의 최단 길이 경로를 보장 . BFS &#45800;&#51216; . - 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요 . - 해가 존재하지 않는다면 유한 그래프(finite graph)의 경우에는 모든 그래프를 탐색한 후에 실패로 끝남 . - 무한 그래프(infinite graph)의 경우에는 결코 해를 찾지도 못하고, 끝내지도 못함 . BFS 참고: 너비 우선 탐색 | . BFS &#53076;&#46300; &#44396;&#54788; . - tree 구조 . - queue 자료 구조 활용: 선입선출(양쪽 면이 뚫린 원통) . - 노드: [A], [B], [C], [D], [E], [F], [G], [H], [I], [J] . - 분기: [A, B, E], [A, B, F, I], [A, C, G], [A, D, H, I] . deque &#54876;&#50857; . - 성능이 좋음 --&gt; $O(1)$ . - 사용: from collections import deque . - 만약 queue = list()라면 queue.pop(0)을 해야함 --&gt; $O(N)$ . - deque를 사용하여 queue.pop(0)대신 queue.popleft( ) 사용 --&gt; $O(1)$ . - DFS와 마찬가지로 visited는 해시 테이블로 구현 . def BFS_queue(graph, start_node): from collections import deque ## deque패키지 import visited = {} ## 방문한 노드 queue = deque() ## 방문할 노드 queue.append(start_node) ## 방문할 노드에 시작 노드 추가 while queue: ## 방문할 노드가 있다면(리스트에 원소가 있으면 True) node = queue.popleft() ## 첫번째 노드 추가(큐 구조 사용) if node not in visited: ## 만약 아직 방문한 노드가 아니라면 visited[node] = True ## 이제 방문했으니까 방문한 노드에 추가 queue.extend(graph[node]) ## 방문한 노드에 연결된 노드를 탐색해보자 print(list(visited.keys())) print(queue) print(&#39;-&#39;) ## 방문과정 확인 return list(visited.keys()) ## 방문한 노드를 반환 BFS_queue(tree, &#39;A&#39;) . [&#39;A&#39;] deque([&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]) - [&#39;A&#39;, &#39;B&#39;] deque([&#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;E&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] deque([&#39;D&#39;, &#39;A&#39;, &#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] deque([&#39;A&#39;, &#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] deque([&#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] deque([&#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] deque([&#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] deque([&#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] deque([&#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] deque([&#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;B&#39;, &#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;C&#39;, &#39;D&#39;, &#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;D&#39;, &#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([&#39;F&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([&#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([]) - . [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] . - return 결과를 보면 BFS 방식임을 알 수 있다 .",
            "url": "https://jaesu26.github.io/green/python/algorithm/2021/07/09/DFS-BFS.html",
            "relUrl": "/python/algorithm/2021/07/09/DFS-BFS.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post26": {
            "title": "정렬 알고리즘",
            "content": "- 데이터를 오름차순으로 정렬해보자! . $O(N^2)$ &#51221;&#47148; . &#49440;&#53469; &#51221;&#47148; . - 가장 작은 수를 첫 번째 인덱스로 선택 그 다음으로 작은 수를 두 번째 인덱스로 선택 . - 이런식으로 가장 큰 수까지 마지막 인덱스로 선택하면 정렬 끝 . &#49440;&#53469; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2] . 2 첫 번째 인덱스와 나머지 $n - 1$개의 수를 비교하여 가장 작은 수와 위치를 바꾼다 . 3 5와 비교하여 1이 가장 작으므로 5와 1의 위치를 바꾼다 . List = [1, 8, 7, 5, 2] . 4 이제 두 번째 인덱스와 나머지$n - 2$개의 수를 비교하여 남은 수 중 가장 작은 수와 위치를 바꾼다 . 5 8과 비교하여 2가 가장 작으므로 8과 2의 위치를 바꾼다 . List = [1, 2, 7, 5, 8] . 6 이런 식으로 $n-1$번째 인덱스와 나머지 1개의 수를 비교하여 오름차순 정렬을 마친다 . List = [1, 2, 5, 7, 8] . &#49440;&#53469; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(n - 1): min_idx = i for j in range(i + 1, n): if List[j] &lt; List[min_idx]: min_idx = j List[i], List[min_idx] = List[min_idx], List[i] print(List) . [1, 8, 7, 5, 2] [1, 2, 7, 5, 8] [1, 2, 5, 7, 8] [1, 2, 5, 7, 8] . &#48260;&#48660; &#51221;&#47148; . - 연속된 인덱스를 비교하여 더 큰 값을 오른쪽으로 보냄 . - 한 사이클을 돌면 가장 큰 값이 맨 뒤에 위치 . - 사이클마다 남은 수 중 가장 큰 값이 뒤에 위치함 . &#48260;&#48660; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2] . 2 첫 번째 인덱스와 두 번째 인덱스를 비교하여 더 큰값을 오른쪽에 위치시킨다 . 3 5와 8을 비교하면 8이 더 크므로 8을 오른쪽을 보낸다 . List = [5, 8, 7, 1, 2] . 4 이제 두 번째 인덱스와 세 번째 인덱스를 비교한다 . 5 8과 7을 비교하면 8이 더 크므로 8을 오른쪽으로 보낸다 . List = [5, 7, 8, 1, 2] . 6 이런식으로 한 사이클을 돌면 8이 마지막에 위치한다 . List = [5, 7, 1, 2, 8] . 7 다시 사이클을 돌면 7이 8 왼쪽에 위치한다 . List = [5, 1, 2, 7, 8] . 8 이런식으로 $n - 1$ 번의 사이클을 돌면 자료가 오름차순으로 정렬된다 . List = [1, 2, 5, 7 ,8] . &#48260;&#48660; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(n - 1, 0, -1): for j in range(i): if List[j + 1] &lt; List[j]: List[j + 1], List[j] = List[j], List[j + 1] print(List) . [5, 7, 1, 2, 8] [5, 1, 2, 7, 8] [1, 2, 5, 7, 8] [1, 2, 5, 7, 8] . &#49341;&#51077; &#51221;&#47148; . - 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교함 . - 자신의 위치를 찾아 삽입함 . - 일반적으로 선택 정렬, 버블 정렬 보다 빠름 . &#49341;&#51077; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2] . 2 두 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . List = [5, 8, 7, 1, 2] . 3 5와 8을 비교하면 8이 더 크므로 8을 오른쪽을 보낸다 . List = [5, 8, 7, 1, 2] . 4 세 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . 5 7과 8을 비교하면 8이 더 크고 5와 7을 비교하면 7이 더 크므로 5와 8사이에 위치한다 . List = [5, 7, 8, 1, 2] . 6 네 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . 7 1이 부분 리스트 중 가장 작으므로 맨 앞에 삽입 . List = [1, 5, 7, 8, 2] . 8 마지막 원소를 부분 리스트에서 적절한 위치에 삽입 . 9 2는 부분 리스트 중 1 다음으로 작으므로 1 오른쪽에 삽입 . List = [1, 2, 5, 7, 8] . &#49341;&#51077; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(1, n): j = i - 1 key = List[i] while List[j] &gt; key and j &gt;= 0: List[j+1] = List[j] j = j - 1 List[j+1] = key print(List) . [5, 8, 7, 1, 2] [5, 7, 8, 1, 2] [1, 5, 7, 8, 2] [1, 2, 5, 7, 8] . $O(NlogN)$ &#51221;&#47148; . &#48337;&#54633; &#51221;&#47148; . - 리스트 안에 있는 요소들을 왼쪽, 오른쪽 두 그룹으로 나눔 . - 각 그룹을 또 왼쪽, 오른쪽 두 그룹으로 나눔, 이를 요소가 1개 남을 때까지 반복함 . - 나누어진 두 개의 리스트를 병합함 . - 이를 정렬될 때까지 반복함 . &#48337;&#54633; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2, 3, 9, 4] . 2 그룹을 두 그룹으로 나눈다 . [5, 8, 7, 1], [2, 3, 9, 4] . 3 각 그룹을 두 그룹으로 나눈다 . [5, 8], [7, 1], [2, 3], [9, 4] . 4 이를 요소가 1개 남을 때까지 반복한다 . [5], [8], [7], [1], [2], [3], [9], [4] . 5 이제 나눈 순서의 역순으로 두 그룹씩 오름차순으로 병합한다 . [5, 8], [1, 7], [2, 3], [4, 9] . 6 이를 정렬이 끝날 때까지 반복한다 . [1, 5, 7, 8], [2, 3, 4, 9] . List = [1, 2, 3, 4, 5, 7, 8, 9] . &#48337;&#54633; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . - 위의 병합 정렬 알고리즘을 보면 두 그룹으로 나누고 병합하는 과정을 반복한다 . - 그렇기에 재귀 함수를 사용하여 구현했음 --&gt; 리스트의 길이가 클 경우 많은 재귀 함수 호출이 이루어지기에 시간이 매우 오래걸림(내 생각) . - 먼저 left, right로 나눈 후 나눠진 left를 가지고 또 left, right로 나눈다 . - left를 나누는 것이 끝나면 이제서야 right를 가지고 left, right로 나눈다 . 이 코드는 아래 코드보다 느림 | . - list타입.pop(0)은 $O(N)$임 . List = [5, 8, 7, 1, 2, 3, 9, 4] def mergeSort(x): if len(x) &lt;= 1: return x mid = len(x) // 2 left = x[:mid] right = x[mid:] next_left = mergeSort(left) next_right = mergeSort(right) return merge(next_left, next_right) def merge(left, right): sorted_list = [] while left and right: if left[0] &lt; right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) while left: sorted_list.append(left.pop(0)) while right: sorted_list.append(right.pop(0)) return sorted_list mergeSort(List) . - 그래서 pop(0)함수를 사용하지 않음 . - 아래의 코드가 이해가 잘 안될 수 있다 . - 그래서 어떻게 split하고 merge가 되는지 알아보기로 하자 . - 밑의 출력을 보니 처음으로 merge()에 대입된 left와 right는 [5]와 [8]임을 알 수 있다 . - 처음으로 넣은 값은 [5, 8, 7, 1, 2, 3, 9, 4]인데 신기하다 . - 자세히 살펴보자 . List = [5, 8, 7, 1, 2, 3, 9, 4] k = 0 def mergeSort(x): ## 나누기 n = len(x) if n &lt;= 1: return x mid = n // 2 left = x[:mid] ## mid를 기준으로 왼쪽 right = x[mid:] ## mid를 기준으로 오른쪽 next_left = mergeSort(left) ## 재귀적으로 나누기 next_right = mergeSort(right) ## 재귀적으로 나누기 global k k += 1 print(&#39;return 횟수 %s&#39; %k) return merge(next_left, next_right) def merge(left, right): ## 병합하기 i = 0 j = 0 sorted_list = list() print(left) print(right) while i &lt; len(left) and j &lt; len(right): ## left와 right중 더 작은 값 넣기 if left[i] &lt; right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 ## left와 right 중 남은 값을 넣어주기 while i &lt; len(left): sorted_list.append(left[i]) i += 1 while j &lt; len(right): sorted_list.append(right[j]) j += 1 return sorted_list print(mergeSort(List)) . return 횟수 1 [5] [8] return 횟수 2 [7] [1] return 횟수 3 [5, 8] [1, 7] return 횟수 4 [2] [3] return 횟수 5 [9] [4] return 횟수 6 [2, 3] [4, 9] return 횟수 7 [1, 5, 7, 8] [2, 3, 4, 9] [1, 2, 3, 4, 5, 7, 8, 9] . - 우선 mergeSort 함수에서 return은 총 7번 일어남을 알 수 있다 . - 각 상황에서 어떤일이 일어나는지 알아보자 . 우리는 print(mergeSort(List))를 통해 mergeSort 함수에 List라는 input을 넣었다 . | mergeSort에는 [5, 8, 7, 1, 2, 3, 9, 4]이 대입됐다 . | left는 [5, 8, 7, 1], right는 [2, 3, 9, 4]이다 . | next_left는 mergeSort([5, 8, 7, 1]), next_right는 mergeSort([2, 3, 9, 4])이다 . | merge(next_left, next_right)값을 return한다 . | 근데 merge(next_left, next_right)를 return하려고 보니까 next_left, next_right 값을 알아야한다 . | 4번으로 돌아가서 보면 mergeSort([5, 8, 7, 1])와 mergeSort([2, 3, 9, 4])를 구해야 한다 --&gt; 그럼 구하면 되지 . | mergeSort()에 [5, 8, 7, 1]이 대입된다 . | 그러면 mergeSort()는 merge(mergeSort([5, 8]), mergeSort([7, 1]))를 return한다 . | 근데 mergeSort([5, 8]), mergeSort([7, 1])값은 뭐지?? --&gt; 이것도 구해야 한다 . | mergeSort([5, 8])을 구하면 next_left = [5], next_right = [8]이다 . | merge(next_left, next_right)는 merge([5], [8])이 되고 드디어 merge()함수에 left와 right가 대입된다 --&gt; 그래서 처음 left와 right로 출력된 값이 [5]와 [8]이었던 것: return1 . | merge([5], [8])은 [5,8]인 sorted_list를 return한다 --&gt; mergeSort([5, 8])은 [5,8]을 return한다 즉, mergeSort([5, 8])= [5, 8] . | 이제 mergeSort([5, 8])를 구했으니 mergeSort([7, 1])값을 구할 차례이다 . | mergeSort([7, 1])은 merge([7], [1])이고 [1, 7]을 return한다 --&gt; mergeSort([7, 1]) = [1, 7]: return2 . | 이제 8번을 보자. 8번은 merge([5, 8, 7, 1])이고 merge(mergeSort([5, 8]), mergeSort([7, 1]))를 return한다 . | 이때는 mergeSort([5, 8])와 mergeSort([7, 1])를 모르는 상태였지만 이제는 구해서 알고 있다 . | merge([5, 8], [1, 7])을 구해보면 sorted_list로 [1, 5, 7, 8]을 return한다: return3 . | 이제 mergeSort([2, 3, 9, 4])을 구할 차례이다. 이는 위에서 한 방식대로 따라하면 된다 . | 결과적으로 print(mergeSort(List))는 [1, 2, 3, 4, 5, 7, 8, 9]을 출력하게 된다 . | - 메모리 아끼는 병합 정렬 참고: https://www.daleseo.com/sort-merge/ . $O(N)$ &#51221;&#47148; . &#44228;&#49688; &#51221;&#47148; . - 카운팅 정렬이라고도 한다 . - 양수만 가능, 값의 범위가 크면 안됨(메모리 크기를 넘기면 안됨) . - 수의 범위가 작다면(입력으로 주어지는 값들의 개수: 0 ~ 1이라고 수의 범위가 작은 것이 아님... 0 ~ 1사이의 수는 무한개이다) 카운팅 정렬을 통해 빠르게 정렬할 수 있음 . - 비교 정렬이 아님 --&gt; 위의 코드들은 다른 요소값과 비교하는데 카운팅 정렬은 비교없이 데이터를 정렬함 . - 입력으로 주어지는 input의 개수는 큰데 주어지는 값의 개수가 적다면 메모리 관점에서 효율적이다 . - 예로 input이 최대1억개인데 값이 1 ~ 10까지라면 위에서 다룬 정렬은 1억크기의 배열이 필요하지만 카운팅 정렬에 경우는 크기가 10인 배열을 만들면 된다 . - 하지만, 최대 수를 기준으로 배열을 만든다(최대값이 100인 경우 크기가 100인 리스트 생성) . - 그렇기에 [0, 1, 1, 1, 100]인 리스트를 정렬한다고 보면 숫자는 3개 뿐이지만 최대값이 100이므로 크기가 100인 리스트를 만들어야 한다 --&gt; 심한 메모리 낭비 . &#44228;&#49688; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 최대 값이 k인 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 1, 3, 9] . 2 k = 10 이라고 가정하자. [0] * (k+1) 리스트를 만든다 --&gt; 파이썬에서 인덱스는 0부터 시작하기 때문 . count = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] . 3 List 요소의 값을 x라 하면 count[x]의 값을 +1 해준다 . count = [0, 2, 0, 1, 0, 1, 0, 1, 1, 1, 0] . 4 count 리스트에서 자기(x) 앞에 몇개의 숫자가 있는지를 바탕으로 x의 위치를 결정하여 정렬한다. 예로 3의 경우 자기 앞에 숫자 2개가 있으므로 3번째이다 . List = [1, 1, 3, 5, 7, 8, 9] . &#44228;&#49688; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 1, 3, 9] def counting_sort(arr): count = [0] * (max(arr) + 1) sorted_list = [0] * len(arr) for i in arr: count[i] += 1 ## arr에 있는 수를 몇개인지 카운팅함 for j in range(1, max(arr) + 1): count[j] += count[j - 1] ## count[j] 앞에 몇 개의 숫자가 있는지 저장 ## count[5] = 10이라면 5가 x번 등장했다고 할 때 5앞에 10-x개의 숫자가 있다는 의미이므로 sorted_list[10-x : x]에 5가 위치한다. (x 번째 포함 no, x-1번째 까지) for k in range(len(arr)): sorted_list[count[arr[k]] - 1] = arr[k] ## 인덱스는 0부터 시작하므로 -1을 해줌 count[arr[k]] -= 1 return sorted_list print(counting_sort(List)) . [1, 1, 3, 5, 7, 8, 9] .",
            "url": "https://jaesu26.github.io/green/python/algorithm/2021/07/04/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "relUrl": "/python/algorithm/2021/07/04/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "date": " • Jul 4, 2021"
        }
        
    
  
    
        ,"post27": {
            "title": "확률 분포",
            "content": "- 2학기에 수리통계학 배움 . - 내용 추가 + 확률 밀도 함수 유도 과정 추가 + 증명 안하고 넘어갔던 부분 추가 예정 . - 만약 수리통계학에 없는 내용이라면? &gt; . . . . . . . &#54869;&#47456; &#48516;&#54252;&#46976;? . - 확률 분포(probability distribution)는 확률 변수가 특정한 값을 가질 확률을 나타내는 함수를 의미한다 &gt; 참고: 확률 분포 . &#44536;&#47111;&#45796;&#47732; &#54869;&#47456; &#48320;&#49688;&#46976;? . - 확률변수(Random Variable)란 무작위 실험을 했을 때, 특정 확률로 발생하는 각각의 결과를 수치로 표현한 변수 . - 무작위 실험 &gt; 동전 던지기 . - 특정 확률 &gt; 앞면이 나올 확률 $ frac{1}{2}$, 뒷면이 나올 확률 $ frac{1}{2}$ . - 수치 &gt; 앞면 = $1$, 뒷면 = $2$ . &#50672;&#49549; &#54869;&#47456; &#48516;&#54252; . - 연속 확률 변수가 가지는 확률 분포 . - 이산 확률 변수는 확률을 $[ star]P(X=x)[ star]$와 같이 표현 가능, 연속 확률 변수는 불가능 . - 연속 확률 변수는 확률을 $[ star]P(A leq X leq B)[ star]$로 표현 가능 . &#51221;&#44508; &#48516;&#54252; . - 정규 분포는 수집된 자료의 분포를 근사하는 데에 자주 사용됨 . - 중심극한정리에 의하여 독립적인 확률변수들의 평균은 정규 분포에 가까워지는 성질이 있기 때문임 . - 신뢰구간이나 가설검정 등의 모델에서 사용 . - 기호로는 $N sim ( mu, sigma^{2})$ . - 정규 분포의 기댓값, 중앙값, 최빈값은 $ mu$, 분산은 $ sigma^{2}$ . - 표준정규분포는 평균이 0, 표준편차가 1인 경우임 &gt; $N sim (0, 1)$ . - 정규 분포에서 $ mu pm2 sigma$에 전체 데이터 중 $95 %$가 존재 . &#54364;&#51456;&#54868; . - 정규 분포 밀도 함수에서 $Z = cfrac{X - mu}{ sigma}$ 를 통해 $X$(원점수)를 $Z$($z$점수) 표준화하여 표준정규분포(z-분포)를 얻을 수 있다 . &#51221;&#44508; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688;(PDF) . $f(x) = dfrac{1}{ sqrt{2 pi sigma^{2}}}e^{- dfrac{(x- mu)^{2}}{2 sigma^{2}}}$ . &#51221;&#44508; &#48516;&#54252; plot . import numpy as np np.random.normal(loc, scale, size) . - loc는 평균, scale은 표준편차, size는 표본의 수 . np.random.normal(loc = 0, scale = 1, size = 1000) . - np.random.normal(loc = 0, scale = 1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.normal(loc = 0, scale = 1, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.normal(loc = 0, scale = 1, size = 1000)&#39;) plt.show() . &#44512;&#51068; &#48516;&#54252; . - 모든 확률 변수에 대하여 구간 내에서 균일한 확률을 가짐 . - 임의의 구간 내에서 균일한 확률을 가지기에 난수 생성기로 쓰임 . - 이산 확률 변수에서도 가능 . &#44512;&#51068; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x) = begin{cases} cfrac{1}{b-a} &amp; text{for $x in [a,b]$} 0 &amp; text{otherwise} end{cases} $ . - $f(x)$는 구간 $[a,b]$에서 균등한 확률을 가짐 . &#44512;&#51068; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = cfrac{a+b}{2}$ . - $Var(X) = cfrac{(b-a)^{2}}{12}$ . &#44512;&#51068; &#48516;&#54252; plot . import numpy as np np.random.uniform(low, high, size) . - low는 출력값의 최소 경계, high은 출력값의 최대 경계, size는 표본의 수 . np.random.uniform(low = 0, high = 1, size = 1000) . - np.random.uniform(low = 0, high = 1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.uniform(low = 0, high = 1, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.normal(loc = 0, scale = 1, size = 1000)&#39;) plt.show() . &#50672;&#49549;&#54805; &#54869;&#47456;&#48320;&#49688;&#51032; cdf&#45716; $U(0, 1)$&#51012; &#46384;&#47480;&#45796; . - 증명 . $U=F(x)=P(X leq x) F_{U}(u)=P(U leq u)=P(F(X) leq u)=P(X leq F^{-1}(u))=F(F^{-1}(u))=u f_{U}(u)=1, ;0&lt;u&lt;1 therefore F(X) sim U(0,1)$ . - 역함수가 없는 경우는... 몰라 . - 정규분포를 예로 들자 . - 정규분포에서 샘플을 뽑고 샘플을 누적분포함수에 input하자 . - 그러면 output이 나오고 이를 가지고 확률밀도함수를 그리면 $U(0, 1)$이 된다 . - 일단 연속형 확률변수의 cdf 값은 $0$과 $1$ 사이에 있다 . - 정규분포에서 $x$를 뽑았는데 $0$이 나왔다고 하자 . - 이에 대한 누적분포함수값은 $0.5$이다 . - 이를 반복하면 누적분포함수값이 많이 나올것이다 . - 이를 가지고 확률밀도함수를 그리면 $U(0, 1)$이라는 것이다 . - 즉 누적분포함수값이 $0$과 $1$사이인데 나올 가능성이 모두 같다는 것이다(?) . - 근데 하나의 누적분포함수값에는 하나의 $x$가 대응되는것 아닌가? . - 누적분포함수값이 $0.5$라면 그에 대한 $x$값은 $0$이다 . - $0$과 $1$ 사이의 값을 가지는 누적분포함수값이 나올 가능성이 모두 같다면 $x$도 뽑힐 가능성이 같다(?) . - 히스토그램을 그려보면 $x$값이 $0$근처에 몰려있고 $3$이 넘어가면 거의 없는데 뭐가 같지??? . - 하지만 이는 잘못됐는데 일단 실수는 무한히 많기에 정규분포에서 특정값이 나올 확률은 $0$이다 . - 그러니 특정값에 대한 확률은 같다 . - 그렇기에 범위로 비교하는것이 올바르다 . - 그러면 $x$값이 $0$과 $1$사이에서 나올 확률이랑 $1$과 $2$사이에서 나올 확률이 같음? . - no 다름 . - ??? 위에서 누적분포함수값이 나올 가능성이 모두 같다면 $x$도 뽑힐 가능성이 같다고 했잖음... . - 동일한 누적분포함수값의 범위에 대해서는 같다 . - 일단 하나의 실수를 뽑았다고 치자 &gt; $x$는 $0$이 나왔고 이에 대한 cdf값은 $0.5$임 . - cdf값은 $0$부터 $1$사이에 존재하고 $0$부터 $1$사이의 실수는 무한개이기에 cdf값이 $0.5$일 확률은 $0$이다 . - 또한 $x$가 $3$ 이 나왔다고 치고 이에대한 cdf값은 대충 $0.99$라 치자 &gt; 이 역시 확률은 $0$이다 . - 그럼 범위로 따지면? . - 누적분포함수값이 $0$부터 $0.5$사이일 확률과 $0.5$부터 $1$사이일 확률은 서로 동일하다 . - 바꿔말하자면 확률밀도함수 아래의 면적으로 따졌을 때 $- infty$부터 $0$사이 면적과 $0$부터 $ infty$사이 면적은 동일하다 . - 즉 정규분포에서 표본을 뽑았을 때 $x$값이 $- infty$부터 $0$사이일 확률과 $0$부터 $ infty$사이일 확률은 같다 . - 확률밀도함수에 확률은 $y$값이 아니라 면적이다 . - $x$값이 $0$과 $1$사이에서 나올 확률이랑 $1$과 $2$사이에서 나올 확률은 다른데 그래프 아래의 면적이 다르다 . - 그렇기에 당연히 누적분포함수값의 범위도 다르다 . - 정규분포에서 cdf값이 $0.1$과 $0.3$사이일 확률과 $0.5$와 $0.7$사이일 확률은 같음 . - 이는 정규분포에서 $x$값을 뽑았을 때 $-1.28 sim -0.52$일 확률과 $0 sim 0.52$일 확률이 같다는 의미 . - 즉 $X$를 정규분포에서 생성하고 $X$에 정규분포 cdf를 취하면 이것은 $U(0,1)$을 따른다는 소리 . - 직접 구현하여 맞는지 확인해보자 . import numpy as np import matplotlib.pyplot as plt from scipy.stats import norm ## 연속형 확률변수는 정규분포로 하자 . np.random.seed(2021) x = np.random.normal(loc = 0, scale = 1, size = 10000) ## 표준정규분포 plt.hist(x, bins = 30) plt.show() . - $x$는 정규분포에서 뽑은 거니까 이를 가지고 히스토그램을 그리면 당연히 정규분포이다 . - $x$축은 정규확률변수가 가질 수 있는 값, $y$축은 빈도수 . - 히스토그램의 면적을 $1$로 만들면 $y$축은 $f(x)$(정규분포의 pdf)가 된다 . - $f(x) = dfrac{1}{ sqrt{2 pi sigma^{2}}}e^{- dfrac{(x- mu)^{2}}{2 sigma^{2}}}$ . - ex) $f(0) = 0.3989422804014327$ . - 정규확률변수가 가질 수 있는 값($x$)의 $99 %$는 $ mu pm 2 sigma$안에 있고 $ mu$에 가까울 수 록 뽑힐 가능성이 높다 . norm.pdf(0) . 0.3989422804014327 . F_x = norm.cdf(x) plt.hist(F_x) plt.show() . - $x$축은 $F(X)$, $y$축은 빈도수, $X$는 정규분포를 따름 . - 정말 $U(0, 1)$를 따른다 . - 즉 연속형 확률분포(예컨대 정규분포) $f(x)$에서 $x$를 뽑고 이를 연속형 확률분포의 cdf $F(x)$에 input하여 나온 값으로 히스토그램을 그리면 위와 같이 $U(0,1)$ 된다 . - 그럼 특정 연속형 확률분포에서 $x$를 뽑지 않고 그냥 균일분포에서 뽑으면? . X = np.linspace(-3, 3, 10000) ## -3부터 3까지 나올 가능성이 동등하다고 생각하자 fig, (ax1, ax2) = plt.subplots(1,2) ax1.plot(X, norm.pdf(X)) ax2.plot(X, norm.cdf(X)) plt.show() . - $x$축은 $U(-3, 3)$, $y$축은 각각 $f(x)$와 $F(x)$ . - 그런데 문득 궁금한점이 있다 . x = np.random.normal(loc = 0, scale = 1, size = 10000) . - 위의 코드를 사용하여 정규분포에서 랜덤표본을 뽑았다 . - 그런데 랜덤표본은 어떻게 뽑지? . - $x$의 pdf를 아는것과 $x$에 대한 샘플링이 가능한것은 다른 문제 . - 예컨대 정규분포에서 특정$x$가 뽑힐 확률은 $0$인데 어떻게 뽑을거? . - $U(0,1)$은 생성할 수 있다고 했을 때 랜덤표본을 추출하는 방법을 알아보자(균일분포를 어떻게 생성하는지는 모르니 넘어가자) . - 위에서 $F(x) = U$라고 했다 &gt; 연속형 확률변수의 cdf는 균일분포를 따른다 . - 그런데 이를 바꿔 말하자면 $x = F^{-1}(U)$ . - 즉 임의의 확률변수에서 $x$를 뽑는것은 $x$의 cdf의 역함수에 $U(0,1)$에서 뽑은 난수를 input하여 구하는것과 동일하다는 것 . - 즉 $x$의 cdf의 역함수를 알고 균일분포에서 랜덤표본을 뽑을 수 있으면 임의의 확률변수에서 $x$를 뽑는것과 같은 효과를 얻을 수 있다는 것 . - 이를 역변환기법(Inverse CDF Method)이라고 한다 . - 단점은 cdf의 역함수를 알아야 한다는 것.... . from scipy.stats import uniform n = 10000 U = uniform.rvs(size = n) X1 = norm.ppf(U) X2 = norm.rvs(size = n) fig, (ax1, ax2) = plt.subplots(1,2) ax1.hist(X1, bins = 30) ax2.hist(X2, bins = 30) plt.show() . - 정말 둘 다 표준정규분포이다! . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;($ chi^2$&#48516;&#54252;) . - $k$개의 서로 독립인 표준 정규 확률변수를 각각 제곱하여 합해 얻어진 분포 . - 이때 $k$는 자유도이며 카이제곱 분포의 매개변수 . - 분산의 퍼진 정도를 분포로 보여줌 . - 모분산을 구하거나 적합도 검정, 독립성/동질성 검정 등의 모델에서 사용 . - $k$개의 독립적이고 표준정규분포를 따르는 확률변수 $Z_1, dots,Z_k$가 있을 때 자유도 $k$의 카이제곱 분포는 . - 확률변수 $Q = sum limits^{k}_{i=1}Z{_i}{^2}$의 분포임 . - 따라서 $Q sim chi{^2}(k)$ . - 참고: 카이제곱 분포 . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x; k) = dfrac{1}{2^ frac{k}{2} Gamma big( frac{k}{2} big)}x^{ frac{k}{2}-1}e^{- frac{x}{2}}$ . - $ Gamma big( frac{k}{2} big)$는 감마함수이다 . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = k$ . - $Var(X) = 2k$ . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252; plot . import numpy as np np.random.chisquare(df, size) . - df는 자유도, size는 표본의 수 . np.random.chisquare(df = 10, size = 1000) . - np.random.chisquare(df = 10, size = 1000)를 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.chisquare(df = 10, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.chisquare(df = 10, size = 1000)&#39;) plt.show() . - 자유도(df)를 바꿔볼까? . - df = 5 . np.random.seed(1) sample = np.random.chisquare(df = 5, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.chisquare(df = 5 , size = 1000)&#39;) plt.show() . - df = 1 . - 표준정규분포의 제곱은 자유도가 1인 카이제곱 분포를 따름 . - $V = bigg( dfrac{X- mu}{ sigma} bigg)^{2} sim chi^{2}(1)$ . - 표본을 10000개 뽑아 둘을 비교해보자! . np.random.seed(2) sample = np.random.chisquare(df = 1, size = 10000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.chisquare(df = 1 , size = 10000)&#39;) plt.show() . np.random.seed(2) sample = np.random.normal(loc = 0, scale = 1, size = 10000) sample = sample**2 plt.hist(sample, bins = 30) plt.title(&#39;square of a standard normal distribution&#39;) plt.show() . - 두 분포가 거의 동일하다 . - 표준정규분포의 제곱은 자유도가 1인 카이제곱 분포를 따른다는 것을 확인할 수 있다 . &#51648;&#49688; &#48516;&#54252; . - 사건이 서로 독립적일 때, 일정 시간동안 발생하는 사건의 횟수가 포아송 분포를 따른다면, 다음 사건이 일어날 때까지 대기 시간은 지수분포를 따른다(지수 분포) . - 기하 분포에서 베르누이 시행 횟수$n$이 많아지고 성공 확률 $p$가 작아지면 지수 분포로 수렴 . - 감마 분포에서 $ alpha = 1$일 때의 특수한 경우임(감마 분포 참고) . &#51648;&#49688; &#48516;&#54252;&#51032; &#47924;&#44592;&#50613;&#49457; . - 기하 분포의 무기억성과 같은 내용임 . - $P(A mid B)$ &gt; 사건 B가 발생한 상황에서 사건 A가 발생할 확률 . - $P(X&gt;s+t mid X&gt;t) = P(X&gt;s)$ . - 핸드폰의 고장률이 지수 분포를 따른다면 내가 핸드폰을 처음 구매하고 1년안에 고장날 확률 = 핸드폰을 5년 사용한 시점에서 1년 안에 고장날 확률 . - 물론 현실은 핸드폰을 5년 사용한 후에 고장날 확률이 더 크다 . &#51648;&#49688; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x; beta) = frac{1}{ beta}e^{- frac{x}{ beta}}, ; x &gt; 0$ . - 위의 확률 밀도 함수는 감마 분포의 확률 밀도 함수에서 $ alpha = 1$을 대입한 결과이다 . - 여기서 $ beta$는 사건 사이의 평균 시간인데 포아송 분포의 모수인 $ lambda$는 단위 시간당 사건의 평균 발생 횟수이다 . - 위의 지수 분포 설명에서 사건의 횟수가 포아송 분포를 따를 때를 전제로 대기 시간은 지수 분포를 따른다고 했다 . - 그렇기에 여기서는 위의 확률 밀도 함수 대신 포아송 분포의 모수인 $ lambda = frac{1}{ beta}$ 를 통해 지수 분포의 확률 밀도 함수를 나타내기로 함 . - 위아래 확률 밀도 함수 둘 다 맞는 표현임, 그런데 numpy.random.exponential이 위의 확률 밀도 함수를 사용하므로 위의 확률 밀도 함수를 기억하는 것이 좋을 것 같음 . $f(x; lambda) = lambda e^{- lambda x}, ; x&gt;0$ . &#51648;&#49688; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = cfrac{1}{ lambda}$ . - $Var(X) = cfrac{1}{ lambda^{2}}$ . - 기댓값은 어찌보면 당연한데 단위 시간 동안 사건이 $ lambda$번 발생한다면 대기 시간은 $ cfrac{1}{ lambda}$여야 $ lambda times cfrac{1}{ lambda} = 1$(단위 시간)이 성립한다 . &#51648;&#49688; &#48516;&#54252; plot . - 사건이 발생하고 다음 사건이 발생하기 까지의 대기 시간에 대한 확률 분포 . - numpy.random.exponential의 확률 밀도 함수는 $f(x; beta) = frac{1}{ beta}e^{- frac{x}{ beta}}, ; x &gt; 0$임 (numpy 지수 함수) . import numpy as np np.random.exponential(scale, size) . - scale은 $ beta$ = 대기 시간, size는 표본의 수 . np.random.exponential(scale = 2, size = 1000) . - 우리 집 앞에서 1시간당 평균 0.5명이 넘어진다 &gt; $ lambda$(사건의 빈도) $= 0.5$ 이므로 대기 시간 $ beta$(대기 시간) $= 2$ . - 다시말하면 우리 집 앞에서 한 명이 넘어지고 다음 사람이 넘어지기 까지 2시간이 걸린다 . - 이때 한 사람이 넘어지고 다음 사람이 넘어지기 까지 걸리는 대기 시간에 대한 분포를 그려보자 . - np.random.exponential(scale = 2, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.exponential(scale = 2, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.exponential(scale = 2, size = 1000)&#39;) plt.show() . &#44048;&#47560; &#48516;&#54252; . - 감마 분포는 지수 분포나 푸아송 분포 등의 매개변수에 대한 켤레 사전 확률 분포 . - 이에 따라 베이즈 확률론에서 사전 확률 분포로 사용 . - $ alpha$개의 사건이 일어날 때까지 걸리는 대기 시간에 대한 분포 . - 지수 분포를 한 번의 사건이 아닌 여러 개의 사건으로 확장 . - 지수 분포의 모수가 $ beta$ &gt; $ beta$ = 사건 사이의 평균 시간 . - 모수가 $ beta$인 지수 분포를 따르는 확률 변수 X가 $ alpha$개가 있고 각 확률 변수 X는 i.i.d를 따름 &gt; 이 확률 변수의 합은 모수가 $ alpha, beta$인 감마 분포를 따름 . - 참고: 감마 분포 . &#44048;&#47560;&#54632;&#49688;(Gamma Function) . - 복소수 범위까지 일반화 된 팩토리얼(!) . $ Gamma( alpha) = int_{0}^{ infty}x^{ alpha-1}e^{-x}dx, , alpha geq 0$ . &#44048;&#47560;&#54632;&#49688; &#49457;&#51656; . - $ Gamma( alpha+1) = alpha Gamma( alpha)$ . - $ Gamma(n) = (n-1)!, , n in mathbb{N}$ . - $ Gamma big( frac{1}{2} big) = sqrt{ pi}$ . &#44048;&#47560; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x; alpha, beta) = cfrac{1}{ beta^{ alpha} Gamma( alpha)}x^{ alpha - 1}e^{- frac{x}{ beta}},(x, alpha, beta geq 0)$ . - 확률 변수 $X$가 감마 분포를 따른 다면 $X sim Gamma( alpha, beta)$ . - 발생하기 까지의 평균$ beta = cfrac{1}{ lambda}$의 시간이 소요되는 어떤 사건이 $ alpha$번 발생하는데 걸리는 시간 $X$에 대한 확률 분포 . - $ lambda$는 포아송 분포의 모수로 단위 시간당 사건의 평균 발생 횟수 . - $ alpha = 1$일 때 $ lambda = cfrac{1}{ beta}$인 지수 분포를 따름 . - $X sim Gamma(1, beta) Longleftrightarrow exp big( frac{1}{ beta} big)$ . &#44048;&#47560; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = alpha beta$ . - $Var(X) = alpha beta^{2}$ . &#44048;&#47560; &#48516;&#54252; plot . - $ alpha$는 형태 모수(shape parameter), $ beta$는 척도 모수(scale parameter) . - 사건이 발생하고 다음 사건이 발생하기 까지의 평균 대기 시간이 $ beta$일 때 $ alpha$번의 사건이 발생하는데 걸리는 시간에 대한 확률 분포 . import numpy as np np.random.gamma(shape, scale, size) . - shape는 $ alpha$, scale은$ beta$, size는 표본의 수 . np.random.gamma(shape = 2, scale = 2, size = 1000) . - 우리 집 앞에서 1시간당 평균 0.5명이 넘어진다 &gt; $ lambda = 0.5$이므로 $ beta = 2$ . - 다시말하면 우리 집 앞에서 한 명이 넘어지고 다음 사람이 넘어지기 까지 평균 2시간이 걸린다 . - 이때 2명의 사람이 넘어지기 까지 걸리는 시간에 대한 분포를 그려보자 . - np.random.gamma(shape = 2, scale = 2, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.gamma(shape = 2, scale = 2, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.gamma(shape = 2, scale = 2, size = 1000)&#39;) plt.show() . - 위에서 지수 분포는 감마 분포에서 $ alpha = 1$인 특수한 경우라고 했음 . - 진짜로 동일한지 $ beta = 4$인 지수 분포와 $ alpha = 1, beta = 4$인 감마 분포를 히스토그램을 그려 비교하자 . np.random.seed(1) sample1 = np.random.gamma(shape = 1, scale = 4, size = 1000) sample2 = np.random.exponential(scale = 4, size = 1000) fig, ax = plt.subplots(1, 2, figsize = (14, 4)) ax[0].hist(sample1, bins = 30) ax[1].hist(sample2, bins = 30) ax[0].set_title(&#39;np.random.gamma(shape = 2, scale = 4, size = 1000)&#39;) ax[1].set_title(&#39;np.random.exponential(scale = 4, size = 1000)&#39;) plt.show() . - 히스토그램을 통해 비교하니 $ alpha = 1$인 감마 분포는 지수 분포와 동일함을 알 수 있다 . $ alpha$&#50752;$ beta$&#50640; &#46384;&#47480; &#44048;&#47560; &#48516;&#54252; &#47784;&#50577; . - $ alpha$는 형태 모수로 $ alpha$가 커질수록 그래프의 모양이 종모양에 가까워짐 . - $ beta$는 척도 모수로 $ beta$가 커질수록 그래프가 퍼짐 . - shape는 $ alpha$, scale은 $ beta$, loc은 위치 매개변수 . - scipy.stats.gamma 참고 . $ alpha$ &#48320;&#54868; $ beta$ &#44256;&#51221; . - $ alpha$(사건 발생 횟수)가 커질수록 그래프가 종모양에 가까워짐 . import numpy as np import matplotlib.pyplot as plt from scipy.stats import gamma loc = 0 scale = 0.5 x = np.linspace(0, 12, 1000) plt.figure(figsize = (14, 7)) for shape in np.arange(2, 11, 2): plt.plot(x, gamma(shape, loc, scale).pdf(x), label = &#39;α = &#39; + str(shape)) plt.title(&quot;Gamma distribution(α = 2, 4, 6, 8, 10, β = 0.5)&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$f(x)$&quot;) plt.grid() plt.legend() plt.show() . $ alpha$ &#44256;&#51221; $ beta$ &#48320;&#54868; . - $ beta$(대기 시간)가 커질수록 그래프가 넓게 퍼짐 . loc = 0 shape = 3 x = np.linspace(0, 16, 1000) plt.figure(figsize = (14, 7)) for scale in np.arange(0.4, 2.1, 0.4): plt.plot(x, gamma(shape, loc, scale).pdf(x), label = &#39;β = &#39; + str(round(scale, 1))) plt.title(&quot;Gamma distribution(α = 3, β = 0.4, 0.8, 1.2, 1.6, 2.0)&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$f(x)$&quot;) plt.grid() plt.legend() plt.show() . t &#48516;&#54252; . - 표본평균$ bar{X}$을 이용해 정규분포의 평균을 해석 &gt; 모집단이 정규분포를 따를 때 . - 표준화한 표본평균의 분포: 모표준편차를 알고 있음$ bigg( frac{x- mu}{ sqrt{ frac{ sigma}{n}}} bigg)$ --&gt; 정규분포, 모표준편차를 모르고 표본표준편차를 알고 있음$ bigg( frac{x- bar{x}}{ sqrt{ frac{s}{n}}} bigg)$ &gt; t분포 . - 다음의 확률 분포로 정의 &gt; $ cfrac{Z}{ sqrt{ frac{V}{ nu}}}$ . - $Z$는 표준정규분포, $V$는 자유도$ nu$인 카이제곱 분포 . - 자유도가 커질수록 t분포는 표준정규분포에 가까워짐 (중심극한정리와 무관) &gt; 보통 표본 크기 $n geq30$이면 표준정규분포와 가깝다고 한다 . - [$ star$]표본크기가 커지면 표준정규분포에 가까워짐[$ star$] &gt; 표본 크기가 커진다는 것은 모집단에 가까워진다는 의미이므로 표본표준편차도 모표준편차에 가까워짐 . - t 분포의 적률생성함수는 정의되지 않음 . - 참고: t분포 . t &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x) = cfrac{ Gamma big( frac{ nu + 1}{2} big)}{ sqrt{ nu pi} Gamma big( frac{ nu}{2} big)} big(1+ frac{x^2}{ nu} big)^{- big( frac{ nu+1}{2} big)}$ . t &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = 0, ; nu &gt; 1$ . - $Var(X) = cfrac{ nu}{ nu-2} ,( nu&gt;2), ; infty ,(1&lt;v leq2)$ . t &#48516;&#54252; plot . import numpy as np np.random.standard_t(df, size) . - df는 자유도, size는 표본의 수 . np.random.standard_t(df = 5, size = 1000) . - np.random.standard_t(df = 5, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.standard_t(df = 5, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.standard_t(df = 5, size = 1000)&#39;) plt.show() . - $x = 0$을 기준으로 대칭임 . - 자유도가 5이므로 표본 크기는 6 . - 모표준편차 대신 표본표준편차를 알고 표본 크기가 6일 때 표준화한 표본 평균$ bigg( frac{x- bar{x}}{ sqrt{ frac{s}{n}}} bigg)$에 대한 분포 . - t분포는 표준정규분포보다 꼬리 부근에 밀도가 높음 &gt; 모표준편차 대신 표본표준편차를 사용하기 때문 &gt; 표본의 특성상 추출할 때마다 다르므로 변동성이 있음 . t&#48516;&#54252;&#50752; &#54364;&#51456;&#51221;&#44508;&#48516;&#54252; &#48708;&#44368; . import numpy as np import scipy as sp import scipy.stats import matplotlib.pyplot as plt . x = np.linspace(-5, 5, 100) rv_norm = sp.stats.norm(loc=0, scale=1) rv_t10 = sp.stats.t(df=10) rv_t5 = sp.stats.t(df=5) rv_t1 = sp.stats.t(df=1) norm_pdf = rv_norm.pdf(x) t10_pdf = rv_t10.pdf(x) t5_pdf = rv_t5.pdf(x) t1_pdf = rv_t1.pdf(x) legend = [&#39;z-dist&#39;, &#39;t(df=1)&#39;, &#39;t(df=5)&#39;, &#39;t(df=10)&#39;] plt.figure(figsize = (10, 6)) plt.plot(x, norm_pdf) plt.plot(x, t1_pdf) plt.plot(x, t5_pdf) plt.plot(x, t10_pdf) plt.title(&quot;z-dist, t-dist(df=1, 5, 10)&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$p(x)$&quot;) plt.grid() plt.legend(legend) plt.show() . - 위에서 말한대로 t분포가 표준정규분포보다 꼬리가 두껍다 . - 하지만 자유도가 커지면 표준정규분포와 비슷해진다 . F &#48516;&#54252; . - F 검정과 분산분석(ANOVA)등에서 주로 사용됨 . - 카이제곱 분포가 한 집단의 분산에 대해 다뤘다면 F 분포는 두 집단의 분산에 대해 다룸 . - 두 확률변수 $V_1, V_2$가 각각 자유도가 $ nu_1, nu_2$이고 서로 독립인 카이제곱 분포를 따를 때 다음의 확률변수 F는 자유도가 ($ nu_1, nu_2$)인 F-분포를 따름 . - 적률생성함수가 존재하지 않음 . - $F = cfrac{ frac{V_1}{ nu_1}}{ frac{V_2}{ nu_2}} sim F( nu_1, nu_2)$ . - 참고: F 분포 . F &#48516;&#54252; &#49457;&#51656; . - 분자와 분모의 자유도가 뒤바뀐 F 분포 성질: $F_{ nu_1, nu_2, alpha} = cfrac{1}{F_{ nu_2, nu_1, alpha}}$ . - t 분포를 제곱하면 분자와 분모의 자유도가 각각 1, $ nu$인 F분포가 된다 . - $t = cfrac{Z}{ sqrt{ frac{U}{ nu}}} sim t_{ nu}$ . F &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x) = cfrac{ Gamma big( frac{ nu_1+ nu_2}{2} big) big( frac{ nu_1}{ nu_2} big)^{ frac{ nu_1}{2}}x^{ frac{ nu_1}{2}-1}}{ Gamma big( frac{ nu_1}{2} big) Gamma big( frac{ nu_2}{2} big) big(1+ frac{ nu_1}{ nu_2}x big)^{ frac{ nu_1+ nu_2}{2}}}$ . F &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X)= cfrac{ nu_2}{ nu_2-2}, ; nu_2&gt;2$ . - $Var(X)= cfrac{2{ nu_{2}}^{2}( nu_1+ nu_2-2)}{ nu_1( nu_2-2)^{2}( nu_2-4)}, ; nu_2&gt;4$ . F &#48516;&#54252; plot . import numpy as np np.random.f(dfnum, dfden, size) . - dfnum은 분자의 자유도, dfden은 분모의 자유도, size는 표본의 수 . np.random.f(dfnum = 1, dfden = 10, size = 1000) . - np.random.f(dfnum = 1, dfden = 5, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.f(dfnum = 1, dfden = 10, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.f(dfnum = 1, dfden = 10, size = 1000)&#39;) plt.show() . &#48288;&#53440; &#48516;&#54252; . - 제한된 범위$[0, 1]$에서 확률적인 모델링에 적합함(ex: 비율) . - 두개의 매개변수 $ alpha, beta$에 따라 그래프의 모양이 다양함 . - 베타 분포는 확률에 대한 확률분포 &gt; 베이즈안 통계학에서 이항 분포의 켤레 사전 분포로 사용됨 . - 베이지안 방법 &gt; 모수를 확률변수로 생각하여 사전 정보를 활용해 모수를 추정함 . - 이항 분포에서는 성공 확률 $p$가 고정이고 성공 횟수($n-x=$ 실패횟수)가 확률변수인데 베타 분포에서는 성공 횟수($ alpha-1$)와 실패 횟수($ beta-1$)이 고정이고 성공 확률이 확률변수임 . - 베타 분포에서 $ alpha =1, beta=1$이면 균일분포와 동일함 &gt; $ alpha=1, beta=1$이면 성공 횟수와 실패 횟수 둘다$0$이므로 성공확률을 특정할 수 없어서 균일분포 모양을 띄움 . - 참고: 베타 분포 . &#48288;&#53440; &#54632;&#49688; . - 베타 분포의 확률 밀도 함수의 적분값을 1로 만드는 상수 . - 이항 계수를 실수범위까지 확장한 것 . $B( alpha, beta)= int_{0}^{1}x^{ alpha -1}(1-x)^{ beta - 1}dx = cfrac{ Gamma( alpha) Gamma( beta)}{ Gamma( alpha + beta)}$ . &#48288;&#53440; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x)= cfrac{1}{B( alpha, beta)}x^{ alpha-1}(1-x)^{ beta-1}, quad 0 leq x leq1, ;( alpha , beta&gt;0)$ . &#48288;&#53440; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X)= cfrac{ alpha}{ alpha + beta}$ . - $Var(X)= cfrac{ alpha beta}{( alpha+ beta)^{2}( alpha+ beta+1)}$ . - $ underset{x}{ mathrm{argmax}} , f(x)= cfrac{ alpha-1}{ alpha + beta - 2}, ; ( alpha, beta &gt; 1)$ . - 최빈값은 성공횟수($ alpha-1$)와 실패횟수($ beta-1$)에 대한 성공률(= 성공횟수($ alpha-1$) / 성공횟수($ alpha-1$) + 실패횟수($ beta-1$)) . &#48288;&#53440; &#48516;&#54252;&#50752; &#51060;&#54637; &#48516;&#54252; . - 베타 분포는 확률에 대한 확률분포라고 했음 . - 예시를 들어서 설명하자 . - 게임을 하는 중임 &gt; 동전이 있는데 앞면이 나오면 이김 &gt; 그런데 앞면과 뒷면이 나올 확률을 알지 못함 . - 연습으로 동전을 10번 던져봤더니 앞면이 3번 뒷면이 7번 나왔음 &gt; 앞면이 나와야 이기므로 앞면이 나올 확률이 뒷면이 나올 확률 보다 높으면 좋겠음 . - 위에 상황에서 앞면이 나올 확률이 0.5보다 클 확률은 얼마일까? &gt; 확률에 대한 확률분포 . $$ begin{aligned}P(X&gt;0.5) &amp;= 1-P(X&lt;0.5) [10pt] &amp;=1- int_{0}^{0.5} cfrac{ Gamma(12)}{ Gamma(4) Gamma(8)}x^{4-1}(1-x)^{8-1}dx [10pt] &amp;=1- int_{0}^{0.5} binom{12}{4}x^{4-1}(1-x)^{8-1}dx [12pt] &amp;= ,??? end{aligned}$$ - 적분하기가 힘들다 . - R의 pbeta() 함수로 구해보자 . import rpy2 import os os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; %load_ext rpy2.ipython . C: anaconda3 envs py38r40 lib site-packages rpy2 robjects packages.py:366: UserWarning: The symbol &#39;quartz&#39; is not in this R namespace/package. warnings.warn( . %%R 1 - pbeta(0.5, shape1 = 4, shape2 = 8) . [1] 0.1132812 . - 앞면이 3번 뒷면이 7번 나왔을 때 앞면이 나올 확률이 0.5보다 클 확률은 0.1132812이다 &gt; 약 11% . - 아무래도 게임에서 이기기는 힘들어 보인다 . - 그런데 위의 식에서 3번째 줄을 보면 이항 분포가 보인다 . - 성공확률의 거듭제곱과 실패확률의 거듭제곱은 이항분포의 확률 질량 함수에서도 존재함 . - 베타 분포에서는 확률변수 $X$가 성공 확률인 반면 이항 분포에서는 확률변수 $X$가 성공 횟수임 . - 베타 분포: $ cfrac{1}{B( alpha, beta)}x^{ alpha-1}(1-x)^{ beta-1}, ;$ $x$는 성공 확률 . - 이항 분포: $ binom{n}{x} ,p^{k} ,(1-p)^{n-x}, ;$ $x$는 성공 횟수 . - 이렇기에 이항 분포의 모수를 추정하는데 베타 분포가 사전 분포로 사용된다 . &#48288;&#53440; &#48516;&#54252; plot . - scipy.stats.beta()를 통해 다양한 베타 분포를 그려보자 . import numpy as np import matplotlib.pyplot as plt from scipy.stats import beta x = np.linspace(0, 1, 1000) beta_pdf1 = beta(a = 0.5, b = 0.5).pdf(x) beta_pdf2 = beta(a = 5, b = 1).pdf(x) beta_pdf3 = beta(a = 1, b = 3).pdf(x) beta_pdf4 = beta(a = 2, b = 2).pdf(x) beta_pdf5 = beta(a = 2, b = 5).pdf(x) plt.figure(figsize = (7, 5)) plt.plot(x, beta_pdf1, label = &#39;α = 0.5, β = 0.5&#39;) plt.plot(x, beta_pdf2, label = &#39;α = 5, β = 1&#39;) plt.plot(x, beta_pdf3, label = &#39;α = 1, β = 3&#39;) plt.plot(x, beta_pdf4, label = &#39;α = 2, β = 2&#39;) plt.plot(x, beta_pdf5, label = &#39;α = 2, β = 5&#39;) plt.xlabel(&#39;rate of success(x)&#39;) plt.ylabel(&#39;Beta pdf&#39;) plt.title(&#39;Beta distribution&#39;) plt.grid() plt.legend() plt.show() . - $x$축은 성공확률이어서 0과 1사이임 . - $y$축 자체가 확률이 아니라 $ int_{a}^{b}f(x)dx$가 확률이고 $y$축은 $f(x)$임 . - $ alpha = 1, beta geq 1$이면 성공횟수는 0인데 실패횟수는 존재하므로 성공확률 $x$가 낮을 수록 함수값이 큼 . - $ alpha geq 1, beta = 1$이면 성공횟수는 존재하는데 실패횟수는 0이므로 성공확률 $x$가 높을 수록 함수값이 큼 . - $ alpha &gt; 1, beta &gt; 1$이면 기댓값 부근에서 함수값이 크다 + $ alpha+ beta$가 커지고 $ alpha$와 $ beta$가 비슷하면 정규분포에 근사 가능 . - $ alpha &lt; 1, beta &lt; 1$이면 $x$가 0 과 1에 극단적으로 치우침 . &#51060;&#49328; &#54869;&#47456; &#48516;&#54252; . - 이산 확률 변수가 가지는 확률 분포 . &#48288;&#47476;&#45572;&#51060; &#48516;&#54252; . - 성공 확률이 $p$인 베르누이 시행 결과가 성공이면 $1$, 실패면 $0$의 값을 가지는 확률변수의 분포 . &#48288;&#47476;&#45572;&#51060; &#49884;&#54665; . - 임의의 결과가 성공 또는 실패와 같이 가능한 결과가 2 가지 . &#48288;&#47476;&#45572;&#51060; &#49884;&#54665; &#51312;&#44148; . - 각 시행의 결과는 상호 배타적인 두 사건(성공 or 실패)으로 구분 . - 성공 확률 $p$, 실패 확률 $q$일 때, $p+q=1$ . - 각 시행은 독립적 . &#48288;&#47476;&#45572;&#51060; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688;(PMF) . $f(x)=p^x(1-p)^{1-x}, quad x=0,1$ . &#48288;&#47476;&#45572;&#51060; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = p$ . - $Var(X) = p(1-p)$ . &#51060;&#54637; &#48516;&#54252; . - 서로 독립이고 동일한 베르누이 분포를 따르는 확률변수$X_1, dots,X_n$을 모두 합한 것 &gt; $X = sum limits_{i=1}^{n}X_i$ . - 성공 확률이 $p$인 베르누이 시행을 독립적으로 $n$번 반복했을 때 성공 횟수 $X$는 이항 분포를 따름 . - 기호로는 $X sim B(n,p)$ . - 독립적 시행 &gt; 각 시행은 서로 영향을 주지 않음 . &#51060;&#54637; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) ,= , _{n} rm C_{x} ,p^{x} ,(1-p)^{n-x} ,= , binom{n}{x} ,p^{k} ,(1-p)^{n-x}$ . - 성공 확률 $p$인 베르누이 시행을 $n$번 시행하여 그 중 $x$번을 성공할 확률 질량 함수 . - 베르누이 분포는 이항 분포에서 $n=1$일 때이다 . &#51060;&#54637;&#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = np$ . - $Var(X) = np(1-p)$ . &#51060;&#54637; &#48516;&#54252; plot . import numpy as np np.random.binomial(n, p, size) . - $n$은 표본 크기, $p$는 성공 확률, size는 표본의 수 . np.random.binomial(n = 50, p = 0.5, size = 1000) . - 성공 확률이 p = 0.5인 베르누이 시행을 n = 50번 반복하는 것을 표본 하나로 두고 표본을 size = 1000번 추출한다 . - 동전 던지기($p=0.5$)를 $n$ = $50$번 시행하여 앞면이 나온 횟수($X=0,1,2, dots,49,50$)를 하나의 표본이라 할 때 표본을 $size = 1000$번 추출한다 . - np.random.binomial(n = 10, p = 0.5, size = 1000)을 히스토그램으로 나타내면? . - $np geq 5$ 이면 이항분포를 정규분포로 근사할 수 있다 . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.binomial(n = 10, p = 0.5, size = 1000) plt.hist(sample) plt.title(&#39;np.random.binomial(n = 10, p = 0.5, size = 1000)&#39;) plt.show() . &#54252;&#50500;&#49569; &#48516;&#54252; . - 단위 시간, 단위 공간 안에 어떤 사건이 몇 번 발생할 것인지를 표현하는 이산 확률 분포 . - 이항 분포에서 시행횟수$n$이 매우 크고 성공 확률$p$가 매우 작은 경우 성공횟수는 포아송 분포로 근사 가능 &gt; 나중에 증명 . - 음이항 분포에서 성공횟수$x$가 매우 크고 실패 확률$p$가 매우 작은 경우 실패횟수는 포아송 분포로 근사 가능 &gt; 나중에 증명 . - 포아송 분포의 모수($ lambda$)는 단위 시간에서 사건의 평균 발생 횟수 . &#54252;&#50500;&#49569; &#48516;&#54252; &#51204;&#51228; &#51312;&#44148; . - 독립성: 1시간 동안 우리 집 앞에서 넘어진 사람 수와 친구 집앞에서 넘어진 사람 수는 독립이다 . - 일정성: 1시간 동안 평균 3명이 넘어졌다면 2시간 동안에는 평균 6명이 넘어진다 . - 비집락성: 우리 집 앞에서 같은 시간에 두 명 이상이 넘어질 확률은 0이다 . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) = cfrac{e^{- lambda} lambda^{x}}{x!}$ . - $x$는 단위 시간에서 사건의 발생 횟수, $ lambda$는 단위 시간에서 사건의 평균 발생 횟수 . - $ lambda = 10$, $x = 7$ &gt; 단위 시간에서 사건의 평균 10번 발생할 때 7번 발생할 확률은? . - 우리 집 앞에서 1시간에 사람이 평균적으로 10명이 넘어진다고 한다. 이 때 1시간에 사람이 5명 넘어질 확률은? . - $ lambda = 10, , x = 5 longrightarrow f(5) = cfrac{e^{-10} ,10^5}{5!} = 0.03783327480207071$ . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = lambda$ . - $Var(X) = lambda$ . - 평균과 분산이 같으므로 평균이 클수록 그래프가 더 넓게 퍼진다 . &#54252;&#50500;&#49569; &#48516;&#54252; plot . import numpy np.random.poisson(lam, size) . - $ lambda$는 모수, size는 표본의 수 . np.random.poisson(lam = 10, size = 1000) . - 단위 시간에서 사건이 평균 10번 발생할 때 (lam = 10) 단위 시간에서 사건이 몇 번 발생하는지를 하나의 표본이라 할 때 size = 1000번 표본을 추출한다 . - 우리 집 앞에서 1시간당 평균 10명이 넘어질 때($ lambda=10$) 1시간당 몇 명 넘어지는지($x = 0,1,2, dots,10,11, dots$)를 $size = 1000$번 기록한다 . - np.random.poisson(lam = 10, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.poisson(lam = 10, size = 1000) plt.hist(sample, bins = 24) plt.title(&#39;np.random.poisson(lam = 10, size = 1000)&#39;) plt.show() . - $ lambda$를 바꿔볼까? &gt; 우리 집 앞에서 1시간당 평균 4명이 넘어진다면?? . np.random.seed(1) sample = np.random.poisson(lam = 4, size = 1000) plt.hist(sample) plt.title(&#39;np.random.poisson(lam = 4, size = 1000)&#39;) plt.show() . &#44592;&#54616; &#48516;&#54252; . - 어떤 확률변수 $X$가 성공 확률이 $p$인 베르누이 시행에서 처음 성공까지 시도한 횟수라고 할 때 $X$는 성공 확률 $p$인 기하분포를 따른다 . - 처음 성공할 때까지 걸린 시도 횟수 X가 확률 변수이다 . &#44592;&#54616; &#48516;&#54252;&#51032; &#47924;&#44592;&#50613;&#49457; . - $P(X=x+k mid X&gt;k)=P(X=x)$ . - 성공 확률 p인 베르누이 시행을 현재 k번 시도 했다 . - 하지만 아직 까지 성공하지 못했다 . - 내가 여태까지 k번 실패했으니까 성공확률이 올라갈까?? &gt; 답은 No . - 내가 이제껏 시도한 횟수와 관계없이 성공할 확률은 p로 동일하다 . - 쉽게 말하자면 내가 순백의 주문서10%를 바르고 있는 중이다 . - 여태까지 50장을 발랐는데도 성공하지 못했다 . - 하지만 확률은 그대로 10%이고 기댓값도 10번으로 동일하다 . - 즉, 처음에 순백의 주문서를 성공시키기 위한 기대되는 시도 횟수는 10번이다 . - 50번을 실패했지만 여전히 순백의 주문서를 성공시키기 위한 기대되는 시도 횟수는 10번이다...... . &#44592;&#54616; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) = (1-p)^{x-1}p, ; x = 1, 2, 3, dots$ . - 성공 확률이 $p$일 때 $x-1$번 째 시도까지는 모두 실패하고 $x$번 째 시도에 성공할 확률 질량 함수 . &#44592;&#54616; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = cfrac{1}{p}$ . - $Var(X) = cfrac{1-p}{p^2}$ . &#44592;&#54616; &#48516;&#54252; plot . import numpy np.random.geometric(p, size) . - $p$는 베르누이 시행에서 성공 확률, size는 표본의 수 . np.random.geometric(p = 0.1, size = 1000) . - 성공 확률이 p = 0.1인 베르누이 시행을 성공할 때까지 시도하는 것을 size = 1000번 반복한다 . - 순백의 주문서($p=0.1$)를 성공할 때까지 시도하여 순백의 주문서가 적용될 때까지 걸린 시도 횟수($X=1,2, dots$)를 $size = 1000$번 기록한다 . - np.random.geometric(p = 0.1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.geometric(p = 0.1, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.geometric(p = 0.1, size = 1000)&#39;) plt.show() . &#51020;&#51060;&#54637; &#48516;&#54252; . - 확률변수 $X$를 성공 확률이 $p$인 베르누이 시행을 반복하여 $k$번째 성공이 나올 때 까지 시행횟수라 하면 확률변수 $X$는 음이항 분포를 따름 . - 기하분포는 $k=1$인 음이항 분포 . &#51020;&#51060;&#54637; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) ,= , _{x-1} rm C_{k-1} ,p^{k} ,(1-p)^{x-k} ,= , binom{x-1}{k-1} ,p^{k} ,(1-p)^{x-k}$ . - $x-1$번째 시도까지 성공횟수 $k-1$번였다가 $x$번째 시도에서 성공하여 성공횟수는 $k$가 되었음 . &#51020;&#51060;&#54637; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = cfrac{k}{p}$ . - $Var(X) = cfrac{k(1-p)}{p^2}$ . &#51020;&#51060;&#54637; &#48516;&#54252; plot . import numpy np.random.negative_binomial(n, p, size) . - $n$은 성공횟수, $p$는 베르누이 시행에서 성공 확률, size는 표본의 수 . np.random.negative_binomial(n = 5, p = 0.1, size = 1000) . - 성공 확률이 p = 0.1인 베르누이 시행을 5번 성공할 때까지 시도하는 것을 size = 1000번 반복한다 . - 순백의 주문서($p=0.1$)를 5번 성공할 때까지 시도하여 순백의 주문서가 5번 적용될 때까지 걸린 시도 횟수($X=5,6, dots$)를 $size = 1000$번 기록한다 . - np.random.negative_binomial(n = 5, p = 0.1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.negative_binomial(n = 5, p = 0.1, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.negative_binomial(n = 5, p = 0.1, size = 1000)&#39;) plt.show() . - 위에서 기하 분포는 음이항 분포에서 $k = 1$인 특수한 경우라고 했음 . - 진짜로 동일한지 $p = 0.4$인 기하 분포와 $p = 0.4, k = 1$인 음이항 분포를 히스토그램을 그려 비교하자 . np.random.seed(1) sample1 = np.random.geometric(p = 0.4, size = 1000) sample2 = np.random.negative_binomial(n = 1, p = 0.4, size = 1000) fig, ax = plt.subplots(1, 2, figsize = (14, 4)) ax[0].hist(sample1, bins = 12) ax[1].hist(sample2, bins = 12) ax[0].set_title(&#39;np.random.geomaric(p = 0.3, size = 1000)&#39;) ax[1].set_title(&#39;np.random.negative_binomial(n = 1, p = 0.3, size = 1000)&#39;) plt.show() . - 히스토그램을 통해 비교하니 $k= 1$인 음이항 분포는 기하 분포와 동일함을 알 수 있다 . &#52488;&#44592;&#54616; &#48516;&#54252; . - $k$개의 성공과 $N-k$개의 실패로 이루어진 크기가 $N$인 유한모집단에서 크기가 $n$인 표본을 뽑고 이 중 성공의 개수를 $X$라 할 때 확률변수$X$는 초기하 분포를 따름 . - $N, k to infty$이고 $ cfrac{k}{N} to p$이면 초기하 분포를 이항 분포로 근사 가능 . - 비복원추출을 하기에 각각의 시행이 서로 영향을 미치므로 독립적 시행이 아님 &gt; 베르누이 시행과의 차이점 . - 샘플링 검사 시에 복원추출을 하지 않고 비복원 추출을 하기 때문에 초기하 분포를 주로 사용함 . &#52488;&#44592;&#54616; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) = cfrac{_{k} , rm C ,_{x} ; times ; _{N-k} ; rm C ,_{n-x}}{_{N} , rm C ,_{n}} $ . - $N$개 중 $n$개를 뽑는 방법 중에서 성공 $k$개에서 $x$개의 성공을 뽑고 실패 $N-k$개에서 $n-x$개의 실패를 뽑을 확률 . &#52488;&#44592;&#54616; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X)=n cdot cfrac{k}{N}$ . - $Var(X)= n cdot cfrac{k}{N} cdot cfrac{N-k}{N} cdot cfrac{N-n}{N-1}$ . - 이항분포의 기댓값과 분산과 유사함 . - n은 표본크기, $ cfrac{k}{N}$은 성공확률, $ cfrac{N-k}{N}$은 실패확률 . - $ cfrac{N-n}{N-1}$은 유한모집단수정항으로 $n$는 대체로 1보다 크므로 유한모집단수정항도 1보다 작음 &gt; 이항분포보다 분산이 더 작음 . &#52488;&#44592;&#54616; &#48516;&#54252; plot . import numpy np.random.hypergeometric(ngood, nbad, nsample, size) . - $ngood(=k)$은 유한모집단중 성공횟수, $nbad(=N-k)$는 유한모집단중 실패횟수, $nsample(=n)$은 표본크기, size는 표본의 수 . np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000) . - 성공횟수 ngood = 700개와 실패횟수 nbad = 300개로 구성된 크기가 1000인 유한모집단($N$)에서 샘플 nsample = 100개를 비복원추출하여 나온 성공횟수 $x$를 size = 1000번 반복한다 . - 당첨용지 700개($ngood = 700$)와 꽝용지 300개($nbad = 300$)로 구성된 로또용지 1000개(유한모집단의 크기$N$)중에서 100개($nsample = 100$)를 비복원추출하여 나온 성공횟수를 $size = 1000$번 기록한다 . - np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000) plt.hist(sample, bins = 30) plt.title(&#39;np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000)&#39;) plt.show() . - 이항분포와 유사해 보임 .",
            "url": "https://jaesu26.github.io/green/python/statistics/2021/06/30/%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html",
            "relUrl": "/python/statistics/2021/06/30/%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html",
            "date": " • Jun 30, 2021"
        }
        
    
  
    
        ,"post28": {
            "title": "깃허브 데스크탑",
            "content": "&#44611;&#54728;&#48652; &#45936;&#49828;&#53356;&#53457; &#51060;&#50857;&#54644;&#49436; &#52964;&#48139;&#54616;&#44592; . 처음에 레포지토리 선택할 때 정보를 저장할 폴더 경로를 선택한다 . | 나의 경우에는 &quot;C:/Users/한재수/github_desktop/green&quot; 이다 . | green폴더에 가보면 notebooks폴더가 있는데 거기서 작업한 주피터 노트북 파일은 깃허브 데스크탑 changes에 표시된다 . | 커밋할 파일 하나를 클릭하고 하단에 메시지를 같이 남긴다 . | 변동 내역 메시지를 작성하고 커밋을 했으면 마지막으로 푸쉬를 한다 . | 깃허브에 변동 내역이 저장된다 . | - 아무 것도 변경하지 않고 save만 해도 깃허브 데스크탑 changes에서 감지된다 . - 아무 것도 변경하지 않았는데 커밋이 된다는 의미... --&gt; 아무짝에도 쓸모 없다. --&gt; 이런 경우에는 커밋을 하지 말고 냅두자 . - 파일이 제대로 푸쉬가 안됐다면? --&gt; 깃허브 _notebook 파일에 있는 history를 보자 . - 만약 빨간색으로 $ times$표시가 되어있다면 클릭 --&gt; error메시지를 볼 수 있음 --&gt; 이를 보고 오류 수정 하면 됨 . &#51089;&#50629; &#44277;&#44036; . - 이제부터 작업은 나의 깃허브 레포지토리(green) 저장 폴더인 green에 있는 notebooks에서 해야 한다 . - 만약 &quot;C:/Users/한재수/github_desktop/green/notebooks&quot; 에서 작업하지 않으면 깃허브 데스크탑 changes에 기록되지 않는다 --&gt; 망함 . Liquid Exception: Liquid syntax error &#54644;&#44208; . - Jekyll에서 사용되는 liquid는 {{ 와 }}를 escape 문자로 사용 &gt; 마크다운에 {{ 과 }}이 있으면 커밋이 error가 나고 {{ 과 }} 사이에 있는 내용은 무시됨 . - 해결 방법 &gt; 여는 중괄호 앞에 {% raw %}를 닫는 중괄호 뒤에 {% endraw %}를 추가함 . - 참고: Liquid syntax error 해결 . - 참고: How to escape liquid template tags . Latex math alignment not working . - Liquid syntax error를 예상하고 {% raw %}와 {% endraw %}를 사용했는데 오류가 발생했음 . - Liquid Exception: Liquid syntax error (line 732): Unknown tag &#39;endraw&#39; . - 뭐가 문제인지 삽질하다가 {% raw %}와 {% endraw %}를 모두 없앴는데 오류가 해결됨 . - 교훈 : 미리 사용하지 말고 오류가 발생하면 사용하자 . - 그런데 또 다른 문제가 생겼다 &gt; 블로그에 수식이 랜더링되지 않음 . - 수식을 등호를 기준으로 정렬하려고 begin{align} ~ end{align} 을 사용했는데 이게 문제를 일으킴 . - 찾아보니 align 대신 aligned를 사용하면 된다고 한다 . - ref : https://github.com/fastai/fastpages/issues/439 . &#44611;&#54728;&#48652; &#49436;&#48260; &#50724;&#47448; &#54869;&#51064; . - 깃허브 데스크탑으로 커밋을 하려는데 오류가 발생했음 . - 왜 그런가 찾아보니 내 문제가 아니라 서버 문제였다 . - 갑자기 오류가 생겼는데 내 문제가 아닌 것 같으면 서버 상태를 확인해보자 . - site: 깃허브 서버 오류 확인 .",
            "url": "https://jaesu26.github.io/green/python/github/2021/06/26/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91.html",
            "relUrl": "/python/github/2021/06/26/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post29": {
            "title": "리스트 처리",
            "content": "&#47532;&#49828;&#53944; &#51221;&#47148; . list.sort()&#54632;&#49688;, sorted()&#54632;&#49688; . - ?.sort()함수는 list형태인 ? 의 요소를 오름차순으로 정렬한다 . - ?.sort(reverse = True)함수는 내림차순으로 정렬한다 . - ?.sort()함수와 sorted()함수는 거의 같다 . - ?.sort()함수는 ?의 속성을 바꾸지만 sorted()함수는 ?의 속성을 바꾸지 않는다 (a.append()와 + 연산의 차이) . a=[1,5,2,3,7,4] a . [1, 5, 2, 3, 7, 4] . a.sort() a . [1, 2, 3, 4, 5, 7] . a.sort(reverse = True) a . [7, 5, 4, 3, 2, 1] . - sort(), sorted()의 key 옵션에 지정된 함수의 결과에따라 정렬한다 . - lambda함수(익명 함수) 사용 --&gt; lambda 매개변수: 결과 . b = [(1, 2), (0, 2), (1, 3), (1, 5), (0, 1), (2, 8)] c = sorted(b, key = lambda x: (x[0], -x[1])) ## x[1]앞에 있는 &#39;-&#39;기호는 현재정렬순서와 반대로이다 print(c) ##첫 번째 원소는 오름차순, 두 번째 원소는 내림차순으로 정렬 . [(0, 2), (0, 1), (1, 5), (1, 3), (1, 2), (2, 8)] . reverse()&#54632;&#49688; . - ?.reverse()함수는 list형태인 ? 의 요소를 역순으로 정렬한다 . d = [1,5,2,3,7,4] d.reverse() print(d) . [4, 7, 3, 2, 5, 1] . reversed()&#54632;&#49688; . - reversed()함수는 요소를 역순으로 정렬해 반환한다 . - 반환값을 그대로 사용하지 않고 list()나 tuple()함수를 통해 사용한다 . d = [1,5,2,3,7,4] reversed(d) . &lt;list_reverseiterator at 0x2185ce99e20&gt; . d = [1,5,2,3,7,4] tuple(reversed(d)) . (4, 7, 3, 2, 5, 1) . &#47532;&#49828;&#53944; &#52488;&#44592;&#54868; . 1&#52264;&#50896; &#47532;&#49828;&#53944; . a = [] ## 빈 리스트로 초기화 a . [] . A = [x] * n . $A = [x, x, x, ..., x, x] --&gt;$ $x$가 $n$개인 $1$차원 리스트 . a = [0]*10 ## 0리스트로 초기화 a . [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] . 2&#52264;&#50896; &#47532;&#49828;&#53944; . n = 5 list = [[0] * n for _ in range(n)] ## 0으로 채원진 2차원 리스트 . list . [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . list[0][0] = 123 . list . [[123, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . - ?? . List = [[0] * 5 for _ in range(5) . 그런데 _ 는 뭐지? . - 사실 _ 자리에 다른 것이 들어가도 된다 이를 테면 i . x = [0*i for i in range(5)] x . [0, 0, 0, 0, 0] . - 위에 List에서 _ 대신에 i를 넣는다고 생각하자 . List = [[0] * 5 for i in range(5) . - 위에 리스트인 x 에서는 i가 리스트 안에 0을 몇 개 생성할 지 정하는 변수였다 . - 위에 리스트인 List 에서는 i가 무슨 역할을 하지?? . - 아무역할도 하지 않는다 . - 0을 5개 생성하고 이를 5번 반복한다 . - List를 정의할 때 부터 정해졌다 . - i는 그저 for문을 쓰기 위해 필요함 --&gt; range(5)의 값을 받아낼 변수가 필요하다 . - 그래서 i 자리에 오는 변수는 아무짝에도 쓸모가 없다 . - 아무 의미가 없어서 그냥 아무 의미 없어보이는 기호인 _를 쓴다(내 생각) . &#47532;&#49828;&#53944; &#52628;&#44032; . ?.append() . - ? --&gt; 리스트 . - 마지막(?[-1]) 위치에 하나의 원소 추가 . a = [] a.append(1) a . [1] . ?.insert(i, v) . - i 위치에 v 원소 추가 . b = [1,2,3,5,6,7] b.insert(3,4) b . [1, 2, 3, 4, 5, 6, 7] . ?.extend() . - 마지막(?[-1]) 위치에 리스트 추가 . c = [1,2,3,4,5] c.extend([6,7,8]) c . [1, 2, 3, 4, 5, 6, 7, 8] . ?.pop() . - pop(i)는 리스트의 i번째 요소를 돌려주고 그 요소는 삭제, pop( ) = pop(-1) . d = [1, 2, 3, 4 ,5] x = d.pop() print(x) print(d) . 5 [1, 2, 3, 4] . arr[::] &#50857;&#48277; . - 슬라이싱 방법임 . - arr[A:B:C] &gt; index A부터 index B(포함X)까지 C간격으로 arr 생성 . - A가 none이면 처음부터 B가 none이면 끝까지 C가 none이면 1만큼 . - ::은 :과 동일함 . - 참고: https://docs.python.org/release/2.3.5/whatsnew/section-slices.html . arr = list(range(10)) arr . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . arr[1:9:2] . [1, 3, 5, 7] . arr[:10:3] . [0, 3, 6, 9] . arr[1::2] ## arr[1:2]와 결과가 동일함 . [1, 3, 5, 7, 9] . arr[1:5:] . [1, 2, 3, 4] . arr[5::] ## arr[5:]과 결과가 동일함 . [5, 6, 7, 8, 9] . arr[5:] . [5, 6, 7, 8, 9] . arr[:3:] . [0, 1, 2] . arr[::4] ## arr[:4]와 결과가 동일함 . [0, 4, 8] . arr[:4] . [0, 1, 2, 3] . arr[::] ## arr[:]과 결과가 동일함 . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . arr[:] . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . &#45796;&#52264;&#50896;&#50640;&#49436;&#51032; &#49324;&#50857; . - 다차원 matrix에서의 사용도 동일함 . - 리스트에서 [ ]를 영역마다 사용하여 슬라이싱 &gt; ex) list[0:2][0:2][0:2] . - 참고: https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html . arr1 = [[1, 2, 3], [2, 3, 4], [3, 4, 5]] ## arr1은 (3, 3)차원 ## arr1(a, b) &gt; a는 1차원 b는 2차원 &gt;a는 x축 b는 y축이라 생각해도 됨 arr1[0:2][0:2] ## x축에서 0~1까지, y축에서 0~1까지 리스트를 슬라이싱함 . [[1, 2, 3], [2, 3, 4]] . arr2 = [[[1, 2, 3], [2, 3, 4]], [[3, 4, 5], [4, 5, 6]], [[5, 6, 7], [6, 7, 8]]] arr2[0:2][0:2][0:2] ## x축에서 0~1까지, y축에서 0~1까지, z축에서 0~1까지 리스트를 슬라이싱함 . [[[1, 2, 3], [2, 3, 4]], [[3, 4, 5], [4, 5, 6]]] . arr2[:][1][0:2] ## x축에서 처음부터 끝까지, y축에서 1, z축에서 0~1까지 리스트를 슬라이싱함 . [[3, 4, 5], [4, 5, 6]] . numpy&#50640;&#49436;&#51032; &#49324;&#50857; . import numpy as np arr3 = np.array(arr2) arr3 . array([[[1, 2, 3], [2, 3, 4]], [[3, 4, 5], [4, 5, 6]], [[5, 6, 7], [6, 7, 8]]]) . arr3.shape ## arr3는 (3, 2, 3)차원의 matrix임 . (3, 2, 3) . - 리스트에서는 [ ]를 영역마다 사용했지만 numpy array에서는 하나의 [ ]안에서 표현 가능 . - numpy array에서는 콤마(,)로 영역을 구분하고 :를 통해 슬라이싱을 함 &gt; ex) numpy_array[0:2, 0:2, 0:2] . - list[0:2][0:2][0:2] &gt; 리스트에서 슬라이싱 . - arr[0:2, 0:2, 0:2] &gt; numpy array에서 슬라이싱 . - 둘다 의미는 x축에서 0~1까지, y축에서 0~1까지, z축에서 0~1까지 array를 슬라이싱하라는 뜻 . arr3[1, 1 ,1] ## 기본적인 인덱싱 방법 . 5 . arr3[0:2, 0:2, 0:2] ## x축에서 0~1까지, y축에서 0~1까지, z축에서 0~1까지 array를 슬라이싱함 . array([[[1, 2], [2, 3]], [[3, 4], [4, 5]]]) . arr3[:2, :1, :] ## x축에서 처음부터 1까지 y축에서 처음부터 0까지, z축에서 처음부터 끝까지 array를 슬라이싱함 . array([[[1, 2, 3]], [[3, 4, 5]]]) . - 어떤 array가 있는데 마지막 차원에서 인덱스가 마지막 번호인 array만 슬라이싱하고 싶다고 하자 . - 아래와 같이 해도 됨 . arr3[:, :, -1] ## 1차원의 모든 원소, 2차원의 모든 원소, 3차원은 마지막 원소만 가지는 array를 슬라이싱함 . array([[3, 4], [5, 6], [7, 8]]) . - numpy array에서는 ,를 통해 차원의 구분을 하고 :를 통해 슬라이싱을 함 . - 근데 차원이 매우 크다면? . - 예컨데 차원이 100차원이라면 일일이 :와 ,를 입력할 것인가? &gt; 궁금한건 마지막 차원에 대한 조건임, 더 작은 차원은 무관심 . - 어떻게 함?? &gt; ...(ellipsis)를 사용 . - ...은 우리가 일일이 입력해야할 앞의 차원에서의 :와 ,을 의미함 + ...을 뒤에 입력하면 뒤의 차원을 커버함 &gt; 하나의 [ ]안에서 한 개만 사용 가능 . arr3[..., -1] ## ...은 앞의 차원들의 원소를 모두 포함한다는 의미 . array([[3, 4], [5, 6], [7, 8]]) . arr3[..., 0:2] . array([[[1, 2], [2, 3]], [[3, 4], [4, 5]], [[5, 6], [6, 7]]]) . arr3[1, ...] ## 1차원에서 인덱스가 1인 array를 추출, 뒤에 차원들의 원소는 ...을 사용하여 모두 포함했음 . array([[3, 4, 5], [4, 5, 6]]) . &#49836;&#46972;&#51060;&#49905;&#51012; &#49324;&#50857;&#54644; &#51060;&#48120;&#51648;&#51032; RGB&#44050; &#44144;&#44984;&#47196;&#54616;&#44592; . - 이 문제때문에 ellipsis에 대해 알아봄 . - OpenCV를 통해 이미지를 불러온다고 해보자 . - OpenCV에서는 컬러 이미지를 BGR 순서로 저장함 . - plt.imshow()로 이미지를 확인할 것임 . - 그런데 matplotlib에서는 RGB 순서로 저장함 &gt; RGB순서가 바뀜(흑백 사진은 괜찮음) . - 즉 OpenCV로 읽어온 이미지를 RGB순서로 바꿔야 함 . import matplotlib.pyplot as plt import cv2 as cv img = cv.imread(&#39;squirrel.jpg&#39;) plt.imshow(img) . &lt;matplotlib.image.AxesImage at 0x2737ecd7880&gt; . - cv.imread()를 통해 이미지를 읽어오는데 이 함수가 RGB순서가 아닌 BGR순서로 이미지를 읽어서 원본과 다르게 보이는 것임 . - 이미지도 숫자 matrix임 &gt; BGR순서만 GRB로 할 수 있을까? . - 만약 어떤 array가 있는데 나머지는 그대로 두고 마지막 차원의 원소의 순서만 반대로 하고 싶다면?? &gt; ...을 활용하자 . - img[..., ?]과 같이 하면 일단 마지막 차원의 원소를 제외하고 모두 그대로임 . - 이제 제어할 차원이 하나 남음 &gt; 벡터와 마찬가지 . - 1차원 array의 순서를 거꾸로 하려면??? &gt; array[ : : -1] &gt; 처음부터 끝까지 음의 방향으로 리스트 슬라이싱 . img2 = img[..., ::-1] plt.imshow(img2) ## 원본 이미지가 보임 . &lt;matplotlib.image.AxesImage at 0x2737ee0c340&gt; . - 원본 이미지가 제대로 보임 . - ref: https://stackoverflow.com/questions/50963283/python-opencv-imshow-doesnt-need-convert-from-bgr-to-rgb . - ref: https://ko.wikipedia.org/wiki/%EB%8B%A4%EB%9E%8C%EC%A5%90 . &#47532;&#49828;&#53944; &#49325;&#51228; . ?.remove(x) . - 리스트에서 x원소를 삭제 . - 삭제할 원소가 없을 시 error . a = [1,2,3,4,5,6] a.remove(1) print(a) . [2, 3, 4, 5, 6] . a.remove(10) . ValueError Traceback (most recent call last) &lt;ipython-input-2-72b3315abecc&gt; in &lt;module&gt; -&gt; 1 a.remove(10) ValueError: list.remove(x): x not in list . &#47928;&#51088;&#50676; &#54252;&#54632;&#50668;&#48512; . ?.find(&quot;&#47928;&#51088;&#50676;&quot;) . - ?에 문자열이 존재하면 가장 앞에 원소의 시작 인덱스 값을 반환하며 존재하지 않으면 -1값을 반환 . day = &quot;2021-07-03&quot; . day.find(&#39;2021&#39;) . 0 . day.find(&#39;-&#39;) . 4 . day.find(&#39;2222&#39;) . -1 . &quot;&#47928;&#51088;&#50676;&quot; in ? , &quot;&#47928;&#51088;&#50676;&quot; not in ? . - ?에 문자열이 존재하면 True 반환, 존재하지 않으면 False 반환, not in에 경우는 반대로 . day = &quot;2021-07-03&quot; . &#39;2021&#39; in day . True . &#39;-&#39; not in day . False . &#39;2222&#39; in day . False . list = [&#39;1011&#39;, &#39;2022&#39;, &#39;day&#39;, &#39;model&#39;] . &#39;2022&#39; in list . True . &#39;day&#39; not in list . False . &#39;month&#39; in list . False . enumerate &#54632;&#49688; . - for문을 사용할 때 인덱스를 같이 출력할 수 있음 . - 참고: 파이썬 for문 . cards = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] for i in range(len(cards)): print(i, cards[i]) . 0 A 1 B 2 C . for value in enumerate(cards): print(value) . (0, &#39;A&#39;) (1, &#39;B&#39;) (2, &#39;C&#39;) . - enumerate 함수는 인덱스와 원소로 이루어진 tuple을 생성함 . - 만약 인덱스와 원소를 다른 변수로 만들고 싶다면 tuple unpacking을 사용하면 됨 . for idx, card in enumerate(cards): print(idx, card) . 0 A 1 B 2 C . zip &#54632;&#49688; . - zip 함수는 iterable한 객체들을 인자로 받아 각각의 원소를 tuple로 접근가능한 iterator를 만듦 . - 참고: python zip function . a = (&quot;John&quot;, &quot;Charles&quot;, &quot;Mike&quot;) b = (&quot;Jenny&quot;, &quot;Christy&quot;, &quot;Monica&quot;) zip(a, b) . &lt;zip at 0x28632cc8e40&gt; . list(zip(a, b)) . [(&#39;John&#39;, &#39;Jenny&#39;), (&#39;Charles&#39;, &#39;Christy&#39;), (&#39;Mike&#39;, &#39;Monica&#39;)] . tuple(zip(a, b)) . ((&#39;John&#39;, &#39;Jenny&#39;), (&#39;Charles&#39;, &#39;Christy&#39;), (&#39;Mike&#39;, &#39;Monica&#39;)) .",
            "url": "https://jaesu26.github.io/green/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%ED%95%A8%EC%88%98.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post30": {
            "title": "마크다운 용법",
            "content": "fastpages &#52852;&#53580;&#44256;&#47532; . - _notebook 폴더안에 파일을 만드는데 아래와 같은 형식을 준수하자 . 제목 . &quot;부제목&quot; . -toc: true . -branch: master . -badges: true . -comments: true . -author: 한재수 . -categories: [python] . - 위에 내용을 아무곳에나 붙여 넣는다. 부제목은 (&gt;&quot;부제목&quot;), 제목은 (# 제목) . - categories에 해당하는 부분이 깃허브 홈페이지에서 tag에 보이는 부분이다. . - categories 에서 [ ] 안에 여러개를 추가 할 수 있다. ex) [python, R, CSS] . &#48660;&#47196;&#44536; &#44288;&#47532; . 1_ 깃허브 가입하기 | 2_ fastai/fastpages 사용 | 3_ 깃허브 데스크탑 이용 . | (1) 주피터노트북으로 공부한다 . | (2) 깃허브와 연결된 어떤 폴더(드랍박스 안의 green)에 공부한 내용을 넣는다 | (3) 깃허브 데스크탑이라는 프로그램을 이용하여 local(내 윈도우 컴퓨터)에서 remote (github)로 변경사항을 반영한다 | (4) 2~3분 뒤에 블로그 홈페이지에 반영된다 | (5) 공부한 내용을 편집없이 주피터 노트북 파일을 올리기만 하면 블로그에 올라가서 편하다 필요에 따라 숨기기, 비밀 포스트도 만들 수 있다 | . - 수식을 제대로 입력했는데 블로그에서는 raw 수식 내용이 그대로 보인다면 text{ ... }안에 내용이 수식과 일반 텍스트로 심하게 혼용이 되어 있는지 보자 . - 일반 텍스트는 text{ }안에 적고 수식은 밖에 적으면 해결됨 &gt; 삽질해서 확인함 . &#44611;, &#44611;&#54728;&#48652; . - 버전 관리 시스템 . - 서로 코드를 공유 . - 혼자 쓰면 개인 저장소.. . &#51452;&#54588;&#53552; &#45432;&#53944;&#48513; . &#50976;&#50857;&#54620; &#53412; . - 삭제한 셀 복원 &gt; Edit - Undo cell operation or Esc 후 z키 입력 . - 삭제한 코드 복원 &gt; Ctrl + z . - 주석처리 단축키 &gt; Ctrl + / (여러줄을 동시에 처리할려면 마우스로 스크롤하기) . &#51452;&#54588;&#53552; &#45432;&#53944;&#48513; &gt; remote &gt; page (&#50504; &#50732;&#46972;&#44040; &#49688; &#46020; &#51080;&#45796;) . - 깃허브 데스크탑 history에서 이제껏 했던 커밋을 볼 수 있다. 게다가 삭제된 파일을 복구할 수 도 있다. . - 화면 캡쳐 프로그램으로 캡쳐를 함 &gt; 마크다운에서 캡쳐한 이미지를 ctrl+v하면 캡쳐한 이미지가 삽입된다. . - 이미지 파일을 넣은 주피터 노트북 파일을 올리면 깃허브 notebook에는 올라가지만 블로그에는 올라가지 않는다. . &#47553;&#53356; &#49341;&#51077; . - 보통 링크 삽입은 [label](link)의 형식임 . - 그런데link에 )기호가 있으면 링크 연결에 문제가 있을 수 도 있음 . - [label][key] . - [key]: link . - 위와 같이 해도 링크 연결에 문제가 없고 위의 문제도 해결 가능함 . - 참고: 링크 연결 . &#49688;&#49885; &#44592;&#54840; &#54364;&#54788; . - 3.141592를 변수에 저장하고 싶음 . - pi = 3.141592 . - 그런데 pi 대신에 $ pi$를 사용하고 싶다면?? . - code셀에서 pi를 입력한 후 Tab을 누르면 됨 . pi = 3.141592 π = 3.141592 . pi . 3.141592 . π . 3.141592 . &#49472;&#51032; &#50577;&#45149;&#51004;&#47196; &#51060;&#46041; . - 키보드 위 키를 누르면 셀의 오른쪽 끝으로 이동함 . - 키보드 아래 키를 누르면 셀의 왼쪽 끝으로 이동함 . &#49688;&#49885;&#51012; &#47691;&#51080;&#44172; &#54364;&#54788;&#54616;&#44256; &#49910;&#45796;&#47732;?? . - $수식$ 꼴로 나타낸다. . - y = x^2 + 1 . - $y = x^2 +1$ . &#48145; &#52392;&#51088; &#54364;&#54788; . - $수식_밑첨자$ . - x_1 + x_2 = x_3 . - $x_1 + x_2 = x_3$ . $ sum$ &#54364;&#54788; . - limits 옵션을 통해 $ sum$의 시작과 끝의 위치를 $ sum$의 바로 위와 아래로 지정가능 . - $ sum_{n=1}^{ infty} frac{1}{n^2}$ . - $ sum limits_{n=1}^{ infty} frac{1}{n^2}$ . - mathop로 여러개의 sum을 { }로 감싸주면 글씨를 가운데에 표현 가능 . - $2 mathop{ sum sum} limits_{j&lt;k}Cov(X_j,X_k)$ &gt; mathop{ sum sum} limits_{j&lt;k} . &#48177;&#53552; &#54364;&#54788; . - 벡터 표현하기: 화살표, 볼드체 . - $X$는 변수 . - $ boldsymbol{X}, ; vec{X}$는 벡터 . &#50948;&#50500;&#47000;&#47196; &#51473;&#44292;&#54840; &#54364;&#54788; . - overbrace를 통해 위로 중괄호를 표현함 . - $x+x+x+ dots+x+x, ;x$를 $n$번 더함 . - underbrace를 통해 아래로 중괄호를 표현함 . - $x times x times x times dots times x times x, ;x$를 $n$번 곱함 . - $ overbrace{x + cdots + x}^{n rm times}$ . - $ underbrace{x times cdots times x}_{n rm times}$ . &#51216;&#52237;&#44592; . - s 제외하면 점 하나만 찍힘, s 포함하면 점 세개 찍힌다 . - dots &gt; $ dots$ . - cdots &gt; $ cdots$ . - ddots &gt; $ ddots$ . - vdots &gt; $ vdots$ . &#44292;&#54840; &#53356;&#44172; &#47564;&#46308;&#44592; . - big Big bigg Bigg 을 통해 괄호를 크게 만들 수 있음 . - $ big( Big( bigg( Bigg($ . - $ big[ Big[ bigg[ Bigg[$ . - $ big { Big { bigg { Bigg { $ . - 참고로 수식안에 들어가는 기호로서 중괄호 표현은 { 이다 . &#44544;&#50472; &#53356;&#44592; &#51312;&#51208; . - link : https://ko.overleaf.com/learn/latex/Font_sizes,_families,_and_styles . &#44060;&#54665; &#44036;&#44201; &#51312;&#51208; . - link : https://tex.stackexchange.com/questions/494582/spacing-of-newline-and . - 참고로 주피터노트북에서 보이는 간격이랑 블로그에서 보이는 간격이 다름 . &#47928;&#51088; &#50948;&#50640; &#47928;&#51088; &#54364;&#49884; . - ${H_0}^{ sim}$ &gt; {H_0}^{ sim} . - $ overset{ sim}{H_0}$ &gt; overset{ sim}{H_0} . - ref : https://tex.stackexchange.com/questions/43335/how-to-write-is-distributed-as-under-a-certain-hypothesis . &#49688;&#49885;&#51032; &#49884;&#51089; &#50948;&#52824;&#47484; &#46041;&#51068;&#54616;&#44172; &#54616;&#44256; &#49910;&#45796;&#47732;? . $$ frac{ partial boldsymbol L}{ partial beta_0} = - frac{1}{ sigma^2} sum limits^{n}_{i=1}(y_i- beta_0- beta_1 x_i)=0 frac{ partial boldsymbol L}{ partial beta_1} = frac{1}{ sigma^2} sum limits^{n}_{i=1}x_i(y_i- beta_0- beta_1 x_i)=0 frac{ partial boldsymbol L}{ partial beta_1} = - frac{n}{2 sigma^2}+ frac{1}{2 sigma^4} sum limits^{n}_{i=1}x_i(y_i- beta_0- beta_1 x_i)=0$$- begin{aligned} 와 end{aligned}를 사용하면 된다 . $$ begin{aligned} frac{ partial boldsymbol L}{ partial beta_0} &amp; = - frac{1}{ sigma^2} sum limits^{n}_{i=1}(y_i- beta_0- beta_1 x_i)=0 frac{ partial boldsymbol L}{ partial beta_1} &amp; = frac{1}{ sigma^2} sum limits^{n}_{i=1}x_i(y_i- beta_0- beta_1 x_i)=0 frac{ partial boldsymbol L}{ partial beta_1} &amp; = - frac{n}{2 sigma^2}+ frac{1}{2 sigma^4} sum limits^{n}_{i=1}x_i(y_i- beta_0- beta_1 x_i)=0 end{aligned}$$- ref: https://stackoverflow.com/questions/28353127/how-to-change-alignment-of-displayed-equations-in-ipython-notebook . &#50976;&#50857;&#54620; latex . boldsymbol . - applies to nearly all symbols, not just letters and numbers . - ex) $ boldsymbol{A} ,A$ . bf . - Used to turn on boldface; affects uppercase and lowercase letters, and digits . - ex) ${ bf 123} ,{123}$ . - ex) ${ bf A} ,{A}$ . therefore . - therefore를 통해 삼각형 모양 점3개를 만듦 . - $ therefore 1+1= text{힘든 삶}$ . bigcup . - 집합열을 포현할 때 합집합 기호의 밑과 위에 시작과 끝을 표시하고 싶다면 bigcup과 limits를 사용하자 . - $ cup_{i=1}^{ infty} A_i$ &gt; cup_{i=1}^{ infty} A_i . - $ bigcup_{i=1}^{ infty} A_i$ &gt; bigcup_{i=1}^{ infty} A_i . - $ bigcup limits_{i=1}^{ infty} A_i$ &gt; bigcup limits_{i=1}^{ infty} A_i . cfrac . - 일반적인 frac과의 차이점은 글씨의 크기임 . - $P(A|B) = frac{P(A cap B)}{P(B)}$ &gt; frac . - $P(A|B) = cfrac{P(A cap B)}{P(B)}$ &gt; cfrac . mid . - 수직선을 그려줌 &gt; 조건부 확률 표현할 때 사용 . - $P(A|B) = cfrac{P(A cap B)}{P(B)}$ &gt; | . - $P(A mid B) = cfrac{P(A cap B)}{P(B)}$ &gt; mid . xrightarrow . - 오른쪽방향의 화살표를 그려주는데 화살표위에 글씨를 적을 수 있다! . - 확률변수의 수렴을 표현할 때 사용할 수 있음 . - $X_n{ xrightarrow{p}} X$ &gt; X_n{ xrightarrow{p}} X : 확률수렴 . - 그런데 화살표길이가 더 길었으면 좋겠다 . - 그럴땐 ~ 기호를 이용하면 된다 . - $X_n{ xrightarrow{~~p~~}} X$ &gt; X_n{ xrightarrow{~~p~~}} X . - 아래처럼 할 수 도 있음 . - $X_n overset{p}{ longrightarrow}X$ &gt; X_n overset{p}{ longrightarrow}X . &#47588;&#50864; &#50976;&#50857;&#54620; &#49324;&#51060;&#53944; . - &lt;Jupyter 노트북에서 Markdown 및 LaTeX을 작성하는 방법 알아보기 &gt; https://ichi.pro/ko/jupyter-noteubug-eseo-markdown-mich-latexleul-jagseonghaneun-bangbeob-al-abogi-18246612521469 . - latex command 총 정리 &gt; https://www.tutorialspoint.com/tex_commands/percentage.htm .",
            "url": "https://jaesu26.github.io/green/python/github/markdown/jupyter/latex/2021/06/24/markdown-in-latex.html",
            "relUrl": "/python/github/markdown/jupyter/latex/2021/06/24/markdown-in-latex.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post31": {
            "title": "백준 문제풀기",
            "content": ". &#48177;&#51456; &#54616;&#47732;&#49436; &#50508;&#50500;&#45240; &#51216; . 같은 언어, 같은 코드여도 시간이 다를 수 있음 . | 메모리도 다를 수 있음 . | . &#51077;&#52636;&#47141;&#44284; &#49324;&#52825;&#50672;&#49328; . &#49324;&#52825;&#50672;&#49328; &#52636;&#47141; . a, b = map(int, input().split()) print(a+b) print(a-b) print(a*b) print(a//b) print(a%b) . 10 4 21 2 1 . A+B - 1 . a, b = map(int, input().split()) print(a+b) . 12 . &#45208;&#47672;&#51648; . (A+B)%C는 ((A%C) + (B%C))%C 와 같을까? . | (A×B)%C는 ((A%C) × (B%C))%C 와 같을까? . | 세 수 A, B, C가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오. . | . A, B, C = map(int, input().split()) print((A+B)%C) print(((A%C) + (B%C))%C) print((A*B)%C) print(((A%C) * (B%C))%C) . 1 1 0 0 . &#44273;&#54616;&#44592; . a = str(input()) b = str(input()) result = ([int(a) * int(b[2-x]) for x in range(3)]) for i in range(3): print(result[i]) print(int(a)*int(b)) . 2360 3776 1416 181720 . &#54217;&#44512;&#51008; &#45336;&#44192;&#51648; . 각 케이스마다 한 줄씩 평균을 넘는 학생들의 비율을 반올림하여 소수점 셋째 자리까지 출력한다. | . C = int(input()) for i in range(C): line = list(map(int, input().split())) mean = sum(line[1:]) / line[0] over_mean = [x for x in range(1, len(line)) if line[x] &gt; mean] over_mean_percent = len(over_mean) * 100 / line[0] print(&#39;{:.3f}%&#39;.format(over_mean_percent)) . 57.143% . &#44256;&#50577;&#51060; &#52636;&#47141; . - 문자열은 &#39; &#39;로 둘러 싸임 . - 를 출력하고 싶으면 . - &#39;을 출력하고 싶으면 &#39; 또는 문자열을 &quot; &quot;로 감싸기 . - 정규표현식의 일종임 --&gt; 정규표현식 공부하기 . print(&#39; &#39;) . File &#34;&lt;ipython-input-28-eaac87876c3b&gt;&#34;, line 1 print(&#39; &#39;) ^ SyntaxError: EOL while scanning string literal . print(&#39; &#39;) . . print(&#39;&#39;&#39;) . File &#34;&lt;ipython-input-33-c6d045ece466&gt;&#34;, line 1 print(&#39;&#39;&#39;) ^ SyntaxError: EOF while scanning triple-quoted string literal . print(&#39; &#39;&#39;) . &#39; . print(&quot;&#39;&quot;) . &#39; . print(&#39; / n ) ( &#39;) n( / ) n (__)|&#39;) . / ) ( &#39;) ( / ) (__)| . &#44053;&#50500;&#51648; . - 문자열에서 &quot; &quot;를 표현하고 싶으면 &#39; &#39;로 감싸기 . - 또는 문자열을 &#39;&#39;&#39; &#39;&#39;&#39;로 감싸는 방법도 있음 . print(&quot;&quot;&quot;) . File &#34;&lt;ipython-input-46-3f29872ceae9&gt;&#34;, line 1 print(&#34;&#34;&#34;) ^ SyntaxError: EOF while scanning triple-quoted string literal . print(&#39;&quot;&#39;) . &#34; . print(&#39;&#39;&#39; | _/| n|q p| /} n( 0 )&quot;&quot;&quot; n|&quot;^&quot;` | n||_/= __| &#39;&#39;&#39;) . | _/| |q p| /} ( 0 )&#34;&#34;&#34; |&#34;^&#34;` | ||_/= __| . - &#39;&#39;&#39; &#39;&#39;&#39;로 감쌀 때 앞의 &#39;&#39;&#39; 앞에 r을 적으면 문자열을 원시 문자열로 처리함 . - 를 표현하기 위해 로 하지 않고 그냥 역슬래시만 해도 가능 . print(&#39;| _/| n|q p| /} n( 0 )&quot;&quot;&quot; n|&quot;^&quot;` | n||_/= __|&#39;) . | _/| |q p| /} ( 0 )&#34;&#34;&#34; |&#34;^&#34;` | ||_/= __| . print(r&#39;&#39;&#39;| _/| |q p| /} ( 0 )&quot;&quot;&quot; |&quot;^&quot;` | ||_/= __|&#39;&#39;&#39;) . | _/| |q p| /} ( 0 )&#34;&#34;&#34; |&#34;^&#34;` | ||_/= __| . . if&#47928; . &#46160; &#49688; &#48708;&#44368;&#54616;&#44592; . A, B = map(int, input().split()) if A&gt;B: print(&#39;&gt;&#39;) elif A&lt;B: print(&#39;&lt;&#39;) else: print(&#39;==&#39;) . &gt; . &#49884;&#54744; &#51216;&#49688; &#52636;&#47141; . def result(grade): if grade &gt;= 90 and grade &lt;= 100: print(&quot;A&quot;) elif grade &gt;= 80 and grade &lt;= 89: print(&quot;B&quot;) elif grade &gt;= 70 and grade &lt;= 79: print(&quot;C&quot;) elif grade &gt;= 60 and grade &lt;= 69: print(&quot;D&quot;) else: print(&quot;F&quot;) grade = int(input()) result(grade) . A . &#50980;&#45380; &#54032;&#45800; . 윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다. . | 예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다. . | . def leap_year(year): if (year%4 ==0 and year%100 != 0) or year%400 == 0: print(1) else: print(0) year = int(input()) leap_year(year) . 1 . &#49324;&#48516;&#47732; &#44256;&#47476;&#44592; . 첫 줄에는 정수 x가 주어진다. (−1000 ≤ x ≤ 1000; x ≠ 0) 다음 줄에는 정수 y가 주어진다. (−1000 ≤ y ≤ 1000; y ≠ 0) . | 점 (x, y)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다. . | . def quadrant(a,b): if a&gt;0 and b&gt;0: print(1) elif a&gt;0 and b&lt;0: print(4) elif a&lt;0 and b&gt;0: print(2) elif a&lt;0 and b&lt;0: print(3) x = int(input()) y = int(input()) quadrant(x, y) . 4 . &#50508;&#46988; &#49884;&#44228; . 45분 일찍 알람 설정하기 | . h, m = map(int, input().split()) if m &gt;= 45: print(h, m-45) elif h == 0: print(23, m+15) else: print(h-1, m+15) . 23 40 . . for&#47928; . &#44396;&#44396;&#45800; . n = int(input()) for i in range(1,10): print(&#39;%s * %s = %s&#39; % (n, i, n*i)) . 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 . A+B - 3 . 첫째 줄에 테스트 케이스의 개수 T가 주어진다. . | 각 테스트 케이스마다 A+B를 출력한다. . | . T = int(input()) for i in range(T): A, B = map(int, input().split()) print(A+B) . 6 . 10 . 75 . 1&#48512;&#53552; n&#44620;&#51648; &#54633; . 반복문 있는 버전 | . n = int(input()) sum = 0 for i in range(1, n+1): sum += i print(sum) . 55 . 반복문 없는 버전 | . n = int(input()) print(int(n * (n+1) / 2)) . 55 . sys.stdin.readline() . 본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. . | 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다. . | Python을 사용하고 있다면 input() 대신 sys.stdin.readline()을 사용할 수 있다. . | 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우 .rstrip()을 추가로 해 주는 것이 좋다. . | . import sys T = int(input()) for i in range(T): A, B = map(int, sys.stdin.readline().split()) print(A+B) . ValueError Traceback (most recent call last) &lt;ipython-input-3-173fe188e1c6&gt; in &lt;module&gt; 2 T = int(input()) 3 for i in range(T): -&gt; 4 A, B = map(int, sys.stdin.readline().split()) 5 print(A+B) ValueError: not enough values to unpack (expected 2, got 0) . - error 왜 뜨지? . - sys.stdin.readline()를 쓸 때마다 에러가 난다. . 1&#48512;&#53552; N&#44620;&#51648; &#52636;&#47141; . N = int(input()) for i in range(1, N+1): print(i) . 1 2 3 4 5 . N&#48512;&#53552; 1&#44620;&#51648; &#52636;&#47141; . N = int(input()) for i in range(1, N+1): print(N-i+1) . 5 4 3 2 1 . A+B - 7 . 각 테스트 케이스마다 &quot;Case #x: &quot;를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다. | . import sys T = int(input()) for i in range(1, T+1): A, B = map(int, sys.stdin.readline().split()) print(&#39;Case #%s: %s&#39; % (i, A+B)) . Case #1: 6 . Case #2: 6 . Case #3: 8 . &#48324; &#52237;&#44592; - 1 . 문제 출처: 백준 2438번 | . N = int(input()) for i in range(1, N+1): for j in range(i): print(&#39;*&#39;, end = &#39;&#39;) print(&#39; n&#39;, end = &#39;&#39;) . * ** *** **** ***** . print&#54632;&#49688; &#50857;&#48277; . print(출력할 객체, end = &#39;함수가 종료될 때 실행하는 값&#39;) . | print()함수에서 end값을 따로 지정하지 않으면 끝을 줄바꿈 문자로 한다. . | . print(&#39;안녕&#39;, end = &#39;~~~~&#39;) print(&#39;하세요&#39;) . 안녕~~~~하세요 . N = int(input()) for i in range(N): for j in range(1, N-i): print(&quot; &quot;, end = &quot;&quot;) for k in range(i+1): print(&quot;*&quot;, end = &quot;&quot;) print(&quot; n&quot;, end = &quot;&quot;) . * ** *** **** ***** . X&#48372;&#45796; &#51089;&#51008; &#49688; . 첫째 줄에 N과 X가 주어진다. (1 ≤ N, X ≤ 10,000) . | 둘째 줄에 수열 A를 이루는 정수 N개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다. . | X보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. X보다 작은 수는 적어도 하나 존재한다. . | . N, X = map(int, input().split()) A = list(map(int, input().split())) for i in range(N): if A[i] &lt; X: print(A[i], end = &quot; &quot;) . 1 0 . . while&#47928; . A+B - 5 . 입력의 마지막에는 0 두 개가 들어온다. | . while True: A,B = map(int, input().split()) if A==0 and B==0: break else: print(A+B) . 2 . 4 . &#45908;&#54616;&#44592; &#49324;&#51060;&#53364; . 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. . | 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. . | 26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다. . | 위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다. . | N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.(0&lt;=N&lt;=99 인 정수) . | . n = N = int(input()) N_cycle = 0 while True: if N &lt; 10: N = int(2*str(N)) N_cycle += 1 else: N = int(str(N)[-1]+str(int(str(N)[0])+int(str(N)[-1]))[-1]) N_cycle += 1 if N == n: print(N_cycle) break . 60 . . &#54632;&#49688; . N&#44060;&#51032; &#54633; . 정수 n개가 주어졌을 때, n개의 합을 구하는 함수를 작성하시오. | . def solve1(a): sum = 0 for i in range(len(a)): sum += a[i] return(sum) . a=[0,1,2,3,4] solve1(a) . 10 . def solve2(a): return(sum(a)) . a=[0,1,2,3,4] solve2(a) . 10 . &#49472;&#54532; &#45336;&#48260; . 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다. | . z = set(range(1,10001)) - {x+sum([int(a) for a in str(x)]) for x in range(1,10001)} z = list(z) z.sort() for i in range(len(z)): print(z[i]) # 출력이 너무 길어서 출력은 생략 . &#54620;&#49688; . 어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. . | 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. . | N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오. . | . N = int(input()) def solve(a): if a &lt; 100: print(a) else: n = 99 for i in range(100, a+1): if int(str(i)[1]) - int(str(i)[0]) == int(str(i)[2]) - int(str(i)[1]): n += 1 print(n) solve(N) . 129 . . &#51116;&#44480;&#54632;&#49688;(&#51473;&#50836;&#54632; &#50500;&#47560;&#46020; &#44536;&#47532;&#44256; &#54775;&#44040;&#47548;) . - 재귀함수를 구상해보자. . - 재귀함수는 관계가 중요하다. . - 팩토리얼에서는 $fact(x)= x * fact(x-1)$ 관계가 성립한다. . - $fact(0), fact(1)$ 은 1이다. . - x가 0 또는 1일 때는 return을 1로 설정하고 나머지의 경우에는 $fact(x)= x * fact(x-1)$ 을 return한다면 재귀함수가 된다. . - 즉, 기본값 [$fact(0 or 1)=1$] 을 알고 관계식 [$fact(x)= x * fact(x-1)$] 을 안다면 재귀함수로 구현할 수 있다. . &#54057;&#53664;&#47532;&#50620; . 0보다 크거나 같은 정수 N이 주어진다. . | 이때, 재귀함수를 이용하여 N!을 출력하는 프로그램을 작성하시오. . | . N = int(input()) def fact(x): if x == 0 or x == 1: return 1 else: return x*fact(x-1) print(fact(N)) . &#54588;&#48372;&#45208;&#52824; &#49688; 5 . n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오. . | 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. . | 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. . | n은 20보다 작거나 같은 자연수 . | . N = int(input()) def fibo(x): if x == 0: return 0 elif x == 1: return 1 else: return fibo(x-1) + fibo(x-2) print(fibo(N)) . 55 . &#54588;&#48372;&#45208;&#52824; &#49688;&#50676; &#47700;&#47784;&#51060;&#51228;&#51060;&#49496; . 피보나치 재귀 함수의 경우 이미 구한 값을 구하기 위해 반복을 많이 해서 효율성이 떨어진다. . | 재귀 함수가 효율적이지 못하다면 메모이제이션을 사용한다. . | 재귀함수가 한 번 호출될 때마다 결과값을 저장하여 효율성을 높이는 것이 좋다. (메모이제이션) . | . N = int(input()) fibonacci = {0:0, 1:1} ## 메모이제이션을 위한 딕셔러니 선언 def fibo(x): if x in fibonacci: return fibonacci[x] fibonacci[x] = fibo(x-1) + fibo(x-2) return fibonacci[x] print(fibo(N)) . 55 . print(&#39;&#47928;&#51088;&#50676;&#39;) . $ star$ 과 $ star$ 사이에 빈칸이 있다. 이유는 ,(콤마) 때문이다. | . print(&#39;*&#39;, &#39;*&#39;, end = &quot;&quot;) . * * . ,(콤마)를 없애면 $ star$ 과 $ star$ 사이에 빈칸이 없다. | . print(&#39;*&#39; &#39;*&#39;, end = &quot;&quot;) . ** . &#54616;&#45432;&#51060; &#53457; &#51060;&#46041; &#49692;&#49436; . 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. . | 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다. . | 첫째 줄에 옮긴 횟수 K를 출력한다. . | 두 번째 줄부터 수행 과정을 출력한다. . | . N = int(input()) def Hanoi(n,from_pos,to_pos,aux_pos): if n==1: print(from_pos,to_pos) else: Hanoi(n-1,from_pos,aux_pos,to_pos) print(from_pos,to_pos) ## 가장 큰 원반을 목적지로 이동 Hanoi(n-1,aux_pos,to_pos,from_pos) print(2**N-1) Hanoi(N,1,3,2) . 7 1 3 1 2 3 2 1 3 2 1 2 3 1 3 . . &#47928;&#51088;&#50676; . &#49707;&#51088;&#51032; &#54633; . N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오. | . N = int(input()) num_str = str(input()) num_str = num_str.replace(&#39;0&#39;,&quot;&quot;) print(sum([int(num_str[x]) for x in range(len(num_str))])) . 15 . - map 함수 사용 . N = int(input()) num_str = str(input()) print(sum(map(int, num_str))) . 15 . &#45800;&#50612;&#51032; &#44060;&#49688; . 영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. . | 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. . | 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다. . | . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] == &#39;&#39;: spaces += 1 if s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 6 . - 어이없는 상황을 맞이함 . - 아래 코드는 틀린 코드임 . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . - input을 a = &#39; Mazatneunde Wae Teullyeoyo&#39; 으로 하게 되면(&#39; &#39;은 빼고) 앞에 띄어쓰기가 있으므로 len(s) - 1 = 3이 출력되야 하는데 4가 출력됨 . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 4 . - 사실 위 코드에 문제가 없는 건 아님 . - 만약 앞 뒤 모두 띄어쓰기가 있다면? . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 4 . - 4가 출력됨?? . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 2 . - 웃긴게 뒤에만 띄어쓰기가 있는 경우에는 올바르게 출력함 . &#45800;&#50612; &#44277;&#48512; . 알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. . | 단, 대문자와 소문자를 구분하지 않는다. . | . - 처음에는 for문을 2개 사용해서 같은 원소가 몇 개인지 알아낼려고 했다 . - 그런데 문자열길이가 백만이라 for문을 2번 돌면 2초안에 통과를 못할 것 같았다 . - 그래서 for문을 2개 쓰는 대신 다른 방법을 생각했다 . - 문자열을 대문자로 바꾸고 A~Z까지 원소를 삭제한 후 문자열 길이를 비교해 몇 개가 있는지 파악하기로 했다. . - 나중에 찾아보니 count 함수를 쓰면 더 쉽게 할 수 있다. . alphabet = str(input()) alp = alphabet.upper() alpha_list = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;] lenghts = len(alphabet) max_alpha = [] for i in alpha_list: if i in alp: a_len = len(alp.replace(i, &#39;&#39;)) if a_len &lt; lenghts: lenghts = a_len del max_alpha[:] max_alpha.append(i) elif a_len == lenghts: max_alpha.append(i) if len(max_alpha) &gt; 1: print(&#39;?&#39;) else: print(max_alpha[0]) . ? . &#50500;&#49828;&#53412; &#53076;&#46300; . 알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하는 프로그램을 작성하시오. | . input_ = str(input()) print(ord(input_)) . 48 . &#50508;&#54028;&#48307; &#52286;&#44592; . 알파벳 소문자로만 이루어진 단어 S가 주어진다. . | 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오. . | . S = str(input()) for i in &#39;abcdefghijklmnopqrstuvwxyz&#39;: find_ = S.find(i) print(find_, end = &quot; &quot;) . 1 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 . &#47928;&#51088;&#50676; &#48152;&#48373; . 문자열 S를 입력받은 후에, 각 문자를 R번 반복해 새 문자열 P를 만든 후 출력하는 프로그램을 작성하시오. | . T = int(input()) for i in range(T): R, S = map(str, input().split()) R = int(R) string = &#39;&#39; print(&#39;&#39;.join([string + (S[j] * R) for j in range(len(S))])) . /////HHHHHTTTTTPPPPP . &#49345;&#49688; . 상근이의 동생 상수는 수학을 정말 못한다. 상수는 숫자를 읽는데 문제가 있다. . | 이렇게 수학을 못하는 상수를 위해서 상근이는 수의 크기를 비교하는 문제를 내주었다. . | 상근이는 세 자리 수 두 개를 칠판에 써주었다. 그 다음에 크기가 큰 수를 말해보라고 했다. . | 상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. . | 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다. 두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오. . | . a, b = map(str, input().split()) rev_a = int(a[2] + a[1] + a[0]) rev_b = int(b[2] + b[1] + b[0]) if rev_a &gt; rev_b: print(rev_a) else: print(rev_b) . 437 . &#53356;&#47196;&#50500;&#54000;&#50500; &#50508;&#54028;&#48307; . 문제 출처: 백준 2941번 | . - 아니 디버깅하고 있었다가 예제 모두 맞춰서 이제 됐나? 싶어서 제출 했더니 정답임.. 근데 왜 맞지?? . - 왜 정답인지 생각해 봤음 . - 내 코드를 보면 ddz=z= 가 입력되면 dz=: 1개, z=: 2개임 . - z= 원래 1개여야 맞지만 dz=에 있는 z=을 z=에 포함시켜 2개임 . - 그래서 total_num이 원래보다 +1이 됐음 . - 정상 출력은 total_num + len(S) - 2 * total_num임 . - 2를 곱한 이유는 알파벳 1개당 길이가 2여서임(&#39;dz=&#39;제외) . - 근데 사실 출력이 잘못됨. 왜냐하면 &#39;dz=&#39;의 길이는 3이기 때문 --&gt; 출력값이 &#39;dz=&#39; 하나당 1씩 부족함 . - 그런데 &#39;dz=&#39; 에 &#39;z=&#39;이 포함돼서 +1이 되어 -1과 +1이 서로 상쇄됨 . - 그래서 정답을 출력함, 노리고 한 건 아니지만 어부지리로 맞춘셈 . S = str(input()) s_len = len(S) total_num = (s_len - len(S.replace(&#39;dz=&#39;,&#39;&#39;))) // 3 for i in [&#39;c=&#39;, &#39;c-&#39;, &#39;d-&#39;, &#39;lj&#39;, &#39;nj&#39;, &#39;s=&#39;, &#39;z=&#39;]: total_num += (s_len - len(S.replace(i, &#39;&#39;))) // 2 print(len(S) - total_num) . 3 . - 아래는 다른 사람이 작성한 코드를 보고 영감을 받아 작성한 코드임 . - 위에서 문제점은 dz=에 z=이 포함된것이다 . - 만약 &#39;dz=&#39;을 없앤다면 괜찮을까? --&gt; 그렇지 않음 . - 만약 ddz=z=이면 &#39;dz=&#39;을 없애도 &#39;dz=&#39;이 남게 된다 . - 만약 &#39;dz=&#39;을 없애는 대신에 다른 문자로 바꾼다면? 예컨데 알파벳이 아닌 다른 문자 . - &#39;dz=&#39;을 * 로 바꾼다면 ddz=z= --&gt; d*z=이 되어 제대로 개수를 셀 수 있음 . - 또 다른 장점은 이제 더 이상 알파벳의 개수를 셀 때 //2 or //3 을 하지 않아도 됨 . - 왜냐하면 크로아티아 알파벳을 한 자리 문자로 바꿨기 때문임 . - 모두 길이가 1이므로 바꾼 후에 최종 문자열의 길이를 출력하면 됨 . S = input() for i in [&#39;c=&#39;, &#39;c-&#39;, &#39;dz=&#39;, &#39;d-&#39;, &#39;lj&#39;, &#39;nj&#39;, &#39;s=&#39;, &#39;z=&#39;]: S = S.replace(i, &#39;*&#39;) print(len(S)) . 3 . &#44536;&#45824;&#47196; &#52636;&#47141;&#54616;&#44592; . 문제 출처: 백준 11718번 | . while 1: try: print(input()) except: break . Hello world! . &#44536;&#45824;&#47196; &#52636;&#47141;&#54616;&#44592;2 . 문제 출처: 백준 11719번 | . - 그대로 출력하기 문제와 동일한 코드로 해결됨 . while True: try: print(input()) except: break . Hello world! . UCPC&#45716; &#47924;&#50631;&#51032; &#50557;&#51088;&#51068;&#44620;? . 문제 출처: 백준 15904번 | . words = input() cnt = 0 for i in range(len(words)): if cnt == 0 and words[i] == &#39;U&#39;: cnt += 1 elif cnt == 1 and words[i] == &#39;C&#39;: cnt += 1 elif cnt == 2 and words[i] == &#39;P&#39;: cnt += 1 elif cnt == 3 and words[i] == &#39;C&#39;: cnt += 1 if cnt == 4: print(&#39;I love UCPC&#39;) else: print(&#39;I hate UCPC&#39;) . I love UCPC . . &#48652;&#47336;&#53944; &#54252;&#49828;(brute force) . - 완전탐색 알고리즘으로 가능한 모든 경우의 수를 탐색한다. --&gt; 100%확률로 정답 출력 . &#48660;&#47001;&#51117; . 기존 룰: 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. . | 변형 룰: N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오. . | . N, M = map(int,input().split()) card = list(map(int,input().split())) def blackjack(card,length,Max): card_list=[] for i in range(N): for j in range(N): for k in range(N): if i != j and j != k and i != k: if card[i]+card[j]+card[k] &lt;= Max: card_list.append(card[i]+card[j]+card[k]) print(max(card_list)) blackjack(card,N,M) ## 아쉬운점: for문3번사용 --&gt; O(n^3) . 21 . &#48516;&#54644;&#54633; . 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. . | 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. . | 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. . | 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. . | 반대로, 생성자가 여러 개인 자연수도 있을 수 있다. . | 자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오. . | . N = int(input()) def solve(x): list=[] for i in range(1, x+1): generator = i + sum([int(str(i)[j]) for j in range(len(str(i)))]) if generator == x: list.append(i) if len(list) &gt; 0: return(min(list)) else: return 0 print(solve(N)) . 198 . &#51076;&#51032;&#51032; &#49707;&#51088;&#51032; (&#44033; &#51088;&#47551;&#49688; + &#51088;&#44592; &#51088;&#49888;) . x=12345 sum([int(str(x)[i]) for i in range(len(str(x)))])+x ### 리스트 컴프리헨션 . 12360 . &#48152;&#50732;&#47548; &#50724;&#52264;(&#48177;&#51456; &#47928;&#51228; &#50500;&#45784; + &#47924;&#51312;&#44148; &#51069;&#51004;&#49464;&#50836;) . - 문제를 풀다보면 나누기 연산을 할 때가 있다 . - 만약 나누기연산과 몫 연산의 결과가 같다면 무조건 몫 연산자를 쓰자 &gt; 10 / 5 = 10 // 5 . - 왜???? . - 0.1 + 0.2 = 0.3 일까? &gt; no . - ???? 정말로? . 0.1 + 0.2 . 0.30000000000000004 . - 정말로 0.1 + 0.2 = 0.3이 아님 . 0.1 + 0.2 == 0.3 . False . - 하나 더: 1.2 * 3 = 3.6 일까? &gt; no . 1.2 * 3 . 3.5999999999999996 . 1.2 * 3 == 3.6 . False . - 밑에 문제인 IQ Test도 틀린 이유가 몫 연산자를 쓰지 않고 나누기 연산자를 사용한 것이다 . - 위에서 확인한 봐와 같이 반올림 오차 때문에 float형은 불안정하므로 몫 연산자를 사용하는 것이 무조건 안전하다 . IQ Test(&#48145;&#50640; &#49345;&#54889; &#46412;&#47928;&#50640; &#48152;&#47168; &#52286;&#50500; &#48420;&#51020;) + &#47582;&#45716; &#44163; &#44057;&#51008;&#45936; &#44228;&#49549; &#53952;&#47548;..., &#44536;&#47000;&#49436; &#45796;&#47480; &#49324;&#46988; &#53076;&#46300; &#48420;&#45716;&#45936; &#50780; &#53952;&#47160;&#45716;&#51648; &#47784;&#47476;&#44192;&#51020; + &#50508;&#50500;&#45256;&#45796; . IQ Test의 문제 중에는 공통된 패턴을 찾는 문제가 있다. 수열이 주어졌을 때 다음 수를 찾는 문제이다. . | 예를 들어 1, 2, 3, 4, 5가 주어졌다. 다음 수는 무엇인가? 당연히 답은 6이다. . | 약간 더 어려운 문제를 보면 3, 6, 12, 24, 48이 주어졌을 때 다음 수는 무엇인가? 역시 답은 96이다. . | 이제 제일 어려운 문제를 보자. . | 1, 4, 13, 40이 주어졌을 때 다음 수는 무엇일까? 답은 121이다. . | 그 이유는 항상 다음 수는 앞 수 * 3 + 1이기 때문이다. . | 은진이는 위의 3문제를 모두 풀지 못했으므로 자동으로 풀어주는 프로그램을 작성하기로 했다. . | 항상 모든 답은 구하는 규칙은 앞 수 * a + b이다. 그리고 a와 b는 정수이다. . | 수 N개가 주어졌을 때 규칙에 맞는 다음 수를 구하는 프로그램을 작성하시오. . | . - N은 2여도 1, 1 과 같이 답이 있을 수 있다. . - 일반적으로 N = 2이면 다음 수는 여러개이다, . - $1, 2$ --&gt; 다음 수 $3(a=0, b=1)$ or $-8(a=-10, b=12)$ 등등 . - a, b 둘다 0일 수 도 있음 . - 스파게티 코드 + 틀렸습니다 . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule(x): if len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif len(x) == 2 and x[0] == x[1]: return x[0] if len(x) == 1: return &#39;A&#39; if x[0] == x[1] == x[2] : a = 0 elif x[1] == x[0] and x[1] != x[2]: return &#39;B&#39; else: a = (x[2] - x[1]) / (x[1] - x[0]) b = x[1] - a * x[0] for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; elif x[i+1] == 0: ## 이 부분이 문제였다. x[i+1] == 0이면 그 뒤는 확인 안하고 return 0 실행 return 0 return int(a * x[-1] + b) print(sequence_rule(N_list)) . - 위에 있는 코드를 정리하자 . - 틀렸습니다 . - exit(0) --&gt; python 프로그램 종료 . - exit(0)써서 코드 짤려했는데 복잡하고 틀렸다고 처리돼서 다른 방법을 찾아 떠났음 . - 이 파일을 둘러보다가 예전에 왜 틀렸는지 모르겠던 기억에 맞은 사람 코드랑 비교해봄 . - 내 코드: a = (x[1] - x[2]) / (x[0] - x[1]) . - 맞은 사람 코드: a = (x[1] - x[2]) // (x[0] - x[1]) . - 나누기 연산자 대신에 몫 연산자를 사용했음 &gt; 뭔 차이인데? . - 10/5 = 2.0이지만 10//5 = 2 &gt; 그래서 왜?? &gt; 출력을 보면 소수점이 없어야 함 &gt; 하지만 나는 소수점이 있으므로 틀림 . - 근데 그 이유가 아니었다 &gt; return (int(a * x[-1] + b)) 이므로 int형이다 &gt; 소수점 없다는 의미 &gt; 그럼 왜 나누기 연산자 쓰면 틀리고 몫 연산자 쓰면 맞음?? &gt; 그러게? . - 아마 float형이 불안정해서 그럴 것이다 &gt; 그래서 안전하게 나누기 대신 몫 연산자를 쓰는 것이 좋음 &gt; 결과가 같을때 만: 10 / 5 = 10 // 5 . - 밑에 있는 코드는 17%부근에서 틀렸습니다로 처리됨 + 내 제출들을 보면 런타임에러(NameError)가 많이 있음 &gt; 이유: if len(x) == 1: 에서 return할 때 &#39;A&#39;가 아닌 A라고 했음 . - &#39;A&#39;라고 해도 17%부근에서 틀렸음 . - 하지만 나누기 연산자 대신에 몫 연산자를 쓰고 정답처리 됐음 . 틀린 코드 | . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule2(x): if len(x) == 1: return &#39;A&#39; elif len(x) == 2 and x[0] == x[1]: return x[1] elif len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 else: a = (x[1] - x[2]) / (x[0] - x[1]) b = x[1] - a * x[0] for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; return int(a * x[-1] + b) print(sequence_rule2(N_list)) . 13 . 맞은 코드 | . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule2(x): if len(x) == 1: return &#39;A&#39; elif len(x) == 2 and x[0] == x[1]: return x[1] elif len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 else: a = (x[2] - x[1]) // (x[1] - x[0]) b = x[1] - a * x[0] for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; return int(a * x[-1] + b) print(sequence_rule2(N_list)) . 13 . - continue --&gt; 아래 코드를 실행하지 않고 건너뜀 . for i in range(10): # 0부터 99까지 증가하면서 100번 반복 if i % 2 == 0: # i를 2로 나누었을 때 나머지가 0면 짝수 continue # 아래 코드를 실행하지 않고 건너뜀 print(i) . 1 3 5 7 9 . - 맞았습니다(3시간 걸림 힘들다) . - 위에 있는 틀린 코드와 밑의 코드는 무슨 차이일까... &gt; 나누기 연산자와 몫 연산자의 차이 . N = int(input()) x = list(map(int, input().split())) if N == 1: print(&#39;A&#39;) elif N == 2: if x[0] == x[1]: print(x[0]) else: print(&#39;A&#39;) else: if x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 b = x[1] else: a = (x[2] - x[1]) // (x[1] - x[0]) b = x[1] - x[0] * a result = True for i in range(N - 1): if x[i] * a + b == x[i+1]: continue else: result = False if result: print(a * x[-1] + b) else: print(&#39;B&#39;) . 121 . &#50689;&#54868;&#44048;&#46021; &#49676; . 종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. . | 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다. . | 숌이 만든 ($N leq10000$)번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. . | . - $N leq 10000$ --&gt; 계산 결과 영화제목은 최대 7자리 . - 7자리 수까지 666을 포함하는 수를 모두 생성한 후 오름차순으로 정렬 . - 문제점: 666xxx 같은 수를 표현한다고 치자 --&gt; 이때 xxx = 010이라면 자연수가 아니므로 010을 수로 표현할 수 없음 . - 666xxx --&gt; 66600x + 6660xx . - 하지만 좋은 방법이 떠오름 . - 666xxx --&gt; 66yxxx , y = 6이므로 yxxx =&gt; range(6000,7000) . - 위와 같이 표현하면 666010도 표현 가능! . import math result = [666] result.extend([int(str(i) + &#39;666&#39;) for i in range(1, 3000)]) ## x666, xy666, xyy666, 1yyy666, 2yyy666 --&gt; 앞으로 나오는 x는 자연수, y는 0포함 result.extend([int(&#39;66&#39; + str(i)) for i in range(6000,7000)]) ## 666yyy result.extend([int(&#39;66&#39; + str(i)) for i in range(600, 700)]) ## 666yy result.extend([int(&#39;666&#39; + str(i)) for i in range(10)]) ## 666y result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 30) for j in range(600, 700)]) ## x666yy, 1y666yy, 2y666yy result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 100) for j in range(60, 70)]) ## x666y, xy666y result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 3) for j in range(6000, 7000)]) ## 1666yyy, 2666yyy result.extend([int(str(i) + &#39;666&#39; + str(j)) for i in range(100, 300) for j in range(10)]) ## 1yy666y, 2yy666y result.extend([int(str(i) + &#39;666&#39;) for i in range(1000, 3000)]) ## 1yyy666, 2yyy666 result = list(set(result)) result.sort() N = int(input()) print(result[N-1]) . 1666 . - 다른 사람 아이디어 보고 만든 코드 --&gt; 내 코드보다 코드 길이가 10배 짧아서 10배 좋다고 생각할라 했는데 시간이 너무 오래 걸리네? --&gt; 내 실수인 걸로 할라 했는데 숏코딩 보니까 다른 사람도 시간이 오래 걸렸다. . - 종말의 수는 $10000$개가 최대이므로 아무거 커도 $3000000$ 이하이다. . - $3000000$까지의 숫자 중 $666$을 포함하면 새로운 리스트에 포함한다. . result = [] result.extend([int(str(i)) for i in range(666,3000000) if str(i).find(&#39;666&#39;) != -1]) N = int(input()) print(result[N-1]) . 1666 . - 숏코딩으로 만들었음(가독성 쓰레기) . print([i for i in range(9**7)if&#39;666&#39;in str(i)][int(input())-1]) . 1666 . &#52404;&#49828;&#54032; &#45796;&#49884; &#52832;&#54616;&#44592; . $8 times8$ 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠한다. | 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오. | . - 밑에 있는 코드 왜 틀림??????????????? . - W로 채워진 8$ times$8 체스판을 input 하면 답이 32가 나와야 하는데 chess1, chess2 = 24, 25가 나온다.(원인 불명) . - 아 왜 틀렸냐고... 안해 다른 거 할 거야 . N, M = map(int, input().split()) data = [] for i in range(N): data.append(list(input())) def chess(n, m): x, y = 0, 7 chess_list = [] while x &lt; n - 7 and y &lt; n: a, b = 0, 7 while a &lt; m - 7 and b &lt; m: chess1, chess2 = 0, 0 for i in range(x, y): for j in range(a, b): if (a + x) % 2 ==0: if (i + j) % 2 == 0: if data[i][j] == &#39;B&#39;: chess1 += 1 else: chess2 += 1 if (i + j) % 2 == 1: if data[i][j] == &#39;B&#39;: chess2 += 1 else: chess1 += 1 else: if (i + j) % 2 == 0: if data[i][j] == &#39;B&#39;: chess2 += 1 else: chess1 += 1 if (i + j) % 2 == 1: if data[i][j] == &#39;B&#39;: chess1 += 1 else: chess2 += 1 chess_list.extend([chess1, chess2]) a += 1 b += 1 x += 1 y += 1 print(chess_list) chess(N, M) . - input . 8, 8 . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . - output . [24, 25] . &#45929;&#52824;(7568&#48264;) . N = int(input()) body = [] for i in range(N): body.append(list(map(int,input().split()))) for i in range(N): rank = 1 for j in range(N): if body[i][0] &lt; body[j][0] and body[i][1] &lt; body[j][1]: rank += 1 print(rank, end = &quot; &quot;) . 2 2 1 2 5 . a=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;] x=&#39; &#39;.join(a) a=1,2,3 print(a) . (1, 2, 3) . . &#49548;&#49688; . &#50500;&#54028;&#53944; &#51076;&#45824;(5615&#48264;) --&gt; &#49884;&#44036; &#52488;&#44284; pass . 아파트 면적은 $2xy+x+y = k$ --&gt; 2k+1 = (2x+1)(2y+1) , $x,y$는 양의 정수 . | 즉, 아파트 면적을 k라 할 때 2k+1은 합성수이다. . | 만약, $2k+1$이 소수라면 잘못된 아파트 면적이다. . | . &#49548;&#49688; &#54032;&#48324; . def Is_prime_number(a): from math import sqrt for i in range(2,int(sqrt(a)+1)): if a%i==0: return True else: return False . from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return False else: return True def apart(n): sum = 0 for i in range(n): x = int(input()) if Is_prime_number(2*x+1) == True: sum +=1 return(sum) N = int(input()) apart(N) . - error: 이렇게 코드를 짜면 N에 어떤 수를 대입해도 if Is_prime_number(2*x+1) == True 부분이 항상 참이여서 sum += 1이 실행된다.(원인불명) . from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return 0 else: return 1 def apart(n): sum = 0 for i in range(n): x = int(input()) if Is_prime_number(2*x+1) == 1: sum += 1 return(sum) N = int(input()) apart(N) . - error: 이렇게 코드를 짜면 N에 어떤 수를 대입해도 if Is_prime_number(2*x+1) == True 부분이 항상 참이여서 sum += 1이 실행된다.(마찬가지로 원인불명) . - 아파트 임대 --&gt; 시간 초과 코드 . import sys from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return False return True def apart(n): sum = 0 for i in range(n): x = int(sys.stdin.readline()) if Is_prime_number(2*x+1) == 1: sum += 1 return(sum) N = int(input()) apart(N) . 2 . &#49548;&#49688;&#54032;&#51221; &#51032;&#47928;&#51216; . def is_prime_number(x): # 2부터 x의 제곱근까지의 모든 수를 확인하며 for i in range(2, int(sqrt(x)) + 1): # x가 해당 수로 나누어떨어진다면 if x % i == 0: return False # 소수가 아님 return True # 소수임 . - 위에 코드는 문제가 없다.$ ,$ x에 2나 3을 넣어도 잘 작동함. . def is_prime_number(x): # 2부터 x의 제곱근까지의 모든 수를 확인하며 for i in range(2, int(sqrt(x)) + 1): # x가 해당 수로 나누어떨어진다면 if x % i == 0: return False # 소수가 아님 else: return True # 소수임 . - 위에 코드는 문제가 있다. x에 2나 3을 넣으면 return이 없다. . - 아마 2나 3을 넣으면 range(2,1) 이 돼서 그럴 것이다. . &#54028;&#51060;&#50028; &#53076;&#46300; &#49892;&#54665; &#49884;&#44036; &#52769;&#51221; . import time start = time.time() ## 시작 시간 저장 ## --작업 코드-- print(&quot;time :&quot;, time.time() - start) . &#49548;&#49688; &#52286;&#44592;1 . 주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오. | . N = int(input()) def Is_prime_num(x): if x == 1: return False for i in range(2, int(x**0.5) + 1): if x % i == 0: return False return True prime_num = 0 num_list = list(map(int, input().split())) for i in range(N): if Is_prime_num(num_list[i]) == True: prime_num += 1 print(prime_num) . 3 . &#49548;&#49688; &#52286;&#44592;2 . 자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오. . | 만약 N과 M사이에 소수가 없다면 1을 출력하시오. . | . N = int(input()) M = int(input()) def Is_prime_num(x): if x == 1: return False for i in range(2, int(x**0.5)+1): if x % i == 0: return False return True prime_list = [] for j in range(N, M+1): if Is_prime_num(j) == True: prime_list.append(j) if len(prime_list) == 0: print(-1) else: print(sum(prime_list)) print(min(prime_list)) . 620 61 . &#50640;&#46972;&#53664;&#49828;&#53580;&#45348;&#49828;&#51032; &#52404;&#47484; &#53685;&#54620; &#49548;&#49688; &#52286;&#44592;(&#49548;&#49688; &#52286;&#44592;2 &#45796;&#47480; &#54400;&#51060;) . - N과M은 10000이하의 자연수 이므로 미리 에라토스테네스의 체를 통해 소수를 구해놓자 . N = int(input()) M = int(input()) n = 10000 m = int(n**0.5) prime_list = [False, False] + [True] * (n-1) for i in range(2, m+1): if prime_list[i] == True: for j in range(2*i, n+1, i): prime_list[j] = False prime_num_list = [ x for x in range(N, M+1) if prime_list[x] == True] if len(prime_num_list) == 0: print(-1) else: print(sum(prime_num_list)) print(min(prime_num_list)) . 620 61 . if prime_list[i] == True: . - 위 부분은 아래와 같이 해도 됨 . if prime_list[i]: . prime_list[i] 자체가 True or False임 . &#49548;&#51064;&#49688;&#48516;&#54644; . 정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오. | . import sys n = 3164 m = int(n**0.5) prime_nums = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_nums[i] == True: for j in range(2*i, n+1, i): prime_nums[j] = False N = int(input()) M = int(N**0.5) def factorization_into_primes(x): if x == 1: sys.exit(0) stack = 0 mul = 1 for k in range(2, M+1): if prime_nums[k] == False: continue else: l = x/k while l == int(l): print(k) mul *= k stack += 1 l = l/k if stack == 0: print(x) elif mul != N: print(int(x/mul)) . 7 11 13 . &#49548;&#49688; &#44396;&#54616;&#44592; . M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오. | . n = 1000000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False M, N = map(int, input().split()) prime_num = [x for x in range(M, N+1) if prime_num_list[x] == True] for k in range(len(prime_num)): print(prime_num[k]) . 3 5 7 11 13 . &#48288;&#47476;&#53944;&#46993; &#44277;&#51456; . 베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다. . | 예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23) . | 자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오. . | . n = 123456 * 2 m = int(n**0.5) prime_nums = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_nums[i] == True: for j in range(2*i, n+1, i): prime_nums[j] = False def prime_number(num): print(len([x for x in range(num+1, 2*num+1) if prime_nums[x] == True])) while True: n = int(input()) if n == 0: break prime_number(n) . 1 . 4 . 3 . 21 . 135 . 1033 . 8392 . &#44264;&#46300;&#48148;&#55120;&#51032; &#52628;&#52769; . 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다. . | 2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오. . | 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다. . | . - 신기한점 . n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False prime_num = [x for x in range(2, n+1) if prime_num_list[x] == True] ### 여기까지 동일 last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True].reverse() type(last_prime_num) . - 위의 코드에서 type(last_prime_num)의 결과는 Nonetype임 . ### 동일 부분 생략 last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True] last_prime_num.reverse() type(last_prime_num) . - 위의 코드에서 type(last_prime_num)의 결과는 list임 . - 무슨 차이일까? . n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False prime_num = [x for x in range(2, n+1) if prime_num_list[x] == True] last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True] last_prime_num.reverse() p = len(prime_num) T = int(input()) for i in range(T): N = int(input()) for j in range(N//2, N+1): if j in prime_num and N - j in prime_num: print(N - j, j) break . 5 7 . - 위의 코드는 시간이 매우 오래 걸리는 쓰레기임 . - 새로 만들었음 . - 시간이 $ frac{1}{4}$ 이 됐다: 2344ms --&gt; 556ms . import sys n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i]: for j in range(2*i, n+1, i): prime_num_list[j] = False T = int(input()) for i in range(T): N = int(sys.stdin.readline()) for j in range(N//2, N+1): if prime_num_list[j] and prime_num_list[N - j]: print(N - j, j) break . 5 7 . - 더 줄이고 싶다 . - 시간이 96ms로 단축됨 . - [$ star star star$] 여러번 반복하여 입력을 받는 경우에는 input() 대신 sys.stdin.readline() 사용 [$ star star star$] . . &#44592;&#48376; &#49688;&#54617;1 (&#49884;&#44036; &#52488;&#44284; &#51452;&#51032;) . &#45804;&#54077;&#51060;&#45716; &#50732;&#46972;&#44032;&#44256; &#49910;&#45796;. . 땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다. . | 달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다. . | 달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오. . | . - 달팽이는 올라가고 싶다 --&gt; 시간 초과 코드(while 반복문 사용) . A, B, V = map(int,input().split()) ### 시간 초과 day = 1 h = 0 while 1: h += A if h &gt;= V: break h -= B day += 1 print(day) . 25 . - 달팽이는 올라가고 싶다 --&gt; 시간 초과 해결한 코드(한 줄 수식) . import math A, B, V = map(int,input().split()) ### 시간 초과 해결 print(math.ceil((V-A)/(A-B))+1) . 25 . &#49552;&#51061;&#48516;&#44592;&#51216; . A는 고정 비용, B는 가변 비용, C는 수익, k는 판매량 . | $C*k &gt; A + B*k$ --&gt; $k &gt; frac{A}{C-B}$ . | . A, B, C = map(int, input().split()) if abs(C-B) &lt; 0.5: ### C == B 여부를 판단 print(-1) elif int(A/(C-B)) &lt; 0: print(-1) else: print(int(A/(C-B)) + 1) . -1 . - 위에 코드보다 더 간결한 코드 . - A에 관계없이 B &gt;= C이면 손익분기점이 없다. . A, B, C = map(int, input().split()) if B &gt;= C: ### C == B 여부를 판단 print(-1) else: print(int(A/(C-B)) + 1) . 11 . Fly me to the Alpha Centauri . 시작할 땐 1만큼 도착할 때도 1만큼 이동 . | k만큼 이동한 후에 k-1 or k or k+1 만큼 이동 가능 . | . - 이동 횟수를 최소화할려면? . - $x지점(출발=0) to{1} to{2} to{3} to dots to{n} to{n-1} to dots to{2} to{1} to{y지점}(도착=0)$ . - $이동 ,거리 = sum_{i=1}^{n}{k} + sum_{i=1}^{n-1}{k} = frac{n(n+1)}{2} + frac{(n-1)n}{2} = n^2$ . - $y-x = n^2$ . - $이동 ,횟수 = 화살표의 ,개수 = n+(n-1)=2n-1$ . - 즉 $n^2$의 거리를 이동하기 위한 최소한의 이동 횟수는 $2n-1$이다. . - 바꿔말하면 $2n-1$번의 이동으로 갈 수 있는 최대 거리는 $n^2$이다. . - 위에 방법에 기반하여 정리를 해봤다. . - 위에서는 이동 거리가 $n^2$에 대해서 고려했다. 하지만 이동 거리가 제곱수가 아닐 수 도 있다. . - 예로 이동 거리가 110이면 이동 횟수는 $ sqrt{100} leq sqrt{110} leq sqrt{121}$ 이므로 10 or 11 or 12이다. . - $n^2 = 1+1+2+2+ dots+(n-1)+(n-1)+n$ 이다. . - 100 과 121의 차이는 21 = 10 + 11 --&gt; 100은 이동 횟수 $2n-1=19$, 101$ sim$110 은 $2n=20$, 111$ sim$121은 $2n+1=21$이다. . T = int(input()) for i in range(T): x, y = map(int, input().split()) n = y - x m = int(n**0.5) if n**0.5 == m: print(2*m - 1) elif n - m**2 &lt;= m: print(2*m) else: print(2*m + 1) . 3 . 3 . 4 . &#49444;&#53461; &#48176;&#45804; . 상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. . | 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다. . | 상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. . | 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 된다. . | 하지만 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다. . | 상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오. . | 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다. . | . - 봉지를 최소화 해야 한다. --&gt; 5kg 봉지를 최대한 많이 써야 한다. . - 설탕의 무게를 5로 나눈다. . - 만약 5로 나눠지면 끝이다. 그러지 않다면 5kg 봉지를 하나씩 줄여나가고 나머지를 3kg 봉지로 담는다. . - 5kg 봉지를 하나씩 줄이다가 0이 됐다면 전부 3kg 봉지를 사용한다. . - 그래도 안된다면 정확하게 Nkg을 만드는 것이 불가능하므로 -1을 출력한다. . N = int(input()) def sugar(n): k = n//5 l = n % 5 if l == 0: return k else: n = n - k*5 if n % 3 ==0: return k + 1 else: n = n - (k-1)*5 if n % 3 ==0: return k - 1 + n//3 else: n = n - (k-2)*5 if n % 3 == 0: return k - 2 + n//3 else: n = n -(k-3)*5 if n % 3 ==0: return k - 3 + n//3 else: ...... if n &lt; 0: return -1 . 이런식으로 전개될 것이다. | . N = int(input()) def sugar(n): k = n // 5 l = n % 5 for i in range(k+1): if l == 0: return k break elif l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 201 . - 코드를 둘러보던 중 위의 코드가 비효율적이라 느껴졌다 . - 왜냐하면 for문에서 if l == 0: 은 처음 한 번 해서 False이면 영원히 False이다 --&gt; else: l += 5 때문 . - 하지만 for문 안에 있어서 k+1번 쓸모없는 행위를 반복해야 한다. . - 그래서 아래와 같이 수정했다 . - 그런데 시간이 64ms 에서 72ms가 됐다??? . N = int(input()) def sugar(n): k = n // 5 l = n % 5 if l == 0: return k for i in range(k+1): if l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 201 . print &#50752; return &#51032; &#52264;&#51060;(&#44036;&#45800;&#55176;) . - return 은 종료문이다. 함수에서 return을 만나면 함수가 종료된다. . - 그렇기에 return이 여러개여도 하나만 반환된다. . - 여러 값을 반환하고 싶다면 return a,b,c, $ dots$ . - print()는 그렇지 않다. . - 위에 설탕배달 코드에서 return을 print()로 바꾼다면 항상 -1을 출력하지만 . - return이기 때문에 return k or return k + l//3이 실행되지 않을 때만 return -1이 실행된다. . &#48516;&#49688;&#52286;&#44592; . 이와 같이 나열된 분수들을 1/1 -&gt; 1/2 -&gt; 2/1 -&gt; 3/1 -&gt; 2/2 -&gt; … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자. . | X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오. . | . - 분모 + 분자 = n + 1인 분수가 n개 있다. . - 분모 + 분자가 2인 분수가 1개, 3인 분수가 2개, 4인 분수가 3개, $ dots$, n+1인 분수가 n개 . - 분모 + 분자가 $n+1$인 끝점: $1+2+3+ dots+n-2+n-1+n$ . x = int(input()) n = int((x * 2) ** 0.5) k = n * (n + 1) // 2 a = k - x if a &lt; 0: n += 1 k += n a = k - x if n % 2 == 0: print(str(n-a)+&#39;/&#39;+str(1+a)) else: print(str(1+a)+&#39;/&#39;+str(n-a)) . 4 10 4 15 5/1 . &#49688;&#54617;&#51008; &#48708;&#45824;&#47732;&#44053;&#51032;&#51077;&#45768;&#45796;(19532&#48264;) . - 백준은 내부 라이브러리만 사용 가능, numpy는 외부 라이브러리라 사용 불가능 . import numpy as np a, b, c, d, e, f = map(int, input().split()) array1 = np.array([[a, b], [d, e]]) array2 = np.array([c, f]) x, y = np.linalg.inv(array1) @ array2 print(round(x), round(y)) . - 연립 일차 방정식을 행렬을 통해 풀어 보자 . a, b, c, d, e, f = map(int, input().split()) det = a * e - b * d print(round((e * c - f *b ) / det), round((a * f - c * d) / det)) . -1 2 . &#48512;&#45376;&#54924;&#51109;&#51060; &#46112;&#53580;&#50556; . 아파트에 거주를 하려면 조건이 있는데 . | a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다 . | 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다 . | . - a층의 b호 사람 수 = a층의 b-1호 사람 수 + a-1층의 b호 사람 수 . - 기본적으로 생각하면 0층 b호에는 n명이 살고 a층 1호에는 1명이 a층 2호에는 a+2명이 산다. . - 점화식을 알고 있으므로 재귀 함수를 사용했음 . - 호출을 여러 번 해야해서 좋지 않음 . - 시간 초과에 걸림 . def apart(a, b): if a == 0: return b if b == 1: return 1 return apart(a, b - 1) + apart(a - 1, b) T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart(k, n)) . 37442160 . - 이미 구한 층,호수 사람 수는 기록하는 방법 사용(메모이제이션) . - 똑같이 시간 초과 . List = [[0] * 14 for _ in range(15)] List[0] = [x for x in range(1, 15)] for i in range(len(List)): List[i][0] = 1 for j in range(len(List)): List[j][1] = j + 2 def apart(a, b): if List[a][b - 1] != 0: return List[a][b - 1] return apart(a, b - 1) + apart(a - 1, b) T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart(k, n)) . 37442160 . - 난 위의 코드가 메모이제이션인 것 같았다. . - 근데 처음 짠 코드와 다른 게 없었다. 메모이제이션이 아닌 가 보다. . - 수학으로 풀려면 계차수열을 사용해야 하는데 복잡해 보인다. . - 그래서 이번에는 처음부터 아파트를 채워놓고 시작하는 방법을 사용했다. . - 층과 호수를 입력하면 채워진 아파트에서 그 층과 호수에 사는 사람 수를 출력한다. . - 최대 사람수가 사는 14층 14호를 입력하면 첫 번째와 두 번째 코드는 2초 정도 걸렸는데 이 코드는 바로 출력된다. . - 시간 초과 해결 . apart = [[0] * 14 for _ in range(15)] apart[0] = [x for x in range(1, 15)] x = len(apart) for i in range(x): apart[i][0] = 1 for j in range(x): apart[j][1] = j + 2 for i in range(1, x): for j in range(1, x - 1): apart[i][j] = apart[i][j-1] + apart[i - 1][j] T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart[k][n - 1]) . 37442160 . &#48516;&#49328;&#52376;&#47532; . 문제 출처: 백준 1009번 | . - 이 문제는 $a^b$의 일의 자리 숫자만 알면 풀 수 있음 . - 그런데 $a^b$의 값은 최대 $100^1000000$이므로 이를 계산하기는 불가능함 . - 여기서 중요한 점은 전체 값이 필요한 게 아니라 일의 자리만 필요하다는 것 . - 데이터가 $a^b$꼴로 주어진 점에서 힌트를 얻었는데 어떤 수 $m$의 일의 자리수가 $n$이면 $m^x$의 일의 자리수는 $n^x$의 일의 자리수와 동일함 &gt; 당연한 소리 . - 그리고 $0 leq n leq 9$이고 $n^x$의 일의 자리수는 규칙성을 띈다 . - 예시로 $7^x$꼴의 일의 자리수는 7, 9, 3, 1이 반복된다 . - 이를 이용하여 문제를 해결하자 . T = int(input()) for _ in range(T): a, b = map(int, input().split()) a = a % 10 b = (b % 4) + 4 ## x^0 = 1이므로 x = str(a ** b)[-1] if x == &#39;0&#39;: print(10) else: print(int(x)) . 1 . 7 . 6 . 1 . 9 . 3&#51032; &#48176;&#49688; . 문제 출처: 백준 1769번 | . x = input() cnt = 0 while len(x) &gt; 1: x = str(sum([int(i) for i in x])) cnt += 1 print(cnt) if int(x) % 3 == 0: print(&#39;YES&#39;) else: print(&#39;NO&#39;) ## input ## 1234567 . 3 NO . . &#44592;&#48376; &#49688;&#54617; 2 -- &#44592;&#54616; . &#53552;&#47131;(&#52280;&#44256;&#54644;&#49436; &#54400;&#50632;&#51020;) . 두 원의 중심과 반지름이 각각 주어졌을 때 교점의 개수를 출력하시오 | . - 두 점에서 만나는 경우 . r1 + r2 &gt; d and abs(r1 - r2) &lt; d . - 두 원의 위치관계 참고 : https://mathbang.net/101 . T = int(input()) for i in range(T): x1, y1, r1, x2, y2, r2 = map(int, input().split()) d = ((x1 - x2)**2 + (y1 - y2)**2)**0.5 if d == 0: if r1 == r2: print(-1) else: print(0) elif r1 + r2 &lt; d: print(0) elif r1 + r2 &gt; d and abs(r1 -r2) &lt; d: print(2) elif r1 + r2 == d: print(1) elif abs(r2 - r1) == d: print(1) elif abs(r2 - r1) &gt; d: print(0) . 2 . 1 . 0 . &#53469;&#49884; &#44592;&#54616;&#54617; . 택시 기하학에서 두 점 $T_1(x_1,y_1)$, $T_2(x_2,y_2)$ 사이의 거리는 다음과 같이 구할 수 있다. . | $D(T_1, T_2) = |x_1 - x_2| + |y_1 - y_2|$ . | 첫째 줄에는 유클리드 기하학에서 반지름이 R인 원의 넓이를, 둘째 줄에는 택시 기하학에서 반지름이 R인 원의 넓이를 출력한다. . | . - 반지름이 $R$일 때 원은 $|x_1 - x_2| + |y_1 - y_2| = R$의 자취임 . - 이를 그려본면 택시 기하학에서 원은 마름모임을 쉽게 알 수 있음 . - 넓이는 $ frac{2R times 2R}{2} = 2R^2$ . import math R = int(input()) π = math.pi print(π*R**2) print(2*R**2) . 1385.4423602330987 882 . . &#51221;&#47148; . &#49688; &#51221;&#47148;&#54616;&#44592; 1 . N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. | . - 선택 정렬 . N = int(input()) List = [] for i in range(N): num = int(input()) List.append(num) n = len(List) for j in range(n): min_idx = j for k in range(j + 1, n): if List[k] &lt; List[min_idx]: min_idx = k List[j], List[min_idx] = List[min_idx], List[j] print(List[j]) . 1 2 3 4 5 . - 내장 함수 ?.sort() . N = int(input()) List = [] for i in range(N): num = int(input()) List.append(num) List.sort() for j in range(len(List)): print(List[j]) . 1 2 3 4 5 . &#49688; &#51221;&#47148;&#54616;&#44592; 2 . N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. | . - 아래의 병합 정렬 코드는 시간초과임 . - 왜냐하면 리스트의 길이가 매우 긴데 재귀 함수를 사용했기 때문 . - 재귀 함수 호출이 매우 많이 일어나서 시간이 오래 걸림 . - 그래서 재귀 함수 없는 코드로 짜봤는데 시간 초과 --&gt; 그냥 파이썬이 느림 . - pop(0)이 문제였음 --&gt; $O(N)$ . - 그래서 pop()를 안쓰고 코드를 구성 . N = int(input()) unsorted_list = [] for i in range(N): unsorted_list.append(int(input())) def merge_sort(x): if len(x) &lt;= 1: return x mid = len(x) // 2 left = x[:mid] right = x[mid:] left1 = merge_sort(left) right1 = merge_sort(right) return merge(left1, right1) def merge(left, right): sorted_list = [] while left and right: if left[0] &lt; right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) while left: sorted_list.append(left.pop(0)) while right: sorted_list.append(right.pop(0)) return sorted_list sort_list = merge_sort(unsorted_list) for i in range(N): print(sort_list[i]) . - python은 시간 초과여서 pypy3로 제출해서 맞춤 . - 위 코드는 pypy3로 제출해도 시간 초과임 . N = int(input()) unsorted_list = [] for i in range(N): unsorted_list.append(int(input())) def mergeSort(x): ## 나누기 n = len(x) if n &lt;= 1: return x mid = n // 2 left = x[:mid] ## mid를 기준으로 왼쪽 right = x[mid:] ## mid를 기준으로 오른쪽 next_left = mergeSort(left) ## 재귀적으로 나누기 next_right = mergeSort(right) ## 재귀적으로 나누기 return merge(next_left, next_right) def merge(left, right): ## 병합하기 i = 0 j = 0 sorted_list = list() while i &lt; len(left) and j &lt; len(right): ## left와 right중 더 작은 값 넣기 if left[i] &lt; right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 ## left와 right 중 남은 값을 넣어주기 while i &lt; len(left): sorted_list.append(left[i]) i += 1 while j &lt; len(right): sorted_list.append(right[j]) j += 1 return sorted_list sort_list = mergeSort(unsorted_list) for i in range(N): print(sort_list[i]) . 1 2 3 4 5 . &#49688; &#51221;&#47148;&#54616;&#44592; 3 . N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. . | N은 최대 10000000, 10000보다 작거나 같은 자연수 . | 수 정렬하기 2와 다르게 메모리 제한이 있다. . | . - 수 정렬하기 2에서 사용했던 코드는 메모리 제한에 걸림 . - 힌트를 보고 생각했음 . - 그런데 생각해보면 메모리가 8MB 이다 . - N이 최대 10000000이면 short형(2byte, c언어)를 쓰더라도 20000000byte로 20MB이다 --&gt; 메모리 초과 . - 근데 N이 10000000이라고 하면 적어도 어느 자연수 하나는 1000번 이상 등장함(비둘기집 원리) . - 그러면 1~10000까지 번호를 새긴 깡통을 만들어두고 input으로 등장한 숫자와 같은 번호의 깡통에 투표를 하는 매커니즘으로 생각하면 어떨까 . - [0]*10001인 리스트를 만듦. 등장한 숫자가 i라면 list의 i번째 요소의 값을 1씩 증가시킴 . - 최종적으로 리스트의 처음 인덱스부터 끝까지 value만큼 출력한다 . - 10000000크기의 list를 만드는 대신에 10000크기의 list를 만듦 --&gt; 메모리 소비 줄임 . - input() 대신 sys.stdin.readline() 사용, 근데 왜 나는 sys.stdin.readline()가 error가 날까... --&gt; 그래서 사용을 안하는 버릇생김 . - Test는 input()으로 해도 제출은 sys.stdin.readline()로 하는 습관 가지기 . 이 코드는 메모리 초과임 | . - arr[i] = 0이어도 뒤에 for문을 실행한다 . - arr[i] = 0이면 pass 하도록 아래와 같이 코드를 바꿨다 . import sys arr = [0] * 10001 N = int(input()) for i in range(N): arr[int(sys.stdin.readline())] += 1 for i in range(1, 10001): for j in range(arr[i]): print(i) . 1 2 4 5 5 . - 문제를 보니 카운팅 정렬로 해결하는 문제였다 --&gt; 카운팅 정렬 공부해야지 . &#53685;&#44228;&#54617; . 수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자. . | 산술평균 : N개의 수들의 합을 N으로 나눈 값 . | 중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값 . | 최빈값 : N개의 수들 중 가장 많이 나타나는 값 . | 범위 : N개의 수들 중 최댓값과 최솟값의 차이 . | N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오. . | . - 이 코드는 잘못된 코드임. while문에서 빠져나오지 못함 . - 처음에는 while문만 보다가 while문은 이상한점이 없어서 처음부터 다시 봤음 . - 처음에 입력을 받는 부분이 잘못됨. 양수와 음수를 구별하는 if-else코드가 for문안에 들어가야 한다 . - 그렇지 않으면 입력을 받아 저장하는 x가 counting되지 않음 . - 또 문제가 있음 while문에서 k+1을 쓰면 무한loop에 빠지고 4001을 써야함(이유는 자고 일어나서..) . - 이유를 찾았다 . for k in range(neg_nums[i]): val_sum -= i . - for문에 변수로 k를 사용해서 k값이 4000에서 다른값으로 변한 것 --&gt; 변수명 안겹치게 하기 . - 또 문제가 있다 . - 중앙값이 제대로 출력되지 않음. 입력으로 1, 3, 8, -2, 2를 주어졌을 때 중앙값으로 8이 출력됨 . - while문에서 num &lt; mid일 때만 수행하라고 했는데 왜지?? num이 mid보다 커져도 for문이 계속 작동하여 median = 8을 store함 . - 이유를 알고보니까 이런 거임. 내가 일을 시키는 입장인데 내가 주는 업무를 수행하는데 12시간 넘으면 쉬라고 명령함 . - 근데 업무로 일 40시간 하기를 시킴.. . - while문에서는 num &lt; mid이면 탈출하라고 했음. True일 동안 for i in range(4001)을 수행해야 함 . - 근데 시킨 업무가 range(4001)여서 i가 0 부터 4000이 될동안 num도 mid보다 커지지만 일단 시킨 업무가 for i in range(4001)이라 멈출 수 없고 다 끝낸 뒤 num &gt;= min여서 while문 탈출 . - 또 문제가 있음... . - 파이썬 round()를 하면 대부분 잘 작동함 근데 -1.5, -3.5같이 -?.5 (?은 홀수)의 경우에 제대로 값을 반환하지 않음 . - 또 2.5, 4.5 같이 ?.5(?은 짝수)의 경우 제대로 값을 반환하지 않음 . - -1.5를 반올림하면 -1이 맞지만 round(-1.5)는 -2를 return한다. 또 2.5를 반올림하면 2가 맞지만 round(2.5)는 2를 return한다 . - 파이썬에서는 반올림 자리가 5인 경우, 앞자리가 홀수면 올림, 짝수면 버림을 한다. 이를 고려해주어야 한다 . - 진짜 마지막으로 에러가 하나 있었다 . - 범위를 구하는 곳에서 오류가 있었는데 입력으로 0, 0, 0, -1, -2 가 주어지면 2가 출력되야 하지만 1이 출력됐다 . - 왜냐하면 양수로 0이 입력됐지만 max_pos = 0이기 때문 . - 그래서 양수는 입력되지 않았다고 판단하여 -1 - (-2) = 1을 범위로 output함 . N = int(input()) k = 4000 pos_nums = [0] * (k+1) neg_nums = [0] * (k+1) for _ in range(N): x = int(input()) if x &gt;= 0: pos_nums[x] += 1 else: neg_nums[-x] += 1 val_sum = 0 min_pos = 0 max_neg = 0 max_pos = 0 min_neg = 0 for i in range(k+1): if pos_nums[i] != 0: max_pos = i if min_pos == 0: min_pos += i for j in range(pos_nums[i]): val_sum += i for i in range(k+1): if neg_nums[i] != 0: min_neg = -i if max_neg == 0: max_neg -= i for k in range(neg_nums[i]): val_sum -= i mean = val_sum / N num_pos = sum(pos_nums) num_neg = sum(neg_nums) mid = (N + 1) // 2 num = 0 if num_pos &gt;= num_neg: mid -= num_neg while num &lt; mid: for i in range(k+1): if pos_nums[i] != 0: for j in range(pos_nums[i]): num += 1 median = i else: mid -= num_pos while num &lt; mid: for i in range(k+1): if neg_nums[i] != 0: for j in range(neg_nums[i]): num += 1 median = -i range_ = 0 if max_pos != 0 and min_neg != 0: range_ = max_pos - min_neg elif max_pos == 0: range_ = max_neg - min_neg elif min_neg == 0: range_ = max_pos - min_pos mode = [] freq = max(pos_nums + neg_nums) for i in range(k+1): if pos_nums[i] == freq: mode.append(i) if neg_nums[i] == freq: mode.append(-i) if mode: mode.remove(min(mode)) mode_ = min(mode) else: mode_ = min(mode) print(mean) print(median) print(mode) print(range_) . - 위에서 잘못된 부분을 디버깅한 코드 . - 디버깅은 print()를 사용했는데 나중에 이에 대해 다뤄보자 . - 시간 초과 --&gt; input() 말고 sys.stdin.readline()써야함 . - 입력구문을 바꾸니 맞았다 . - 디버깅하느라 힘들었음 . N = int(input()) k = 4000 pos_nums = [0] * (k+1) neg_nums = [0] * (k+1) for _ in range(N): x = int(input()) if x &gt;= 0: pos_nums[x] += 1 else: neg_nums[-x] += 1 val_sum = 0 min_pos = [] max_neg = 0 max_pos = 0 min_neg = 0 for i in range(k+1): if pos_nums[i] != 0: max_pos = i if len(min_pos) &lt; 1: min_pos.append(i) for j in range(pos_nums[i]): val_sum += i for i in range(1, k+1): if neg_nums[i] != 0: min_neg = -i if max_neg == 0: max_neg -= i for m in range(neg_nums[i]): val_sum -= i ## 산술평균 def round2(number): if number &gt;= 0: if number - int(number) &gt;= 0.5: a = 1 else: a = 0 return int(number) + a else: if int(number) - number &gt; 0.5: a = -1 else: a = 0 return int(number) + a mean = round2(val_sum / N) ## 중앙값 num_pos = sum(pos_nums) num_neg = sum(neg_nums) mid = (N + 1) // 2 num = 0 if num_pos &gt;= num_neg: mid -= num_neg for i in range(k+1): if pos_nums[i] != 0: for j in range(pos_nums[i]): num += 1 median = i if num &gt;= mid: break else: mid -= num_pos for i in range(k+1): if neg_nums[i] != 0: for j in range(neg_nums[i]): num += 1 median = -i if num &gt;= mid: break ## 범위 range_ = 0 if min_pos and min_neg != 0: range_ = max_pos - min_neg elif len(min_pos) &lt; 1: range_ = max_neg - min_neg elif min_neg == 0: range_ = max_pos - min_pos[0] ## 최빈값 mode = [] freq = max(pos_nums + neg_nums) for i in range(4001): if pos_nums[i] == freq: mode.append(i) if neg_nums[i] == freq: mode.append(-i) if len(mode) &gt; 1: mode.remove(min(mode)) mode_ = min(mode) else: mode_ = min(mode) print(mean) print(median) print(mode_) print(range_) . 2 2 1 10 . &#45208;&#51060;&#49692; &#51221;&#47148; . 문제 출처: 백준 10814번 | . N = int(input()) data = [] for i in range(N): member = list(input().split()) + [i] member[0] = int(member[0]) data.append(member) data.sort(key = lambda x: (x[0], x[2])) for j in range(N): print(data[j][0], data[j][1]) . 20 Sunyoung 21 Junkyu 21 Dohyun . . &#44536;&#47532;&#46356; &#50508;&#44256;&#47532;&#51608; . &#46041;&#51204; 0 . 준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다. . | 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. . | 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오. . | 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수) . | . N , K = map(int, input().split()) coins = [] for i in range(N): coins.append(int(input())) num = [K] for j in range(N - 1): val = coins[j+1] / coins[j] replace = num[j] // val num[j] -= replace * val num.append(replace) print(int(sum(num))) . 12 . &#51075;&#50612;&#48260;&#47536; &#44292;&#54840; . 세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들고 난 후 괄호를 모두 지웠다. . | 그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다. . | . - 한번만 minus 기호가 나오면 그 뒤에 수는 모두 빼기로 만들 수 있음 . - 50 - 70 + 80 + 90 --&gt; 50 - (70 + 80 + 90) . - join(), split(), replace(), map() 함수 사용 . string = str(input()) s1 = string.split(&#39;-&#39;) s2 = s1[0] s2 = s2.split(&#39;+&#39;) s2 = list(map(int, s2)) s3 = s1[1:] if len(s3) &gt; 0: s3 = &#39;-&#39;.join(s3) s3 = s3.replace(&#39;-&#39;, &#39;+&#39;) s3 = s3.split(&#39;+&#39;) s3 = list(map(int, s3)) print(sum(s2) - sum(s3)) else: print(sum(s2)) . 0 . ATM . 문제 출처: 백준 11399번 . | 인하은행에는 ATM이 1대밖에 없다. . | 줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 $P_i$가 주어졌다. . | 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오. . | . - times를 sort()함수를 통해 오름차순으로 정렬 . - 최소값 $=$ 첫 번째 원소 $ times$ N $+$ 두 번째 원소 $ times$ (N-1) $+ dots +$ 마지막 원소 $ times$ 1 . N = int(input()) times = list(map(int, input().split())) times.sort() print(sum([times[i] * (N - i) for i in range(N)])) . 32 . &#51452;&#50976;&#49548; . 설명이 길어서 링크를 남긴다. . | 문제 출처: 백준 13305번](https://www.acmicpc.net/problem/13305 . | . - 현재 주유소 가격보다 더 싼 주유소가 있는 곳 까지의 거리만큼만 구매하여 더 싼 주유소까지 감 . - 정확히는 현재 주유소 가격보다 더 싼 주유소 중 가장 거리가 가까운 주유소 . - 더 싼 주유소 까지 갔으면 그 주유소보다 더 싼 주유소가 있는 곳 까지의 거리만큼만 구매하여 더 싼 주유소까지 감 . - 만약 더 싼 곳이 없으면 목표지점까지 남은 거리 만큼 기름을 구매 . - 이를 도착할 때 까지 반복함 . - 백준 문제 예시를 보자 . 기름 가격이 현재 5원 보다 더 싼 곳은 2원이므로 5원에서 2원까지 거리인 2km를 갈 수 있을 정도만 기름을 구매함(2L 구매) . | 현재 2원 보다 더 싼 곳은 1원이므로 2원에서 1원까지 거리인 4km를 갈 수 있을 정도만 기름을 구매함(4L 구매) . | 목표 지점에 도착했으므로 끝 . | N = int(input()) lengths = list(map(int, input().split())) oils = list(map(int, input().split())) idx = 0 costs = 0 for i in range(1, len(oils)): if oils[i] &lt;= oils[idx]: costs += oils[idx] * lengths[i - 1] idx = i else: costs += oils[idx] * lengths[i - 1] print(costs) . 10 . - 아래는 더 간결한 코드(중복 부분 제거) . N = int(input()) lengths = list(map(int, input().split())) oils = list(map(int, input().split())) idx = 0 costs = 0 for i in range(1, len(oils)): costs += oils[idx] * lengths[i - 1] if oils[i] &lt;= oils[idx]: idx = i print(costs) . 10 . &#51452;&#50976;&#49548; &#47928;&#51228; &#46356;&#48260;&#44613; . - 아래는 잘못된 코드임 . N = int(input()) lengths = list(map(int, input().split())) oils = list(map(int, input().split())) idx = 0 costs = 0 for i in range(1, len(oils)): if oils[i] &lt;= oils[idx]: costs += oils[idx] * lengths[idx] idx = i else: costs += oils[idx] * lengths[i - 1] print(costs) . - 아래 코드가 잘못됨 . costs += oils[idx] * lengths[idx] . - 아래 코드로 수정해야함 . lengths[idx] --&gt; lengths[i - 1] . - 디버깅 하면서 느낀점 : 다양한 상황을 고려하고 [$ star$]종이에 쓰면서[$ star$] 어떻게 흘러가는지 분석하자 . &#54924;&#51032;&#49892; &#48176;&#51221; . 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. . | 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. . | 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. . | 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다. . | . - 가장 빨리 끝나는 회의를 배정하는 것이 best임, 시작 시간과 종료 시간이 같은 것이 있을 수 있으므로 종료 시간이 같다면 먼저 시작하는 것을 앞에 배정함 . - 그 회의를 마치고 다음 회의를 고를 때 마찬가지로 가장 빨리 끝나는 회의를 배정함 . - 이를 반복하면 된다 . - [1, 1]과 [0, 1]이 있다면 [0, 1]을 배정하고 [1, 1]을 해야한다. 순서를 바꾸면 1개가 최대임 . - 처음에는 종료 시간만 고려해서 틀림 --&gt; 디버깅을 합시다 . - 그래서 생각한 것이 &quot;아!, 시작 시간과 종료 시간 간격이 짧은 것이 더 좋겠지([5, 8]보단 [6, 8]더 좋을 거야)&quot;라고 했음 . - 그래서 종료 시간 기준으로 오름차순 정렬한 후 시작 시간 기준으로 내림차순 정렬을 했다. 하지만 위에서 다룬 [1, 1]과 [0, 1]의 상황에 의해 틀림 . - 종료 시간기준으로 오름차순 정렬한 후 이를 시작 시간 기준으로 오름차순 정렬해야 함 --&gt; 맞았습니다 . meeting_time = [] N = int(input()) for i in range(N): meeting_time.append(list(map(int, input().split()))) meeting_num = 1 meeting_time.sort(key = lambda finish_time: (finish_time[1], finish_time[0])) ## 종료 시간을 기준으로 오름차순 정렬한 것을 시작 시간을 기준으로 오름차순 정렬 fir_meeting = meeting_time[0] for i in range(1, N): if meeting_time[i][0] &gt;= fir_meeting[1]: meeting_num += 1 fir_meeting = meeting_time[i] print(meeting_num) . 4 . A $ to$ B . 문제 출처: 백준 16953번 | . - 미로찾기 할 때 출발지점에서 시작하는 것보다 도착지점에서 시작하는 것이 미로 탈출을 더 쉽게 만듦 . - 이런 느낌으로 접근하자 . - A에서 B를 만드는 것 보다 역으로 B에서 A를 만든다고 생각하는 거임 . - 만약 B가 x자리수인데 x자리 숫자가 1이라면 A에서 B를 만드는 과정에서 A가 x-1자리인 순간이 있었고 그 때 마지막 자리에 1을 추가하는 연산을 했음을 알 수 있음 . - 이런식으로 생각하면 만약 B의 x자리의 숫자가 1이 아닌 홀수다 &gt; A 에서 B를 만드는 것이 불가능 . - 만약 B의 x자리의 숫자가 짝수다 &gt; 일단 B를 2로 나누자 . - 위에서 한 것을 반복하면 됨 . - 그리디 알고리즘으로 풀었는데 BFS로도 풀 수 있다고 함 &gt; 나중에 그래프 탐색 문제도 풀어보자 . A, B = map(int, input().split()) num = 1 while B != A: if str(B)[-1] == &#39;1&#39; and B &gt; A: B = int(str(B)[:-1]) num += 1 elif B % 2 == 1 or B &lt; A: num = -1 break else: B = B // 2 num += 1 print(num) . 5 . &#52852;&#46300; &#54633;&#52404; &#45440;&#51060; . 문제 출처: 백준 15903번 | . - 가장 작은 카드 2장을 뽑아서 더한 값으로 초기화 함 . - 또 다시 전체 카드 중에서 가장 작은 카드 2장을 뽑아서 더한 값으로 초기화 함 . - 위를 반복하면 됨 . - 힙(Heap)자료 구조로 풀 수 있다고 함 &gt; 공부하기 . n, m = map(int, input().split()) cards = list(map(int, input().split())) cards.sort() cnt = 0 while cnt &lt; m: cards[0] = cards[1] = cards[0] + cards[1] cards.sort() cnt += 1 print(sum(cards)) . 16 . . &#51221;&#49688;&#47200; &#48143; &#51312;&#54633;&#47200; . &#51060;&#54637; &#44228;&#49688; 2 . 자연수 N과 정수 K가 주어졌을 때 이항 계수 $ binom{N}{K}$를 10,007로 나눈 나머지를 구하는 프로그램을 작성하시오. | . - $ _{n} rm C_{k} ;= ; _{n-1} rm C_{k-1} ;+ ;_{n-1} rm C_{k}$ . - n명 중 k명을 선택하는 방법 = 일단 나를 k명에 포함하고 나머지 n-1명 중 k-1명을 선택하는 방법 + 나를 k명에서 제외하고 나머지 n-1명 중 k명을 선택하는 방법 . - 메모이제이션 활용 . - 아래 코드는 수를 곱하고 나누고 하는 과정에서 오차가 발생함(이유 알 것 같음) . N, K = map(int, input().split()) if K &gt; N - K: K = N - K def binom(n, k): frac = 1 if k == 0: return frac for i in range(k): frac *= (n - i) frac /= (k - i) return frac print(binom(N, K)) . 270288240945436736896419468186285475891156693372573153808127299354545159392842888344379470775469423606583114895222426893312341135200171386904964166401328583914403638232447354301148995510201690344719626632436541851159067180652764129719441081806265387434048424366211327146525860903129335008845962936320 . - 아래코드는 메모이제이션으로 구현했다 . - 계산해보면 알겠지만 $_{1000} rm C_{500}$은 매우$ times 100$ 큰 수이다. 300자리임 . - 그래서 $_{1000} rm C_{500}$를 계산할 때 위와같이 구하면 곱하고 나누는 과정에서 소수점 오차가 발생하고 이는 결과적으로 밑의 코드와 다른 값을 출력하게 된다 . - 메모이제이션을 안 쓴 코드와 쓴 코드로 구한 $_{1000} rm C_{500}$ 값을 비교하면 다른 것을 알 수 있다 . - 아래 코드는 오류 발생(만약 위의 코드가 오차없이 답을 구한다면 똑같이 오류 발생) --&gt; 재귀 깊이에 관한 오류 . - 백준에서 정한 파이썬 재귀 깊이는 1000이다. 즉, 같은 함수를 1000번 이상 호출하면 오류가 난다 . - 그래서 오류가 나지 않으려면 재귀 깊이를 sys.setrecursionlimit()를 통해 바꾸던가 해야함 . - 오류가 발생한 이유를 알았으니 아래 코드를 다시 수정함 . import sys sys.setrecursionlimit(10**6) N, K = map(int, input().split()) if K &gt; N - K: K = N - K binom_list = [[-1] * 501 for _ in range(1001)] def binom(n, k): if binom_list[n][k] != -1: return binom_list[n][k] elif n &lt; k: return 0 elif k == 0: return 1 elif n == 1: return 1 binom_list[n][k] = binom(n-1, k) + binom(n-1, k-1) return binom_list[n][k] print(binom(N, K)) . 270288240945436569515614693625975275496152008446548287007392875106625428705522193898612483924502370165362606085021546104802209750050679917549894219699518475423665484263751733356162464079737887344364574161119497604571044985756287880514600994219426752366915856603136862602484428109296905863799821216320 . - 사실 재귀함수를 사용하지 않고 첫 번째 코드를 수정하는 것으로도 정답을 맞출 수 있다 . - 문제는 /(나누기) 이다 / 대신 //(몫 구하기)를 사용하면 해결된다 . - /(나누기 연산자)는 큰 값을 계산할 때 오차에 취약하다 . - 그래서 // 를 쓰는 것이 좋다. 물론 /와 // 결과가 같을 때 ex) 10 / 2 = 10 // 2 . - 밑의 코드 결과는 메모이제이션을 사용한 코드와 같은 것을 알 수 있다 . N, K = map(int, input().split()) if K &gt; N - K: K = N - K def binom(n, k): frac = 1 for i in range(k): frac *= (n - i) for i in range(k): frac //= (k - i) return frac print(binom(N, K)) . 270288240945436569515614693625975275496152008446548287007392875106625428705522193898612483924502370165362606085021546104802209750050679917549894219699518475423665484263751733356162464079737887344364574161119497604571044985756287880514600994219426752366915856603136862602484428109296905863799821216320 . &#54057;&#53664;&#47532;&#50620; 0&#51032; &#44060;&#49688; . 문제 출처: 백준 1676번 | . - 끝이 0인 수는 어떤 수를 곱하든지 간에 0으로 끝남 . - 2와 5가 곱해지면 10이 됨 &gt; 10이 한 번 곱해질 때마다 0의 개수가 1개 증가함 . - 2의 개수가 5의 개수보다 훨씬 많으므로 사실상 5의 개수는 0의 개수와 동일함 . - 25와 같이 5가 여러번 곱해진 수를 잘 고려해야 함 . N = int(input()) cnt = 0 for i in range(1, N+1): val = i while val % 5 == 0: if val % 5 == 0: val //= 5 cnt += 1 print(cnt) ## input &gt; 25 . 6 . - 간결한 코드 숏코딩에서 찾음 . - N의 범위는 최대 500으로 이를 넘지않는 5의 거듭제곱수는 $5^3$임 . - 즉 N을 5로 나눈 몫을 통해 5의 배수의 개수를 찾음 . - 25의 배수(&lt;125)는 소인수 5의 개수가 2개이므로 N을 25로 나눔으로써 25의 배수를 찾고 마찬가지로 125로 나눠 125 배수의 개수를 찾음 . - 이를 모두 더하면 소인수 5의 총 개수임 . N = int(input()) print(N//5 + N//25 + N//125) ## input &gt; 6 . 6 . &#51312;&#54633; 0&#51032; &#44060;&#49688; . 문제 출처: 백준 2004번 | . - 팩토리얼 0의 개수를 푼 것과 같이 풀면 된다 . - 2와 5의 개수를 세서 2와 5중 더 적은 숫자만큼 끝자리에 0이 생김 . - 바로 for문 사용하면 N, M의 범위 때문에 시간초과임 . N, M = map(int, input().split()) if N - M &lt; M: M = N - M k = j = i = 1 i2 = j2 = k2 = 1 cnt2 = cnt = 0 ## n C m = n! / (n-m)! / m! while 5**i &lt; 2000000001: ## n!의 소인수 5의 개수를 더해줌 cnt += N // (5**i) i += 1 while 5**j &lt; 1000000001: ## m!의 소인수 5의 개수를 빼줌 cnt -= M // (5**j) j += 1 while 5**k &lt; 2000000001: ## (n-m)!의 소인수 5의 개수를 빼줌 cnt -= (N - M) // (5**k) k += 1 while 2**i2 &lt; 2000000001: ## n!의 소인수 2의 개수를 더해줌 cnt2 += N // (2**i2) i2 += 1 while 2**j2 &lt; 1000000001: ## m!의 소인수 2의 개수를 뺴줌 cnt2 -= M // (2**j2) j2 += 1 while 2**k2 &lt; 2000000001: ## (n-m)!의 소인수 2의 개수를 빼줌 cnt2 -= (N - M) // (2**k2) k2 += 1 print(min(cnt, cnt2)) ## 소인수 2와 5의 개수 중 최소값이 끝자리 0의 개수 ## input ## 25 12 . 2 . . &#46041;&#51201; &#44228;&#54925;&#48277; . &#54588;&#48372;&#45208;&#52824; &#54632;&#49688; . 문제가 길어서 출처를 남김: 백준 피보나치 함수 문제 | . - 직접 0과 1이 몇번 출력되는지 계산해도 된다 . - 근데 규칙을 보면 출력되는 횟수의 합이 피보나치 수열을 따름 . - 그리고 0이 출력되는 횟수가 1이 출력되는 횟수보다 1이 더 작다 (fibo(3) 이상 부터) . - fibo(1) = 5이므로 0은 5 // 2 번 1은 5 - 5 // 2번 출력됨 . T = int(input()) def fibo(n): fir_fibo = 0 sec_fibo = 1 for i in range(n): next_fibo = fir_fibo + sec_fibo fir_fibo = sec_fibo sec_fibo = next_fibo return next_fibo for i in range(T): N = int(input()) if N == 0: print(1, 0) elif N == 1: print(0, 1) elif N &gt; 1: fibo_N = fibo(N) print(fibo_N // 2, fibo_N - (fibo_N // 2)) . - 위의 코드는 틀렸다 . - 계산해보니 0출력 횟수와 1출력 횟수 차이는 1이 아니었음 . - fibo(5)의 경우 0은 3번, 1은 5번 출력함 . - fibo(n)일 떄 0은 fibo(n-1)번 1은 fibo(n)번 출력함 (n &gt; 1) . T = int(input()) def fibo(n): if n &lt;= 1: return n fir_fibo = 0 sec_fibo = 1 for i in range(n-1): next_fibo = fir_fibo + sec_fibo fir_fibo = sec_fibo sec_fibo = next_fibo return next_fibo for i in range(T): N = int(input()) if N == 0: print(1, 0) elif N == 1: print(0, 1) elif N &gt; 1: print(fibo(N-1), fibo(N)) . 1 0 . 0 1 . 1 2 . &#49888;&#45208;&#45716; &#54632;&#49688; &#49892;&#54665; . 문제 출처: 백준 9184번 | . w_dict = {(0,0,0):1} def w(a, b, c): if (a, b, c) in w_dict: return w_dict[(a, b, c)] if a &lt;= 0 or b &lt;= 0 or c &lt;= 0: return 1 elif a &gt; 20 or b &gt; 20 or c &gt; 20: return w(20, 20, 20) elif a &lt; b and b &lt; c: w_dict[(a, b, c)] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c) else: w_dict[(a, b, c)] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1) return w_dict[(a, b, c)] while True: A, B, C = map(int, input().split()) if A == B == C == -1: break print(&#39;w(%s, %s, %s) = %s&#39; % (A, B, C, w(A, B, C))) . w(1, 1, 1) = 2 . w(2, 2, 2) = 4 . w(10, 4, 6) = 523 . w(50, 50, 50) = 1048576 . w(-1, 7, 18) = 1 . &#54028;&#46020;&#48152; &#49688;&#50676; . 문제 출처: 백준 9461번 | . - 점화식: $f(n) = f(n-2)+f(n-3)$ . padoban_sequence_dict = {1:1, 2:1, 3:1} def padoban_sequence(n): if n in padoban_sequence_dict: return padoban_sequence_dict[n] padoban_sequence_dict[n] = padoban_sequence(n-3) + padoban_sequence(n-2) return padoban_sequence_dict[n] T = int(input()) for _ in range(T): N = int(input()) print(padoban_sequence(N)) . 3 . 16 . 01&#53440;&#51068; . 문제 출처: 백준 1904번 | . - 점화식 노가다로 구했음 --&gt; 만약 노가다로 찾을 수 없는 문제를 해결해야 한다면... . - 피보나치 수열의 점화식과 동일함 . - 점화식: $f(n) = f(n-1) + f(n-2)$ . 이 코드는 재귀함수를 사용해 top-down으로 구현함 | . - RecursionError 발생 --&gt; 재귀 깊이 초과 . - 그래서 재귀 깊이를 크게 하려고 했는데 조건을 보니 N이 최대 $10^6$ 이다 . - 그래서 그냥 bottom-up방식으로 코드를 짜기로 함 . - 재귀 깊이를 크게 했더니 --&gt; 시간 초과 . top-down 코드 | . tile_dict = {1:1, 2:2} def tile(n): if n in tile_dict: return tile_dict[n] tile_dict[n] = tile(n-1) + tile(n-2) return tile_dict[n] N = int(input()) print((tile(N) % 15746)) . 5 . bottom-up 코드 | . - 메모리 초과 --&gt; 왜? 이유 모름 . N = int(input()) x = 10**6 tile_list = [1, 1, 2] + [0]*(x-2) for i in range(3, N+1): tile_list[i] = tile_list[i-1] + tile_list[i-2] print((tile_list[N] % 15746)) . 5 . - 그래서 다른 방법으로 코드 구현했음 . - 시간 초과(0.75초) --&gt; 왜? . N = int(input()) if N &lt;= 2: print(N) else: fir = 1 sec = 2 for i in range(N-2): next_ = fir + sec fir = sec sec = next_ print(next_ % 15746) . 5 . - 참고: https://m.blog.naver.com/hankrah/221863365092 . - map()함수 사용 . - 메모리 초과 --&gt; append() 때문인 듯 . N = int(input()) def fibonacci(n): fibo = [1, 2] [*map(lambda _: fibo.append(sum(fibo[-2:])), range(2, n))] ## tuple unpacking return fibo[n-1] print(fibonacci(N) % 15746) . 5 . - 아래 코드는 정답임 . - 일단 재귀 함수로 구현한 top-down방식은 시간이 오래걸린다 . - 그러므로 bottom-up 방식을 사용했다 . - 근데 메모리초과가 발생했다 --&gt; 이유가 뭐지?? . - 처음엔 몰랐는데 생각해보니 나는 숫자를 다 계산한 다음에 15746으로 나눈 나머지를 구했다 . - N = 1000000 이라면 백만번째 피보나치 항의 값을 구하는 것인데 수가 얼마나 크나면 겁나 큼 --&gt; 수가 너무 커서 메모리 터짐 . - 그래서 N 번째 피보나치 수열을 구한 뒤에 15746으로 나누지 않고 15746으로 나눈 값들을 더해나갔다 --&gt; 이게 왜 성립함?? . - 편의를 위해 15746대신 7000을 쓰자 . - 다음은 피보나치 수열의 점화식과 같은 형태임 . - 10000 + 20000 = 30000, 20000 + 30000 = 50000 . - 일단 최종 결과인 50000을 7000으로 나눈 나머지는 1000 이다 . - 30000을 7000으로 나눈 나머지는 2000이다. 그러면 20000 + 30000 에서 30000 대신 2000을 써도 식이 성립할까? . - 20000 + 2000 = 22000, 22000을 7000으로 나눈 나머지는 1000 이다 --&gt; 식이 성립함 . - 왜 성립하냐면 50000을 7000으로 나눌 것인데 50000을 20000과 30000으로 쪼갤 수 있음 . - (20000 + 30000) % 7000은 20000을 7000으로 나눈 나머지와 30000을 7000으로 나눈 나머지를 더한 것임 --&gt; 근데 더한 값이 7000보다 클 수 도 있으니 더한 값을 7000으로 또 나눠준다 . - 동그란 케잌으로 생각하자 한 번에 7000만큼의 케잌을 조각내어 퍼갈 수 있음(피자 8등분 하듯이 50000중에 7000만큼 조각 케잌 모양으로 퍼감) . - 케잌크기가 50000이라면 7번 퍼가면 1000이 남는다 . - 근데 50000을 20000과 30000으로 나눈뒤에(50000만 크기의 동그란 케잌을 각각 20000, 30000크기인 반원형 케잌으로 cut) 20000에서 7000만큼 퍼가고 30000에서 7000만큼 퍼가도 된다 . - 20000에서 퍼가고 남은 케잌 조각과 30000에서 퍼가고 남은 케잌 조각을 합쳐서 다시 케잌을 만들고 이 케잌에서 7000을 퍼가면 결과적으로 50000에서 7000을 퍼간것과 동일함 . N = int(input()) x = 10**6 tile_list = [0]*(x+1) tile_list[1] = 1 tile_list[2] = 2 for i in range(3, N+1): tile_list[i] = (tile_list[i-1] + tile_list[i-2]) % 15746 print(tile_list[N]) . 5 . RGB&#44144;&#47532; . 문제 출처: 백준 1149번 | . - N = 10이라면 10개를 최소 비용으로 칠하는 방법은 9개까지 칠하는 방법이 여러개 있음(일단 $dp[9]$라고 하자) + 10번째 칠하는 방법은 3가지 . - $dp[9]+P_{10}$의 최소값이 $dp[10]$이 된다 . - 일반화하면 $min(dp[i-1]+P_i) = dp[i]$ --&gt; 아닌듯 . - 위의 논리는 그리디 알고리즘이다. 항상 최소가 되는 비용을 선택하면 전체적으로도 비용이 최소가 되기를 바라는 것이다 --&gt; 하지만 틀렸다 . - $dp[10]$은 10개까지 색칠하는 여러 방법 =&gt; $min(dp[10]+P_{11}) to dp[11]$ . - $dp[11]$은 최소값 -&gt; 100원이라 하자, 다음으로 싼게 110원 . - $dp[11]+P_{12} to dp[12]$ 이미 $dp[11]$이 최소값 --&gt; 100원을 골라서 $dp[12]$는 200원임 다른건 뭐냐? 1원이 있고 1000원, 근데 1원은 이미 고른 색이어서 못 고름 . - $dp[12]$는 200이 아니라 111원임 $dp[11]$이 최소지만 $dp[12]$는 최소가 아니었음 . - 그럼 남음 방법 뭐임?? . - $dp[11]$을 최소값으로 골랐지만 $dp[12]$가 최소가 아닌 이유는 중복되는 색깔을 선택하지 못하기 때문 . - 그러면 $dp[11]$을 전체의 최소값으로 선택하지 말고 색깔마다 최소값을 고르자 --&gt; 11번째 색이 각각 (빨,초,파)인 경우에 최소값을 구하자 --&gt; 총 3가지가 존재함 . - 이제 $dp[12]$는 어떻게 구하냐면 $dp[11]$과 $P_{12}$의 조합이 총 6가지 존재 . - 6개 중에서 12번째 색이 빨, 파, 초가 존재하는데 각각 2개씩 있다 --&gt; 각각 2개 중에서 더 적은 비용을 고른다 . - 그러면 이제 12번째 색이 빨, 파, 초 일때의 전체 비용의 최소값이 존재 --&gt; $dp[12]$는 색깔별로 존재하니까 총 3개 . - 위와 같은 논리로 마지막 N번째까지 최소비용으로 선택하면 된다 . 처음 짠 코드 | . - 이상한 값을 출력함 . - $dp[i+1][0]$의 의미는 i번째 색깔로 0을 선택했다는 의미임 --&gt; 즉 house_prices[i][0] 이어야함 . - 근데 house_prices가 0이 아니라 $dp[i]$의 값을 0으로 선택했음 --&gt; $dp[i][0]$ 이라면 $dp[i+1]$은 1 or 2이다. 0이 아님 . - 틀렸습니다 . N = int(input()) house_prices = [] for _ in range(N): house_prices.append(list(map(int, input().split()))) dp = [[0]*3 for _ in range(1001)] dp[1] = house_prices[0] for i in range(1, N): dp[i+1][0] = min(dp[i][0] + house_prices[i][1], dp[i][0] + house_prices[i][2]) dp[i+1][1] = min(dp[i][1] + house_prices[i][0], dp[i][1] + house_prices[i][2]) dp[i+1][2] = min(dp[i][2] + house_prices[i][0], dp[i][2] + house_prices[i][1]) print(min(dp[N])) . 102 . 디버깅한 코드 | . - 맞았습니다 . N = int(input()) house_prices = [] for _ in range(N): house_prices.append(list(map(int, input().split()))) dp = [[0]*3 for _ in range(1001)] dp[1] = house_prices[0] for i in range(1, N): dp[i+1][0] = min(dp[i][1] + house_prices[i][0], dp[i][2] + house_prices[i][0]) dp[i+1][1] = min(dp[i][0] + house_prices[i][1], dp[i][2] + house_prices[i][1]) dp[i+1][2] = min(dp[i][0] + house_prices[i][2], dp[i][1] + house_prices[i][2]) print(min(dp[N])) . 96 . &#51221;&#49688; &#49340;&#44033;&#54805; . 문제 출처: 백준 1932번 | . - 위의 RGB 문제와 같은 매커니즘이다 . - 그리디 알고리즘으로 접근하면 주어진 조건하에 항상 최대값을 골라야 하지만 항상 최대값을 고른다고 전체가 최대가 되는 것이 아니다(선택에 제약이 있기 때문: 인접한 곳만 선택 가능) . - 현재 n층 i번째에 위치하고 있다면 n+1층으로 내려갈 때 n+1층의 i번째 or i+1번째만 선택 가능 . - N = 4일 때 $dp[4]$는 무엇일까? . - 4층은 칸이 4개가 존재 --&gt; 이를 인덱스로 생각하면 0~3 . - 그러면 4층의 0번째, 4층의 1번째, 4층의 2번째, 4층의 3번째까지 가는 방법이 각각 여러개가 있을 것이다(대각선상에 존재하는 경우는 1개) . - 그러면 각각 그 중에서 최대값을 선택함 --&gt; 4층의 0번째까지 가는 방법 중 최대값, 4층의 1번째까지 가는 방법 중 최대값 ... --&gt; 총 4개 존재함: 인덱스가 4개 이므로 . - 그 4가지 방법 중 최대값이 4층까지 가는 방법 중 가장 큰 값이다 . N = int(input()) triangle = [] for _ in range(N): triangle.append(list(map(int, input().split()))) dp = [[0]*x for x in range(1,501)] dp[0][0] = triangle[0][0] ## 0층 꼭짓점 ## 1층은 왼쪽 대각선과 오른쪽 대각선만 존재하고 대각선 사이에는 데이터가 없어서 따로 처리했음 if N &gt; 1: dp[1][0] = triangle[1][0] + dp[0][0] ## 왼쪽 대각선 dp[1][1] = triangle[1][1] + dp[0][0] ## 오른쪽 대각선 for i in range(1, N-1): for k in range(1, i+1): dp[i+1][0] = dp[i][0] + triangle[i+1][0] ## 왼쪽 대각선 dp[i+1][k] = max(dp[i][k-1]+triangle[i+1][k] , dp[i][k]+triangle[i+1][k]) ## 대각선 사이 dp[i+1][i+1] = dp[i][i] + triangle[i+1][i+1] ## 오른쪽 대각선 print(max(dp[N-1])) . 30 . - 재채점 되어서 확인했더니 틀렸습니다 &gt; N = 1일 때를 고려하지 않아 indexerror 발생 . - N = 1일 때를 고려하도록 수정했음 &gt; 맞았습니다 . &#44228;&#45800; &#50724;&#47476;&#44592; . 문제 출처: 백준 2579번 | . - 계단은 최대 300개, 칸 마다 점수는 10000이하의 자연수 . - 도착 지점은 무조건 밟아야 한다 . - 그래서 출발 지점부터 시작하지말고 도착 지점부터 시작한다고 생각했음 . - $dp[i]$ --&gt; 마지막으로 밟은 지점이 step의 i번째 인덱스일 때 점수가 최대가 되도록 하는 경로 . - $dp[i] = max(step[i] + dp[i-2] , step[i] + dp[i-1])$ --&gt; 아닌듯, 연속해서 3번 밟을 수 없음. $step[i] + dp[i-2]$는 상관없지만 $step[i] + dp[i-1]$는 상관있음 . - $dp[i] = max(step[i] + step[i-1] + dp[i-3]) , max(step[i] + step[i-2] + dp[i-3])$ . - i번째 계단을 밟는데 i-1번째 계단과 i-2번째 계단을 밟았는지 밟지않았는지가 중요하다 . - 만약 i-1번째와 i-2번째 계단을 둘다 밟았다면 i번째 계단을 밟을 수 없다 . - 만약 i-1번째나 i-2번째 계단 중 한 곳만 밟았다면 i번째 계단을 밟을 수 있다 . - 만약 i-1번째나 i-2번째 계단을 둘다 밟지 않았으면 i번째 계단을 밟을 수 없다 . - 하나하나씩 써보자 . - $dp[0]$ = 도착 지점의 점수 . - $dp[1] = step[1]$ (0번쨰 계단 안밟음) , $step[1] + dp[0]$ (0번째 계단 밟음) . - $dp[2] = step[2] + dp[0]$ (1번쨰 계단 안밟음, 0번째 계단 밟음), $step[2] + dp[1] (= step[1])$ (1번째 계단 밟음, 0번째 계단 안밟음) . - $dp[3] = step[3] + dp[2] (= step[2] + dp[0])$ (2번쨰 계단 밟음, 1번째 계단 안밟음), $step[3] + dp[1] (= step[3] + dp[1] = max(step[1], step[1] + dp[0])$ (2번쨰 계단 안밟음, 1번째 계단 밟음) . - 위에 틀린 부분이 있음, 규칙상 0번째 계단(도착 지점)은 무조건 밟아야 하는데 $dp[1](= step[1])$, $dp[2](= step[2] + step[1])$ 은 0번째 계단을 밟지 않았으므로 제외해야 함 . N = int(input()) step = [] for _ in range(N): step.append(int(input())) step.reverse() ## 도착부터 시작할거임 --&gt; 미로찾기할 때 출발부터 시작안하고 도착부터 시작하듯이 dp = [[0] * 2 for _ in range(300)] ## dp[i][0] =&gt; i-1번째를 밟고 i-2번째를 안밟음, dp[i][1] =&gt; i-1번째를 안밟고 i-2번째를 밟음 dp[0][0] = step[0] dp[0][1] = step[0] if N &gt;= 2: dp[1][0] = step[1] + step[0] dp[1][1] = -(3*10**6) ## 0번째 계단은 무조건 밟아야 하는데 dp[1][1]은 0번째 계단을 안 밟음 --&gt; 그래서 의도적으로 dp[1][1]을 경유하면 절대로 최대값이 나오지 안도록 값을 조정함 if N &gt;= 3: dp[2][0] = -(3*10**6) ## dp[1][1]과 마찬가지임 dp[2][1] = step[2] + step[0] for i in range(3, N): dp[i][0] = step[i] + dp[i-1][1] dp[i][1] = step[i] + max(dp[i-2][0], dp[i-2][1]) print(max(dp[N-1][0], dp[N-1][1], dp[N-2][0], dp[N-2][1])) ## 출발지점을 밟는 길과 밟지 않는 길 중에서 점수 획득이 가장 높은 것을 선택 . 75 . 1&#47196; &#47564;&#46308;&#44592; . 문제 출처: 백준 1463번 | . - 일단 내 생각: 3으로 나누는 것이 수를 1로 만드는데 가장 효과적이라 생각했음 . - 그래서 일단 3으로 나눈다 --&gt; 만약 3으로 나눠지지 않는다면?? . - 만약 1을 뺀 값이 3으로 나눠지면 1을 뺀다 --&gt; 그렇지 않다면 2로 나눈다 --&gt; 만약 2로도 나눠지지 않는다면? . - 1을 뺀다 . - 만약 2의 거듭제곱수이면 2로만 나누기 . - 틀렸습니다 . num = N = int(input()) numbers = [0]*(1+10**6) power_of_2 = {} i = 2 j = 1 while i &lt; 10**6: power_of_2[i] = j j += 1 i *= 2 while True: if num &lt; 2: break if num in power_of_2: numbers[1] = numbers[num] + power_of_2[num] break if num % 3 == 0: now_num = num // 3 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif (num-1) % 3 == 0: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif num % 2 == 0: now_num = num // 2 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue else: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num if num &lt; 2: break print(numbers[1]) . - 만약 number가 소인수로 2와 3만을 가지는 시점이 온다면? . - $number = 2^a cdot 3^b$ . - 1까지 만드려면 2로 a번 나누고 3으로 b번 나누면 됨 --&gt; a+b번 필요함 . - 그냥 모든 경우를 고려한다면? . - N이 주어지면 N을 3으로 나누고 2로 나누고 1을 뺀다 . - 각각에 대해서 또 다시 3으로 나누고 2로 나누고 1을 뺀다 . - 이를 1이 될 때까지 반복 . - 음... 어떻게 함? 재귀로? . - 디버깅 중... . - 근데 위와 같이 하면 $N = 10^6$일 때 연산횟수가 커서 시간초과가 발생할 것 같음 . ## 시간초과 ## N = int(input()) numbers = [0]*(1+10**6) def divide3(x): if x == 1: return numbers[1] if x % 3 == 0: if numbers[x // 3] == 0: numbers[x // 3] += (numbers[x] + 1) else: numbers[x // 3] = min(numbers[x] + 1, numbers[x // 3]) x //= 3 divide3(x) if x % 2 == 0: divide2(x) sub1(x) def divide2(y): if y == 1: return numbers[1] if y % 2 == 0: if numbers[y // 2] == 0: numbers[y // 2] += (numbers[y] + 1) else: numbers[y // 2] = min(numbers[y] + 1, numbers[y // 2]) y //= 2 divide2(y) if y % 3 == 0: divide3(y) sub1(y) def sub1(z): if z == 1: return numbers[1] if z &gt; 1: if numbers[z-1] == 0: numbers[z-1] += (numbers[z] + 1) else: numbers[z-1] = min(numbers[z] + 1, numbers[z-1]) z -= 1 if z % 3 == 0: divide3(z) if z % 2 == 0: divide2(z) sub1(z) divide3(N) divide2(N) sub1(N) print(numbers[1]) . - 굳이 1을 빼야할까? . - 2나 3으로 나눠지지 않을 때만 1을 빼는 것이 좋을 것 같음 . - 하지만 10에 경우 위와 같이 하면 10 - 5 - 4 - 2 - 1 . - 정답은 10 - 9 - 3 - 1 . - 만약 1을 뺀 값이 $2^a cdot 3^b$ 꼴이라면 1을 빼자 . 이것도 틀리면 질문검색 볼거임 | . - 5%에서 틀렸습니다.... . num = N = int(input()) numbers = [0]*(1+10**6) mul_2_3 = {} power_of_2 = {} i = 2 j = 1 while i &lt; 10**6: power_of_2[i] = j j += 1 i *= 2 power_of_3 = {} i = 3 j = 1 while i &lt; 10**6: power_of_3[i] = j j += 1 i *= 3 for i in range(1,13): for j in range(1,20): if list(power_of_3.keys())[i-1] * list(power_of_2.keys())[j-1] &lt; 10**6: mul_2_3[list(power_of_3.keys())[i-1] * list(power_of_2.keys())[j-1]] = i+j mul_2_3.update(power_of_2) mul_2_3.update(power_of_3) while True: if num &lt; 2: break if num in mul_2_3: numbers[1] = numbers[num] + mul_2_3[num] break if num % 3 == 0: now_num = num // 3 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif (num-1) in mul_2_3: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif num % 2 == 0: now_num = num // 2 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue else: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num if num &lt; 2: break print(numbers[1]) . - 질문검색 보고 옴 &gt; 모든 경우를 탐색해 보자 . - 맞았습니다!!! . - 위에서는 어렵게 생각했는지 모든 경우를 탐색하는 코드를 각각의 경우에 대해서 설계했는데 밑에서는 i의 값을 1씩 줄여나가면서 3가지 경우에 대해 탐색하도록 코드를 구성했음 . i = N = int(input()) dp = [0]*(1+10**6) while i &gt; 1: if i % 3 == 0: if dp[i // 3] == 0: dp[i // 3] += (1 + dp[i]) else: dp[i // 3] = min(dp[i] + 1, dp[i // 3]) if i % 2 == 0: if dp[i // 2] == 0: dp[i // 2] += (1 + dp[i]) else: dp[i // 2] = min(dp[i] + 1, dp[i // 2]) if dp[i-1] == 0: dp[i-1] += (1 + dp[i]) else: dp[i-1] = min(dp[i] + 1, dp[i-1]) i -= 1 print(dp[1]) . 4 . &#49772;&#50868; &#44228;&#45800; &#49688; . 문제 출처: 백준10844번 | . - N = 1일 때 9, N = 2일 때 17 . - N = 3일 때 32이었음(내가 손수 구함) . - 다음과 같은 규칙이 바로 생각났음 &gt; $dp[i+1] = 2 times dp[i] - 2^{i-1}$ . - 위 규칙에 따르면 N = 4일 때 60인데 손수 구할 용기가 안나서 검증없이 바로 코드로 구현함 . - ^^ 틀렸습니다 . - i가 어느 정도 커지면 음수가 된다 . - 규칙을 바꿔봄 &gt; $dp[i+1] = 2 times dp[i] - i$ . - 일단 위의 규칙은 음수가 될 일은 절대 없음 . - 위 규칙에 따르면 N = 4일 때 61인데 손수 구할 용기가 안나서 검증없이 바로 코드로 구현함 . - 틀렸습니다 ^^ . - 이제 N = 4일 때 dp를 구해보자 &gt; 손수 구해보니 N = 4일 때 61임 !!!! &gt; 규칙이 틀렸나? . - 일단 직관적으로 생각하면 $dp[i] = 2^{i-1}*9$ . - 왜냐하면 옆 자릿수와 차이가 1이여야 하므로 +1 or -1임 즉 2가지 경우이므로 2를 계속 곱하고 숫자가 1~9까지 9개이므로 9를 곱합 . - 하지만 9에 경우 -1은 가능하지만 +1은 없음 또 0에 경우 +1은 가능하지만 -1은 존재하지 않는다 &gt; 차이만큼 빼줘야함 . - 위에 기반하면 N = 1: 9 - 0, N = 2: 18 - 1, N = 3: 36 - 4, N = 4: 72 - 11 &gt; 규칙이 보이지 않음 . - 그리고 또 2자리는 1자리에 기반하여 만들고 3자리는 2자리에 기반하여 만듦 ex) 23 --&gt; 232 or 234, 232 --&gt; 2321 or 2323 . - N = 5일 때 118인지 확인할까? . N = int(input()) dp = [0]*101 dp[1] = 9 for i in range(1, 100): dp[i+1] = (2*dp[i] - i) % 1000000000 print(dp[N]) . - 질문검색 보고옴 . - 코드 대충 봐보니 i-1번째에 기반하여 i번째를 만드는 것 같았음 . - 끝자리가 0이나 9인 경우에는 다음 자리에 올 수 있는 숫자가 1개 뿐이므로 이를 고려하여 코드를 구성하자 . - 아니면 끝자리가 0~9 까지 10개이므로 배열을 10칸으로 만들자 . - $dp[i][j]$의 의미는 자릿수가 i인데 끝자리가 j인 경우임 . N = int(input()) dp = [[0]*10 for _ in range(101)] for k in range(1, 10): dp[1][k] = 1 for i in range(1, 100): for j in range(10): if j == 0: dp[i+1][j] = dp[i][j+1] % 1000000000 elif j == 9: dp[i+1][j] = dp[i][j-1] % 1000000000 else: dp[i+1][j] = (dp[i][j+1] + dp[i][j-1]) % 1000000000 print(sum(dp[N]) % 1000000000) . 116 . - 흐음 질문검색에서 아이디어를 가져온거라 정답을 맞춘게 맞춘게 아님 . - 옛날이었으면 풀었을 듯... 요새 안하다보니 감이 떨어짐 . &#54252;&#46020;&#51452; &#49884;&#49885; . 문제 출처: 백준 2156번 | . - 문제를 보자마자 전에 풀었던 계단오르기와 유사하다고 생각이 들었음 . - $dp[i]$는 두 종류가 있음 &gt; i-1번째 와인을 마신 경우와 i-1번째 와인을 마시지 않은 경우 &gt; 두 경우 중 최대값이 $dp[i]$임 . - $dp[i][1] = wines[i] + dp[i-1][0]$ . - $dp[i][0] = max(wines[i] + dp[i-2][0], wines[i] + dp[i-2][1], wines[i] + dp[i-3][1])$ . - $dp[i][0]$은 i-1번째 와인을 마시지 않은 경우 . - $dp[i][1]$는 i-1번째 와인을 마신 경우 . N = int(input()) dp = [[0] * 2 for __ in range(10001)] wines = [0] for _ in range(N): wine = int(input()) wines.append(wine) dp[1][0] = wines[1] dp[1][1] = wines[1] + wines[0] if N &gt; 1: dp[2][0] = wines[2] dp[2][1] = wines[2] + wines[1] for i in range(3, N+1): dp[i][0] = max(wines[i] + dp[i-2][0], wines[i] + dp[i-2][1], wines[i] + dp[i-3][1]) dp[i][1] = wines[i] + dp[i-1][0] print(max(dp[N][0], dp[N][1], dp[N-1][1])) . 33 . &#44032;&#51109; &#44596; &#51613;&#44032;&#54616;&#45716; &#48512;&#48516; &#49688;&#50676; . 문제 출처: 백준 11053번 | . - 모르겠다 공부 ㄱㄱ . - 공부하고 왔음 . - 수열A: 10, 20, 30, 11, 12, 13, 14, 40, 15, 16 이런 수열이 있다고 해보자 . - 위에서 다룬 수열을 A라고 해보자 . - A[6] = 13, dp[6] = 4이다. dp[6] = 4라는 뜻은 A[6]이 마지막 원소이고 만약 수열A가 A[5]까지만 존재했다면 가장 긴 증가하는 부분 수열의 길이는 3이라는 의미이다 . - A[6]을 추가하는데 되도록이면 증가하는 부분 수열의 길이가 크면 좋음 &gt; A[6]이 마지막 원소가 될 수 있는 여러개의 증가하는 부분 수열 중에서 길이가 가장 긴 것에 A[6]을 추가해야 함 . - 즉 dp[1]에서 dp[5]중에서 가장 큰 값에다 A[6]을 추가하여 새로운 dp[6]을 만듦 &gt; dp[i]는 i번째 인덱스 값을 수열의 마지막 원소로 가지는 증가하는 부분 수열 중 가장 길이가 긴 것 . - 가장 긴 증가하는 부분 수열 점화식: $dp[n] = max(dp[i], dp[j], dots, dp[k]) + 1, quad (A[n] &gt; A[i], A[j], dots,A[k]])$ . N = int(input()) dp = [0] * 1001 data = list(map(int, input().split())) arr = [0] + data for i in range(1, N+1): for j in range(i): if arr[i] &gt; arr[j]: dp[i] = max(dp[j] + 1, dp[i]) print(max(dp)) . 5 . &#44032;&#51109; &#44596; &#48148;&#51060;&#53664;&#45769; &#48512;&#48516; &#49688;&#50676; . 문제 출처: 백준 11054번 | . - 질문 검색에서 아이디어 참고함 . - 증가하는 부분 수열 + 감소하는 부분 수열 - 1(겹치는 부분)의 최댓값을 구하자 . - dp_up[n]은 n를 마지막 원소로 가지는 증가하는 부분 수열 중 길이가 가장 긴 것 . - dp_down[n]은 n를 첫번째 원소로 가지는 감소하는 부분 수열 중 길이가 가장 긴 것 . N = int(input()) dp_up = [0] * 1001 dp_down = [1] * 1001 data = list(map(int, input().split())) arr = [0] + data ## 가징 긴 바이토닉 부분 수열 for i in range(1, N+1): for j in range(i): if arr[i] &gt; arr[j]: dp_up[i] = max(dp_up[j] + 1, dp_up[i]) for i in range(N, 0, -1): for j in range(N, i, -1): if arr[i] &gt; arr[j]: dp_down[i] = max(dp_down[j] + 1, dp_down[i]) print(max(list(map(lambda x, y: x+y, dp_up, dp_down)))-1) . 7 . - 위에서 사용한 lambda 함수 간단히 참고 . a = [1, 2, 3, 4, 5] b = [10, 1 ,2, 3, 4] print(max(list(map(lambda x, y: x+y, a, b)))-1) . 10 . - 서로 동일한 index위치에 있는 값을 더한 후 최대값 - 1을 출력 . - 리스트 길이가 다르다면? . a = [1, 2, 3, 20, 20] b = [1 ,2, 10] print(max(list(map(lambda x, y: x+y, a, b)))-1) . 12 . - b는 길이가 3이어서 a의 4와 5 원소는 고려되지 않음 . &#51204;&#44611;&#51460; . 문제 출처: 백준 2565번 | . - A와 B는 연결되어 있으므로 세트임 . - 우선 A, B에 대해 오름차순 정렬을 함(A, B 순서 바뀌어도 ok) &gt; 전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨지므로 . - dp[n]은 n번째 전깃줄이 마지막에 위치하는 LIS임 . - n번째의 전깃줄은 n-1번째 전깃줄에 대해 A, B 각각 숫자가 커야함 . - dp 최대값을 구한 후 N에서 빼면 제거해야 할 전깃줄의 개수임 . N = int(input()) arr = [[0, 0]] dp = [0] * 101 for _ in range(N): arr.append(list(map(int, input().split()))) arr1 = sorted(arr, key = lambda x: (x[0], x[1])) for i in range(1, N+1): for j in range(i): if arr1[i][0] &gt; arr1[j][0] and arr1[i][1]&gt; arr1[j][1]: dp[i] = max(dp[j] + 1, dp[i]) print(N - max(dp)) . 3 . &#54588;&#48372;&#45208;&#52824; &#49688; 2 . 문제 출처: 백준 2748번 | . - n은 90보다 작거나 같은 자연수 . N = int(input()) first_fibo = 0 second_fibo = 1 for i in range(N): next_fibo = first_fibo + second_fibo first_fibo = second_fibo second_fibo = next_fibo print(first_fibo) . 55 . &#54588;&#48372;&#45208;&#52824; &#49688; 3 . 문제 출처: 백준 2749번 | . - n은 1,000,000,000,000,000,000보다 작거나 같은 자연수 . - 아래와 같은 bottom-up 방식은 시간초과임 . N = int(input()) first_fibo = 0 second_fibo = 1 for i in range(N): next_fibo = (first_fibo + second_fibo) % 1000000 first_fibo = second_fibo % 1000000 second_fibo = next_fibo % 1000000 print(first_fibo) . 228875 . - 곰곰이 생각해보니 n이 최대 100경이라 for문 써도 컴퓨터 터지고 배열로 만들어도 컴퓨터 터짐 . - 피보나치 수열의 일반항이 생각나서 검색해봄 . - 근데 n이 너무 커서 overflow 때문에 불가능 . - 위의 방법을 사용하지 않으면 어떻게 푸는지 모르겠어서 질문 검색을 보니 피사노 주기 를 이용하여 푼다고 한다 . - 참고: 피보나치 수를 구하는 여러가지 방법 . - 아무튼 그래서 피사노 주기를 통해서 문제를 해결함 . N = int(input()) m = 10**6 P = 15 * (10**5) M = N % P fibo = {0:0, 1:1} for i in range(M): fibo[i+2] = (fibo[i] % m + fibo[i+1] % m) % m print(fibo[M]) . 228875 . &#54588;&#48372;&#45208;&#52824; &#49688; 4 . 문제 출처: 백준 10826번 | . - n은 10000보다 작거나 같은 자연수 . N = int(input()) dp = [0] * 10001 dp[1] = 1 for i in range(N-1): dp[i+2] = dp[i] + dp[i+1] print(dp[N]) . 55 . LCS . 문제 출처: 백준 9251번 | . - 머리가 멍청해짐 &gt; 어려워서 공부하고 옴 . - a와 b 두 문자열이 있음 . - 두 문자열의 길이가 각각 n과 m이라고 해보자 . - 만약 a[ i ]와 b[ j ] 문자가 서로 같다면 dp[ i ][ j ] = dp[ i-1 ][ j-1 ]+1과 동일함 . - 만약 문자가 서로 다르다면 dp[ i ][ j ] = max(dp[ i-1 ][ j ], dp[ i ][ j-1 ]) . a = input() b = input() dp = [[0] * (len(b)+1) for _ in range(len(a)+1)] for i in range(1, len(a)+1): for j in range(1, len(b)+1): if a[i-1] == b[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i][j-1], dp[i-1][j]) print(dp[len(a)][len(b)]) ## input ## ACAYKP ## CAPCAK . 4 . &#50672;&#49549;&#54633; . 문제 출처: 백준 1912번 | . &#54217;&#48276;&#54620; &#48176;&#45229; . 문제 출처: 백준 12865번 | . . &#44396;&#54788; . &#48727;&#47932; . 문제 출처: 백준 14719번 | . - $n$번째 블록의 높이를 $x$라 해보자 . - 만약 $x$이상인 높이 $y$가 $n+α$번째에 있다면 그 사이에 빗물을 $x$높이 까지 담을 수 있음 . - 만약 $x$이상인 높이가 없다면?? &gt; 탐색하는 방향을 거꾸로 하면 된다(처음 $ to$ 끝 대신 끝 $ to$ 처음) . - 그렇게 되면 처음에 탐색했을 때와 반대로 되므로 똑같이 크거나 같은 블록을 찾아 나가면 된다 . - 처음 $ to$ 끝 탐색과 끝 $ to$ 처음 탐색을 할 때 서로 겹치는 부분이 없을 것 같지만 높이가 같은 경우에는 겹치게 되므로 이에 대해서는 한번만 고려하자 . - 위에 설명만 들으면 어려울 것 같으니 예를 들어보자 . - 시작 &gt; 끝 . - 블록의 높이가 3 1 2 3 3 1 1 2 라 하면 처음부터 탐색하므로 시작 블록 높이는 3이다 . - 3보다 크거나 같은 블록을 찾아 헤매다니니 4번째에 3이 존재함 &gt; 빗물을 3만큼 담을 수 있음 . - 이제 블록의 기준이 바뀜 (3 &gt; 3) . - 이제 또 다시 3보다 크거나 같은 블록을 헤매다니자 &gt; 3이 존재함 &gt; 빗물을 0만큼 담음 . - 3보다 큰 블록이 없음 &gt; 하지만 그렇다고 빗물을 못담는것이 아니다 3과 2사이에 빗물을 2만큼 담을 수 있다 &gt; 이런 경우를 고려하기 위해 이제 탐색 방향을 바꾸자 . - 끝 &gt; 시작 . - 시작 블록 높이는 2이다 . - 2보다 크거나 같은 블록은 3가 있음 &gt; 빗물을 2만큼 담음 . - 이제 블록의 높이 기준이 3으로 바뀜 . - 3보다 크거나 같은 블록이 바로 앞에 있음 &gt; 빗물을 0만큼 담음 . - 이제 다시 3보다 크거나 같은 블록을 찾자 &gt; 마지막 블록의 높이가 3이다 &gt; 빗물을 3만큼 담음 . - 결과를 보자 . - 두가지 경우를 더하면 결과로 8이 나오지만 사실 정답은 5인데 왜냐하면 3 1 2 3 부분이 두 가지 모두에서 고려되어 빗물이 추가로 더해졌기 때문이다 . - 이렇기에 시작 &gt; 끝 탐색에서 크거나 같은 경우를 고려했다면 끝 &gt; 시작 탐색에서는 큰 경우만 고려해야 함 . - 만약 끝 &gt; 시작 탐색에서 크거나 같은 경우를 고려했다면 시작 &gt; 끝 탐색에서는 큰 경우만 고려 . h, w = map(int, input().split()) blocks = list(map(int, input().split())) ## 시작 &gt; 끝 탐색 start1 = blocks[0] idx1 = 0 water1 = 0 for i in range(1, w): if blocks[i] &gt;= start1: for j in range(idx1+1, i): water1 += start1 - blocks[j] idx1 = i start1 = blocks[i] ## 끝 &gt; 시작 탐색 blocks1 = blocks.reverse() start2 = blocks[0] idx2 = 0 water2 = 0 for i in range(1, w): if blocks[i] &gt; start2: for j in range(idx2+1, i): water2 += start2 - blocks[j] idx2 = i start2 = blocks[i] print(water1 + water2) . 5 . . &#49828;&#53469;(stack) . &#49828;&#53469; . 문제 출처: 백준 10828번 | . - 스택(stack)은 선입후출 구조임 &gt; 한쪽이 막힌 원기둥에 공을 넣는다고 생각하자 &gt; 처음 넣은 공을 빼려면 이제껏 넣어던 공을 모두 빼야 빼낼 수 있음 . N = int(input()) stack = [] def push(num): stack.append() def pop(): if stack: print(stack.pop()) else: print(-1) def size(): print(len(stack)) def empty(): if stack: print(0) else: print(1) def top(): if stack: print(stack[-1]) else: print(-1) orders = [] for _ in range(N): orders.append(input().split()) for i in range(N): if orders[i][0] == &#39;push&#39;: x = str(orders[i][-1]) xx = &#39;push&#39; + &#39;(&#39; + x + &#39;)&#39; xxx = &#39;&#39;.join(xx) eval(xxx) else: y = orders[i][0] + &#39;()&#39; eval(y) . 2 2 0 2 1 -1 0 1 -1 0 3 . &#51228;&#47196; . 문제 출처: 백준 10773번 | . - 스택 구조를 통해 해결하면 된다 . K = int(input()) stack = [] for _ in range(K): num = int(input()) if num == 0: stack.pop() else: stack.append(num) print(sum(stack)) . 0 . &#44292;&#54840; . 문제 출처: 백준 9012번 | . - &#39;(&#39;가 입력되면 스택에 추가하고 &#39;)&#39;가 입력되면 제거하는 방식으로 오류가 발생하면 잘못된 문자열임을 판단하자 . T = int(input()) for _ in range(T): string = input() stack = [] cnt = 0 for i in range(len(string)): if string[i] == &#39;(&#39;: stack.append(&#39;(&#39;) elif string[i] == &#39;)&#39;: ## else:로 하면 틀림 &gt; 이유 모름 if stack: stack.pop() else: cnt = -1 break if not stack and cnt == 0: print(&quot;YES&quot;) else: print(&quot;NO&quot;) . YES . &#44512;&#54805;&#51105;&#55180; &#49464;&#49345; . 문제출처: 백준 4949번 | . - 괄호 문제에서 대괄호가 추가된 경우임 . - stack에 &#39;(&#39;와 &#39;[&#39;를 추가하고 &#39;)&#39;과 &#39;]&#39;이 입력되었을 때 stack.pop()을 하는데 서로 짝이 맞지 않으면 잘못된 문자열 . - &#39;(&#39;, &#39;)&#39;와 &#39;[&#39;, &#39;]&#39; 각각의 쌍이 맞지 않아도 잘못된 문자열 . - &#39;(&#39;다음에 &#39;)&quot;이 와야하고 &#39;[&#39;다음에 &#39;]&#39;이 와야함 &gt; 이를 지키지 않아도 잘못된 문자열 . - input 대신에 sys.stdin.readline을 사용하면 틀림 &gt; 이유 모름 . while True: string = input() stack = [] cnt = 0 num1 = 0 num2 = 0 if string == &#39;.&#39;: break else: for i in string: if i == &#39;(&#39;: stack.append(&#39;(&#39;) num1 += 1 elif i == &#39;)&#39;: num1 -= 1 if num1 &lt; 0: cnt = -1 if stack: tmp = stack.pop() if tmp != &#39;(&#39;: cnt = -1 break elif i == &#39;[&#39;: stack.append(&#39;[&#39;) num2 += 1 elif i == &#39;]&#39;: num2 -= 1 if num2 &lt; 0: cnt = -1 if stack: tmp = stack.pop() if tmp != &#39;[&#39;: cnt = -1 break if num1 == 0 and num2 == 0 and cnt != -1: print(&quot;yes&quot;) else: print(&quot;no&quot;) . yes . yes . no . no . no . yes . yes . &#49828;&#53469; &#49688;&#50676; . 문제 출처: 백준 1874번 | . - stack에 숫자를 1부터 n까지 push함 . - 그러다가 input으로 받은 nums 리스트의 마지막 원소와 stack의 마지막 원소가 동일하면 pop함 . - pop한 숫자의 배열과 기존의 input으로 받은 nums 리스트의 배열과 동일하면 성공적임 . - 만약 그렇지 않다면 동일한 배열로 만드는 것이 불가능하므로 &#39;NO&#39;를 출력 &gt; 불가능한 경우는 다음과 같음 . - push와 pop의 개수가 다름 &gt; push는 n번 하지만 동일한 패턴의 배열로 만드는게 불가능하여 pop을 실행 못함 &gt; pop의 개수가 적음 . n = int(input()) nums = [] stack = [] print_ = [] for _ in range(n): nums.append(int(input())) nums.reverse() i = 1 cnt = 0 while i &lt;= n: stack.append(i) print_.append(&#39;+&#39;) cnt += 1 if stack and nums: while stack[-1] == nums[-1]: if stack[-1] == nums[-1]: stack.pop() nums.pop() print_.append(&#39;-&#39;) cnt -= 1 if not stack or not nums: break i += 1 if cnt == 0: for j in print_: print(j) else: print(&#39;NO&#39;) . + + + + - - + + - + + - - - - - . &#50724;&#53360;&#49688; . 문제 출처: 백준 17298번 | . - 마지막 인덱스부터 처음 인덱스 순서로 진행할 거임 i(N-1 $ to$ 0) . - 일단 num.pop()한 값을 tmp에 저장 &gt; tmp는 num의 마지막 원소임 . - 그리고 tmp를 stack에 append한다 . - stack은 num[i]의 오큰수를 찾는 역할임 &gt; stack에는 num의 마지막 원소부터 처음 원소까지 append된다 . - 스택 구조 특징(후입선출)상 stack[-1]은 num[i]의 바로 오른쪽이며 stack[0]은 num[i]와 오른쪽으로 가장 멀리 떨어진 원소임 . - 그래서 stack으로 어떻게 오큰수 찾음? &gt; 일단 tmp &gt; num[i]이면 num[i]의 오큰수는 tmp임 . - 만약 tmp &lt;= num[i]라면 stack.pop()과 비교함 . - 만약 stack.pop() &gt; num[i]라면 num[i]의 오큰수는 stack.pop()임 . - 만약 stack.pop() &lt;= num[i]라면 기존의 stack.pop()을 버리고 다시 stack.pop()한 값과 비교 &gt; stack의 모든 원소와 비교해도 오큰수가 없으면 -1 . - 질문검색 참고해서 풀었음 . N = int(input()) num = list(map(int, input().split())) arr = [-1] * N stack = [] for i in range(N-2, -1, -1): tmp = num.pop() ## num[i]와 num[i+1](=tmp)을 비교하기 위한 수단 ## for문을 반복할 때 마다 num의 마지막 원소가 pop되어짐 &gt; 총 (N-2-0)+1개 pop stack.append(tmp) ## num의 마지막원소부터 계속하여 추가함 while stack: if num[i] &lt; tmp: arr[i] = tmp break else: val = stack.pop() if num[i] &lt; val: arr[i] = val stack.append(val) ## num[i]와 비교를 위해 val를 pop했는데 num[i] &lt; val이어서 아직 val은 쓸모 있음 &gt; 그러므로 다시 val을 append break else: ## num[i] &gt;= stack.pop() &gt; num[i]의 오른쪽 숫자중에서 가장 왼쪽에 있는 수 부터 살펴봄 &gt; arr[i] = -1 ## 그런데 num[i]보다 더 작으므로 앞으로 쓸모가 없음(val을 다시 append하지 않음) &gt; 왜냐면 앞으로 탐색할 것은 num[i]의 왼쪽에 있는 수 인데 예로 num[x]라 하자 ## stack.pop()이 num[x]의 오큰수하 하자 &gt; 그런데 stack.pop() &gt;= num[i]이므로 num[x]의 오큰수는 num[i]가 됨 &gt; 그러므로 stack.pop()은 이제 무쓸모 print(*arr) ## input &gt; N = 4, num = 9 5 4 8 . -1 8 8 -1 . . &#53328;(queue) . &#53328; 2 . 문제 출처: 백준 18258번 | . - 큐(queue)는 선입선출(= 후입선출) 구조임 . - 양쪽이 뚫린 원기둥에서 한쪽 입구에 push하면 반대쪽 입구에서 pop된다 . - collections의 deque를 import하여 사용한다 . - 코드를 보면 input == &#39;pop&#39;이 아니라 input[:2] == &#39;po&#39;라고 한것을 볼 수 있음 &gt; 왜 그럼? 그냥 input_ == &#39;pop&#39;하지.. . - input이 정확히 &#39;pop&#39;이 아니라 개행문자가 포함되어 &#39;pop &#39;이면 실행이 안됨(아님 말고) &gt; 그래서 input_[:2] == &#39;po&#39;라고 함 . from collections import deque N = int(input()) queue = deque() ## queue 생성 for _ in range(N): input_ = input() if input_[:2] == &#39;pu&#39;: data = int(input_.split()[1]) queue.append(data) elif input_[:2] == &#39;po&#39;: if queue: print(queue.popleft()) else: print(-1) elif input_[:2] == &#39;si&#39;: print(len(queue)) elif input_[:2] == &#39;em&#39;: if queue: print(0) else: print(1) elif input_[:2] == &#39;fr&#39;: if queue: print(queue[0]) else: print(-1) elif input_[:2] == &#39;ba&#39;: if queue: print(queue[-1]) else: print(-1) ## input ## 15 ## push 1 ## push 2 ## front ## back ## size ## empty ## pop ## pop ## pop ## size ## empty ## pop ## push 3 ## empty ## front . 1 . 2 . 2 . 0 . 1 . 2 . -1 . 0 . 1 . -1 . 0 . 3 . &#52852;&#46300; 2 . 문제 출처: 백준 2164번 | . - 큐(queue) 자료구조를 활용하면 됨 . from collections import deque N = int(input()) queue = deque(list(range(1, N+1))) while len(queue) &gt; 1: queue.popleft() ## 맨 앞에 있는 원소를 버림 queue.append(queue.popleft()) ## 맨 앞에 있는 원소를 맨 뒤로 보냄 print(queue[0]) ## input &gt; 6 . 4 . &#50836;&#49464;&#54392;&#49828; &#47928;&#51228; 0 . 문제 출처: 백준 11866번 | . - 1~n번째 값을 줄세우고 k번째 이전의 값을 마지막 인덱스에 이어붙인 후 k번째 값을 제거함 &gt; 이를 모든 원소를 제거할 때까지 반복함 . - 헷갈리니 예시를 들어보자 . - 1 2 3 4 5 6 7 이 있고 3번째 데이터를 제거한다고 하자 . - (1 2) 3(제거) 4 5 6 7 &gt; 3번째 앞의 데이터(= 1, 2)를 4 5 6 7 뒤에 이어 붙이고 3을 제거함 &gt; queue.append(queue.popleft())를 k-1번 반복하고 k번째는 queue.popleft()하면 된다 . - (4 5) 6(제거) 7 1 2 &gt; 또 다시 3번째 앞의 데이터(= 4, 5)를 7 1 2 뒤에 이어 붙이고 6을 제거함 . - 이를 계속하면 된다 + 남은 원소를 m개라 할 때 m이 3보다 작어지면 (3 % m - 1) 번째 인덱스의 값을 제거하고 앞의 데이터들을 뒤에 이어붙이면 됨 . from collections import deque N, K = map(int, input().split()) queue = deque(list(range(1, N+1))) death_seq = [] while queue: ## queue에 원소가 있을때까지 if len(queue) &gt;= K: for _ in range(K-1): queue.append(queue.popleft()) ## k번째 앞의 데이터를 맨 뒤에 이어 붙임 death_seq.append(queue.popleft()) ## k번째 데이터 삭제^^ else: m = (K % len(queue)) - 1 if m == -1: ## 만약 -1이면 마지막 인덱스를 의미하므로 m = len(queue) - 1로 바꿈 m = len(queue) - 1 for __ in range(m): queue.append(queue.popleft()) ## k번째 앞의 데이터를 맨 뒤에 이어 붙임 death_seq.append(queue.popleft()) ## k번째 데이터 삭제^^ print(&#39;&lt;&#39;, end = &#39;&#39;) ## death_seq 출력 for k in range(N): if k != (N-1): print(str(death_seq[k]) + &#39;, &#39;, end = &#39;&#39;) else: print(str(death_seq[k]), end = &#39;&#39;) print(&#39;&gt;&#39;, end = &#39;&#39;) ## input &gt; 7 3 . &lt;3, 6, 2, 7, 5, 1, 4&gt; . &#54532;&#47536;&#53552; &#53328; . 문제 출처: 백준 1966번 | . - 중요도가 같더라도 순서에 따라 이름이 다르므로 큐 구조를 2개 만듦 &gt; 하나는 중요도 담는 용도 나머지는 이름 저장 용도 . - max함수를 통해 인쇄조건을 판단 &gt; 인쇄해도 되면 중요도 큐와 이름 큐에서 각각 popleft()함 &gt; cnt값에 +1 &gt; 만약 우리가 궁금해한 인덱스이면 cnt 출력 . - 인쇄조건에 맞지 않으면 popleft()한 중요도를 다시 append하고 이름 담는 큐에서도 popleft() 후 apppend한다 . from collections import deque T = int(input()) for _ in range(T): N, M = map(int, input().split()) queue1 = deque(list(map(int, input().split()))) queue2 = deque([&#39;x_&#39; + str(i) for i in range(N)]) cnt = 1 while queue1: tmp1 = queue1.popleft() if queue1: if tmp1 &gt;= max(queue1): tmp2 = queue2.popleft() if tmp2[2:] == str(M): print(cnt) break cnt += 1 else: queue1.append(tmp1) queue2.append(queue2.popleft()) else: print(cnt) ## input ## 3 ## 1 0 ## 5 ## 4 2 ## 1 2 3 4 ## 6 0 ## 1 1 9 1 1 1 . 1 . 2 . 5 . - 위 코드에서 아쉬운 점은 중요도와 이름 정보를 담기 위해 2가지 queue를 만들었다는 것임 . - 이름 정보는 인덱스임 &gt; 중요도와 인덱스를 한번에 queue에 담고 싶음 &gt; enumerate 함수를 사용해서 할 수 있음 . from collections import deque T = int(input()) for _ in range(T): N, M = map(int, input().split()) queue = deque([*enumerate(map(int, input().split()))]) ## 인덱스와 중요도를 하나의 queue에 담음 cnt = 1 while queue: tmp = queue.popleft() if queue: if tmp[1] &gt;= max(list(zip(*queue))[1]): ## zip 함수를 통해 중요도만 추출하여 최대값과 비교 if tmp[0] == M: print(cnt) break cnt += 1 else: queue.append(tmp) else: print(cnt) ## input은 위와 동일함 . 1 . 2 . 5 . . &#45937;(deque) . &#45937; . 문제 출처: 백준 10866번 | . - 덱은 스택과 큐를 합친 구조 &gt; 양쪽으로 넣고(append) 빼기(pop) 가능함 . from collections import deque N = int(input()) deque = deque() for _ in range(N): input_ = input() if input_[:2] == &#39;pu&#39;: num = int(input_.split()[1]) if input_[5] == &#39;f&#39;: ## push_front와 push_back구별 deque.appendleft(num) else: deque.append(num) elif input_[:2] == &#39;po&#39;: if input_[4] == &#39;f&#39;: if deque: print(deque.popleft()) else: print(-1) else: if deque: print(deque.pop()) else: print(-1) elif input_[:2] == &#39;si&#39;: print(len(deque)) elif input_[:2] == &#39;em&#39;: if deque: print(0) else: print(1) elif input_[:2] == &#39;fr&#39;: if deque: print(deque[0]) else: print(-1) elif input_[:2] == &#39;ba&#39;: if deque: print(deque[-1]) else: print(-1) ## input ## 15 ## push_back 1 ## push_front 2 ## front ## back ## size ## empty ## pop_front ## pop_back ## pop_front ## size ## empty ## pop_back ## push_front 3 ## empty ## front . 2 . 1 . 2 . 0 . 2 . 1 . -1 . 0 . 1 . -1 . 0 . 3 . &#54924;&#51204;&#54616;&#45716; &#53328; . 문제 출처: 백준 1021번 | . - 오랜만에 풀어서 머리가 굳었음 . - 일단 내 생각은 x[0]의 원소가 deque의 왼쪽 입구와 가까운지 오른쪽 입구와 가까운지 판단하는 것 . - 가까운쪽으로 x[0]을 보내고 deque[0]을 pop하면 된다 . - 참고로 오른쪽 입구 끝으로 간 다음에 한번더 오른쪽으로 한칸씩 이동시켜야 첫번째에 도달한다(오른쪽끝까지 가는 거리 + 1) . - x[0]의 원소를 pop하면 새로운 x[0]를 위와같이 pop하자 . from collections import deque N, M = map(int, input().split()) x = deque(list(map(int, input().split()))) deque = deque(list(range(1, N+1))) min_ = 0 while x: n = len(deque) mid = n // 2 loc = deque.index(x[0]) if loc &gt; mid: while deque[0] != x[0]: deque.appendleft(deque.pop()) min_ += 1 else: while deque[0] != x[0]: deque.append(deque.popleft()) min_ += 1 deque.popleft() x.popleft() print(min_) . 14 . AC . 문제 출처: 백준 5430번 | . - 그냥 하면 된다 . - 풀고나서 다른 정답봤는데 RR은 어자피 의미가 없으니 그냥 없앴음(매우 좋은 생각) . List.replace(&#39;RR&#39;, &#39;&#39;) ` . - 나는 생각이 안나서 그냥 했다 . - R이면 그냥 popleft() 대신에 pop()을 수행했음 . from collections import deque T = int(input()) for _ in range(T): funcs = input() n = int(input()) nums = input() if n == 0: nums = deque() else: nums = deque(list(map(int, nums[1:-1].split(&#39;,&#39;)))) z = &#39;True&#39; c = 0 for i in range(len(funcs)): if funcs[i] == &#39;R&#39;: c += 1 elif funcs[i] == &#39;D&#39; and nums: if c % 2 == 0: nums.popleft() else: nums.pop() else: z = &#39;error&#39; nums2 = [] if c % 2 == 1: for j in range(len(nums)): nums2.append(nums.pop()) else: nums2 = list(nums.copy()) nums2 = list(map(str, nums2)) nums2 = &#39;[&#39; + &#39;,&#39;.join(nums2) + &#39;]&#39; if z == &#39;True&#39;: print(nums2) else: print(z) # input # 1 # RRD # 6 # [1,1,2,3,5,8] . [1,2,3,5,8] . . &#50864;&#49440;&#49692;&#50948; &#53328;(priority queue) . &#52572;&#45824; &#55193; . 문제 출처: 백준 11279번 | . - heap 자료구조를 이용하면 된다 . - 파이썬에서 heap 자료구조는 heapq 모듈이 지원한다 . - 파이썬에서 heapq 모듈은 최소힙을 지원하니 수를 append할 때 마이너스(-)를 붙이자 . - 그러면 절대값이 큰 값이 최소값이 되고 다시 마이너스(-)를 붙이면 최대값이 된다 . - 그리고 input() 대신 sys.stdin.readline() 사용해야 됨 . - 주피터에서는 오류나서 제출할 때만 수정함 . import heapq N = int(input()) heap = [] for _ in range(N): x = int(input()) if x == 0: if heap: print(-heapq.heappop(heap)) else: print(0) else: heapq.heappush(heap, -x) # input # 11 # 0 # 1 # 2 # 0 # 0 # 3 # 2 # 1 # 0 # 0 # 0 . 0 . 2 . 1 . 3 . 2 . 1 . &#52572;&#49548; &#55193; . 문제 출처: 백준 1927번 | . - 최대 힙 문제와 동일한 매커니즘이다 . import heapq N = int(input()) heap = [] for _ in range(N): x = int(input()) if x == 0: if heap: print(heapq.heappop(heap)) else: print(0) else: heapq.heappush(heap, x) # input # 9 # 0 # 12345678 # 1 # 2 # 0 # 0 # 0 # 0 # 32 . 0 . 1 . 2 . 12345678 . 0 . &#51208;&#45843;&#44050; &#55193; . 문제 출처: 백준 11286번 | . - heap 구조에 tuple형태로 push하면 첫번째원소를 기준으로 최소힙을 구성한다 . - 그리고 첫번째원소가 같으면 두번째원소가 더 작은 tuple이 부모노드가 된다 . import heapq N = int(input()) heap = [] for _ in range(N): x = int(input()) if x == 0: if heap: print(heapq.heappop(heap)[1]) else: print(0) else: heapq.heappush(heap, (abs(x), x)) # input # 9 # 1 # -1 # 2 # -2 # 0 # 0 # 0 # 0 # 0 . -1 . 1 . -2 . 2 . 0 . &#44032;&#50868;&#45936;&#47484; &#47568;&#54644;&#50836; . 문제 출처: 백준 1655번 | . - 어떻게 풀지 감이 안잡혀서 질문검색 보고옴 . - 중앙값을 기준으로 두개의 힙을 관리하면 된다고 한다 . - 중앙값보다 큰쪽은 최소힙으로 작은쪽은 최대힙으로 만든다 . - 만약 큰쪽heap과 작은쪽heap 원소 개수가 동일하다고 해보자 . - input이 큰쪽heap에서 최소값보다 작으면 input을 작은쪽heap에 push하고 작은쪽heap에서 최대값이 중앙값이다 . - 크거나 같으면 input을 큰쪽heap에 push하고 큰쪽heap에서 최소값이 중앙값이다 . - 이번에는 큰쪽heap이 작은쪽heap원소 개수보다 1개가 더 많다고 해보자 . - input이 큰쪽heap에서 최소값보다 작으면 input을 작은쪽heap에 push하고 작은쪽heap에서 최대값이 중앙값이다 . - 크거나 같으면 input을 큰쪽heap에 push하고 큰쪽heap에서 pop한 원소를 작은쪽heap에 push하고 작은쪽heap에서 최대값이 중앙값이다 . - 이번에는 작은쪽heap이 큰쪽heap원소 개수보다 1개가 더 많다고 해보자 . - input이 큰쪽heap에서 최소값보다 크면 input을 큰쪽heap에 push하고 작은쪽heap에서 최대값이 중앙값이다 . - 작거나 같으면 input을 작은쪽heap에 push하고 작은쪽heap에서 pop한 원소를 큰쪽heap에 push하고 작은쪽heap에서 최대값이 중앙값이다 . - 틀린내용이 있을수도 있으니 정확한건 코드 확인하자 . import heapq N = int(input()) heap_down = [] # 최대힙 heap_up = [] # 최소힙 heapq.heappush(heap_up, int(input())) cnt = 0 print(heap_up[0]) if N &gt; 1: x = int(input()) if x &gt; heap_up[0]: print(heap_up[0]) y = heapq.heappop(heap_up) heapq.heappush(heap_down, (-y, y)) heapq.heappush(heap_up, x) else: heapq.heappush(heap_down, (-x, x)) print(x) for _ in range(N-2): x = int(input()) if cnt == 0: # 개수 동일 if x &lt; heap_up[0]: heapq.heappush(heap_down, (-x, x)) print(heap_down[0][1]) cnt = -1 else: heapq.heappush(heap_up, x) print(heap_up[0]) cnt = 1 elif cnt == 1: # 큰쪽이 1개 더 많음 if x &lt; heap_up[0]: heapq.heappush(heap_down, (-x, x)) print(heap_down[0][1]) else: y = heapq.heappop(heap_up) heapq.heappush(heap_down, (-y, y)) heapq.heappush(heap_up, x) print(y) cnt = 0 else: # 작은쪽이 1개 더 많음(cnt == -1) if x &gt; heap_up[0]: heapq.heappush(heap_up, x) print(heap_down[0][1]) else: heapq.heappush(heap_down, (-x, x)) y = heapq.heappop(heap_down)[1] heapq.heappush(heap_up, y) print(heap_down[0][1]) # y가 아님 cnt = 0 # input # 7 # 1 # 5 # 2 # 10 # -99 # 7 # 5 . 1 . 1 . 2 . 2 . 2 . 2 . 5 . . &#51060;&#48516; &#53456;&#49353; . &#45208;&#47924; &#51088;&#47476;&#44592; . 문제 출처: 백준 2805번 | . - 이진탐색으로 해결가능할 듯 하다 &gt; 처음 푸는 유형이었음 . - 나무를 높이 순서로 오름차순 정렬한 후 0과 최대 나무 높이를 중간으로 나눠서 기준치를 넘는지 안넘는지를 판단함&gt; 1~100사이 랜덤 숫자 맞추듯이 . - 목표는 나무를 x미터 까지 잘랐을 땐 기준치 미달인데 x+1미터를 자르니 기준치를 넘기는 x+1을 찾는 것 . - 여러번 틀려서 디버깅 해보니 나무를 반으로 나누는데 최대값은 나무의 최대 높이로 하고 최소값은 나무의 최소 높이로 설정했었다 . - 위에 처럼하면 잘못됐는데 왜냐하면 이 문제의 해가 나무의 최소 높이보다 더 낮은 높이를 절단해야 하면 답이 나오지 않기 때문이다 . - ex) 나무가 3개 있고 높이가 각각 10 20 30이라 하고 필요한 나무는 10미터이라 하자 . - 이 경우는 잘못된 코드로 풀어도 가능함 &gt; 왜냐면 정답이 20미터인데 20은 10과 30 사이 숫자이므로 . - 하지만 필요한 나무가 60미터라면 정답은 0미터여야 하지만 틀린 코드는 최소값 10과 최대값 30 사이를 이분탐색하므로 0이 나올 수 가 없음 . N, M = map(int, input().split()) x = list(map(int, input().split())) x.sort() def trees_sum(h): ## 잘라서 나온 나무 높이의 합 구하기 _sum= 0 for i in range(N): if x[i] &gt; h: _sum += x[i] - h return _sum def cut(trees): left = 0 ## 잘못된 코드는 left = trees[0] 나머지는 동일함 right = trees[-1] mid = (left + right) // 2 sum_ = trees_sum(mid) while True: if right - left &lt; 2: break if sum_ &gt;= M: left = mid mid = (left + right) // 2 sum_ = trees_sum(mid) else: right = mid mid = (left + right) // 2 sum_ = trees_sum(mid) return mid print(cut(x)) ## input ## 4 7 ## 20 15 10 17 . 15 .",
            "url": "https://jaesu26.github.io/green/python/algorithm/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "relUrl": "/python/algorithm/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post32": {
            "title": "map 함수",
            "content": "map &#54632;&#49688; &#53945;&#51669; . - 여러 개의 데이터를 한 번에 다른 형태로 변화하기 위해 사용한다. . - map 함수는 원본 리스트를 변경하지 않고 새 리스트를 생성한다. . - map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환해야 한다. . - map 함수는 리스트의 요소를 지정된 함수로 처리한다. . x = list(range(5)) x . [0, 1, 2, 3, 4] . def two_times(x): return x * 2 . y = two_times(x) y . [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] . z = list(map(two_times, x)) z . [0, 2, 4, 6, 8] . map &#54632;&#49688; &#49324;&#50857;&#48277; . - map(함수, 반복가능한 객체) . x = [1.1, 2.1, 3.1, 4.1] y = map(int, x) print(y) . &lt;map object at 0x0000023B6D93D040&gt; . - map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환한다. $ rightarrow [ star$] 변환하지 않으면 위와 같은 결과를 출력한다. [$ star$] . - print(y)하지 않고 그냥 y만 입력해도 된다. . x = [1.1, 2.1, 3.1, 4.1] y = list(map(int, x)) y . [1, 2, 3, 4] . def minus(a): return a - 0.1 . list(map(minus, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . - minus 함수는 map 함수를 위해 한 번 쓰고 버려질 운명이다. 만드는게 귀찮음... . map &#54632;&#49688;&#50640; &#46988;&#45796; &#49885; &#49324;&#50857; . x = [1.1, 2.1, 3.1, 4.1] list(map(lambda a: a - 0.1, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . input().split()&#44284; map . - input()함수는 c언어의 scanf()함수와 비슷하다. . z = input() . z . &#39;hello&#39; . - input()으로 입력받은 값은 문자열이다. . n = input() . type(n) . str . - input()함수에서 안내문구를 추가할 수 도 있다. . Q = input(&#39;숫자 하나를 입력하세요:&#39;) . Q . &#39;26&#39; . - input()함수의 출력값을 문자열이 아닌 다른 자료형으로 바꾸고 싶다면? . w = int(input(&#39;숫자 하나를 입력하세요:&#39;)) . type(w) . int . - input().split(&quot;기준문자열&quot;)을 사용하면 입력값을 변수 여러 개에 저장할 수 있다. . - split()에서 &quot;기준문자열&quot;이 없는 즉 default는 공백이다. . a, b = input().split() # 입력받은 값을 공백(스페이스, 탭, 엔터 등)을 기준으로 분리 . a, b . (&#39;10&#39;, &#39;20&#39;) . c = a, b type(c) . tuple . - a와b가 문자열이다. . - int형으로 바꾸고 싶다면? . a, b = int(input().split()) . TypeError Traceback (most recent call last) &lt;ipython-input-17-0de5d52cb787&gt; in &lt;module&gt; -&gt; 1 a, b = int(input().split()) TypeError: int() argument must be a string, a bytes-like object or a number, not &#39;list&#39; . - int()함수를 쓰면 될 것 같았는데 오류가 나온다 . - error메시지를 읽어보니 int()함수는 무조건 a string, a bytes-like object or a number 여야 한다.(not &#39;list&#39;) . - a, b는 tuple인 것 같다. . - 그러면 어떻게 하지? $ longrightarrow$ map()함수를 쓰면 된다. . a, b = map(int, input().split()) # 입력받은 값을 정수로 변환 . a, b . (10, 20) . type(a) . int . type(b) . int . - a, b = map(int, input().split())을 풀어서 쓰면 다음과 같은 코드이다. . x = input().split() # input().split()의 결과는 문자열 리스트 m = map(int, x) # 리스트의 요소를 int형으로 변환, 결과는 맵 객체 a, b = m # 맵 객체는 변수 여러 개에 저장 가능 . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#54620; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . L = list(map(int, input().split())) L . [10, 8, 7, 1, 0, 3, 5, 2] . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#50668;&#47084; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . data = [] N = int(input()) for i in range(N): data.append(list(map(int, input().split()))) . data . [[1, 4, 0, 2], [17, 8, 1, 0, 4, 6], [1, 0], [0, 4, 5], [0, 0, 10]] .",
            "url": "https://jaesu26.github.io/green/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "date": " • Jun 21, 2021"
        }
        
    
  
    
        ,"post33": {
            "title": "파이썬 기말시험",
            "content": "- 문제 : https://miruetoto.github.io/yechan/%ED%8C%8C%EC%9D%B4%EC%8D%AC/2021/06/13/2021%EB%85%84-1%ED%95%99%EA%B8%B0-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC-%ED%8C%8C%EC%9D%B4%EC%8D%AC.html . import pandas as pd import numpy as np class execution_sword(): def __init__(self): self.upgradestate = pd.DataFrame({&#39;day0&#39;:[0] * 100}) self.prob = 0.3 self.day = 0 def add_day(self): self.day = self.day + 1 ## 날짜를 하루 더함 def attempt(self): self.attemptresult = np.random.binomial(n = 1, p = self.prob, size = 100) def update(self): self.upgradestate[&#39;day%s&#39; % self.day] = np.minimum(self.upgradestate[&#39;day%s&#39; % (self.day - 1)] + self.attemptresult, 5) ## +5이후로는 증가하지 않는다 self.ratio = sum(self.upgradestate.loc[:, &#39;day%s&#39; % self.day] == 5) / 100 . #1-(1) test1 = execution_sword() for test1.day in range(1, 63): test1.attempt() test1.update() 100 * test1.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다 . 100.0 . - 위에처럼 test.i를 함수 외부에서 조작하는 것은 좋지 않다 . - 이를 조작할 수 있는 함수를 새로 만들고 코드를 다시 구현하자 . test_1 = execution_sword() for k in range(1, 63): test_1.add_day() test_1.attempt() test_1.update() 100 * test_1.ratio . 100.0 . class execution_sword2(execution_sword): def __init__(self): nexon.__init__(self) self.prob = 0.7 self.failstate = pd.DataFrame({&#39;day0&#39;:[0] * 100}) def update(self): nexon.update(self) self.failstate[&#39;day%s&#39; % self.day] = self.failstate[&#39;day%s&#39; % (self.day - 1)] + (self.attemptresult == 0) * 1 for j in range(100): if self.upgradestate.iloc[j, self.day] == 0: self.failstate.iloc[j, self.day] = self.failstate.iloc[j, self.day] - 1 ## i-1번째 + 강화시도(0 or 1) = i번째 ## i,i-1번째 강화상태가 0이라는 의미는 i-1째에 시도한 강화가 실패했다는 의미. ## upgradestate가 0이라는 의미는 실패했다는 것이므로 실패횟수가 하나 쌓인다. ## +0에서는 실패횟수가 쌓이지 않으므로 failstate값을 하나 뺀다. if (self.upgradestate.iloc[j, self.day] == 5) and (self.attemptresult[j] == 0): ## i-1번째 + 강화시도(0 or 1) = i번째 ## i번째가 +5강화이면서 i-1번째 시도한 강화가 실패라는 의미는 ## i-1번째가 +5강화였다는 의미이다. 그러므로 i번째 실패횟수가 +1 됐을것이다. ## +5강화에서는 강화를 도전하지 않을 것이다. ## 그러므로 i번째 실패횟수를 1을 감소시킨다. self.failstate.iloc[j, self.day] = self.failstate.iloc[j, self.day] - 1 ## +5에서는 강화를 시도하지 않을것이므로 ## 만약 실패했다면 failstate값을 하나 뺀다. def reset(self): for j in range(100): if (self.upgradestate.iloc[j, self.day] &gt; 0) and (self.upgradestate.iloc[j, self.day] &lt; 5): if self.failstate.iloc[j, self.day] == 2: self.failstate.iloc[j, self.day] = 0 self.upgradestate.iloc[j, self.day] = 0 ## 실패스택이 2라면 실패스택을 0으로 바꾸고 강화상태를 +0으로 바꾼다 def arrangeprobt(self): if self.ratio &gt;= 0.5: self.prob = 0.9 ## +5강 비율이 50%이상이라면 전체유저의 강화 성공확률을 90%로 바꾼다. . #2-(1) test2 = execution_sword2() for k in range(1, 63): test2.add_day() test2.attempt() test2.update() test2.reset() 100 * test2.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . #2-(2) test3 = execution_sword2() for k in range(1, 32): test3.add_day() test3.attempt() test3.update() test3.reset() 100 * test3.ratio ## 31일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 99명이였다. . 99.0 . #2-(3) test4 = execution_sword2() for k in range(1, 63): test4.add_day() test4.attempt() test4.update() test4.reset() test4.arrangeprobt() 100 * test4.ratio ## 과반수가 +5강화 일때 성공확률을 0.9로 바꾼다,62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . - 다음문장을 잘 읽고 참 거짓을 판단하여라. (10점) . (1) tuple은 원소의 값을 임의로 바꿀 수 있다.=&gt; &#39;거짓&#39; . (2) class 에 정의된 함수(=메서드)는 self 만을 인자로 받을수 있다.=&gt; &#39;거짓&#39; .",
            "url": "https://jaesu26.github.io/green/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "relUrl": "/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "date": " • Jun 18, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "수상 . - 1학년 2학기 때 장학금 10만원… . 학점 . - 1학년 1학기: 4.38 . - 1학년 2학기: 4.50 . - 2학년 1학기: 4.00(희망), 4.42(현실)? . 프로그래밍 언어 . - R . - 파이썬 . - 잘하고 싶다… . 자격증 . - 있을까? . 토익 . - 할거임 . 대외활동 . - 해야지 . 봉사활동 . - .. .",
          "url": "https://jaesu26.github.io/green/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jaesu26.github.io/green/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}