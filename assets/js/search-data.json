{
  
    
        "post0": {
            "title": "가설검정",
            "content": "- 대표적인 확률분포에 대한 간단한 정리를 마친 후 작성할 예정임 &gt; 시작 . - 참고: Statistics: Unlocking the power of data, Robin Lock 외 4인 . &#51473;&#49900;&#44537;&#54620;&#51221;&#47532;(central limit theorem) . - 동일한 확률분포를 가진 독립확률변수 $n$개의 평균의 분포는 충분히 크다면($n geq 30$이면) 정규분포에 가까워짐 . - 앞으로 많은 가설검정에서 사용될 예정 . - 나중에 증명 추가 . &#54217;&#44512;&#50640; &#45824;&#54620; &#52628;&#47200; . - 양적 자료에서 관심 있는 모수는 종종 모집단 평균 $ mu$이다 . - ex) 우리나라 사람들의 평균 맥박수가 어느정도 되는지 궁금함 &gt; 평균에 대한 가설검증 . &#54364;&#48376; &#54217;&#44512;&#50640; &#45824;&#54620; &#51473;&#49900;&#44537;&#54620;&#51221;&#47532; . - 평균이 $ mu$이고 표준편차가 $ alpha$인 모집단에서 표본 크기 $n$이 충분히 클 때 표본 평균의 분포는 근사적으로 평균이 $ mu$이고 표준편차는 $ frac{ alpha}{ sqrt{n}}$인 정규분포를 따름 . - 하지만 위의 내용을 그대로 사용할 수 없음 . 모집단의 표준편차 $ alpha$를 모른다 &gt; 표본의 표준편차 $s$를 $ alpha$대신 사용 . | 추정된 표준오차 $ frac{s}{ sqrt{n}}$에 기반하여 표준화한 통계량의 분포는 표준정규분포를 따르지 않음 &gt; t 분포를 따름(t 분포 참고) . | &#54364;&#48376;&#51032; &#54364;&#51456;&#54200;&#52264;&#47484; &#49324;&#50857;&#54624; &#46412; &#54364;&#48376; &#54217;&#44512;&#51032; &#48516;&#54252; . - 평균이 $ mu$인 모집단에서 표본 크기 $n$인 무작위 표본을 뽑을 때 표본 평균의 분포는 중심이 $ mu$이고 표준오차는 $ frac{s}{ sqrt{n}}$으로 추정 . - 표본 평균을 표준화하면 자유도 $n-1$인 t 분포를 근사적으로 따름 . - 표본 크기 $n$이 커질수록 t분포는 표준정규분포와 가까워짐 . import scipy as sp . import scipy.stats . import matplotlib.pyplot as plt . import numpy as np . x = np.linspace(-5, 5, 100) rv_norm = sp.stats.norm(loc=0, scale=1) rv_t10 = sp.stats.t(df=10) rv_t5 = sp.stats.t(df=5) rv_t1 = sp.stats.t(df=1) norm_pdf = rv_norm.pdf(x) t10_pdf = rv_t10.pdf(x) t5_pdf = rv_t5.pdf(x) t1_pdf = rv_t1.pdf(x) legend = [&#39;z-dist&#39;, &#39;t(df=1)&#39;, &#39;t(df=5)&#39;, &#39;t(df=10)&#39;] plt.figure(figsize = (10, 6)) plt.plot(x, norm_pdf) plt.plot(x, t1_pdf) plt.plot(x, t5_pdf) plt.plot(x, t10_pdf) plt.title(&quot;z-dist, t-dist(df=1, 5, 10)&quot;) plt.xlabel(&quot;$x$&quot;) plt.ylabel(&quot;$p(x)$&quot;) plt.grid() plt.legend(legend) plt.show() . - 위의 plot을 보면 자유도가 커질수록 t분포가 표준정규분포에 가까워짐을 알 수 있음 . - 나중에 plot그리는데 사용되는 lib와 사용법 추가 예정 . t &#48516;&#54252; &#49324;&#50857; &#51312;&#44148; . - 표본 크기 $n geq30$이면 문제 없음 . - 만약 표본 크기 $n$이 작다면? &gt; 모집단이 정규분포를 따라야 함 . - 근데 모집단이 정규분포 따르는지 모른다 &gt; 대신에 표본이 정규분포를 따르는지 확인하자 &gt; shapiro.test 실시 . - 표본에 이상점이 있거나 비대칭이면 t 분포 사용$ times$ . - 표본이 정규분포를 따르는 것 같다 &gt; $ bar{x}$의 분포는 정규분포를 따른다 &gt; t-test 실시해도 괜찮다 . &#54217;&#44512;&#50640; &#45824;&#54620; t&#44160;&#51221; . - 영가설 $H_0: mu= mu_0$를 검정하는 t-통계량은 다음과 같음 . - $t= frac{ bar{x}- mu_0}{ frac{s}{ sqrt{n}}}$ . - $ bar{x}$는 표본 평균, $s$는 표본에서 계산한 표준편차 . - p-값을 통해 영가설을 기각할지 기각하지 못하는지를 결정 &gt; 가설검정 용어(영가설, p-값 등등)에 대해 나중에 정리 예정 . - 검증의 p-값은 자유도가 $n-1$인 t분포에서 대안가설에 적절한 꼬리쪽의 비율을 계산 . &#54217;&#44512;&#50640; &#45824;&#54620; t&#44160;&#51221; &#50696;&#51228; . 문제 | . - 사람의 평균 체온이 $36.5^{°} mathrm{C}$인지 검정하기 위해 건강한 사람 50명의 체온을 재었다 . - 임의로 데이터를 설정하여 평균 체온 데이터는 평균이 36.3, 표준편차는 0.5인 정규분포에서 추출했음 . - 임의로 뽑은 표본을 살펴보니 $ bar{x} = 36.35, ;s=0.5$이다 . - 위의 데이터는 사람의 평균 체온이 $36.5^{°} mathrm{C}$와는 다르다는 증거인지 유의수준 $ alpha=0.05$ 에서 검정하자 . 해결 과정 | . - $H_0: mu=36.5, ;H_a: mu neq36.5$ . - 표본 크기가 충분하고 표본에 대한 히스토그램을 보면 정규분포를 따르는 것으로 보인다 . import rpy2 import os os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; %load_ext rpy2.ipython . The rpy2.ipython extension is already loaded. To reload it, use: %reload_ext rpy2.ipython . import matplotlib.pyplot as plt import numpy as np ## 예시 샘플 np.random.seed(2021) sample = np.random.normal(loc = 36.3, scale = 0.5, size = 50) plt.hist(sample) plt.title(&#39;body heat data&#39;) plt.show() %R -i sample . - 샤피로 윌크 검정을 통해 정규성을 정확히 확인하자 . %%R shapiro.test(sample) . Shapiro-Wilk normality test data: sample W = 0.98456, p-value = 0.7524 . - p-값이 크므로 영가설(표본은 정규분포를 따름)을 기각할 수 없으므로 표본의 정규성을 가정 . - t통계량을 직접 구해도 됨 &gt; $t= frac{ bar{x}- mu_0}{ frac{s}{ sqrt{n}}} = frac{36.35-36.5}{ frac{0.5}{ sqrt{50}}}=-2.12$ . - 하지만 매번 직접 구하기 귀찮으므로 R을 통해 구해보도록 하자 + p-값도 구해줌 . - 사실 파이썬으로도 가능하지만 내가 모르는 관계로 R로 하고 나중에 따로 공부하자 . %%R print(mean(sample)) ## 평균 print(sd(sample)) ## 분산 . [1] 36.35498 [1] 0.5006206 . %%R t.test(sample, mu = 36.5, alternative = &#39;two.sided&#39;, conf.level = 0.95) . One Sample t-test data: sample t = -2.0483, df = 49, p-value = 0.04591 alternative hypothesis: true mean is not equal to 36.5 95 percent confidence interval: 36.21271 36.49726 sample estimates: mean of x 36.35498 . - p-값을 보면 0.04591로 유의수준인 0.05보다 작음 &gt; 영가설을 기각한다 . - 따라서 표본에 따르면 사람의 평균 체온은 $36.5^{°} mathrm{C}$와 다르다고 할 수 있다 . - 임의로 만든 표본은 평균이 36.3인 정규분포에서 추출한 것이므로 올바르게 추론한 것을 알 수 있음 . &#54217;&#44512; &#52264;&#51060; &#48516;&#54252; . - 단일 평균에 대한 t검정과 차이점은 표본이 하나인가 둘인가이다 . - 평균 차이에 대한 t검정에서 관심있는 모수는 $ mu_1 - mu_2$이다 . - 평균이 $ mu_1$과 $ mu_2$인 모집단에서 표본크기가 $n_1$과 $n_2$인 무작위 표본을 얻었을 때 표본 평균 차이 $ bar{x_1}- bar{x_2}$의 분포는 중심이 모집단 평균 차이$ mu_1- mu_2$이고 표준오차는 $ sqrt{ frac{{s_1}^{2}}{n_1}+ frac{{s_2}^2}{n_2}}$이다 . - 표본 평균 차이를 표준화한 값은 t분포를 따르며 자유도는 근사적으로 $n_1+n_2-2$ . - $n_1 &lt;30$ or $n_2&lt;30$인 경우 표본 크기가 작으며 이 경우에는 모집단이 정규분포를 따라야 함 . - 평균 차이를 검정할 땐 두 집단이 서로 독립인지 아닌지가 중요함 &gt; 독립여부에 따라 검정 방법이 달라짐 . - 여기서는 독립표본에 대해 얘기할 것 임 . - 두 집단의 분산의 동질성이 중요함 &gt; 평균 차이 검정을 하기 전에 분산의 동질성 검정을 수행함 . - 분산이 같은 경우 student&#39;s t-test를 사용하고 분산이 다른 경우 Welch&#39;s t test사용함 . &#54217;&#44512; &#52264;&#51060;&#50640; &#45824;&#54620; t&#44160;&#51221; . - 영가설 $H_0: mu_1- mu_2=0$를 검정하는 t-통계량은 다음과 같음 . - $t= frac{( bar{x_1}- bar{x_2})-0}{ sqrt{ frac{{s_1}^2}{n_1}+ frac{{s_2}^2}{n_2}}}$ . - $ bar{x_1}$과 $ bar{x_2}$는 표본 평균, $s_1$과 $s_2$는 표본의 표준편차 . &#54217;&#44512; &#52264;&#51060;&#50640; &#45824;&#54620; t&#44160;&#51221; &#50696;&#51228; . 문제 | . - 남자의 평균 체온$( bar{x_1})$과 여자의 평균 체온$( bar{x_2})$이 다른지 검정하기 위해 각각 건강한 사람 50명의 체온을 재었다 . - 임의로 데이터를 설정하여 남자의 평균 체온 데이터는 평균이 36.5, 표준편차는 0.4인 정규분포에서 추출했음 . - 임의로 데이터를 설정하여 여자의 평균 체온 데이터는 평균이 36.45, 표준편차는 0.5인 정규분포에서 추출했음 . - 임의로 뽑은 표본을 보니 $ bar{x_1} = 36.54, ; bar{x_2} = 36.5, ; s_1=0.4, ;s_2=0.53$이다 . - 위의 데이터는 남자와 여자의 평균 체온이 서로 다르다는 증거인지 유의수준 $ alpha=0.05$ 에서 검정하자 . 해결 과정 | . - $H_0: mu_1- mu_2 = 0, ;H_a: mu_1 neq mu_2$ . - 표본 크기가 충분하고 표본에 대한 히스토그램을 보면 정규분포를 따르는 것으로 보인다 . - 남자 모집단과 여자 모집단에서 표본을 추출했으므로 두 표본은 서로 독립이다 . import rpy2 import os os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; %load_ext rpy2.ipython . C: anaconda3 envs py38r40 lib site-packages rpy2 robjects packages.py:366: UserWarning: The symbol &#39;quartz&#39; is not in this R namespace/package. warnings.warn( . import matplotlib.pyplot as plt import numpy as np ## 예시 샘플 np.random.seed(2021) man_heat = np.random.normal(loc = 36.5, scale = 0.4, size = 50) woman_heat = np.random.normal(loc = 36.45, scale = 0.5, size = 50) fig, ax = plt.subplots(1, 2, figsize = (10, 4)) ax[0].hist(man_heat) ax[1].hist(woman_heat) ax[0].set_title(&#39;man body heat data&#39;) ax[1].set_title(&#39;woman body heat data&#39;) plt.show() %R -i man_heat,woman_heat . - 두 표본이 정규성을 따르는지 정확히 확인하자 . %%R shapiro.test(man_heat) . Shapiro-Wilk normality test data: man_heat W = 0.98456, p-value = 0.7524 . %%R shapiro.test(woman_heat) . Shapiro-Wilk normality test data: woman_heat W = 0.96223, p-value = 0.1102 . - 둘다 p-값이 크므로 정규성을 가정하자 . - 평균 차이 검정을 하기전에 우선 두 표본의 분산이 동일한지 검정하자 . - var.test는 두 집단의 분산이 동일한지 비교함 ratio(두 집단 분산의 비율)이 1이 아니라면 두 집단의 분산이 다르다는 증거임 . %%R print(mean(man_heat)) print(sd(man_heat)) print(mean(woman_heat)) print(sd(woman_heat)) . [1] 36.54399 [1] 0.4004965 [1] 36.52622 [1] 0.5260057 . %%R var.test(man_heat, woman_heat, ratio = 1, alternative = &quot;two.sided&quot;, conf.level = 0.95) . F test to compare two variances data: man_heat and woman_heat F = 0.57972, num df = 49, denom df = 49, p-value = 0.05916 alternative hypothesis: true ratio of variances is not equal to 1 95 percent confidence interval: 0.3289758 1.0215715 sample estimates: ratio of variances 0.5797175 . - 두 집단의 분산이 같은지 검정하니 p-값이 0.05보다 크기 때문에 다르다고 할만한 충분한 증거가 없으므로 동일하다 가정함 . - 분산이 각각 0.4와 0.5인 집단에서 표본을 추출하여 원래는 분산이 다르지만 표본크기가 작기 때문에 0.1의 차이를 판단하지 못하였음 . - 아무튼 var.test 결과는 분산이 동일하다 나왔으므로 두 집단의 분산이 동일하다 생각하고 평균 차이를 검정하자 . %%R t.test(man_heat, woman_heat, alternative = &#39;two.sided&#39;, var.equal = T, conf.level = 0.95) . Two Sample t-test data: man_heat and woman_heat t = 0.19001, df = 98, p-value = 0.8497 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: -0.1677758 0.2033056 sample estimates: mean of x mean of y 36.54399 36.52622 . - 검정결과를 보면 p-값이 0.05보다 크므로 영가설을 기각하지 못함 &gt; 남자와 여자의 평균체온을 다르다고 할 수 없음 . - 실제 데이터는 평균이 36.5와 36.45로 다르지만 표본의 크기가 충분하지 않아 이를 잡아내지 못함 . - 표본 크기가 50이 아니라 더욱 커진다면 위의 차이를 알아낼 수 있음 . &#45824;&#51025;&#54364;&#48376;&#50640; &#45824;&#54620; &#54217;&#44512; &#52264;&#51060; t&#44160;&#51221; .",
            "url": "https://gkswotn12345.github.io/green/python/statistics/2021/07/27/%EA%B0%80%EC%84%A4%EA%B2%80%EC%A0%95.html",
            "relUrl": "/python/statistics/2021/07/27/%EA%B0%80%EC%84%A4%EA%B2%80%EC%A0%95.html",
            "date": " • Jul 27, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "matplotlib 기본 사용법",
            "content": "- 파이썬으로 그래프를 그리는데 matplotlib에 대해 너무 무지하단 생각이 들어 작성함 . - 참고 자료: https://wikidocs.net/92071 . - 위에 참고 자료를 보면서 공부할 예정 . - 실행이 안된다면 모듈 import 했는지 확인 . 01. matplotlib &#44592;&#48376; &#49324;&#50857; . - matplotlib 라이브러리를 이용해서 그래프를 그려보자 . - 그 중에서도 pyplot 사용할 것 임 . &#44592;&#48376; &#44536;&#47000;&#54532; . - pyplot을 이용해서 간단하게 시각화 가능 . - plt.plot() 에 하나의 숫자 리스트를 입력함으로써 아래와 같은 그래프가 그려짐 . - plt.plot()은 하나의 리스트만 입력되면 리스트의 값들이 y 값들이라고 가정하고, x 값 [0, 1, 2, 3] (default)을 자동으로 만듦 . import matplotlib.pyplot as plt plt.plot([1, 2, 3, 4]) plt.show() . - plot() 함수는 다양한 기능을 포함하고 있어서, 임의의 개수의 인자를 받을 수 있음 . - 아래와 같이 두 개의 리스트를 입력하면 순서대로 x, y값으로 생각하고 그래프를 나타냄 . plt.plot([1, 2, 3, 4], [10, 20, 30, 40]) . [&lt;matplotlib.lines.Line2D at 0x20767bee700&gt;] . - plt.show() 는 화면에 표시하는 기능을 하는데 Jupyter를 사용할 때는 자동으로 표시되기 때문에 호출할 필요가 없음 . &#49828;&#53440;&#51068; &#51648;&#51221;&#54616;&#44592; . - x, y 값 인자에 대해 선의 색상과 형태를 지정하는 포맷 문자열을 세번째 인자에 입력할 수 있음 &gt; 후에 더 자세히 알아보자 . - axis()를 이용해서 축의 범위 [xmin, xmax, ymin, ymax]를 지정함 . - linewidth를 통해 선 두께 조절 . - markersize를 통해 마커 사이즈 조절 . import matplotlib.pyplot as plt plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;ro--&#39;, linewidth = 3, markersize = 9) plt.axis([0, 6, 0, 20]) plt.show() ## plt.show()를 사용하지 않으면 그래프는 똑같이 출력되나 plt.axis()의 값인 [0, 6, 0, 20]이 출력되므로 깔끔한 plot을 원한다면 plt.show()를 하자 ## plt.axis()없이 plt.plot()만 해도 위의 그래프와 같이 type이 출력되므로 plt.show()를 하자 . &#50668;&#47084; &#44060;&#51032; &#44536;&#47000;&#54532; &#44536;&#47532;&#44592; . - matplotlib는 대개 numpy array를 이용 . - plt.plot()에서 (x, y, 스타일)을 여러쌍 입력하면 한 화면에 여러 개의 그래프가 그려짐 . import numpy as np x = np.arange(0, 5, 0.2) ## 0부터 5까지 0.2간격으로 객체 생성 # 빨간 대쉬, 파란 사각형, 녹색 삼각형 plt.plot(x, x, &#39;r--&#39;) plt.plot(x, x**2, &#39;bs&#39;) plt.plot(x, x**3, &#39;g^&#39;) ## plt.plot(x, x, &#39;r--&#39;, x, x**2, &#39;bs&#39;, x, x**3, &#39;g^&#39;) 도 동일한 결과를 나타냄 plt.show() . - plt.plot(x, x, &#39;r--&#39;, x, x**2, &#39;bs&#39;, x, x**3, &#39;g^&#39;) 도 동일한 결과를 나타냄 . 02. matplotlib &#52629; &#47112;&#51060;&#48660; &#49444;&#51221; . - plt.xlabel(), plt.ylabel()을 통해 그래프의 x, y축에 대한 label(레이블)을 표시할 수 있음 . plt.plot([1, 2, 3, 4], [1, 4, 9, 16]) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.show() . 03. matplotlib &#49828;&#53440;&#51068; &#51648;&#51221; . - 특별한 입력이 없으면 그래프가 실선으로 그려짐 . - 색깔, 선 타입, 마커를 지정하여 그래프를 그릴 수 있음 . - &#39;ro--&#39;는 red circle dashed, &#39;ro--&#39;에서 r, o, --의 순서는 상관없음 &#39;o--r&#39;도 가능 . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;ro--&#39;) ## `r`는 red, &#39;o&#39;는 circle, `--`는 dashed, `r--`는 red dashed, &#39;ro--&#39;에서 r, o, --의 순서는 상관없음 &#39;o--r&#39;도 가능 ## 레이블 설정 plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) ## x, y축 범위 설정 plt.axis([0, 5, 0, 20]) plt.show() . &#49353;&#44628;, &#49440;, &#47560;&#52964; &#54364;&#49884; &#54805;&#49885; . - color, linestyle, marker 인자를 통해 색깔, 선, 마커 선택 가능 . Colors . - 색깔 종류 정리 . character color . &#39;b&#39; | blue | . &#39;g&#39; | green | . &#39;r&#39; | red | . &#39;c&#39; | cyan | . &#39;m&#39; | megenta | . &#39;y&#39; | yellow | . &#39;k&#39; | black | . &#39;w&#39; | white | . Line Styles . - 선 타입 종류 정리 . character line style . &#39;-&#39; | soild | . &#39;--&#39; | dashed | . &#39;-.&#39; | dash-dot | . &#39;:&#39; | dotted | . Markers . - 마커 종류 정리 . character marker . &#39;.&#39; | point | . &#39;,&#39; | pixel | . &#39;o&#39; | circle | . &#39;v&#39; | triangle_down | . &#39;^&#39; | triangle_up | . &#39;&lt;&#39; | triangle_left | . &#39;&gt;&#39; | triangle_right | . &#39;1&#39; | tir_down | . &#39;2&#39; | tri_up | . &#39;3&#39; | tri_left | . &#39;4&#39; | tri_right | . &#39;s&#39; | square | . &#39;p&#39; | pentagon | . &#39;*&#39; | star | . &#39;h&#39; | hexagon1 | . &#39;H&#39; | hexagon2 | . &#39;+&#39; | plus | . &#39;X&#39; | X marker | . &#39;D&#39; | diamond | . &#39;d&#39; | thin_diamond | . &#39;|&#39; | vline | . &#39;_&#39; | hline | . 04. matplotlib &#49353;&#49345; &#51648;&#51221; . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], color = &#39;springgreen&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.axis([0, 5, 0, 20]) plt.show() . - 위와 같이 color 인자를 통해 더욱 다양한 색상의 이름을 지정 가능 . - 사용 가능 색상 확인: plt colors . Hex code &#49324;&#50857; . - 16진수 코드 (Hex code) 로 더욱 다양한 색상을 지정 가능 . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], color = &#39;#e35f62&#39;, marker = &#39;o&#39;, linestyle = &#39;--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.axis([0, 5, 0, 20]) plt.show() . - marker 인자로 마커 지정 가능 . - linestyle 인자로 선 타입 지정 가능 . - 색상 참고: HTML Color Codes . 05. matplotlib &#44536;&#47000;&#54532; &#50689;&#50669; &#52292;&#50864;&#44592; . - 그래프의 특정 영역을 색상으로 채워서 강조 가능 . - 3가지 함수가 존재: fill_between(), fill_betweenx(), fill() . - [$ star$] x, y의 인덱스를 다르게 해도 되지만 범위가 맞지 않아 그래프와 무관한 사각형을 그린다 [$ star$] . &#44592;&#48376; &#49324;&#50857; . - alpha는 투명도, color는 색상 . import matplotlib.pyplot as plt x = [1, 2, 3, 4] y = [1, 4, 9, 16] plt.plot(x, y, &#39;ko--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.fill_between(x[1:3], y[1:3], color = &#39;red&#39;, alpha = 0.5) ## fill_between() 사용 plt.show() . - fill_between() 함수에 x[1:3], y[1:3]를 순서대로 입력하면, 네 점 (x[1], y[1]), (x[2], y[2]), (x[1], 0), (x[2], 0)을 잇는 영역이 채워짐 . - 일반화 해보면? . - fill_between() 함수에 x[a:a+2], y[b:b+2]를 순서대로 입력하면, 네 점 (x[a], y[a]), (x[a+1], y[a+1]), (x[a], 0), (x[a+1], 0)을 잇는 영역이 채워짐 . - x축에 대한 적분이라 생각하자 . x = [1, 2, 3, 4] y = [1, 4, 9, 16] plt.plot(x, y, &#39;g*:&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.fill_betweenx(y[1:3], x[1:3], color =&#39;cyan&#39;, alpha = 0.5) ## fill_betweenx() 사용 plt.show() . - fill_betweenx() 함수에 x[1:3], y[1:3]를 순서대로 입력하면, 네 점 (x[1], y[1]), (x[2], y[2]), (0, y[1]), (0, y[2])을 잇는 영역이 채워짐 . - 일반화 해보면? . - fill_betweenx() 함수에 x[a:a+2], y[a:a+2]를 순서대로 입력하면, 네 점 (x[a], y[a]), (x[a+1], y[a+1]), (0, y[a]), (0, y[a+1])을 잇는 영역이 채워짐 . - y축에 대한 적분이라 생각하자 . &#46160; &#44536;&#47000;&#54532; &#49324;&#51060; &#50689;&#50669; &#52292;&#50864;&#44592; . - fill_between()을 사용하면 x축에 대한 적분, fill_betweenx()를 사용하면 y축에 대한 적분과 같이 두 그래프 사이 영역을 채울 수 있음 . fill_between() . x1 = [1, 2, 3, 4] y1 = [1, 4, 9, 16] y2 = [1, 2, 1, 8] plt.plot(x1, y1, &#39;rd--&#39;) plt.plot(x1, y2, &#39;bd--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.fill_between(x1[1:3], y1[1:3], y2[1:3], color = &#39;gray&#39;, alpha = 0.5) ## x1, y1, y2순서 매우 중요 plt.show() . - x축 기준으로 두 개의 그래프 커브 사이 영역을 채우기 위해서는 하나의 값 x1과 두 개의 y 값 시퀀스 y1, y2를 입력 . - 네 점 (x1[1], y1[1]), (x1[1], y2[1]), (x1[2], y1[2]), (x1[2], y2[2]) 사이 영역이 채워짐 . - 일반화하면 네 점 (x1[a], y1[a]), (x1[a], y2[a]), (x1[a+1], y1[a+1]), (x1[a+1], y2[a+1]) 사이 영역이 채워짐 . - x1, y1, y2순서 매우 중요 &gt; 한 개의 값 x1을 앞에 배치 . fill_betweenx() . x1 = [1, 4, 9, 16] x2 = [1, 2, 4, 8] y1 = [1, 2, 3, 4] plt.plot(x1, y, &#39;rd--&#39;) plt.plot(x2, y, &#39;bd--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.fill_betweenx(y[1:3], x1[1:3], x2[1:3], color = &#39;gray&#39;, alpha = 0.5) ## x1, x2, y1순서 매우 중요 plt.show() . - y축 기준으로 두 개의 그래프 커브 사이 영역을 채우기 위해서는 하나의 값 y1와 두 개의 x 값 시퀀스 x1, x2를 입력 . - 네 점 (x1[1], y1[1]), (x2[1], y1[1]), (x1[2], y1[2]), (x2[2], y1[2]) 사이 영역이 채워짐 . - 일반화하면 네 점 (x1[a], y1[a]), (x2[a], y1[a]), (x1[a+1], y1[a+1]), (x2[a+1], y1[a+1]) 사이 영역이 채워짐 . - y1, x1, x2순서 매우 중요 &gt; 한 개의 값 y1을 앞에 배치 . &#51076;&#51032;&#51032; &#50689;&#50669; &#52292;&#50864;&#44592; . - fill() 함수에 x, y 값의 리스트를 입력해주면, 각 x, y 점들로 정의되는 다각형 영역을 자유롭게 지정해서 채운다 . x1 = [1, 2, 3, 4] y1 = [1, 4, 9, 16] y2 = [1, 2, 4, 8] plt.plot(x1, y1, &#39;go--&#39;) plt.plot(x1, y2, &#39;bo--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.fill([1.9, 1.9, 3.1, 3.1], [2, 5, 11, 8], color = &#39;lightgray&#39;, alpha = 0.5) plt.show() . 06. matplotlib &#44536;&#47532;&#46300; &#49444;&#51221; . - 데이터의 위치를 더 명확하게 하기 위해 그래프에 grid() 함수를 이용해서 그리드(격자)를 표시할 수 있음 . - plt.grid(True, axis = &#39;type)와 같이 설정하면, 그래프의 x, y축에 대해 그리드가 표시 . - type은 &#39;x&#39;, &#39;y&#39;, &#39;both&#39;(default) 존재 . - grid()도 선의 스타일 설정 가능 . - which 파라미터를 &#39;major&#39;, &#39;minor&#39;, &#39;both&#39; 등으로 사용하면 주눈금, 보조눈금에 각각 그리드를 표시할 수 있음 &gt; 나중에 더 자세히 . x = np.arange(0, 2, 0.2) plt.plot(x, x, &#39;bo--&#39;) plt.plot(x, x**2, &#39;ro--&#39;, linewidth = 2) plt.plot(x, x**3, &#39;go--&#39;, markersize = 5) plt.grid(True, axis = &#39;both&#39;, color = &#39;k&#39;, alpha = 0.5, linestyle = &#39;--&#39;, which = &#39;major&#39;) plt.show() . 07. matplotlib &#45576;&#44552; &#54364;&#49884; . - tick은 그래프의 축에 간격을 구분하기 위해 표시하는 눈금 . &#44592;&#48376; &#49324;&#50857; . - xticks(), yticks() 함수는 각각 x축, y축에 눈금을 표시 . - 리스트 또는 numpy array를 입력하면, 해당하는 위치에 눈금과 숫자 레이블이 표시 . a = np.arange(0, 2, 0.2) plt.plot(a, a, &#39;b^&#39;) plt.plot(a, a**2, &#39;r^&#39;, linewidth = 2) plt.plot(a, a**3, &#39;g^&#39;, markersize = 7) plt.xticks([0, 1, 2]) plt.yticks(np.arange(1, 6)) plt.show() . &#45576;&#44552; &#47112;&#51060;&#48660; &#51648;&#51221; . - labels 파라미터를 사용하면 눈금 레이블을 명시적으로 지정 . x = np.arange(0, 2.4, 0.2) plt.plot(x, x, &#39;b*--&#39;) plt.plot(x, x**2, &#39;r*--&#39;, linewidth = 2) plt.plot(x, x**3, &#39;g*--&#39;, markersize = 7) plt.xticks(x, labels = [&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;]) plt.yticks(np.arange(0,12), (&#39;1M&#39;, &#39;2M&#39;, &#39;3M&#39;, &#39;4M&#39;, &#39;5M&#39;, &#39;6M&#39;, &#39;7M&#39;, &#39;8M&#39;, &#39;9M&#39;, &#39;10M&#39;, &#39;11M&#39;, &#39;12M&#39;)) ## labels 없어도 적용됨 plt.show() . &#45576;&#44552; &#49828;&#53440;&#51068; &#49444;&#51221; . tick_params() 함수를 사용하면 눈금의 스타일을 다양하게 설정 &gt; R의 ggplot2의 axe()와 비슷 | . - axis는 설정이 적용될 축을 지정 &gt; &#39;x&#39;, &#39;y&#39;, &#39;both&#39; 중 선택 . - direction은 눈금을 안/밖으로 표시 &gt; &#39;in&#39;, &#39;out&#39;, &#39;inout&#39; 중 선택 . - length는 눈금의 길이를 지정 . - pad는 눈금과 레이블과의 거리를 지정 . - labelsize는 레이블의 크기를 지정 . - labelcolor는 레이블의 색상을 지정 . - top/bottom/left/right를 True/False로 지정하면 눈금이 표시될 위치를 선택 &gt; default: left, bottom . - width는 눈금의 너비를 지정 . - color는 눈금의 색상을 지정 . x = np.arange(0, 2.4, 0.2) plt.plot(x, x, &#39;b*--&#39;) plt.plot(x, x**2, color = &#39;#e35f62&#39;, marker = &#39;*&#39;, linestyle = &#39;--&#39;, linewidth=2) plt.plot(x, x**3, color = &#39;springgreen&#39;, marker = &#39;*&#39;, linestyle = &#39;--&#39;, markersize = 7) plt.xticks(x, labels = [&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;]) plt.yticks(np.arange(0,12), (&#39;1M&#39;, &#39;2M&#39;, &#39;3M&#39;, &#39;4M&#39;, &#39;5M&#39;, &#39;6M&#39;, &#39;7M&#39;, &#39;8M&#39;, &#39;9M&#39;, &#39;10M&#39;, &#39;11M&#39;, &#39;12M&#39;)) ## labels 없어도 적용됨 plt.tick_params(axis = &#39;y&#39;, direction = &#39;in&#39;, length = 3, pad = 6, labelsize = 11, labelcolor = &#39;red&#39;, right = True) plt.tick_params(axis = &#39;x&#39;, direction = &#39;inout&#39;, length = 10, pad = 15, labelsize = 12, width = 2, color = &#39;b&#39;, top = True) plt.show() . 08. matplotlib &#53440;&#51060;&#53952; &#49444;&#51221; . - title() 함수를 이용해서 그래프의 제목을 설정 . &#44592;&#48376; &#49324;&#50857; . - loc를 통해 상단 중 제목의 위치를 지정 가능 &gt; left, right, center(default) . - pad는 title과 그래프와의 간격(오프셋)을 포인트 단위로 설정 . import matplotlib.pyplot as plt import numpy as np plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;ro--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.title(&#39;$x^2$ plot&#39;, loc = &#39;right&#39;, pad = 10) ## pad는 title과 그래프와의 간격을 포인트 단위로 설정 plt.show() . &#54256;&#53944; &#51648;&#51221; . - fontdict에 딕셔너리 형태로 폰트에 대한 설정을 입력 . - 참고1: matplotlib default font . - 참고2: matplotlib writing mathematical expressions . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;ro--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.grid(True) plt.title(&#39;$x^2$ plot&#39;, fontdict = title_font, loc = &#39;center&#39;, pad = 10) ## pad는 title과 그래프와의 간격을 포인트 단위로 설정 title_font = { &#39;fontsize&#39;: 16, &#39;fontweight&#39;: &#39;bold&#39; } plt.show() . 09. matplotlib &#49688;&#51649;&#49440;/&#49688;&#54217;&#49440; &#54364;&#49884; . - 그래프의 특정 값에 해당하는 위치에 수직선/수평선을 표시하기 위해서 axhline(), axvline(), hlines(), vlines() 사용 . &#44592;&#48376; &#49324;&#50857; - axhline()/axvline() . - axhline() 함수의 1번째 인자는 y 값 으로서 수평선의 위치 . - 2, 3번째 인자는 xmin, xmax 값 으로서 0에서 1 사이의 값 . - 0은 왼쪽 끝(y축), 1은 오른쪽 끝을 의미 . - axvline() 함수의 1번째 인자는 x 값 으로서 수직선의 위치 . - 2, 3번째 인자는 ymin, ymax 값 으로서 0에서 1 사이의 값 . - 0은 아래쪽 끝(x축), 1은 위쪽 끝을 의미 . - 2, 3번째 인자를 생략하면 직선을 그려줌(default) + 0~1사이의 값은 비율임 &gt; ex) 0.5는 중간 . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;ro--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.title(&#39;$x^2$ plot&#39;, loc = &#39;center&#39;, pad = 15) plt.axhline(4, 0, 0.35, color = &#39;gray&#39;, linestyle = &#39;--&#39;, linewidth = 2) plt.axvline(2, 0, 0.23, color = &#39;gray&#39;, linestyle = &#39;--&#39;, linewidth = 2) plt.show() . &#44592;&#48376; &#49324;&#50857; - hlines()/vlines() . - axhline()/axvline()는 수직선/수평선을 비율로 그리는 반면 hlines()/vlines() 는 좌표를 지정해서 그림 . - hlines() 함수에 y, xmin, xmax를 순서대로 입력하면 점 (xmin, y)에서 점 (xmax, y)를 따라 수평선을 표시 . - vlines() 함수에 x, ymin, ymax를 순서대로 입력하면 점 (x, ymin)에서 점 (x, ymax)를 따라 수직선을 표시 . plt.plot([1, 2, 3, 4], [1, 4, 9, 16], &#39;bo--&#39;) plt.xlabel(&#39;X-Label&#39;) plt.ylabel(&#39;Y-Label&#39;) plt.title(&#39;$x^2$ plot&#39;, loc = &#39;center&#39;, pad = 15) plt.hlines(9, 2, 3, color = &#39;k&#39;, linestyle = &#39;--&#39;, linewidth = 2) plt.vlines(2, 4, 9, color = &#39;k&#39;, linestyle = &#39;--&#39;, linewidth = 2) plt.show() . 10. matplotlib &#47561;&#45824; &#44536;&#47000;&#54532; . - bar() 함수를 이용해서 막대 그래프를 표현 . &#44592;&#48376; &#49324;&#50857; . - np.arange()는 주어진 범위와 간격에 따라 균일한 값을 갖는 배열을 생성하는 함수 . import matplotlib.pyplot as plt import numpy as np x = np.arange(3) years = [&#39;2019&#39;, &#39;2020&#39;, &#39;2021&#39;] values = [100, 400, 900] plt.bar(x, values) plt.xticks(x, years) plt.show() . &#49828;&#53440;&#51068; &#44984;&#48120;&#44592; . - width는 막대의 너비(default는 0.8) . - align은 tick과 막대의 위치를 조절 . - color는 막대의 색 . - edgecolor는 막대의 테두리 색 . - linewidth는 테두리의 두께 . - tick_label을 array 형태로 지정하면 tick에 array의 문자열을 나타냄 . - log = True로 설정하면, y축이 로그 스케일로 표시 . x = np.arange(3) years = [&#39;2019&#39;, &#39;2020&#39;, &#39;2021&#39;] values = [100, 400, 900] plt.bar(x, values, width = 0.6, align = &#39;edge&#39;, color = &#39;k&#39;, edgecolor = &#39;b&#39;, linewidth = 1.5, tick_label = years, log = True) plt.show() . 11. matplotlib &#49688;&#54217; &#47561;&#45824; &#44536;&#47000;&#54532; . - barh() 함수를 이용하면 수평 막대 그래프를 그림 . &#44592;&#48376; &#49324;&#50857; . - height는 막대의 높이(default는 0.8) . - 나머지는 bar() 함수와 동일 . import matplotlib.pyplot as plt import numpy as np x = np.arange(3) years = [&#39;2019&#39;, &#39;2020&#39;, &#39;2021&#39;] values = [100, 400, 900] plt.barh(x, values, height = 0.6, align = &#39;edge&#39;, color = &#39;k&#39;, edgecolor = &#39;b&#39;, linewidth = 1.5, tick_label = years, log = False) plt.show() . 12. matplotlib &#49328;&#51216;&#46020; . - 산점도 (scatter plot)는 두 변수의 상관 관계를 직교 좌표계의 평면에 데이터를 점으로 표현하는 그래프 . - scatter() 함수를 이용하여 산점도를 그림 . - np.random.rand(N) &gt; 0~1사이의 난수 N개 생성 . - scatter()에 x, y 위치를 입력 . - s는 마커의 면적을 c는 마커의 색을 지정 . np.random.seed(2021) # Reproducible random state N = 50 x = np.random.rand(N) y = np.random.rand(N) colors = np.random.rand(N) area = (30 * np.random.rand(N))**2 plt.scatter(x, y, s = area, c = colors, alpha = 0.5) plt.show() . 13. matplotlib 3&#52264;&#50896; &#49328;&#51216;&#46020; . - scatter() 함수를 이용해서 3차원 산점도 (3D Scatter plot)를 그릴 수 있음 . &#45212;&#49688; &#49373;&#49457; . - random.random_sample() 함수는 [0.0, 1.0) 범위에서 임의의 실수를 반환 . - 괄호안에 파라미터는 배열의 크기를 지정 &gt; ex) random.random_sample(5, 2) : 5$ times$2배열에 [0.0, 1.0) 범위에서 임의의 실수를 채워넣음 . - [a, b) 범위의 난수를 생성하려면??? &gt; (b-a) * random_sample() + a . - np.random.rand() 함수는 0부터 1사이의 균일 분포에서 난수 matrix array 생성 . - np.random.randn() 함수는 표준 정규 분포에서 난수 matrix array를 생성 . - np.random.standard_normal() 함수는 표준 정규 분포에서 난수 matrix array를 생성 + tuple을 인자로 받음 . &#52264;&#53944; &#44592;&#48376; &#53356;&#44592; &#49444;&#51221; . - plt.rcParams()는 차트의 기본 크기를 지정 . - plt.figure(figsize=(10, 3))과 같이 차트의 기본 크기를 지정할 수 있지만 매번 지정해줘야 함 . figure &#49373;&#49457; . - plt.figure() 함수는 새로운 figure를 생성 . - plt.show() 함수를 통해 생성된 모든 figure를 보여줌 . axes &#49373;&#49457; . - axes는 figure 내에서 축을 가지는 하나의 좌표평면과 같은 개념임 . - axes 는 실제로 데이터가 그려지는 곳 . sub plot &#49373;&#49457; . - fig = plt.figure() . add_subplot() | . - 한 화면에 여러 개의 그래프를 그리려면 plt.figure() 함수를 통해 객체를 먼저 만들고 add_subplot() 함수를 통해 그리려는 그래프 개수만큼 subplot을 만듦 . - fig.add_subplot(1,1,1)은 그림의 1 X 1 그리드에 첫 번째 위치에 서브 플롯을 추가 $ longrightarrow$ fig.add_subplot(111)와 동일 . plt.subplot() | . - fig, ax = plt.subplots(2,1)와 같이 사용 . - 행과 열의 수를 함수에 인수로 전달하고 함수는 plot을 조정하는 데 사용할 수있는 figure 객체와 axes 객체를 반환 . - 서브plot들은 ax를 통해 조작함 . - 참고: matplotlib의 그림에 서브 플롯 추가 . 예시1 | . import matplotlib.pyplot as plt fig,ax = plt.subplots(2, 1) ax[0].text(0.3, 0.5, &quot;1st Subplot&quot;) ax[0].set_xticks([]) ax[0].set_yticks([]) ax[1].text(0.3, 0.5, &quot;2nd Subplot&quot;) ax[1].set_xticks([]) ax[1].set_yticks([]) fig.suptitle(&#39;Figure with 2 subplots&#39;, fontsize = 16) plt.show() . 예시2 | . import matplotlib.pyplot as plt x = [1, 2, 3, 4, 5] y1 = [i**2 for i in x ] y2 = [4*i+1 for i in x] fig, ax = plt.subplots(2, 1) ax[0].plot(x, y1) ax[0].set_xlabel(&quot;X&quot;) ax[0].set_ylabel(&quot;Y&quot;) ax[1].plot(x, y2) ax[1].set_xlabel(&quot;X&quot;) ax[1].set_ylabel(&quot;Y&quot;) plt.tight_layout() plt.show() . 3차원 산점도 | . - 3D axes를 만들기 위해 add_subplot()에 projection = &#39;3d&#39;를 입력 . - scatter() 함수에 x, y, z 위치를 array 형태로 입력 . - cmap = &#39;Greens&#39;를 통해 colormap을 녹색 계열로 설정 . import matplotlib.pyplot as plt import numpy as np n = 100 xmin, xmax, ymin, ymax, zmin, zmax = 0, 20, 0, 20, 0, 50 cmin, cmax = 0, 2 x = np.array([(xmax - xmin) * np.random.random_sample() + xmin for __ in range(n)]) y = np.array([(ymax - ymin) * np.random.random_sample() + ymin for __ in range(n)]) z = np.array([(zmax - zmin) * np.random.random_sample() + zmin for __ in range(n)]) color = (cmax - cmin) * np.random.rand(n) + cmin plt.rcParams[&quot;figure.figsize&quot;] = (6, 6) fig = plt.figure() ax = fig.add_subplot(111, projection = &#39;3d&#39;) ax.scatter(x, y, z, c = color, marker = &#39;o&#39;, s = 15, cmap = &#39;Greens&#39;) plt.show() . 14. matplotlib &#55176;&#49828;&#53664;&#44536;&#47016; . - hist() 함수를 이용해서 히스토그램을 그림 . &#44592;&#48376; &#49324;&#50857; . import matplotlib.pyplot as plt weight = [68, 81, 64, 56, 78, 74, 61, 77, 66, 68, 59, 71, 80, 59, 67, 81, 69, 73, 69, 74, 70, 65] plt.hist(weight) plt.show() . &#50668;&#47084;&#44060;&#51032; &#55176;&#49828;&#53664;&#44536;&#47016; &#44536;&#47532;&#44592; . - bins는 몇 개의 영역으로 쪼갤지를 설정 . - density = True로 설정하면 밀도함수가 되어서 막대의 아래 면적이 1이 됨 . - histtype을 &#39;step&#39;으로 설정하면 막대 내부가 비어있고 &#39;stepfilled&#39;로 설정하면 막대 내부가 채워짐 . import matplotlib.pyplot as plt import numpy as np a = 2.0 * np.random.randn(10000) + 1.0 b = np.random.standard_normal(10000) c = 20.0 * np.random.rand(5000) - 10.0 plt.hist(a, bins = 100, density = True, alpha = 0.7, histtype = &#39;step&#39;, color = &#39;red&#39;) plt.hist(b, bins = 50, density = True, alpha = 0.5, histtype = &#39;stepfilled&#39;, color = &#39;blue&#39;) plt.hist(c, bins = 100, density = True, alpha = 0.9, histtype = &#39;step&#39;, color = &#39;green&#39;) plt.show() . 15. matplotlib &#54028;&#51060; &#52264;&#53944; . - pie() 함수를 이용해서 파이 차트를 그림 . &#44592;&#48376; &#49324;&#50857; . - 각 영역의 비율과 이름을 ratio와 labels로 지정 . - autopct는 부채꼴 안에 표시될 숫자의 형식을 지정 . - autopct에서 문자열로 사용할 땐 &#39;%&#39; 앞에 백분율을 표시하고 &#39;%&#39; 뒤에 백분율을 표시할 형식을 지정 . - &#39;%&#39; 문자 자체를 출력하고 싶다면 &#39;%%&#39;와 같이 입력 . import matplotlib.pyplot as plt ratio = [34, 32, 16, 18] labels = [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Melon&#39;, &#39;Grapes&#39;] fig = plt.figure() ## 캔버스 생성 fig.set_facecolor(&#39;white&#39;) ## 캔버스 색상 하얀색 plt.pie(ratio, labels = labels, autopct = &#39;%.1f%%&#39;) ## autopct 문자열로 입력 plt.show() . &#47588;&#44060; &#48320;&#49688; &#49324;&#50857; . - explode는 부채꼴이 파이 차트의 중심에서 벗어나는 정도를 설정 . - startangle는 부채꼴이 그려지는 시작 각도를 설정(디폴트는 0도) . - counterclock = False로 설정하면 시계 방향 순서로 부채꼴 영역이 표시 . - shadow = True로 설정하면 파이 차트에 그림자가 표시 . - colors를 사용하면 각 영역의 색상을 지정 &gt; Hex code를 이용해서 더욱 다양한 색상을 지정 . - wedgeprops는 부채꼴 영역의 스타일을 설정 . import matplotlib.pyplot as plt ratio = [34, 32, 16, 18] labels = [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Melon&#39;, &#39;Grapes&#39;] explode = [0, 0.10, 0, 0.10] colors = [&#39;#ff9999&#39;, &#39;#ffc000&#39;, &#39;green&#39;, &#39;lightgray&#39;] wedgeprops = {&#39;width&#39;: 0.7, &#39;edgecolor&#39;: &#39;w&#39;, &#39;linewidth&#39;: 5} fig = plt.figure() fig.set_facecolor(&#39;white&#39;) plt.pie(ratio, labels = labels, autopct = lambda x: &#39;{:.1f}%&#39;.format(x), startangle = 260, counterclock = False, explode = explode, colors = colors, wedgeprops = wedgeprops, shadow = True) ## autopct 함수로 입력 plt.show() .",
            "url": "https://gkswotn12345.github.io/green/python/visualization/2021/07/27/matplotlib.html",
            "relUrl": "/python/visualization/2021/07/27/matplotlib.html",
            "date": " • Jul 27, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "파이썬에서 R실행",
            "content": "&#54028;&#51060;&#50028;&#50640;&#49436; R&#49892;&#54665;&#54616;&#44592; . 1. 아나콘다에 접속한 후 Anaconda Installers에서 64-Bit Graphical Installer(477MB)설치 . 2. Anaconda Prompt (anaconda3) 실행 . 3. 아래와 같이 입력 . (base) C: Users 한재수&gt; conda create -n py38r40 python=3.8 . (base) C: Users 한재수&gt; conda activate py38r40 . (py38r40) C: Users 한재수&gt; conda install jupyter lab . (py38r40) C: Users 한재수&gt; pip install rpy2 . (py38r40) C: Users 한재수&gt; R . 4. R에서 아래와 같이 입력 . &gt; install.packages(&quot;IRcernel&quot;) . &gt; IRcernel::installspec() . &gt; R.home() ## 나오는 경로 복사 . &gt; q() ## R 종료 . 5. 다시 프롬프트로 돌아와서 주피터랩 실행 . (py38r40) C: Users 한재수&gt; jupyter lab . 6. R세팅은 끝났고 파이썬에서 R을 사용하려면 아래와 같이 입력(주피터랩 킬 때마다 한 번씩만 입력) . import os . os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; ## R.HOME 에서 복사한 경로 . import rpy2 . %load_ext rpy2.ipython . 7. R사용 . 셀 마다 %R or %%R 입력하여 사용 . import os . os.environ[&#39;R_HOME&#39;]=&#39;C:/anaconda3/envs/py38r40/lib/R&#39; ## R.HOME 에서 복사한 경로 . import rpy2 . %load_ext rpy2.ipython . C: anaconda3 envs py38r40 lib site-packages rpy2 robjects packages.py:366: UserWarning: The symbol &#39;quartz&#39; is not in this R namespace/package. warnings.warn( . %R q &lt;- c(1, 2, 3) %R print(q) Q = [1, 2, 3] print(Q) . [1] 1 2 3 [1, 2, 3] . %%R x &lt;- c(1, 2, 3, 4, 5, 8, 9, 11) y &lt;- c(5, 1, 7, 12, 11, 5, 7, 21) model &lt;- lm(y ~ x) summary(model) . Call: lm(formula = y ~ x) Residuals: Min 1Q Median 3Q Max -6.3741 -4.4232 0.9096 3.2796 6.4840 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 2.9958 3.4644 0.865 0.420 x 1.0473 0.5469 1.915 0.104 Residual standard error: 5.185 on 6 degrees of freedom Multiple R-squared: 0.3793, Adjusted R-squared: 0.2759 F-statistic: 3.667 on 1 and 6 DF, p-value: 0.104 . - %R -i 을 통해 파이썬에서 정의한 변수를 R에서 사용할 수 있음 . import numpy as np data = np.random.rand(50) %R -i data . %%R hist(data) .",
            "url": "https://gkswotn12345.github.io/green/python/r/2021/07/26/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EC%84%9C-R%EC%8B%A4%ED%96%89.html",
            "relUrl": "/python/r/2021/07/26/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EC%84%9C-R%EC%8B%A4%ED%96%89.html",
            "date": " • Jul 26, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "변수 줄임말",
            "content": "&#48320;&#49688; &#51460;&#51076;&#47568; . - 변수를 줄임말로 쓸 때가 있는데 뭐인지 헷갈리는 변수를 정리할 거임 . - 나중에 변수 줄임말 말고도 변수명을 어떻게 정할지에 대한 내용도 정리할 수 도 있음 . - rtn &gt; return . - tmp &gt; temporary variable . - num &gt; number . - lib &gt; library . - lin &gt; linear . - rv &gt; random variable . - aes &gt; aesthetic . - axes &gt; axis(축)의 복수형 . - param(s) &gt; parameter . - loc &gt; location . - pch &gt; point character . - fig &gt; figure . - ax &gt; axes . &#48320;&#49688; &#51460;&#51076;&#47568;&#51008; &#50500;&#45768;&#51648;&#47564; &#50500;&#47924;&#53948; &#51460;&#51076;&#47568;&#51076; . - WLLN &gt; Weak Law of Large Numbers(큰 수의 약한 법칙) . - MLE &gt; maximum likelihood estimate(최대우도추정량) .",
            "url": "https://gkswotn12345.github.io/green/python/2021/07/26/%EB%B3%80%EC%88%98-%EC%A4%84%EC%9E%84%EB%A7%90.html",
            "relUrl": "/python/2021/07/26/%EB%B3%80%EC%88%98-%EC%A4%84%EC%9E%84%EB%A7%90.html",
            "date": " • Jul 26, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "적률생성함수",
            "content": "&#51201;&#47456;&#51060;&#46976; . - 확률변수의 특징을 설명 . - 확률변수 $X$의 $k$차 중심적률(central moment)을 $ mu_{k}$라 하면 $ mu_{k} = E[(X- mu)^{k}]$ . - $ mu_{1} = E(X) - mu = 0$ --&gt; 확률변수 $X$의 $1$차 중심적률은 $0$ . - $ mu_{2} = E[(X- mu)^{2}]$ --&gt; 확률변수 $X$의 $2$차 중심적률은 분산 . - 일반적인 확률 변수 $X$의 적률(moment)은 비중심(non-central)적률을 나타냄 $ longrightarrow$ $ mu&#39;_{k} = E[X^k]$ . - $ mu&#39;_{1} = mu$ . - $ sigma^{2} = mu_{2} = mu&#39;_{2} - ( mu&#39;_{1})^{2}$ . - 모평균$ mu$는 확률변수 $X$의 1차 비중심적률 . - 모분산$ sigma^{2}$은 확률변수 $X$의 2차 비중심적률에서 1차 비중심적률의 제곱을 뺀 값 . - 참고 자료: 통계수학 강의 . &#51201;&#47456;&#49373;&#49457;&#54632;&#49688;(moment generating function, mgf) . - 특정 확률 분포의 적률을 생성하는 함수 . - 적률을 계산하려면 연속확률변수의 경우 적분을 하게 되는데 어렵거나 불가능한 경우도 있음 &gt; 적률생성함수를 통해 계산 가능 . - 임의의 확률변수 $X$의 기댓값이 존재한다면 $X$의 적률생성함수 $M_{X}(t) = E(e^{tX}), ; t in mathbb{R}$ . - $M_{X}(t) = E(e^{tX}) = begin{cases} text{이산확률변수 : } sum limits_{x}e^{tx}f(x) text{연속확률변수 : } int_{- infty}^{ infty}e^{tx}f(x)dx end{cases}$ . - 만약 확률변수 $X$의 기댓값을 구하는데 $X$가 아니라 $x$가 사용되네??라고 생각하면 구글창에 확률변수의 기댓값 검색해서 공부하세요 . - 사실 $x$말고 $k$라고 하든지 $a$라고 하든지 다른 변수를 사용해도 됨 &gt; 마치 적분할 때 $ int x ,dx = int t , dt = int a ,da$ 인 것 처럼 . - 참고: $X$는 확률변수, $x$는 확률변수 $X$가 가지는 값 &gt; 이산확률변수는 $P(X=x)$, 연속확률변수는 $P(A leq X leq B)$ . - 적률생성함수는 항상 존재하는 것이 아님 &gt; 1. $e^{tX}$가 $t=0$근방에서 적분이 가능해야 함 $ ; ;$ 2. $ forall , t in mathbb{R}, ; ;E(e^{tX}) &lt; infty $ . &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; &#53945;&#51669; . - 두 확률변수의 mgf가 일치하면 두 확률변수는 같은 분포를 가짐 . - 적률생성함수를 $k$번 미분하고 $t=0$을 대입하면 확률변수 $X$의 $k$차 비중심 적률이다 --&gt; 왜??? . &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; k&#48264; &#48120;&#48516; $ longrightarrow$ k&#52264; &#48708;&#51473;&#49900; &#51201;&#47456; . - $M_{X}(t) = E(e^{tX})$ . - $ frac{d^{k}M_{X}(0)}{dt^{k}} = E(X^{k})$ . - 매클로린 급수를 사용하자 . - $e^{tX} = sum limits_{k = 0}^{ infty} frac{X^k}{k!}(e^{tX})^{(k)}(0) = frac{t^{0}}{0!}X^{0}+ frac{t^1}{1!}X^1+ frac{t^2}{2!}X^2+ frac{t^3}{3!}X^3+ dots$ . - 양변에 기댓값을 취하면... . - $M_X(t)=E(e^{tX}) = 1 + tE(X) + frac{t^2}{2!}E(X^2) + frac{t^3}{3!}E(X^3)+ dots$ . - 이제 양변을 t에 대해 미분하자 . - $ frac{dM_X(t)}{dt} = 0 + E(X) + tE(X^2) + frac{t^2}{2}E(X^3)+ dots$ . - 이제 $t=0$을 대입하면... . - $ frac{dM_X(0)}{dt} = E(X)$ --&gt; 1번 미분하니 1차 적률이 구해짐 . - 그럼 한 번 더 미분하면 2차 적률? --&gt; ㅇㅇ . - $ frac{d^2M_X(t)}{dt^2} = 0 + 0 + E(X^2) + tE(X^3)+ dots$ . - 참고: $E(X)$는 $t$에 대하여 상수임 . - 이제 $t=0$을 대입하면 . - $ frac{d^2M_X(0)}{dt^2} = E(X^2)$ . - 정말로 2번 미분하니 2차 적률이 구해졌다.. . 확률 분포에 대해 정리할 때 기댓값과 분산을 과정없이 결과만 적었었음 . | 적률생성함수를 통해 여러가지 확률 분포의 기댓값과 분산을 구해보자 . | . &#44512;&#51068; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 균일 분포의 확률 밀도 함수: $f(x) = frac{1}{b-a}$ . - 균일 분포의 적률생성함수 . $M_X(t) = E(e^{tX}) = int_{a}^{b}e^{tx} frac{1}{b-a}dx longrightarrow text{확률변수$X$가 $a$부터 $b$까지의 값을 가진다는 뜻} = frac{1}{b-a} left[ frac{1}{t}e^{tx} right]_{a}^{b} = frac{e^{t}(e^{b}-e^{a})}{t(b-a)}$ | . - 균일 분포의 기댓값 --&gt; 적률생성함수를 통해 구하는 것보다 1차 적률의 정의를 통해 구하는 것이 더 쉬움 . $E(X) = int_{a}^{b} frac{1}{b-a}x ;dx = frac{1}{b-a} left[ frac{x^2}{2} right]_{a}^{b} = frac{b^{2}-a^{2}}{2(b-a)} = frac{a+b}{2}$ | . - 균일 분포의 분산 --&gt; 적률의 정의를 통해 구하자 --&gt; 우선 2차 비중심 적률을 구하자 . $E(X^2) = int_{a}^{b} frac{1}{b-a}x^2 ;dx = frac{1}{b-a} left[ frac{x^3}{3} right]_{a}^{b} = frac{b^{3}-a^{3}}{3(b-a)} = frac{a^2+ab+b^2}{3}$ . | $Var(X) = E(X^2) - [E(X)]^2 = frac{a^2+ab+b^2}{3} - ( frac{a+b}{2})^2 = frac{4(a^2+ab+b^2) ,- 3(a^2+2ab+b^2)}{12} = frac{(b-a)^2}{12}$ . | . &#44592;&#54616; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 기하 분포의 확률 질량 함수: $f(x) = q^{x-1}p, ; q=1-p, ; x = 1, 2, 3, dots$ . - 첫째항이 $a$, 공비가 $r$인 무한등비수열의 합: $ frac{a}{1-r}, ; |r|&lt;1$ . - 기하 분포의 적률생성함수 . $M_X(t) = E(e^{tX}) = sum limits_{x=1}^{ infty}e^{tx}q^{x-1}p = frac{p}{q} sum limits_{x=1}^{ infty}(qe^{t})^{x} = frac{pqe^t}{q(1-qe^t)} , ; 0 leq qe^t &lt; 1 = frac{pe^t}{1-qe^t}$ | . - 기하 분포의 기댓값 . - 몫의 미분: $[ frac{f(x)}{g(x)}]&#39; = frac{f&#39;(x)g(x)-f(x)g&#39;(x)}{(g(x))^2}$ . $E(X) = frac{dM_X(t)}{dt} = frac{pe^{t}(1-qe^t)-pe^{t}(-qe^t)}{(1-qe^t)^2} = frac{pe^t}{(1-qe^t)^2} , ; text{$t=0$ 대입} = frac{p}{(1-q)^2} = frac{1}{p}$ | . - 기하 분포의 분산 . $E(X^2) = frac{d^2M_X(t)}{dt^2} = frac{pe^{t}(1-qe^t)^2- 2pe^{t}(1-qe^{t})(-qe^t)}{(1-qe^t)^4} = frac{pe^{t}(1-qe^t)((1-qe^t)+2qe^t)}{(1-qe^t)^4} = frac{pe^{t}(1+qe^t)}{(1-qe^t)^3}, ; text{$t=0$ 대입} = frac{p(1+q)}{(1-q)^3} = frac{1+q}{p^2}$ . | $Var(X) = E(X^2) - [E(X)]^2 = frac{1+q}{p^2} - ( frac{1}{p})^2 = frac{q}{p^2}$ . | . &#51060;&#54637; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 이항 분포의 확률 질량 함수: $f(x) ,= , _{n} rm C_{x} ,p^{x} ,(1-p)^{n-x}$ . - 이항 분포는 서로 독립이고 동일한 베르누이 분포를 따르는 확률변수들을 n개 합한 것임 . - 베르누이 분포의 확률 질량 함수 $f(x) = p^{x}(1-p)^{1-x}, ; x = 0, 1$ . - 베르누이 분포의 기댓값 . $E(X) = sum limits_{x=0}^{1}xp^{x}(1-p)^{1-x} = 0 cdot (1-p) + 1 cdot p = p$ | . - 베르누이 분포의 분산 . $E(X^2) = sum limits_{x=0}^{1}x^2p^x(1-p)^{1-x} = 0 cdot (1-p) + 1 cdot p = p$ . | $Var(X) = E(X^2)-[E(X)]^2 = p - p^2 = p(1-p)$ . | . - 확률변수 $X, Y$에 대해 $E(X + Y)= E(X) + E(Y)$ . - 확률변수 $X, Y$가 독립이면 $Var(X + Y) = Var(X) + Var(Y)$ . - 참고: 확률변수의 합 특징 . - 이항 분포의 기댓값 --&gt; 이항 분포의 정의를 통해 구함: 베르누이 분포를 따르는 확률변수들의 합 . $E(X) = E( sum limits_{i=1}^{n}X_i) = sum limits_{i=1}^{n}E(X_i) = E(X_1) + E(X_2) + dots+E(X_{n-1})+E(X_n) = overbrace{p + dots + p}^{n rm times} = np$ | . - 이항 분포의 분산 --&gt; 기댓값과 마찬가지 . $Var(X) = Var( sum limits_{i=1}^{n}X_i) = sum limits_{i=1}^{n}Var(X_i) = Var(X_1)+Var(X_2)+ dots+Var(X_{n-1})+Var(X_n) = overbrace{p(1-p)+ dots+p(1-p)}^{n rm times} = np(1-p)$ | . - 이항 정리 . $(x+y)^n = sum limits_{k=0}^{n} binom{n}{k}x^{n-k}y^{k}$ | . - 이항 분포의 적률생성함수 . $M_{X}(t) = E(e^{tX}) = sum limits_{x=0}^{n} binom{n}{x}e^{tx}p^{x} ,(1-p)^{n-x} = sum limits_{x=0}^{n} binom{n}{x}(pe^{t})^{x} ,(1-p)^{n-x} = (1-p+pe^{t})^n$ | . - 이항 분포의 기댓값 --&gt; 적률생성함수 미분해서 구하기 . - 합성함수의 미분 . $[f(g(x))]&#39; = g&#39;(x)f&#39;(g(x))$ | . $E(X) = frac{dM_X(t)}{dt} = npe^t(1-p+pe^t)^{n-1}, ; text{$t=0$ 대입} = np$ | . - 곱의 미분 . $[f(x)g(x)]&#39;=f&#39;(x)g(x)+f(x)g&#39;(x)$ | . - 이항 분포의 분산 --&gt; 적률생성함수 미분해서 구하기 . $E(X^2) = frac{d^2M_X(t)}{dt^2} = npe^{t} cdot(1-p+pe^t)^{n-1}+npe^{t} cdot (n-1)pe^{t}(1-p+pe^{t})^{n-2}, ; text{$t=0$ 대입} =np+np^{2}(n-1) = np-np^2+n^2p^2$ . | $Var(X) = E(X^2)-[E(X)]^2 = np-np^2+n^2p^2-(np)^2 = np-np^2 =np(1-p)$ . | . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 테일러 급수 공부해라 구더기야 + 극좌표계도(희망) 하기 싫어............................................... . - 테일러 급수: 초월함수를 특정 값의 근방에서 멱함수로 근사시킴 --&gt; 개사기임 . - $a$에서 $f$의 테일러 급수 . $f(x) = sum limits_{n=0}^{ infty} frac{f^{(n)}(a)}{n!}(x-a)^{n} = f(a) + frac{f&#39;(a)}{1!}(x-a)+ frac{f&#39;&#39;(a)}{2!}(x-a)^2+ frac{f&#39;&#39;&#39;(a)}{3!}(x-a)^3+ cdots$ | . - $a=0$인 특별한 경우 매클로린 급수라고 함 . $f(x) = sum limits_{n=0}^{ infty} frac{f^{(n)}(0)}{n!}x^n = f(0) + frac{f&#39;(0)}{1!}x+ frac{f&#39;&#39;(0)}{2!}x^2+ frac{f&#39;&#39;&#39;(0)}{3!}x^3+ cdots$ | . - $e^x$의 매클로린 급수 . $e^x = sum limits^{ infty}_{n=0} frac{x^n}{n!}$ | . - 포아송 분포의 확률 질량 함수: $f(x) = frac{e^{- lambda} lambda^{x}}{x!}$ . - 포아송 분포의 적률생성함수 . $M_X(t) = E(e^{tX}) = sum limits_{x=0}^{ infty}e^{tx} frac{e^{- lambda} lambda^{x}}{x!} =e^{- lambda} sum limits_{x=0}^{ infty} frac{( lambda e^{t})^{x}}{x!} ; ; ; text{$ therefore lambda e^t to x, ;x to n$ 으로 바꾸면 $e^x$의 매클로린 급수이다} = e^{- lambda} cdot e^{ lambda e^{t}} = e^{ lambda(e^{t}-1)} $ | . - 포아송 분포의 기댓값 . - $e^{- lambda}$ 는 변수가 아니므로 $e^{ lambda e^{t}}$ 에 대해서만 미분하면 된다 . - $y =e^{t}, ; frac{d}{dy}(y) = e^{t}$ . $E(X) = frac{dM_X(t)}{dt} =e^{- lambda} cdot(e^{ lambda y})&#39; = e^{- lambda} cdot lambda e^{ lambda y} cdot frac{d}{dy}(y) = e^{- lambda} cdot lambda e^{ lambda e^{t}} cdot e^{t}, ; text{$t=0$ 대입} = lambda cdot e^{- lambda} cdot e^{ lambda} = lambda$ | . - 포아송 분포의 분산 . $E(X^2) = frac{d^2M_X(t)}{dt^2} = lambda e^{- lambda} cdot([ lambda e^{ lambda e^{t}} cdot e^{t}] cdot [e^{t}] + [e^{ lambda e^{t}}] cdot[e^{t}]), ; text{$t=0$ 대입} = lambda e^{- lambda}( lambda e^{ lambda}+e^{ lambda}) = lambda^{2}+ lambda$ . | $Var(X) = E(X^2)-[E(X)]^{2} = lambda^{2}+ lambda - lambda^{2} = lambda$ . | . &#51648;&#49688; &#48516;&#54252;&#51032; &#51201;&#47456;&#49373;&#49457;&#54632;&#49688; . - 지수 분포의 확률 밀도 함수: $f(x) = lambda e^{- lambda x}, ; x&gt;0$ . - $ lambda$는 포아송 분포의 모수로 단위 시간당 사건의 평균 발생 횟수 . - 지수 분포의 적률생성함수 . $M_{X}(t) = E(e^{tX}) = int_{0}^{ infty}e^{tx} cdot lambda e^{- lambda x} ,dx = lambda int_{0}^{ infty}e^{tx} cdot e^{- lambda x} ,dx = lambda int_{0}^{ infty}e^{(t- lambda)x} ,dx = frac{ lambda}{t- lambda} cdot left[e^{(t- lambda) x} right]_{0}^{ infty}, ; ; ;(t&lt; lambda) = frac{ lambda}{ lambda - t} $ | . - 지수 분포의 기댓값 . $E(X) = frac{dM_X(t)}{dt} = frac{ lambda}{( lambda - t)^2}, ; text{$t=0$ 대입} = frac{1}{ lambda}$ | . - 지수 분포의 분산 . $E(X^2) = frac{d^2M_X(t)}{dt^2} = - frac{-2 lambda( lambda-t) }{( lambda-t)^4} = frac{2 lambda}{( lambda - t)^3}, ; text{$t=0$ 대입} = frac{2}{ lambda^2}$ . | $Var(X) = E(X^2) - [E(X)]^2 = frac{2}{ lambda^2} - ( frac{1}{ lambda})^2 = frac{1}{ lambda^2}$ . | .",
            "url": "https://gkswotn12345.github.io/green/python/statistics/2021/07/23/%EC%A0%81%EB%A5%A0%EC%83%9D%EC%84%B1%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/statistics/2021/07/23/%EC%A0%81%EB%A5%A0%EC%83%9D%EC%84%B1%ED%95%A8%EC%88%98.html",
            "date": " • Jul 23, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "동적 계획법",
            "content": "&#46041;&#51201; &#44228;&#54925;&#48277; . - 다이나믹 프로그래밍 참고: 동적 계획법 . - 다이나믹 프로그래밍((Dynamic Programming)으로도 불림 . - 큰 문제를 작은 문제로 나눠서 푸는 방법 . - 분할 정복과 유사하지만.. . 동적 계획법 분할 정복 . 공통점 | 큰 문제를 작은 문제로 나눠서 해결 | 큰 문제를 작은 문제로 나눠서 해결 | . 차이점 | 작은 문제가 반복됨 | 작은 문제가 반복되지 않음 | . - 나중에 분할 정복에 대해서도 다뤄보자 . &#45796;&#51060;&#45208;&#48121; &#54532;&#47196;&#44536;&#47000;&#48141; &#51312;&#44148; . 작은 문제들의 반복 . | 같은 문제는 구할 때마다 정답이 같음 . | &#45796;&#51060;&#45208;&#48121; &#54532;&#47196;&#44536;&#47000;&#48141; &#44396;&#54788; . - 모든 작은 문제는 단 한번만 풀어야 함 . - 정답을 구한 작은 문제는 어딘가에 저장 . - 큰 문제를 해결할 때 미리 구한 작은 문제의 정답을 사용 . 피보나치 수열을 다이나믹 프로그래밍으로 구현해보자 | . Top-down . - 큰 문제를 해결할 때 작은 문제가 해결되지 않았으면 작은 문제를 해결하여 큰 문제를 해결 . - 재귀 함수로 구현하는 경우가 대부분 Top-down 방법 . - 메모이제이션 기법 사용 --&gt; 미리 구한 작은 문제의 정답을 어딘가에 저장 . fibonacci = {0:0, 1:1} ## 메모이제이션을 위한 딕셔러니 선언 ## 리스트도 가능 def fibo_top_down(n): if n in fibonacci: return fibonacci[n] fibonacci[n] = fibo_top_down(n-1) + fibo_top_down(n-2) return fibonacci[n] . fibo_top_down(10) . 55 . Bottom-up . - 작은 문제부터 차근차근 해결하여 큰 문제를 해결 . - 반복문 사용 . def fibo_bottom_up1(n): if n &lt;= 1: return n fir_fibo = 0 sec_fibo = 1 for _ in range(n-1): next_fibo = fir_fibo + sec_fibo ## 2번째 피보나치 값 = 0번째 피보나치 값 + 1번째 피보나치 값(n번째 피보나치 값 = n-2번째 피보나치 값 + n-1번째 피보나치 값) fir_fibo = sec_fibo ## 0번째 피보나치 값을 1번째 피보나치 값으로 업데이트 sec_fibo = next_fibo ## 1번째 피보나치 값을 2번째 피보나치 값으로 업데이트 ## 다시 for문 시작으로 돌아가서 1번째 피보나치 값과 2번째 피보나치 값을 통해 3번째 피보나치 값을 구함(이를 n-1번 반복) ## for 문의 역할은 점화식을 통해 0번째와 1번째의 피보나치 값을 가지고 n번째의 피보나치 값을 구한다 return next_fibo . fibo_bottom_up1(10) . 55 . - 또 다른 방법 . - 미리 dp라는 list를 생성 . x = 100 ## 문제 조건에 맞춰서 dp = [-1] * x ## 리스트 초기화 def fibo_bottom_up2(n): ## 굳이 함수를 사용하지 않아도 상관 없음 dp[0] = 0 dp[1] = 1 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] . fibo_bottom_up2(10) . 55 . - bottom-up 방식으로 구현한 위의 두개 코드의 차이점은? . - fibo(9)와 fibo(10)을 구할 때 처음 코드는 fibo_bottom_up1(9)과 fibo_bottom_up1(10) 총 함수를 2번 사용 . - 사실 fibo_bottom_up1(10)을 구했다면 fibo_bottom_up1(9)도 당연히 알지만 각각을 따로 두 번 구했다 . - 첫번째 코드의 경우 다이나믹 프로그래밍은 이미 구한 작은 문제 정답은 또 구하지 않기로 했지만 그렇지 않은 모습 . - 하지만 두번째 코드는 fibo_bottom_up2(10)을 구했다면 dp[0] ~ dp[10]까지 값이 채워져 있기에 fibo_bottom_up2(9)를 하지 않고 dp[9]를 통해 fibo(9)를 구할 수 있음 . - 결론: 두번째 코드 쓰세요 .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/19/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html",
            "relUrl": "/python/algorithm/2021/07/19/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html",
            "date": " • Jul 19, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "파이썬 기본 연산 시간 복잡도(Big O)",
            "content": "&#49884;&#44036; &#48373;&#51105;&#46020; . - 컴퓨터 프로그램의 입력값과 연산 수행 시간의 함수 관계 . - 보통 Big O 표기법으로 나타냄 . Big O &#54364;&#44592;&#48277; . - 알고리즘의 시간 복잡도를 나타내는 척도 . &#50672;&#49328; &#49884;&#44036; &#48373;&#51105;&#46020; . - 자료형별 연산의 시간 복잡도를 나타내자 . &#47532;&#49828;&#53944;(list) . - l은 리스트(list) . - k는 상수 . - 참고: 파이썬 자료형별 연산 시간 복잡도 . Operation Example Complexity Class Notes . index | l[n] | $O(1)$ | | . store | l[n] = 0 | $O(1)$ | store는 변수 저장 | . length | len(l) | $O(1)$ | | . append | l.append(5) | $O(1)$ | | . pop | l.pop() | $O(1)$ | same as l.pop(-1) | . clear | l.clear() | $O(1)$ | similar to l = [] | . slice | l[a:b] | $O(b-a)$ | $l[1:5] to O(l)$, $l[ ; ; : ; ; ] to O(len(l)-0)=O(N)$ | . extend | l.extend(...) | $O(len( dots))$ | depends only on len of extension | . construction | list(...) | $O(len( dots))$ | depends on length of ... iterable | . check ==, != | l1 == l2 | $O(N)$ | | . insert | l[a:b] = ... | $O(N)$ | | . delete | del l[n] | $O(N)$ | depends on n; $O(N)$ in worst case | . containment | x in/not in l | $O(N)$ | linearly searches list | . copy | l.copy() | $O(N)$ | Same as $l[ ; ;: ; ;]$ which is $O(N)$ | . remove | l.remove(...) | $O(N)$ | | . pop | l.pop(n) | $O(N)$ | $O(N-i)$: l.pop(0): $O(N)$ (see above) | . extreme value | min(l)/max(l) | $O(N)$ | linearly searches list for value | . reverse | l.reverse() | $O(N)$ | | . iteration | for v in l: | $O(N)$ | Worst: no return/break in loop | . sort | l.sort() | $O(N Log N)$ | key/reverse mostly does not change | . multiply | $k times l$ | $O(kN)$ | $5 times l$ is $O(N)$: $len(l) times l$ is $O(N^2)$ | . &#51665;&#54633;(set) . - 리스트에 비해 시간 복잡도가 작음 . Operation Example Complexity Class Notes . Length | len(s) | $O(1)$ | | . Add | s.add(5) | $O(1)$ | | . Containment | x in/not in s | $O(1)$ | compare to list/tuple - $O(N)$ | . Remove | s.remove(..) | $O(1)$ | compare to list/tuple - $O(N)$ | . Discard | s.discard(..) | $O(1)$ | | . Pop | s.pop() | $O(1)$ | popped value &quot;randomly&quot; selected | . Clear | s.clear() | $O(1)$ | similar to s = set() | . Construction | set(...) | $O(len(...))$ | depends on length of ... iterable | . check ==, != | s != t | $O(len(s))$ | same as len(t); False in O(1) if the lengths are different | . &lt;=/&lt; | s &lt;= t | $O(len(s))$ | issubset | . &gt;=/&gt; | s &gt;= t | $O(len(t))$ | issuperset s &lt;= t == t &gt;= s | . Union | s | t | $O(len(s)$+$len(t))$ | | . Intersection | s &amp; t | $O(len(s)$+$len(t))$ | | . Difference | s - t | $O(len(s)$+$len(t))$ | | . Symmetric Diff | s ^ t | $O(len(s)$+$len(t))$ | | . Iteration | for v in s: | $O(N)$ | Worst: no return/break in loop | . Copy | s.copy() | $O(N)$ | | . &#54644;&#49884;(dictionary) . - 시간 복잡도가 대부분 $O(1)$이다 . - 같은 함수라면 리스트 대신 딕셔너리를 사용하는 것이 시간 복잡도 면에서 우월함 . Operation Example Complexity Class Notes . Index | d[k] | $O(1)$ | | . Store | d[k] = v | $O(1)$ | | . Length | len(d) | $O(1)$ | | . Delete | del d[k] | $O(1)$ | | . get/setdefault | d.get(k) | $O(1)$ | | . Pop | d.pop(k) | $O(1)$ | | . Pop item | d.popitem() | $O(1)$ | popped item &quot;randomly&quot; selected | . Clear | d.clear() | $O(1)$ | similar to s = {} or = dict() | . View | d.keys() | $O(1)$ | same for d.values() | . Construction | dict(...) | $O(len(...))$ | depends # (key,value) 2-tuples | . Iteration | for k in d: | $O(N)$ | all forms: keys, values, items, Worst: no return/break in loop | .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/15/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B8%B0%EB%B3%B8%EC%97%B0%EC%82%B0-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84.html",
            "relUrl": "/python/algorithm/2021/07/15/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B8%B0%EB%B3%B8%EC%97%B0%EC%82%B0-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84.html",
            "date": " • Jul 15, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "문자열 처리",
            "content": "format &#54632;&#49688; . - 문자열을 포매팅(formatting)하는데 사용 . - 포매팅: 문자열의 원하는 위치에 특정 변수를 삽입 . - 아래 예제를 보자 . &#39;이름:{},나이:{},성별:{}&#39;.format(&#39;홍길동&#39;,&#39;21&#39;,&#39;남&#39;) . &#39;이름:홍길동,나이:21,성별:남&#39; . - 순서대로 홍길동, 21, 남이 {}에 삽입됨 . - 구구단도 쉽게 출력할 수 있음 . i = 2 for j in range(1, 10): print(&#39;{} X {} = {}&#39;.format(i, j, i*j)) . 2 X 1 = 2 2 X 2 = 4 2 X 3 = 6 2 X 4 = 8 2 X 5 = 10 2 X 6 = 12 2 X 7 = 14 2 X 8 = 16 2 X 9 = 18 . [$ star$]&#49548;&#49688;&#51216; &#51088;&#47551;&#49688; &#54364;&#54788;[$ star$] . - 알고리즘 문제를 풀다보면 특정 소수점 자릿수까지 출력을 요구할 때가 있음 . - 계산 결과를 소수점 셋째 자리 까지 표현하려면? . a = 10 b = 3 a / b . 3.3333333333333335 . - 소수점 셋째 짜리 까지 표현하고 싶음 . - format 함수 사용! . a = 10 b = 3 print(&#39;{:.3f}&#39;.format(a / b)) . 3.333 . - round 함수도 되는데? . - round(x, a) --&gt; x를 소수점 a번째 까지 나타냄 . a = 10 b = 3 round(a / b, 3) . 3.333 . - 아래와 같은 경우는? . a = 10 b = 2 a / b . 5.0 . - format 함수 . a = 10 b = 2 print(&#39;{:.3f}&#39;.format(a / b)) . 5.000 . - round 함수 . a = 10 b = 2 round(a / b, 3) . 5.0 . - format 함수는 소수점 셋째 자리까지 나타낸 반면 round 함수는 첫째 자리까지 나타냄 . round 함수를 사용할 때 주의할 점 | . - 파이썬에서는 사사오입의 원칙을 따라 반올림할 자리가 5이면 반올림을 할 때 짝수면 내림, 홀수면 올림 한다 . round(2.5) . 2 . round(-1.5) . -2 . - 오사오입의 원칙으로 반올림 하려면? --&gt; 함수를 따로 만들자 . def round2(number): if number &gt;= 0: if number - int(number) &gt;= 0.5: a = 1 else: a = 0 return int(number) + a else: if int(number) - number &gt; 0.5: a = -1 else: a = 0 return int(number) + a . round2(2.5) . 3 . round2(-1.5) . -1 . - 사사오입의 원칙으로 반올림을 하는 이유는 데이터의 대부분이 .5로 끝나는 자료라면 이를 반올림하면 0.5만큼의 오차가 생기기 때문 . 결론: 원하는 자릿수 까지 나타내려면 round 함수 대신 format 함수를 쓰자 | . join &#54632;&#49688; . - 문자열로 이루어진 리스트를 기준 문자열로 합쳐 문자열로 만듦 . - &#39;구분자&#39;.join(list) . - 구분자에는 문자열, list에는 문자열을 원소로 가지는 리스트가 들어감 . a = [&#39;12&#39;, &#39;45&#39;, &#39;48&#39;] . &#39;-&#39;.join(a) . &#39;12-45-48&#39; . &#39;&#39;.join(a) . &#39;124548&#39; . replace &#54632;&#49688; . - 특정 문자를 다른 문자로 대체 . - &#39;문자열&#39;.replace(&#39;기존 문자&#39;, &#39;바꿀 문자&#39;) . a = &#39;hello world&#39; . a.replace(&#39;h&#39;, &#39;H&#39;) . &#39;Hello world&#39; . a.replace(&#39;&#39;, &#39;!&#39;) . &#39;!h!e!l!l!o! !w!o!r!l!d!&#39; . - 문자열에서는 빈칸도 하나의 문자로 취급 . split &#54632;&#49688; . - 문자열을 구분자를 기준으로 쪼갬 . - &#39;문자열&#39;.split(&#39;구분자&#39;) . a = &#39;!h!e!l!l!o! !w!o!r!l!d!&#39; . a.split(&#39;!&#39;) . [&#39;&#39;, &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;&#39;] . upper &#54632;&#49688; . - 문자열에서 모든 소문자를 대문자로 바꿈 . - &#39;문자열&#39;.upper(&#39;구분자&#39;) . a = &#39;hello world&#39; . a.upper() . &#39;HELLO WORLD&#39; . lower &#54632;&#49688; . - 문자열에서 모든 대문자를 소문자로 바꿈 . - &#39;문자열&#39;.lower(&#39;구분자&#39;) . a = &#39;HELLO WORLD&#39; . a.lower() . &#39;hello world&#39; . count &#54632;&#49688; . - 문자열에서 특정 문자 or 문자열의 개수를 반환함 . - &#39;문자열&#39;.count(&#39;찾는 문자&#39;, 시작 인덱스, 끝 인덱스) . - 시작 인덱스 $ leq$ 문자열 $&lt;$ 끝 인덱스 . a = &#39;HELLO WORLD&#39; . a.count(&#39;L&#39;) . 3 . a.count(&#39;L&#39;, 0, 9) . 2 . a.count(&#39;L&#39;, 0, 10) . 3 . chr &#54632;&#49688; . - 아스키 코드를 문자로 변환함 . - chr(아스키코드) . - 아스키 코드 참고: https://ko.wikipedia.org/wiki/ASCII . chr(65) . &#39;A&#39; . ord &#54632;&#49688; . - 문자를 아스키 코드로 변환함 . - ord(&#39;문자&#39;) . ord(&#39;A&#39;) . 65 .",
            "url": "https://gkswotn12345.github.io/green/python/2021/07/09/%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%B2%98%EB%A6%AC.html",
            "relUrl": "/python/2021/07/09/%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%B2%98%EB%A6%AC.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "그리디 알고리즘",
            "content": "&#44536;&#47532;&#46356; &#50508;&#44256;&#47532;&#51608;(&#50837;&#49900;&#51137;&#51060; &#50508;&#44256;&#47532;&#51608;, Greedy Algorithm)&#51060;&#46976;? . - 다이나믹 프로그래밍이 모든 경우를 확인 한다는 점에서 고안된 알고리즘 . - 매 선택마다 가장 최적인 답을 선택하여 결론을 도출 --&gt; 알파고: 자신 차례마다 가장 승률이 높은 수를 선택 . - but, 매 선택마다 최적이지만 결과가 최적이라는 보장 없음 . - 마시멜로 실험: 당장은 1개, 기다리면 2개 --&gt; 최적해: 기다리고 2개 먹기 . - 하지만 그리디 알고리즘은 지금 최적의 선택인 1개를 선택 --&gt; 최적해 아님 . &#44536;&#47084;&#47732; &#50612;&#46500; &#44221;&#50864;&#50640; &#51096; &#46041;&#51089;&#54616;&#45716;&#44032;? . - 탐욕 선택 속성(greedy choice property): 한번의 선택이 다음 선택과는 무관 . - 최적 부분 구조(optimal substructure): 매 순간의 최적해 --&gt; 문제에 대한 최적해 . &#44536;&#47532;&#46356; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . - 백준 - 설탕 배달: https://www.acmicpc.net/problem/2839 . - 설탕 N kg을 3kg, 5kg봉지에 담아야 하는데 봉지의 수를 최소화 . 최적 부분 구조: 매 순간 봉지의 수를 최소화하려는 행위(3kg 봉지 보다 5kg 봉지 사용)는 문제에 대한 최적해(봉지의 수 최소화) . | 탐욕 선택 속성: 전에 5kg 봉지를 선택하든 3kg 봉지를 선택하든 상관없이 현재 남아있는 무게를 가지고만 판단하여 선택 . | - 그리디 알고리즘: 5kg 봉지로만 담는 것이 최선 . - 만약 5kg 봉지로만 담는 것이 불가능하면? . - 5kg 봉지를 하나 줄이고 3kg 봉지를 사용함 . - 이를 반복함 --&gt; 만약 담는 것이 불가능하면 -1 return . 설탕 배달(그리디 알고리즘) | . - 설탕의 무게는 N kg . 5kg 봉지 선택(최적 판단) . | 5kg 봉지 선택(최적 판단) . | 5kg 봉지만 계속 선택 --&gt; total: k 번 선택(최적 판단) . | 만약 남은 무게가 예컨데 4kg 이라 5kg 봉지에 담지 못한다면 3kg 선택(최적 판단) . | 3kg 에 담고나면 1kg 이 남음 --&gt; 어느 봉지에도 담지 못함 . | 5kg 봉지를 k - 1번 선택하고 3kg 봉지를 선택 . | 5kg 봉지를 0번 선택할 때 까지 반복 --&gt; 이 경우에도 답이 없다면 해가 존재하지 않음 . | N = int(input()) def sugar(n): k = n // 5 l = n % 5 for i in range(k+1): if l == 0: return k break elif l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 21 . - 설탕 무게가 101kg 일시 5kg 19개, 3kg 2개를 선택 .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/09/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "relUrl": "/python/algorithm/2021/07/09/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "DFS와 BFS 알고리즘",
            "content": "&#44618;&#51060; &#50864;&#49440; &#53456;&#49353;(Depth First Search, DFS) . - 모든 정점을 한번만 방문 . - 시작 노드에서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색 . - 방문할 노드와 방문한 노드를 기준으로 탐색 . - 특정 노드가 방문할 노드 --&gt; 탐색, 방문한 노드 --&gt; 지나감 . - 그래프나 트리는 dictionary로 생성 . - stack 구조 와 재귀 함수로 구현 가능 . DFS &#51109;&#51216; . - 단지 현 경로상의 노드들만을 기억하면 되므로 저장공간의 수요가 비교적 적음 . - 목표노드가 깊은 단계에 있을 경우 해를 빨리 구함 . DFS &#45800;&#51216; . - 해가 없는 경로에 깊이 빠질 가능성 존재 . - 얻어진 해가 최단 경로가 된다는 보장이 없음 --&gt; 목표에 이르는 경로가 다수일 때 해에 다다르면 탐색을 끝내버림 --&gt; 이때 얻어진 해는 최적이 아닐 수 있음 . DFS 참고: 깊이 우선 탐색 | . DFS &#53076;&#46300; &#44396;&#54788; . - tree 구조 . - stack 자료 구조 활용: 후입선출(한쪽면이 막힌 원통) . - 노드: [A], [B], [C], [D], [E], [F], [G], [H], [I], [J] . - 분기: [A, B, E], [A, B, F, I], [A, C, G], [A, D, H, I] . tree = {&#39;A&#39;: [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;], ## A는 B, C, D와 연결됨 &#39;B&#39;: [&#39;A&#39;, &#39;E&#39;, &#39;F&#39;], ## B는 A, E, F와 연결됨 &#39;C&#39;: [&#39;A&#39;, &#39;G&#39;], ## C는 A, G와 연결됨 &#39;D&#39;: [&#39;A&#39;, &#39;H&#39;], ## D는 A, H와 연결됨 &#39;E&#39;: [&#39;B&#39;], ## E는 B와 연결됨 &#39;F&#39;: [&#39;B&#39;, &#39;I&#39;], ## F는 B, I와 연결됨 &#39;G&#39;: [&#39;C&#39;], ## G는 C와 연결됨 &#39;H&#39;: [&#39;D&#39;, &#39;J&#39;], ## H는 D, J와 연결됨 &#39;I&#39;: [&#39;F&#39;], ## I는 F와 연결됨 &#39;J&#39;: [&#39;H&#39;]} ## J는 H와 연결됨 . &#47532;&#49828;&#53944; &#54876;&#50857; . - 파이썬에서 리스트는 stack구조여서 DFS에 활용 가능 . - list.pop(i)은 성능이 떨어짐, i번째 이후 원소들을 한 칸씩 앞으로 땡겨야하기 때문 --&gt; $O(N)$ . - 비고: $O(N-i) to O(N)$ 최악의 경우(0번째 인덱스) . - list.pop()은 마지막 원소만 pop하므로 $O(1)$ . - list.pop()--&gt; 맨 마지막에 넣었던 노드를 가져옴: stack구조와 동일(후입선출) . def DFS_list(graph, start_node): visited = [] ## 방문한 노드 stack = [] ## 방문할 노드 stack.append(start_node) ## 방문할 노드에 시작 노드 추가 while stack: ## 방문할 노드가 있다면(리스트에 원소가 있으면 True) node = stack.pop() ## 마지막 노드 추가(스택 구조 사용) if node not in visited: ## 만약 아직 방문한 노드가 아니라면 visited.append(node) ## 이제 방문했으니까 방문한 노드에 추가 stack.extend(reversed(graph[node])) ## 방문한 노드에 연결된 노드를 탐색해보자 print(visited) print(stack) print(&#39;-&#39;) ## 방문과정 확인 return visited ## 방문한 노드를 반환 DFS_list(tree, &#39;A&#39;) ## 마지막은 return 값 . [&#39;A&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;E&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;E&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;I&#39;, &#39;B&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;I&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;] [&#39;D&#39;, &#39;C&#39;, &#39;F&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;] [&#39;D&#39;, &#39;C&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;] [&#39;D&#39;, &#39;G&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;] [&#39;D&#39;, &#39;G&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;] [&#39;D&#39;, &#39;C&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;] [&#39;D&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;] [&#39;H&#39;, &#39;A&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;] [&#39;H&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;] [&#39;J&#39;, &#39;D&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;] [&#39;J&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] [&#39;H&#39;] - [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] [] - . [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] . - return 결과를 보면 DFS 방식임을 알 수 있다 . &#54644;&#49884; &#53580;&#51060;&#48660; &#54876;&#50857; . - if node not in visited: --&gt; visited가 list인 경우 $O(N)$의 시간복잡도를 가짐 . - visited도 해시 테이블(key: value 관계인 자료형: 파이썬의 dictionary)로 구현하면 $O(1)$로 효율$ uparrow$ . - 해시 테이블에 관한 좋은 영상 &gt; 해시 테이블 . def DFS_Hash_Table(graph, start_node): visited = {} ## 방문한 노드 stack = [] ## 방문할 노드 stack.append(start_node) ## 방문할 노드에 시작 노드 추가 while stack: ## 방문할 노드가 있다면(리스트에 원소가 있으면 True) node = stack.pop() ## 마지막 노드 추가(스택 구조 사용) if node not in visited: ## 만약 아직 방문한 노드가 아니라면 visited[node] = True ## 이제 방문했으니까 방문한 노드에 추가 stack.extend(reversed(graph[node])) ## 방문한 노드에 연결된 노드를 탐색해보자 return list(visited.keys()) ## 방문한 노드를 반환 DFS_list(tree, &#39;A&#39;) ## 마지막은 return 값 . [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] . - list를 활용한 코드와 return 결과는 동일하다 . - 시간복잡도면에서 list를 활용한 것 보다 Hash Table을 사용한 것이 성능이 우월하다 . - return 결과를 보면 DFS 방식임을 알 수 있다 . &#51116;&#44480;&#54632;&#49688; &#54876;&#50857; . def DFS_recursive(graph, start_node, visited = {}): visited[start_node] = True for node in graph[start_node]: if node not in visited: DFS_recursive(graph, node, visited) ## 간단히 설명 -&gt; 처음 시작 노드는 &#39;A&#39; -&gt; &#39;A&#39;를 visited에 추가 &#39;A&#39;의 node는 [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;] ## -&gt; &#39;B&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;B&#39;를 start_node로 하여 visited에 추가 -&gt;&#39;B&#39;의 node는 [&#39;A&#39;, E&#39;, &#39;F&#39;] ## -&gt; &#39;A&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;E&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;E&#39;를 start_node로 하여 visited에 추가 -&gt; &#39;E&#39;의 node는 [&#39;B&#39;] ## -&gt; &#39;B&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;B&#39;의 node로 &#39;A&#39;, &#39;E&#39; 방문 했고 이제 &#39;F&#39;만 남았음 ## -&gt; &#39;F&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;F&#39;를 start_node로 하여 visited에 추가 -&gt; &#39;F&#39;의 node는 [&#39;B&#39;, &#39;I&#39;] ## -&gt; &#39;B&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;I&#39;는 아직 방문 안했음 -&gt; 재귀함수 실행 -&gt; &#39;I&#39;를 start_node로 하여 visited에 추가 -&gt; &#39;I&#39;의 node는 [F] ## -&gt; &#39;F&#39;는 이미 방문했음 -&gt; pass ## -&gt; &#39;A&#39;의 node인 [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]중 &#39;B&#39;를 방문 끝냈으므로 &#39;B&#39;를 탐색했던 것처럼 나머지 &#39;C&#39;와 &#39;D&#39;도 탐색하면 끝임 return list(visited.keys()) DFS_recursive(tree, &#39;A&#39;) . [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;, &#39;I&#39;, &#39;C&#39;, &#39;G&#39;, &#39;D&#39;, &#39;H&#39;, &#39;J&#39;] . - 재귀함수를 사용하여 방문한 노드를 visited에 추가한다 . - return 결과를 보면 DFS 방식임을 알 수 있다 . &#45320;&#48708; &#50864;&#49440; &#53456;&#49353;(Breadth First Search, BFS) . - 모든 정점을 한번만 방문 . - 시작 노드에서 인접한 다음 분기로 넘어가면서 탐색 . - 넘어갈 분기가 없으면 하위 노드를 탐색 . - 방문할 노드와 방문한 노드를 기준으로 탐색 . - 특정 노드가 방문할 노드 --&gt; 탐색, 방문한 노드 --&gt; 지나감 . - 그래프나 트리는 dictionary로 생성 . - queue 구조로 구현 가능 . BFS &#51109;&#51216; . - 출발노드에서 목표노드까지의 최단 길이 경로를 보장 . BFS &#45800;&#51216; . - 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요 . - 해가 존재하지 않는다면 유한 그래프(finite graph)의 경우에는 모든 그래프를 탐색한 후에 실패로 끝남 . - 무한 그래프(infinite graph)의 경우에는 결코 해를 찾지도 못하고, 끝내지도 못함 . BFS 참고: 너비 우선 탐색 | . BFS &#53076;&#46300; &#44396;&#54788; . - tree 구조 . - queue 자료 구조 활용: 선입선출(양쪽 면이 뚫린 원통) . - 노드: [A], [B], [C], [D], [E], [F], [G], [H], [I], [J] . - 분기: [A, B, E], [A, B, F, I], [A, C, G], [A, D, H, I] . deque &#54876;&#50857; . - 성능이 좋음 --&gt; $O(1)$ . - 사용: from collections import deque . - 만약 queue = list()라면 queue.pop(0)을 해야함 --&gt; $O(N)$ . - deque를 사용하여 queue.pop(0)대신 queue.popleft( ) 사용 --&gt; $O(1)$ . - DFS와 마찬가지로 visited는 해시 테이블로 구현 . def BFS_queue(graph, start_node): from collections import deque ## deque패키지 import visited = {} ## 방문한 노드 queue = deque() ## 방문할 노드 queue.append(start_node) ## 방문할 노드에 시작 노드 추가 while queue: ## 방문할 노드가 있다면(리스트에 원소가 있으면 True) node = queue.popleft() ## 첫번째 노드 추가(큐 구조 사용) if node not in visited: ## 만약 아직 방문한 노드가 아니라면 visited[node] = True ## 이제 방문했으니까 방문한 노드에 추가 queue.extend(graph[node]) ## 방문한 노드에 연결된 노드를 탐색해보자 print(list(visited.keys())) print(queue) print(&#39;-&#39;) ## 방문과정 확인 return list(visited.keys()) ## 방문한 노드를 반환 BFS_queue(tree, &#39;A&#39;) . [&#39;A&#39;] deque([&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]) - [&#39;A&#39;, &#39;B&#39;] deque([&#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;E&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] deque([&#39;D&#39;, &#39;A&#39;, &#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] deque([&#39;A&#39;, &#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] deque([&#39;E&#39;, &#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] deque([&#39;F&#39;, &#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] deque([&#39;A&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] deque([&#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] deque([&#39;A&#39;, &#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] deque([&#39;H&#39;, &#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;B&#39;, &#39;B&#39;, &#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;B&#39;, &#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;] deque([&#39;I&#39;, &#39;C&#39;, &#39;D&#39;, &#39;J&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;C&#39;, &#39;D&#39;, &#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;D&#39;, &#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;] deque([&#39;J&#39;, &#39;F&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([&#39;F&#39;, &#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([&#39;H&#39;]) - [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] deque([]) - . [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] . - return 결과를 보면 BFS 방식임을 알 수 있다 .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/09/DFS-BFS.html",
            "relUrl": "/python/algorithm/2021/07/09/DFS-BFS.html",
            "date": " • Jul 9, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "정렬 알고리즘",
            "content": "- 데이터를 오름차순으로 정렬해보자! . $O(N^2)$ &#51221;&#47148; . &#49440;&#53469; &#51221;&#47148; . - 가장 작은 수를 첫 번째 인덱스로 선택 그 다음으로 작은 수를 두 번째 인덱스로 선택 . - 이런식으로 가장 큰 수까지 마지막 인덱스로 선택하면 정렬 끝 . &#49440;&#53469; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2] . 2 첫 번째 인덱스와 나머지 $n - 1$개의 수를 비교하여 가장 작은 수와 위치를 바꾼다 . 3 5와 비교하여 1이 가장 작으므로 5와 1의 위치를 바꾼다 . List = [1, 8, 7, 5, 2] . 4 이제 두 번째 인덱스와 나머지$n - 2$개의 수를 비교하여 남은 수 중 가장 작은 수와 위치를 바꾼다 . 5 8과 비교하여 2가 가장 작으므로 8과 2의 위치를 바꾼다 . List = [1, 2, 7, 5, 8] . 6 이런 식으로 $n-1$번째 인덱스와 나머지 1개의 수를 비교하여 오름차순 정렬을 마친다 . List = [1, 2, 5, 7, 8] . &#49440;&#53469; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(n - 1): min_idx = i for j in range(i + 1, n): if List[j] &lt; List[min_idx]: min_idx = j List[i], List[min_idx] = List[min_idx], List[i] print(List) . [1, 8, 7, 5, 2] [1, 2, 7, 5, 8] [1, 2, 5, 7, 8] [1, 2, 5, 7, 8] . &#48260;&#48660; &#51221;&#47148; . - 연속된 인덱스를 비교하여 더 큰 값을 오른쪽으로 보냄 . - 한 사이클을 돌면 가장 큰 값이 맨 뒤에 위치 . - 사이클마다 남은 수 중 가장 큰 값이 뒤에 위치함 . &#48260;&#48660; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2] . 2 첫 번째 인덱스와 두 번째 인덱스를 비교하여 더 큰값을 오른쪽에 위치시킨다 . 3 5와 8을 비교하면 8이 더 크므로 8을 오른쪽을 보낸다 . List = [5, 8, 7, 1, 2] . 4 이제 두 번째 인덱스와 세 번째 인덱스를 비교한다 . 5 8과 7을 비교하면 8이 더 크므로 8을 오른쪽으로 보낸다 . List = [5, 7, 8, 1, 2] . 6 이런식으로 한 사이클을 돌면 8이 마지막에 위치한다 . List = [5, 7, 1, 2, 8] . 7 다시 사이클을 돌면 7이 8 왼쪽에 위치한다 . List = [5, 1, 2, 7, 8] . 8 이런식으로 $n - 1$ 번의 사이클을 돌면 자료가 오름차순으로 정렬된다 . List = [1, 2, 5, 7 ,8] . &#48260;&#48660; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(n - 1, 0, -1): for j in range(i): if List[j + 1] &lt; List[j]: List[j + 1], List[j] = List[j], List[j + 1] print(List) . [5, 7, 1, 2, 8] [5, 1, 2, 7, 8] [1, 2, 5, 7, 8] [1, 2, 5, 7, 8] . &#49341;&#51077; &#51221;&#47148; . - 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교함 . - 자신의 위치를 찾아 삽입함 . - 일반적으로 선택 정렬, 버블 정렬 보다 빠름 . &#49341;&#51077; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2] . 2 두 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . List = [5, 8, 7, 1, 2] . 3 5와 8을 비교하면 8이 더 크므로 8을 오른쪽을 보낸다 . List = [5, 8, 7, 1, 2] . 4 세 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . 5 7과 8을 비교하면 8이 더 크고 5와 7을 비교하면 7이 더 크므로 5와 8사이에 위치한다 . List = [5, 7, 8, 1, 2] . 6 네 번째 원소를 부분 리스트에서 적절한 위치에 삽입 . 7 1이 부분 리스트 중 가장 작으므로 맨 앞에 삽입 . List = [1, 5, 7, 8, 2] . 8 마지막 원소를 부분 리스트에서 적절한 위치에 삽입 . 9 2는 부분 리스트 중 1 다음으로 작으므로 1 오른쪽에 삽입 . List = [1, 2, 5, 7, 8] . &#49341;&#51077; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 2] n = len(List) for i in range(1, n): j = i - 1 key = List[i] while List[j] &gt; key and j &gt;= 0: List[j+1] = List[j] j = j - 1 List[j+1] = key print(List) . [5, 8, 7, 1, 2] [5, 7, 8, 1, 2] [1, 5, 7, 8, 2] [1, 2, 5, 7, 8] . $O(NlogN)$ &#51221;&#47148; . &#48337;&#54633; &#51221;&#47148; . - 리스트 안에 있는 요소들을 왼쪽, 오른쪽 두 그룹으로 나눔 . - 각 그룹을 또 왼쪽, 오른쪽 두 그룹으로 나눔, 이를 요소가 1개 남을 때까지 반복함 . - 나누어진 두 개의 리스트를 병합함 . - 이를 정렬될 때까지 반복함 . &#48337;&#54633; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 2, 3, 9, 4] . 2 그룹을 두 그룹으로 나눈다 . [5, 8, 7, 1], [2, 3, 9, 4] . 3 각 그룹을 두 그룹으로 나눈다 . [5, 8], [7, 1], [2, 3], [9, 4] . 4 이를 요소가 1개 남을 때까지 반복한다 . [5], [8], [7], [1], [2], [3], [9], [4] . 5 이제 나눈 순서의 역순으로 두 그룹씩 오름차순으로 병합한다 . [5, 8], [1, 7], [2, 3], [4, 9] . 6 이를 정렬이 끝날 때까지 반복한다 . [1, 5, 7, 8], [2, 3, 4, 9] . List = [1, 2, 3, 4, 5, 7, 8, 9] . &#48337;&#54633; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . - 위의 병합 정렬 알고리즘을 보면 두 그룹으로 나누고 병합하는 과정을 반복한다 . - 그렇기에 재귀 함수를 사용하여 구현했음 --&gt; 리스트의 길이가 클 경우 많은 재귀 함수 호출이 이루어지기에 시간이 매우 오래걸림(내 생각) . - 먼저 left, right로 나눈 후 나눠진 left를 가지고 또 left, right로 나눈다 . - left를 나누는 것이 끝나면 이제서야 right를 가지고 left, right로 나눈다 . 이 코드는 아래 코드보다 느림 | . - list타입.pop(0)은 $O(N)$임 . List = [5, 8, 7, 1, 2, 3, 9, 4] def mergeSort(x): if len(x) &lt;= 1: return x mid = len(x) // 2 left = x[:mid] right = x[mid:] next_left = mergeSort(left) next_right = mergeSort(right) return merge(next_left, next_right) def merge(left, right): sorted_list = [] while left and right: if left[0] &lt; right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) while left: sorted_list.append(left.pop(0)) while right: sorted_list.append(right.pop(0)) return sorted_list mergeSort(List) . - 그래서 pop(0)함수를 사용하지 않음 . - 아래의 코드가 이해가 잘 안될 수 있다 . - 그래서 어떻게 split하고 merge가 되는지 알아보기로 하자 . - 밑의 출력을 보니 처음으로 merge()에 대입된 left와 right는 [5]와 [8]임을 알 수 있다 . - 처음으로 넣은 값은 [5, 8, 7, 1, 2, 3, 9, 4]인데 신기하다 . - 자세히 살펴보자 . List = [5, 8, 7, 1, 2, 3, 9, 4] k = 0 def mergeSort(x): ## 나누기 n = len(x) if n &lt;= 1: return x mid = n // 2 left = x[:mid] ## mid를 기준으로 왼쪽 right = x[mid:] ## mid를 기준으로 오른쪽 next_left = mergeSort(left) ## 재귀적으로 나누기 next_right = mergeSort(right) ## 재귀적으로 나누기 global k k += 1 print(&#39;return 횟수 %s&#39; %k) return merge(next_left, next_right) def merge(left, right): ## 병합하기 i = 0 j = 0 sorted_list = list() print(left) print(right) while i &lt; len(left) and j &lt; len(right): ## left와 right중 더 작은 값 넣기 if left[i] &lt; right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 ## left와 right 중 남은 값을 넣어주기 while i &lt; len(left): sorted_list.append(left[i]) i += 1 while j &lt; len(right): sorted_list.append(right[j]) j += 1 return sorted_list print(mergeSort(List)) . return 횟수 1 [5] [8] return 횟수 2 [7] [1] return 횟수 3 [5, 8] [1, 7] return 횟수 4 [2] [3] return 횟수 5 [9] [4] return 횟수 6 [2, 3] [4, 9] return 횟수 7 [1, 5, 7, 8] [2, 3, 4, 9] [1, 2, 3, 4, 5, 7, 8, 9] . - 우선 mergeSort 함수에서 return은 총 7번 일어남을 알 수 있다 . - 각 상황에서 어떤일이 일어나는지 알아보자 . 우리는 print(mergeSort(List))를 통해 mergeSort 함수에 List라는 input을 넣었다 . | mergeSort에는 [5, 8, 7, 1, 2, 3, 9, 4]이 대입됐다 . | left는 [5, 8, 7, 1], right는 [2, 3, 9, 4]이다 . | next_left는 mergeSort([5, 8, 7, 1]), next_right는 mergeSort([2, 3, 9, 4])이다 . | merge(next_left, next_right)값을 return한다 . | 근데 merge(next_left, next_right)를 return하려고 보니까 next_left, next_right 값을 알아야한다 . | 4번으로 돌아가서 보면 mergeSort([5, 8, 7, 1])와 mergeSort([2, 3, 9, 4])를 구해야 한다 --&gt; 그럼 구하면 되지 . | mergeSort()에 [5, 8, 7, 1]이 대입된다 . | 그러면 mergeSort()는 merge(mergeSort([5, 8]), mergeSort([7, 1]))를 return한다 . | 근데 mergeSort([5, 8]), mergeSort([7, 1])값은 뭐지?? --&gt; 이것도 구해야 한다 . | mergeSort([5, 8])을 구하면 next_left = [5], next_right = [8]이다 . | merge(next_left, next_right)는 merge([5], [8])이 되고 드디어 merge()함수에 left와 right가 대입된다 --&gt; 그래서 처음 left와 right로 출력된 값이 [5]와 [8]이었던 것: return1 . | merge([5], [8])은 [5,8]인 sorted_list를 return한다 --&gt; mergeSort([5, 8])은 [5,8]을 return한다 즉, mergeSort([5, 8])= [5, 8] . | 이제 mergeSort([5, 8])를 구했으니 mergeSort([7, 1])값을 구할 차례이다 . | mergeSort([7, 1])은 merge([7], [1])이고 [1, 7]을 return한다 --&gt; mergeSort([7, 1]) = [1, 7]: return2 . | 이제 8번을 보자. 8번은 merge([5, 8, 7, 1])이고 merge(mergeSort([5, 8]), mergeSort([7, 1]))를 return한다 . | 이때는 mergeSort([5, 8])와 mergeSort([7, 1])를 모르는 상태였지만 이제는 구해서 알고 있다 . | merge([5, 8], [1, 7])을 구해보면 sorted_list로 [1, 5, 7, 8]을 return한다: return3 . | 이제 mergeSort([2, 3, 9, 4])을 구할 차례이다. 이는 위에서 한 방식대로 따라하면 된다 . | 결과적으로 print(mergeSort(List))는 [1, 2, 3, 4, 5, 7, 8, 9]을 출력하게 된다 . | - 메모리 아끼는 병합 정렬 참고: https://www.daleseo.com/sort-merge/ . $O(N)$ &#51221;&#47148; . &#44228;&#49688; &#51221;&#47148; . - 카운팅 정렬이라고도 한다 . - 양수만 가능, 값의 범위가 크면 안됨(메모리 크기를 넘기면 안됨) . - 수의 범위가 작다면(입력으로 주어지는 값들의 개수: 0 ~ 1이라고 수의 범위가 작은 것이 아님... 0 ~ 1사이의 수는 무한개이다) 카운팅 정렬을 통해 빠르게 정렬할 수 있음 . - 비교 정렬이 아님 --&gt; 위의 코드들은 다른 요소값과 비교하는데 카운팅 정렬은 비교없이 데이터를 정렬함 . - 입력으로 주어지는 input의 개수는 큰데 주어지는 값의 개수가 적다면 메모리 관점에서 효율적이다 . - 예로 input이 최대1억개인데 값이 1 ~ 10까지라면 위에서 다룬 정렬은 1억크기의 배열이 필요하지만 카운팅 정렬에 경우는 크기가 10인 배열을 만들면 된다 . - 하지만, 최대 수를 기준으로 배열을 만든다(최대값이 100인 경우 크기가 100인 리스트 생성) . - 그렇기에 [0, 1, 1, 1, 100]인 리스트를 정렬한다고 보면 숫자는 3개 뿐이지만 최대값이 100이므로 크기가 100인 리스트를 만들어야 한다 --&gt; 심한 메모리 낭비 . &#44228;&#49688; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; . 1 최대 값이 k인 크기가 $n$인 정렬되지 않은 리스트가 있다 . List = [5, 8, 7, 1, 1, 3, 9] . 2 k = 10 이라고 가정하자. [0] * (k+1) 리스트를 만든다 --&gt; 파이썬에서 인덱스는 0부터 시작하기 때문 . count = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] . 3 List 요소의 값을 x라 하면 count[x]의 값을 +1 해준다 . count = [0, 2, 0, 1, 0, 1, 0, 1, 1, 1, 0] . 4 count 리스트에서 자기(x) 앞에 몇개의 숫자가 있는지를 바탕으로 x의 위치를 결정하여 정렬한다. 예로 3의 경우 자기 앞에 숫자 2개가 있으므로 3번째이다 . List = [1, 1, 3, 5, 7, 8, 9] . &#44228;&#49688; &#51221;&#47148; &#50508;&#44256;&#47532;&#51608; &#53076;&#46300; &#44396;&#54788; . List = [5, 8, 7, 1, 1, 3, 9] def counting_sort(arr): count = [0] * (max(arr) + 1) sorted_list = [0] * len(arr) for i in arr: count[i] += 1 ## arr에 있는 수를 몇개인지 카운팅함 for j in range(1, max(arr) + 1): count[j] += count[j - 1] ## count[j] 앞에 몇 개의 숫자가 있는지 저장 ## count[5] = 10이라면 5가 x번 등장했다고 할 때 5앞에 10-x개의 숫자가 있다는 의미이므로 sorted_list[10-x : x]에 5가 위치한다. (x 번째 포함 no, x-1번째 까지) for k in range(len(arr)): sorted_list[count[arr[k]] - 1] = arr[k] ## 인덱스는 0부터 시작하므로 -1을 해줌 count[arr[k]] -= 1 return sorted_list print(counting_sort(List)) . [1, 1, 3, 5, 7, 8, 9] .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/07/04/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "relUrl": "/python/algorithm/2021/07/04/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html",
            "date": " • Jul 4, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "확률 분포",
            "content": "- 2학기에 수리통계학 배움 . - 내용 추가 + 확률 밀도 함수 유도 과정 추가 + 증명 안하고 넘어갔던 부분 추가 예정 . - 만약 수리통계학에 없는 내용이라면? &gt; . . . . . . . &#54869;&#47456; &#48516;&#54252;&#46976;? . - 확률 분포(probability distribution)는 확률 변수가 특정한 값을 가질 확률을 나타내는 함수를 의미한다 --&gt; 출처: 확률 분포 . &#44536;&#47111;&#45796;&#47732; &#54869;&#47456; &#48320;&#49688;&#46976;? . - 확률변수(Random Variable)란 무작위 실험을 했을 때, 특정 확률로 발생하는 각각의 결과를 수치로 표현한 변수 . - 무작위 실험 --&gt; 동전 던지기 . - 특정 확률 --&gt; 앞면이 나올 확률 $ frac{1}{2}$, 뒷면이 나올 확률 $ frac{1}{2}$ . - 수치 --&gt; 앞면 = $1$, 뒷면 = $2$ . &#50672;&#49549; &#54869;&#47456; &#48516;&#54252; . - 연속 확률 변수가 가지는 확률 분포 . - 이산 확률 변수는 확률을 $[ star]P(X=x)[ star]$와 같이 표현 가능, 연속 확률 변수는 불가능 . - 연속 확률 변수는 확률을 $[ star]P(A leq X leq B)[ star]$로 표현 가능 . &#51221;&#44508;&#48516;&#54252; . - 정규 분포는 수집된 자료의 분포를 근사하는 데에 자주 사용됨 . - 중심극한정리에 의하여 독립적인 확률변수들의 평균은 정규 분포에 가까워지는 성질이 있기 때문임 . - 신뢰구간이나 가설검정 등의 모델에서 사용 . - 기호로는 $N sim ( mu, sigma^{2})$ . - 정규분포의 기댓값, 중앙값, 최빈값은 $ mu$, 분산은 $ sigma^{2}$ . - 표준정규분포는 평균이 0, 표준편차가 1인 경우임 --&gt; $N sim (0, 1)$ . - 정규분포에서 $ mu pm2 sigma$에 전체 데이터 중 $95 %$가 존재 . &#54364;&#51456;&#54868; . - 정규 분포 밀도 함수에서 $Z =$ $ frac{X - mu}{ sigma}$ 를 통해 $X$(원점수)를 $Z$($z$점수) 표준화하여 표준정규분포(z-분포)를 얻을 수 있다 . &#51221;&#44508;&#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688;(PDF) . $f(x) = frac{1}{ sqrt{2 pi sigma^{2}}}e^{- frac{(x-m)^{2}}{2 sigma^{2}}}$ . &#51221;&#44508;&#48516;&#54252; plot . import numpy as np np.random.normal(loc, scale, size) . - loc는 평균, scale은 표준편차, size는 표본의 수 . np.random.normal(loc = 0, scale = 1, size = 1000) . - np.random.normal(loc = 0, scale = 1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.normal(loc = 0, scale = 1, size = 1000) plt.hist(sample) plt.title(&#39;np.random.normal(loc = 0, scale = 1, size = 1000)&#39;) plt.show() . &#44512;&#51068; &#48516;&#54252; . - 모든 확률 변수에 대하여 구간 내에서 균일한 확률을 가짐 . - 임의의 구간 내에서 균일한 확률을 가지기에 난수 생성기로 쓰임 . - 이산 확률 변수에서도 가능 . &#44512;&#51068; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x) = begin{cases} frac{1}{b-a} &amp; text{for $x in [a,b]$} 0 &amp; text{otherwise} end{cases} $ . - $f(x)$는 구간 $[a,b]$에서 균등한 확률을 가짐 . &#44512;&#51068; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = frac{a+b}{2}$ . - $Var(X) = frac{(b-a)^{2}}{12}$ . &#44512;&#51068; &#48516;&#54252; plot . import numpy as np np.random.uniform(low, high, size) . - low는 출력값의 최소 경계, high은 출력값의 최대 경계, size는 표본의 수 . np.random.uniform(low = 0, high = 1, size = 1000) . - np.random.uniform(low = 0, high = 1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.uniform(low = 0, high = 1, size = 1000) plt.hist(sample) plt.title(&#39;np.random.normal(loc = 0, scale = 1, size = 1000)&#39;) plt.show() . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;($x^2$&#48516;&#54252;) . - $k$개의 서로 독립인 표준 정규 확률변수를 각각 제곱하여 합해 얻어진 분포 . - 이때 $k$는 자유도이며 카이제곱 분포의 매개변수 . - 분산의 퍼진 정도를 분포로 보여줌 . - 모분산을 구하거나 적합도 검정, 독립성/동질성 검정 등의 모델에서 사용 . - $k$개의 독립적이고 표준정규분포를 따르는 확률변수 $Z_1, dots,Z_k$가 있을 때 자유도 $k$의 카이제곱 분포는 . - 확률변수 $Q = sum^{k}_{i=1}Z{_i}{^2}$의 분포임 . - 따라서 $Q sim X{_k}{^i}$ . - 참고: 카이제곱 분포 . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x; k) = frac{1}{2^ frac{k}{2} Gamma( frac{k}{2})}x^{ frac{k}{2}-1}e^{- frac{x}{2}}$ . - $ Gamma( frac{k}{2})$는 감마함수이다 . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = k$ . - $Var(X) = 2k$ . &#52852;&#51060;&#51228;&#44273; &#48516;&#54252; plot . import numpy as np np.random.chisquare(df, size) . - df는 자유도, size는 표본의 수 . np.random.chisquare(df = 10, size = 1000) . - np.random.chisquare(df = 10, size = 1000)를 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.chisquare(df = 10, size = 1000) plt.hist(sample) plt.title(&#39;np.random.chisquare(df = 10, size = 1000)&#39;) plt.show() . - 자유도(df)를 바꿔볼까? . - df = 5 . np.random.seed(1) sample = np.random.chisquare(df = 5, size = 1000) plt.hist(sample) plt.title(&#39;np.random.chisquare(df = 5 , size = 1000)&#39;) plt.show() . - df = 1 . - 표준정규분포의 제곱은 자유도가 1인 카이제곱 분포를 따름 . - $V = ( frac{X- mu}{ sigma})^{2} sim X^{2}(1)$ . - 표본을 10000개 뽑아 둘을 비교해보자! . np.random.seed(2) sample = np.random.chisquare(df = 1, size = 10000) plt.hist(sample) plt.title(&#39;np.random.chisquare(df = 1 , size = 10000)&#39;) plt.show() . np.random.seed(2) sample = np.random.normal(loc = 0, scale = 1, size = 10000) sample = sample**2 plt.hist(sample) plt.title(&#39;square of a standard normal distribution&#39;) plt.show() . - 두 분포가 거의 동일하다 . - 표준정규분포의 제곱은 자유도가 1인 카이제곱 분포를 따른다는 것을 확인할 수 있다 . &#51648;&#49688; &#48516;&#54252; . - 사건이 서로 독립적일 때, 일정 시간동안 발생하는 사건의 횟수가 포아송 분포를 따른다면, 다음 사건이 일어날 때까지 대기 시간은 지수분포를 따른다(지수 분포) . - 기하 분포에서 베르누이 시행 횟수$n$이 많아지고 성공 확률 $p$가 작아지면 지수 분포로 수렴 . - 감마 분포에서 $ alpha = 1$일 때의 특수한 경우임(감마 분포 참고) . &#51648;&#49688; &#48516;&#54252;&#51032; &#47924;&#44592;&#50613;&#49457; . - 기하 분포의 무기억성과 같은 내용임 . - $P(A|B)$ --&gt; 사건 B가 발생한 상황에서 사건 A가 발생할 확률 . - $P(X&gt;s+t|X&gt;t) = P(X&gt;s)$ . - 핸드폰의 고장률이 지수 분포를 따른다면 내가 핸드폰을 처음 구매하고 1년안에 고장날 확률 = 핸드폰을 5년 사용한 시점에서 1년 안에 고장날 확률 . - 물론 현실은 핸드폰을 5년 사용한 후에 고장날 확률이 더 크다 . - 지수 분포는 무기억 성질을 갖는 유일한 연속 확률 분포 . &#51648;&#49688; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x; beta) = frac{1}{ beta}e^{- frac{x}{ beta}}, ; x &gt; 0$ . - 위의 확률 밀도 함수는 감마 분포의 확률 밀도 함수에서 $ alpha = 1$을 대입한 결과이다 . - 여기서 $ beta$는 사건 사이의 평균 시간인데 포아송 분포의 모수인 $ lambda$는 단위 시간당 사건의 평균 발생 횟수이다 . - 위의 지수 분포 설명에서 사건의 횟수가 포아송 분포를 따를 때를 전제로 대기 시간은 지수 분포를 따른다고 했다 . - 그렇기에 여기서는 위의 확률 밀도 함수 대신 포아송 분포의 모수인 $ lambda = frac{1}{ beta}$ 를 통해 지수 분포의 확률 밀도 함수를 나타내기로 함 . - 위아래 확률 밀도 함수 둘 다 맞는 표현임, 그런데 numpy.random.exponential이 위의 확률 밀도 함수를 사용하므로 위의 확률 밀도 함수를 기억하는 것이 좋을 것 같음 . $f(x; lambda) = lambda e^{- lambda x}, ; x&gt;0$ . &#51648;&#49688; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = frac{1}{ lambda}$ . - $Var(X) = frac{1}{ lambda^{2}}$ . - 기댓값은 어찌보면 당연한데 단위 시간 동안 사건이 $ lambda$번 발생한다면 대기 시간은 $ frac{1}{ lambda}$여야 $ lambda times frac{1}{ lambda} = 1 text{(단위 시간)}$이 성립한다 . &#51648;&#49688; &#48516;&#54252; plot . - 사건이 발생하고 다음 사건이 발생하기 까지의 대기 시간에 대한 확률 분포 . - numpy.random.exponential의 확률 밀도 함수는 $f(x; beta) = frac{1}{ beta}e^{- frac{x}{ beta}}, ; x &gt; 0$임 (numpy 지수 함수) . import numpy as np np.random.exponential(scale, size) . - scale은 $ beta$ = 대기 시간, size는 표본의 수 . np.random.exponential(scale = 2, size = 1000) . - 우리 집 앞에서 1시간당 평균 0.5명이 넘어진다 --&gt; $ lambda text{(사건의 빈도)} = 0.5$이므로 대기 시간 $ beta text{(대기 시간)} = 2$ . - 다시말하면 우리 집 앞에서 한 명이 넘어지고 다음 사람이 넘어지기 까지 2시간이 걸린다 . - 이때 한 사람이 넘어지고 다음 사람이 넘어지기 까지 걸리는 대기 시간에 대한 분포를 그려보자 . - np.random.exponential(scale = 2, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.exponential(scale = 2, size = 1000) plt.hist(sample) plt.title(&#39;np.random.exponential(scale = 2, size = 1000)&#39;) plt.show() . &#44048;&#47560; &#48516;&#54252; . - 감마 분포는 지수 분포나 푸아송 분포 등의 매개변수에 대한 켤레 사전 확률 분포 . - 이에 따라 베이즈 확률론에서 사전 확률 분포로 사용 . - $ alpha$개의 사건이 일어날 때까지 걸리는 대기 시간에 대한 분포 . - 지수 분포를 한 번의 사건이 아닌 여러 개의 사건으로 확장 . - 지수 분포의 모수가$ beta$ --&gt; $ beta$ = 사건 사이의 평균 시간 . - 모수가 $ beta$인 지수 분포를 따르는 확률 변수 X가 $ alpha$개가 있고 각 확률 변수 X는 i.i.d를 따름 --&gt; 이 확률 변수의 합은 모수가 $ alpha, beta$인 감마 분포를 따름 . - 참고: 감마 분포 . &#44048;&#47560;&#54632;&#49688;(Gamma Function) . - 복소수 범위까지 일반화 된 팩토리얼(!) . $ Gamma( alpha) = int_{0}^{ infty}x^{ alpha-1}e^{-x}dx, , alpha geq 0$ . &#44048;&#47560;&#54632;&#49688; &#49457;&#51656; . - $ Gamma( alpha+1) = alpha Gamma( alpha)$ . - $ Gamma(n) = (n-1)!, , n in mathbb{N}$ . - $ Gamma( frac{1}{2}) = sqrt{ pi}$ . &#44048;&#47560; &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x; alpha, beta) = frac{1}{ beta^{ alpha} Gamma( alpha)}x^{ alpha - 1}e^{- frac{x}{ beta}},(x, alpha, beta geq 0)$ . - 확률 변수 $X$가 감마 분포를 따른 다면 $X sim Gamma( alpha, beta)$ . - 발생하기 까지의 평균$ beta = frac{1}{ lambda}$의 시간이 소요되는 어떤 사건이 $ alpha$번 발생하는데 걸리는 시간 $X$에 대한 확률 분포 . - $ lambda$는 포아송 분포의 모수로 단위 시간당 사건의 평균 발생 횟수 . - $ alpha = 1$일 때 $ lambda = frac{1}{ beta}$인 지수 분포를 따름 . - $X sim Gamma(1, beta) Leftrightarrow exp( frac{1}{ beta})$ . &#44048;&#47560; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = alpha beta$ . - $Var(X) = alpha beta^{2}$ . &#44048;&#47560; &#48516;&#54252; plot . - $ alpha$는 형태 모수(shape parameter), $ beta$는 척도 모수(scale parameter) . - 사건이 발생하고 다음 사건이 발생하기 까지의 평균 대기 시간이 $ beta$일 때 $ alpha$번의 사건이 발생하는데 걸리는 시간에 대한 확률 분포 . import numpy as np np.random.gamma(shape, scale, size) . - shape는 $ alpha$, scale은$ beta$, size는 표본의 수 . np.random.gamma(shape = 2, scale = 2, size = 1000) . - 우리 집 앞에서 1시간당 평균 0.5명이 넘어진다 --&gt; $ lambda = 0.5$이므로 $ beta = 2$ . - 다시말하면 우리 집 앞에서 한 명이 넘어지고 다음 사람이 넘어지기 까지 평균 2시간이 걸린다 . - 이때 2명의 사람이 넘어지기 까지 걸리는 시간에 대한 분포를 그려보자 . - np.random.gamma(shape = 2, scale = 2, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.gamma(shape = 2, scale = 2, size = 1000) plt.hist(sample) plt.title(&#39;np.random.gamma(shape = 2, scale = 2, size = 1000)&#39;) plt.show() . - 위에서 지수 분포는 감마 분포에서 $ alpha = 1$인 특수한 경우라고 했음 . - 진짜로 동일한지 $ beta = 4$인 지수 분포와 $ alpha = 1, beta = 4$인 감마 분포를 히스토그램을 그려 비교하자 . np.random.seed(1) sample1 = np.random.gamma(shape = 1, scale = 4, size = 1000) sample2 = np.random.exponential(scale = 4, size = 1000) fig, ax = plt.subplots(1, 2, figsize = (14, 4)) ax[0].hist(sample1) ax[1].hist(sample2) ax[0].set_title(&#39;np.random.gamma(shape = 2, scale = 4, size = 1000)&#39;) ax[1].set_title(&#39;np.random.exponential(scale = 4, size = 1000)&#39;) plt.show() . - 히스토그램을 통해 비교하니 $ alpha = 1$인 감마 분포는 지수 분포와 동일함을 알 수 있다 . $ alpha$&#50752;$ beta$&#50640; &#46384;&#47480; &#44048;&#47560; &#48516;&#54252; &#47784;&#50577;(&#52628;&#44032; &#50696;&#51221;) . - $ alpha$는 형태 모수로 $ alpha$가 커질수록 그래프의 모양이 종모양에 가까워짐 . - $ beta$는 척도 모수로 $ beta$가 커질수록 그래프가 퍼짐 . - 그래프 추가 예정 . t &#48516;&#54252; . - 표본평균$ bar{X}$을 이용해 정규분포의 평균을 해석 --&gt; 모집단이 정규분포를 따를 때 . - 표준화한 표본평균의 분포: 모표준편차를 알고 있음($ frac{x- mu}{ sqrt{ frac{ sigma}{n}}}$) --&gt; 정규분포, 모표준편차를 모르고 표본표준편차를 알고 있음($ frac{x- bar{x}}{ sqrt{ frac{s}{n}}}$) --&gt; t분포 . - 다음의 확률 분포로 정의 --&gt; $ frac{Z}{ sqrt{ frac{V}{ nu}}}$ . - $Z$는 표준정규분포, $V$는 자유도$ nu$인 카이제곱 분포 . - 자유도가 커질수록 표준정규분포에 가까워짐 (중심극한정리와 무관) --&gt; 보통 표본 크기 $n geq30$이면 표준정규분포와 가깝다고 한다 . - [$ star$]표본크기가 커지면 표준정규분포에 가까워짐[$ star$] --&gt; 표본 크기가 커진다는 것은 모집단에 가까워진다는 의미이므로 표본표준편차도 모표준편차에 가까워짐 . - 참고: t분포 . t &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x) = frac{ Gamma( frac{ nu + 1}{2})}{ sqrt{ nu pi} Gamma( frac{ nu}{2})}(1+ frac{x^2}{ nu})^{-( frac{ nu+1}{2})}$ . t &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = 0, ; nu &gt; 1$ . - $Var(X) = frac{ nu}{ nu-2} ,( nu&gt;2), ; infty ,(1&lt;v leq2)$ . t &#48516;&#54252; plot . import numpy as np np.random.standard_t(df, size) . - df는 자유도, size는 표본의 수 . np.random.standard_t(df = 5, size = 1000) . - np.random.standard_t(df = 5, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.standard_t(df = 5, size = 1000) plt.hist(sample) plt.title(&#39;np.random.standard_t(df = 5, size = 1000)&#39;) plt.show() . - $x = 0$을 기준으로 대칭임 . - 자유도가 5이므로 표본 크기는 6 . - 모표준편차 대신 표본표준편차를 알고 표본 크기가 6일 때 표준화한 표본 평균($ frac{x- bar{x}}{ sqrt{ frac{s}{n}}}$)에 대한 분포 . - t분포는 표준정규분포보다 꼬리 부근에 밀도가 높음 --&gt; 모표준편차 대신 표본표준편차를 사용하기 때문 --&gt; 표본의 특성상 추출할 때마다 다르므로 변동성이 있음 . F &#48516;&#54252; . - F 검정과 분산분석(ANOVA)등에서 주로 사용됨 . - 카이제곱 분포가 한 집단의 분산에 대해 다뤘다면 F 분포는 두 집단의 분산에 대해 다룸 . - 두 확률변수 $V_1, V_2$가 각각 자유도가 $ nu_1, nu_2$이고 서로 독립인 카이제곱 분포를 따를 때 다음의 확률변수 F는 자유도가 ($ nu_1, nu_2$)인 F-분포를 따름 . - 적률생성함수가 존재하지 않음 . - $F = frac{ frac{V_1}{ nu_1}}{ frac{V_2}{ nu_2}} sim F( nu_1, nu_2)$ . F &#48516;&#54252; &#49457;&#51656; . - 분자와 분모의 자유도가 뒤바뀐 F 분포 성질: $F_{ nu_1, nu_2, alpha} = frac{1}{F_{ nu_2, nu_1, alpha}}$ . - t 분포를 제곱하면 분자와 분모의 자유도가 각각 1, $ nu$인 F분포가 된다 . - $t = frac{Z}{ sqrt{ frac{U}{ nu}}} sim t_{ nu}$ . F &#48516;&#54252;&#51032; &#54869;&#47456; &#48128;&#46020; &#54632;&#49688; . $f(x) = frac{ Gamma( frac{ nu_1+ nu_2}{2})( frac{ nu_1}{ nu_2})^{ frac{ nu_1}{2}}x^{ frac{ nu_1}{2}-1}}{ Gamma( frac{ nu_1}{2}) Gamma( frac{ nu_2}{2})(1+ frac{ nu_1}{ nu_2}x)^{ frac{ nu_1+ nu_2}{2}}}$ . F &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X)= frac{ nu_2}{ nu_2-2}, ; nu_2&gt;2$ . - $Var(X)= frac{2{ nu_{2}}^{2}( nu_1+ nu_2-2)}{ nu_1( nu_2-2)^{2}( nu_2-4)}, ; nu_2&gt;4$ . F &#48516;&#54252; plot . import numpy as np np.random.f(dfnum, dfden, size) . - dfnum은 분자의 자유도, dfden은 분모의 자유도, size는 표본의 수 . np.random.f(dfnum = 1, dfden = 10, size = 1000) . - np.random.f(dfnum = 1, dfden = 5, size = 1000)를 히스토그램으로 나타내보면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.f(dfnum = 1, dfden = 10, size = 1000) plt.hist(sample) plt.title(&#39;np.random.f(dfnum = 1, dfden = 10, size = 1000)&#39;) plt.show() . &#48288;&#53440; &#48516;&#54252;(&#51089;&#49457; &#50696;&#51221;) . &#51060;&#49328; &#54869;&#47456; &#48516;&#54252; . - 이산 확률 변수가 가지는 확률 분포 . &#48288;&#47476;&#45572;&#51060; &#49884;&#54665; . - 임의의 결과가 성공 또는 실패와 같이 가능한 결과가 2 가지 . &#48288;&#47476;&#45572;&#51060; &#49884;&#54665; &#51312;&#44148; . - 각 시행의 결과는 상호 배타적인 두 사건(성공 or 실패)으로 구분 . - 성공 확률 $p$, 실패 확률 $q$일 때, $p+q=1$ . - 각 시행은 독립적 . &#51060;&#54637; &#48516;&#54252; . - 서로 독립이고 동일한 베르누이 분포를 따르는 확률변수$X_1, dots,X_n$을 모두 합한 것 --&gt; $X = sum limits_{i=1}^{n}X_i$ . - 성공 확률이 $p$인 베르누이 시행을 독립적으로 $n$번 반복했을 때 성공 횟수 $X$는 이항 분포를 따름 . - 기호로는 $X sim B(n,p)$ . - 독립적 시행 --&gt; 각 시행은 서로 영향을 주지 않음 . &#51060;&#54637; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688;(PMF) . $f(x) ,= , _{n} rm C_{x} ,p^{x} ,(1-p)^{n-x} ,= , binom{n}{x} ,p^{k} ,(1-p)^{n-x}$ . - 성공 확률 $p$인 베르누이 시행을 $n$번 시행하여 그 중 $x$번을 성공할 확률 질량 함수 . - 베르누이 분포는 이항 분포에서 $n=1$일 때이다 . &#51060;&#54637;&#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = np$ . - $Var(X) = np(1-p)$ . &#51060;&#54637; &#48516;&#54252; plot . import numpy as np np.random.binomial(n, p, size) . - $n$은 표본 크기, $p$는 성공 확률, size는 표본의 수 . np.random.binomial(n = 50, p = 0.5, size = 1000) . - 성공 확률이 p = 0.5인 베르누이 시행을 n = 50번 반복하는 것을 표본 하나로 두고 표본을 size = 1000번 추출한다 . - 동전 던지기($p=0.5$)를 $n$ = $50$번 시행하여 앞면이 나온 횟수($X=0,1,2, dots,49,50$)를 하나의 표본이라 할 때 표본을 $size = 1000$번 추출한다 . - np.random.binomial(n = 10, p = 0.5, size = 1000)을 히스토그램으로 나타내면? . - $np geq 5$ 이면 이항분포를 정규분포로 근사할 수 있다 . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.binomial(n = 10, p = 0.5, size = 1000) plt.hist(sample) plt.title(&#39;np.random.binomial(n = 10, p = 0.5, size = 1000)&#39;) plt.show() . &#54252;&#50500;&#49569; &#48516;&#54252; . - 단위 시간, 단위 공간 안에 어떤 사건이 몇 번 발생할 것인지를 표현하는 이산 확률 분포 . - 이항 분포에서 시행횟수$n$이 매우 크고 성공 확률$p$가 매우 작은 경우 성공횟수는 포아송 분포로 근사 가능 &gt; 나중에 증명 . - 음이항 분포에서 성공횟수$x$가 매우 크고 실패 확률$p$가 매우 작은 경우 실패횟수는 포아송 분포로 근사 가능 &gt; 나중에 증명 . - 포아송 분포의 모수($ lambda$)는 단위 시간에서 사건의 평균 발생 횟수 . &#54252;&#50500;&#49569; &#48516;&#54252; &#51204;&#51228; &#51312;&#44148; . - 독립성: 1시간 동안 우리 집 앞에서 넘어진 사람 수와 친구 집앞에서 넘어진 사람 수는 독립이다 . - 일정성: 1시간 동안 평균 3명이 넘어졌다면 2시간 동안에는 평균 6명이 넘어진다 . - 비집락성: 우리 집 앞에서 같은 시간에 두 명 이상이 넘어질 확률은 0이다 . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) = frac{e^{- lambda} lambda^{x}}{x!}$ . - $x$는 단위 시간에서 사건의 발생 횟수, $ lambda$는 단위 시간에서 사건의 평균 발생 횟수 . - $ lambda = 10$, $x = 7$ --&gt; 단위 시간에서 사건의 평균 10번 발생할 때 7번 발생할 확률은? . - 우리 집 앞에서 1시간에 사람이 평균적으로 10명이 넘어진다고 한다. 이 때 1시간에 사람이 5명 넘어질 확률은? . - $ lambda = 10, , x = 5 longrightarrow f(5) = frac{e^{-10} ,10^5}{5!} = 0.03783327480207071$ . &#54252;&#50500;&#49569; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = lambda$ . - $Var(X) = lambda$ . - 평균과 분산이 같으므로 평균이 클수록 그래프가 더 넓게 퍼진다 . &#54252;&#50500;&#49569; &#48516;&#54252; plot . import numpy np.random.poisson(lam, size) . - $ lambda$는 모수, size는 표본의 수 . np.random.poisson(lam = 10, size = 1000) . - 단위 시간에서 사건이 평균 10번 발생할 때 (lam = 10) 단위 시간에서 사건이 몇 번 발생하는지를 하나의 표본이라 할 때 size = 1000번 표본을 추출한다 . - 우리 집 앞에서 1시간당 평균 10명이 넘어질 때($ lambda=10$) 1시간당 몇 명 넘어지는지($x = 0,1,2, dots,10,11, dots$)를 $size = 1000$번 기록한다 . - np.random.poisson(lam = 10, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.poisson(lam = 10, size = 1000) plt.hist(sample) plt.title(&#39;np.random.poisson(lam = 10, size = 1000)&#39;) plt.show() . - $ lambda$를 바꿔볼까? --&gt; 우리 집 앞에서 1시간당 평균 4명이 넘어진다면?? . np.random.seed(1) sample = np.random.poisson(lam = 4, size = 1000) plt.hist(sample) plt.title(&#39;np.random.poisson(lam = 4, size = 1000)&#39;) plt.show() . &#44592;&#54616; &#48516;&#54252; . - 어떤 확률변수 $X$가 성공 확률이 $p$인 베르누이 시행에서 처음 성공까지 시도한 횟수라고 할 때 $X$는 성공 확률 $p$인 기하분포를 따른다 . - 처음 성공할 때까지 걸린 시도 횟수 X가 확률 변수이다 . &#44592;&#54616; &#48516;&#54252;&#51032; &#47924;&#44592;&#50613;&#49457; . - $P(X=x+k|X&gt;k)=P(X=x)$ . - 성공 확률 p인 베르누이 시행을 현재 k번 시도 했다 . - 하지만 아직 까지 성공하지 못했다 . - 내가 여태까지 k번 실패했으니까 성공확률이 올라갈까?? --&gt; 답은 No . - 내가 이제껏 시도한 횟수와 관계없이 성공할 확률은 p로 동일하다 . - 쉽게 말하자면 내가 순백의 주문서10%를 바르고 있는 중이다 . - 여태까지 50장을 발랐는데도 성공하지 못했다 . - 하지만 확률은 그대로 10%이고 기댓값도 10번으로 동일하다 . - 즉, 처음에 순백의 주문서를 성공시키기 위한 기대되는 시도 횟수는 10번이다 . - 50번을 실패했지만 여전히 순백의 주문서를 성공시키기 위한 기대되는 시도 횟수는 10번이다...... . &#44592;&#54616; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) = (1-p)^{x-1}p, ; x = 1, 2, 3, dots$ . - 성공 확률이 $p$일 때 $x-1$번 째 시도까지는 모두 실패하고 $x$번 째 시도에 성공할 확률 질량 함수 . &#44592;&#54616; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = frac{1}{p}$ . - $Var(X) = frac{1-p}{p^2}$ . &#44592;&#54616; &#48516;&#54252; plot . import numpy np.random.geometric(p, size) . - $p$는 베르누이 시행에서 성공 확률, size는 표본의 수 . np.random.geometric(p = 0.1, size = 1000) . - 성공 확률이 p = 0.1인 베르누이 시행을 성공할 때까지 시도하는 것을 size = 1000번 반복한다 . - 순백의 주문서($p=0.1$)를 성공할 때까지 시도하여 순백의 주문서가 적용될 때까지 걸린 시도 횟수($X=1,2, dots$)를 $size = 1000$번 기록한다 . - np.random.geometric(p = 0.1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.geometric(p = 0.1, size = 1000) plt.hist(sample) plt.title(&#39;np.random.geometric(p = 0.1, size = 1000)&#39;) plt.show() . &#51020;&#51060;&#54637; &#48516;&#54252; . - 확률변수 $X$를 성공 확률이 $p$인 베르누이 시행을 반복하여 $k$번째 성공이 나올 때 까지 시행횟수라 하면 확률변수 $X$는 음이항 분포를 따름 . - 기하분포는 $k=1$인 음이항 분포 . &#51020;&#51060;&#54637; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) ,= , _{x-1} rm C_{k-1} ,p^{k} ,(1-p)^{x-k} ,= , binom{x-1}{k-1} ,p^{k} ,(1-p)^{x-k}$ . - $x-1$번째 시도까지 성공횟수 $k-1$번였다가 $x$번째 시도에서 성공하여 성공횟수는 $k$가 되었음 . &#51020;&#51060;&#54637; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X) = frac{k}{p}$ . - $Var(X) = frac{k(1-p)}{p^2}$ . &#51020;&#51060;&#54637; &#48516;&#54252; plot . import numpy np.random.negative_binomial(n, p, size) . - $n$은 성공횟수, $p$는 베르누이 시행에서 성공 확률, size는 표본의 수 . np.random.negative_binomial(n = 5, p = 0.1, size = 1000) . - 성공 확률이 p = 0.1인 베르누이 시행을 5번 성공할 때까지 시도하는 것을 size = 1000번 반복한다 . - 순백의 주문서($p=0.1$)를 5번 성공할 때까지 시도하여 순백의 주문서가 5번 적용될 때까지 걸린 시도 횟수($X=5,6, dots$)를 $size = 1000$번 기록한다 . - np.random.negative_binomial(n = 5, p = 0.1, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.negative_binomial(n = 5, p = 0.1, size = 1000) plt.hist(sample) plt.title(&#39;np.random.negative_binomial(n = 5, p = 0.1, size = 1000)&#39;) plt.show() . - 위에서 기하 분포는 음이항 분포에서 $k = 1$인 특수한 경우라고 했음 . - 진짜로 동일한지 $p = 0.4$인 기하 분포와 $p = 0.4, k = 1$인 음이항 분포를 히스토그램을 그려 비교하자 . np.random.seed(1) sample1 = np.random.geometric(p = 0.4, size = 1000) sample2 = np.random.negative_binomial(n = 1, p = 0.4, size = 1000) fig, ax = plt.subplots(1, 2, figsize = (14, 4)) ax[0].hist(sample1) ax[1].hist(sample2) ax[0].set_title(&#39;np.random.geomaric(p = 0.3, size = 1000)&#39;) ax[1].set_title(&#39;np.random.negative_binomial(n = 1, p = 0.3, size = 1000)&#39;) plt.show() . - 히스토그램을 통해 비교하니 $k= 1$인 음이항 분포는 기하 분포와 동일함을 알 수 있다 . &#52488;&#44592;&#54616; &#48516;&#54252; . - $k$개의 성공과 $N-k$개의 실패로 이루어진 크기가 $N$인 유한모집단에서 크기가 $n$인 표본을 뽑고 이 중 성공의 개수를 $X$라 할 때 확률변수$X$는 초기하 분포를 따름 . - $N, k to infty$이고 $ frac{k}{N} to p$이면 초기하 분포를 이항 분포로 근사 가능 . - 비복원추출을 하기에 각각의 시행이 서로 영향을 미치므로 독립적 시행이 아님 &gt; 베르누이 시행과의 차이점 . - 샘플링 검사 시에 복원추출을 하지 않고 비복원 추출을 하기 때문에 초기하 분포를 주로 사용함 . &#52488;&#44592;&#54616; &#48516;&#54252;&#51032; &#54869;&#47456; &#51656;&#47049; &#54632;&#49688; . $f(x) = frac{_{k} , rm C ,_{x} ; times ; _{N-k} ; rm C ,_{n-x}}{_{N} , rm C ,_{n}} $ . - $N$개 중 $n$개를 뽑는 방법 중에서 성공 $k$개에서 $x$개의 성공을 뽑고 실패 $N-k$개에서 $n-x$개의 실패를 뽑을 확률 . &#52488;&#44592;&#54616; &#48516;&#54252;&#51032; &#44592;&#45843;&#44050;&#44284; &#48516;&#49328; . - $E(X)=n cdot frac{k}{N}$ . - $Var(X)= n cdot frac{k}{N} cdot frac{N-k}{N} cdot frac{N-n}{N-1}$ . - 이항분포의 기댓값과 분산과 유사함 . - n은 표본크기, $ frac{k}{N}$은 성공확률, $ frac{N-k}{N}$은 실패확률 . - $ frac{N-n}{N-1}$은 유한모집단수정항으로 $k$는 대체로 1보다 크므로 유한모집단수정항도 1보다 작음 &gt; 이항분포보다 분산이 더 작음 . &#52488;&#44592;&#54616; &#48516;&#54252; plot . import numpy np.random.hypergeometric(ngood, nbad, nsample, size) . - $ngood(=k)$은 유한모집단중 성공횟수, $nbad(=N-k)$는 유한모집단중 실패횟수, $nsample(=n)$은 표본크기, size는 표본의 수 . np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000) . - 성공횟수 ngood = 700개와 실패횟수 nbad = 300개로 구성된 크기가 1000인 유한모집단($N$)에서 샘플 nsample = 100개를 비복원추출하여 나온 성공횟수 $x$를 size = 1000번 반복한다 . - 당첨용지 700개($ngood = 700$)와 꽝용지 300개($nbad = 300$)로 구성된 로또용지 1000개(유한모집단의 크기$N$)중에서 100개($nsample = 100$)를 비복원추출하여 나온 성공횟수를 $size = 1000$번 기록한다 . - np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000)을 히스토그램으로 나타내면? . import numpy as np import matplotlib.pyplot as plt np.random.seed(1) sample = np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000) plt.hist(sample) plt.title(&#39;np.random.hypergeometric(ngood = 700, nbad = 300, nsample = 100, size = 1000)&#39;) plt.show() . - 이항분포와 유사해 보임 . &#45796;&#54637; &#48516;&#54252;(&#51089;&#49457; &#50696;&#51221;) . &#46021;&#47549;&#54637;&#46321;&#48516;&#54252;(independent and identically distributed, iid) (&#51089;&#49457; &#50696;&#51221;) . - 확률변수가 여러 개 있을 때 $(X_1 , X_2 , dots , X_n)$ 이들이 상호독립적이며 모두 동일한 확률분포 $f(x)$를 가진다면 $i.i.d$이다 . - $i.i.d$가 깨지는 경우 . &#51060;&#48516;&#49328;&#49457;(Heteroskedasticity) . &#45236;&#49373;&#49457;(Endogeneity) . &#45796;&#51473;&#44277;&#49440;&#49457;(Multicollinearity) .",
            "url": "https://gkswotn12345.github.io/green/python/statistics/2021/06/30/%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html",
            "relUrl": "/python/statistics/2021/06/30/%ED%99%95%EB%A5%A0%EB%B6%84%ED%8F%AC.html",
            "date": " • Jun 30, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "깃허브 데스크탑",
            "content": "&#44611;&#54728;&#48652; &#45936;&#49828;&#53356;&#53457; &#51060;&#50857;&#54644;&#49436; &#52964;&#48139;&#54616;&#44592; . 처음에 레포지토리 선택할 때 정보를 저장할 폴더 경로를 선택한다 . | 나의 경우에는 &quot;C:/Users/한재수/github_desktop/green&quot; 이다 . | green폴더에 가보면 notebooks폴더가 있는데 거기서 작업한 주피터 노트북 파일은 깃허브 데스크탑 changes에 표시된다 . | 커밋할 파일 하나를 클릭하고 하단에 메시지를 같이 남긴다 . | 변동 내역 메시지를 작성하고 커밋을 했으면 마지막으로 푸쉬를 한다 . | 깃허브에 변동 내역이 저장된다 . | - 아무 것도 변경하지 않고 save만 해도 깃허브 데스크탑 changes에서 감지된다 . - 아무 것도 변경하지 않았는데 커밋이 된다는 의미... --&gt; 아무짝에도 쓸모 없다. --&gt; 이런 경우에는 커밋을 하지 말고 냅두자 . - 파일이 제대로 푸쉬가 안됐다면? --&gt; 깃허브 _notebook 파일에 있는 history를 보자 . - 만약 빨간색으로 $ times$표시가 되어있다면 클릭 --&gt; error메시지를 볼 수 있음 --&gt; 이를 보고 오류 수정 하면 됨 . &#51089;&#50629; &#44277;&#44036; . - 이제부터 작업은 나의 깃허브 레포지토리(green) 저장 폴더인 green에 있는 notebooks에서 해야 한다 . - 만약 &quot;C:/Users/한재수/github_desktop/green/notebooks&quot; 에서 작업하지 않으면 깃허브 데스크탑 changes에 기록되지 않는다 --&gt; 망함 . Liquid Exception: Liquid syntax error &#54644;&#44208; . - Jekyll에서 사용되는 liquid는 {{ 와 }}를 escape 문자로 사용 &gt; {{ 또는 }}이 있으면 error . - 해결 방법 &gt; 여는 중괄호 앞에 { % raw %}를 닫는 중괄호 뒤에 { % endraw %}를 추가함 . - 참고: Liquid syntax error 해결 .",
            "url": "https://gkswotn12345.github.io/green/python/github/2021/06/26/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91.html",
            "relUrl": "/python/github/2021/06/26/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91.html",
            "date": " • Jun 26, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "데이터과학",
            "content": "&#49440;&#54805;&#54924;&#44480; . &#54924;&#44480;&#47784;&#54805; . - $y_i= beta_0+ beta_1 x_{1}+ epsilon_i$ . - $y_i$는 관측값, $ beta_0$는 절편, $ beta_1$은 기울기, $ epsilon_i$는 오차항 { $ mathbb{N} sim(0, sigma^2$) } . - $ sum_{i=1}^{n} epsilon_i^2 = sum_{i=1}^{n} (y_i- beta_0- beta_1 x_{1})^2$ 을 최소화하는 $ beta_0, beta_1$을 추정한다 --&gt; 최소제곱추정 . &#54632;&#49688;&#51032; &#52572;&#49548;&#44050; . - 함수 $f(x)$가 있다고 하자. 이 함수의 최소값을 알고 싶다 --&gt; 미분 . - convex fuction (볼록 함수 --&gt; 아래로 볼록)는 임의의 두 점 $x_1,x_2$와 [0,1] 사이의 값 t에 대해 $f(tx_1+(1-t)x_2) geq tf(x_1)+(1-t)f(x_2)$가 항상 성립하는 함수이다 . - $f&#39;&#39;(x) &gt; 0$이면 $f(x)$는 아래로 볼록하다 . 함수를 두 번 미분한다 | $f&#39;&#39;(x)&gt;0$이면 볼록함수이다. --&gt; $f&#39;(x)=0$을 만족할 때 $f(x)$의 극소값(=최소값)이므로 $f(x)$가 최소이다 | &#54924;&#44480;&#47784;&#54805; &#44228;&#49688; &#52628;&#51221; . $ bf L = sum_{i=1}^{n} boldsymbol{ epsilon_i}^2 = boldsymbol{ epsilon}^{ top} boldsymbol{ epsilon} = (y - X boldsymbol{ beta})^ top(Y - X boldsymbol{ beta}) , , , , = (y^{ top} - boldsymbol{ beta}^{ top}X^{ top})(y - boldsymbol{ beta}X) = y^{ top}y - y^{ top}X boldsymbol{ beta} - boldsymbol{ beta}^{ top}X^{ top}y + boldsymbol beta^{ top}X^{ top}X boldsymbol{ beta}$ | $ frac{ partial bf L}{ partial boldsymbol beta} = bf 0 - 2 bf X^{ top}y + 2X^{ top}X boldsymbol{ beta} = 0$ | $ bf X^{ top}y = X^{ top}X boldsymbol{ beta} Leftrightarrow boldsymbol{ hat beta} = big( bf X^{ top}X big)^{-1}X^{ top}y $ | - 의문점: 만약$ big( bf X^{ top}X big)^{-1}$이 존재하지 않는다면? . &#49345;&#44288;&#44288;&#44228; . - 두 개의 양적 변수의 연관강도나 방향을 요약하는 수치 통계량 . - 상관관계는 두 변수 사이의 선형 관계에 대한 정보임 . &#49345;&#44288;&#44228;&#49688; . - 상관관계의 정도를 나타냄 . - 모집단 상관계수: $ rho$ . - 표본 상관계수: $r$ . &#49345;&#44288;&#44228;&#49688; &#53945;&#51669; . 상관계수는 항상 $-1 leq r leq 1$ . | $r$의 부호가 두 변수 관계의 방향(음수: 음의 관계, 양수: 양의 관계) . | $r$이 $-1$ or $+1$에 가까울수록 선형 관계가 강함, $0$에 가까우면 선형 관계가 없음 . | $r$이 $0$이라고 두 변수사이의 관계가 없는 것이 아니라 선형 관계가 없다는 의미 --&gt; 곡선 관계일 수 도 있음 . | 상관계수 $r$은 단위가 없음. 각 변수의 척도와도 무관 . | 상관계수는 대칭적 --&gt; $x$와$y$의 상관계수 $=$ $y$와$x$의 상관계수 . |",
            "url": "https://gkswotn12345.github.io/green/python/statistics/2021/06/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B3%BC%ED%95%99.html",
            "relUrl": "/python/statistics/2021/06/25/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B3%BC%ED%95%99.html",
            "date": " • Jun 25, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "리스트 처리",
            "content": "&#47532;&#49828;&#53944; &#51221;&#47148; . list.sort()&#54632;&#49688;, sorted()&#54632;&#49688; . - ?.sort()함수는 list형태인 ? 의 요소를 오름차순으로 정렬한다 . - ?.sort(reverse = True)함수는 내림차순으로 정렬한다 . - ?.sort()함수와 sorted()함수는 거의 같다 . - ?.sort()함수는 ?의 속성을 바꾸지만 sorted()함수는 ?의 속성을 바꾸지 않는다 (a.append()와 + 연산의 차이) . a=[1,5,2,3,7,4] a . [1, 5, 2, 3, 7, 4] . a.sort() a . [1, 2, 3, 4, 5, 7] . a.sort(reverse = True) a . [7, 5, 4, 3, 2, 1] . - sort(), sorted()의 key 옵션에 지정된 함수의 결과에따라 정렬한다 . - lambda함수(익명 함수) 사용 --&gt; lambda 매개변수: 결과 . b = [(1, 2), (0, 2), (1, 3), (1, 5), (0, 1), (2, 8)] c = sorted(b, key = lambda x: (x[0], -x[1])) ## x[1]앞에 있는 &#39;-&#39;기호는 현재정렬순서와 반대로이다 print(c) ##첫 번째 원소는 오름차순, 두 번째 원소는 내림차순으로 정렬 . [(0, 2), (0, 1), (1, 5), (1, 3), (1, 2), (2, 8)] . reverse()&#54632;&#49688; . - ?.reverse()함수는 list형태인 ? 의 요소를 역순으로 정렬한다 . d = [1,5,2,3,7,4] d.reverse() print(d) . [4, 7, 3, 2, 5, 1] . reversed()&#54632;&#49688; . - reversed()함수는 요소를 역순으로 정렬해 반환한다 . - 반환값을 그대로 사용하지 않고 list()나 tuple()함수를 통해 사용한다 . d = [1,5,2,3,7,4] reversed(d) . &lt;list_reverseiterator at 0x2185ce99e20&gt; . d = [1,5,2,3,7,4] tuple(reversed(d)) . (4, 7, 3, 2, 5, 1) . &#47532;&#49828;&#53944; &#52488;&#44592;&#54868; . 1&#52264;&#50896; &#47532;&#49828;&#53944; . a = [] ## 빈 리스트로 초기화 a . [] . A = [x] * n . $A = [x, x, x, ..., x, x] --&gt;$ $x$가 $n$개인 $1$차원 리스트 . a = [0]*10 ## 0리스트로 초기화 a . [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] . 2&#52264;&#50896; &#47532;&#49828;&#53944; . n = 5 list = [[0] * n for _ in range(n)] ## 0으로 채원진 2차원 리스트 . list . [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . list[0][0] = 123 . list . [[123, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] . - ?? . List = [[0] * 5 for _ in range(5) . 그런데 _ 는 뭐지? . - 사실 _ 자리에 다른 것이 들어가도 된다 이를 테면 i . x = [0*i for i in range(5)] x . [0, 0, 0, 0, 0] . - 위에 List에서 _ 대신에 i를 넣는다고 생각하자 . List = [[0] * 5 for i in range(5) . - 위에 리스트인 x 에서는 i가 리스트 안에 0을 몇 개 생성할 지 정하는 변수였다 . - 위에 리스트인 List 에서는 i가 무슨 역할을 하지?? . - 아무역할도 하지 않는다 . - 0을 5개 생성하고 이를 5번 반복한다 . - List를 정의할 때 부터 정해졌다 . - i는 그저 for문을 쓰기 위해 필요함 --&gt; range(5)의 값을 받아낼 변수가 필요하다 . - 그래서 i 자리에 오는 변수는 아무짝에도 쓸모가 없다 . - 아무 의미가 없어서 그냥 아무 의미 없어보이는 기호인 _를 쓴다(내 생각) . &#47532;&#49828;&#53944; &#52628;&#44032; . ?.append() . - ? --&gt; 리스트 . - 마지막(?[-1]) 위치에 하나의 원소 추가 . a = [] a.append(1) a . [1] . ?.insert(i, v) . - i 위치에 v 원소 추가 . b = [1,2,3,5,6,7] b.insert(3,4) b . [1, 2, 3, 4, 5, 6, 7] . ?.extend() . - 마지막(?[-1]) 위치에 리스트 추가 . c = [1,2,3,4,5] c.extend([6,7,8]) c . [1, 2, 3, 4, 5, 6, 7, 8] . ?.pop() . - pop(i)는 리스트의 i번째 요소를 돌려주고 그 요소는 삭제, pop( ) = pop(-1) . d = [1, 2, 3, 4 ,5] x = d.pop() print(x) print(d) . 5 [1, 2, 3, 4] . arr[::] &#50857;&#48277; . - arr[A:B:C] &gt; index A부터 index B(포함X)까지 C간격으로 arr 생성 . - A가 none이면 처음부터 B가 none이면 끝까지 C가 none이면 1만큼 . arr = list(range(10)) arr . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . arr[1:9:2] . [1, 3, 5, 7] . arr[:10:3] . [0, 3, 6, 9] . arr[1::2] . [1, 3, 5, 7, 9] . arr[1:5:] . [1, 2, 3, 4] . arr[5::] . [5, 6, 7, 8, 9] . arr[:3:] . [0, 1, 2] . arr[::4] . [0, 4, 8] . arr[::] . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . &#47532;&#49828;&#53944; &#49325;&#51228; . ?.remove(x) . - 리스트에서 x원소를 삭제 . - 삭제할 원소가 없을 시 error . a = [1,2,3,4,5,6] a.remove(1) print(a) . [2, 3, 4, 5, 6] . a.remove(10) . ValueError Traceback (most recent call last) &lt;ipython-input-2-72b3315abecc&gt; in &lt;module&gt; -&gt; 1 a.remove(10) ValueError: list.remove(x): x not in list . &#47928;&#51088;&#50676; &#54252;&#54632;&#50668;&#48512; . ?.find(&quot;&#47928;&#51088;&#50676;&quot;) . - ?에 문자열이 존재하면 가장 앞에 원소의 시작 인덱스 값을 반환하며 존재하지 않으면 -1값을 반환 . day = &quot;2021-07-03&quot; . day.find(&#39;2021&#39;) . 0 . day.find(&#39;-&#39;) . 4 . day.find(&#39;2222&#39;) . -1 . &quot;&#47928;&#51088;&#50676;&quot; in ? , &quot;&#47928;&#51088;&#50676;&quot; not in ? . - ?에 문자열이 존재하면 True 반환, 존재하지 않으면 False 반환, not in에 경우는 반대로 . day = &quot;2021-07-03&quot; . &#39;2021&#39; in day . True . &#39;-&#39; not in day . False . &#39;2222&#39; in day . False . list = [&#39;1011&#39;, &#39;2022&#39;, &#39;day&#39;, &#39;model&#39;] . &#39;2022&#39; in list . True . &#39;day&#39; not in list . False . &#39;month&#39; in list . False .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC.html",
            "relUrl": "/python/2021/06/24/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "깃허브 마크다운",
            "content": "&#44611;&#54728;&#48652; &#52852;&#53580;&#44256;&#47532; . 제목 . &quot;부제목&quot; . -toc: true . -branch: master . -badges: true . -comments: true . -author: 한재수 . -categories: [python] . - 위에 내용을 아무곳에나 붙여 넣는다. 부제목은 (&gt;&quot;부제목&quot;), 제목은 (# 제목) . - categories에 해당하는 부분이 깃허브 홈페이지에서 tag에 보이는 부분이다. . - categories 에서 [ ] 안에 여러개를 추가 할 수 있다. ex) [python, R, CSS] . &#48660;&#47196;&#44536; &#44288;&#47532; . 1_ 깃허브 가입하기 | 2_ fastai/fastpages 사용 | 3_ 깃허브 데스크탑 이용 . | (1) 주피터노트북으로 공부한다. . | (2) 깃허브와 연결된 어떤 폴더(드랍박스 안의 green)에 공부한 내용을 넣는다. | (3) 깃허브 데스크탑이라는 프로그램을 이용하여 local(내 윈도우 컴퓨터)에서 remote (github)로 변경사항을 반영한다. | (4) 2~3분 뒤에 블로그 홈페이지에 반영된다. | (5) 공부한 내용을 편집없이 주피터 노트북 파일을 올리기만 하면 블로그에 올라가서 편하다. 필요에 따라 숨기기, 비밀 포스트도 만들 수 있다. | . &#44611;, &#44611;&#54728;&#48652; . - 버전 관리 시스템 . - 서로 코드를 공유 . - 혼자 쓰면 개인 저장소.. . &#51452;&#54588;&#53552; &#45432;&#53944;&#48513; . &#50976;&#50857;&#54620; &#53412; . - 삭제한 셀 복원 --&gt; Edit - Undo cell operation or Esc 후 z키 입력 . - 삭제한 코드 복원 --&gt; Ctrl + z . &#51452;&#54588;&#53552; &#45432;&#53944;&#48513; --&gt; remote --&gt; page (&#50504; &#50732;&#46972;&#44040; &#49688; &#46020; &#51080;&#45796;) . - 깃허브 데스크탑 history에서 이제껏 했던 커밋을 볼 수 있다. 게다가 삭제된 파일을 복구할 수 도 있다. . - 화면 캡쳐 프로그램으로 캡쳐를 함 --&gt; 마크다운에서 캡쳐한 이미지를 ctrl+v하면 캡쳐한 이미지가 삽입된다. . - 이미지 파일을 넣은 주피터 노트북 파일을 올리면 깃허브 notebook에는 올라가지만 블로그에는 올라가지 않는다. . &#49688;&#49885; &#44592;&#54840; &#54364;&#54788; . - 3.141592를 변수에 저장하고 싶음 . - pi = 3.141592 . - 그런데 pi 대신에 $ pi$를 사용하고 싶다면?? . - code셀에서 pi를 입력한 후 Tab을 누르면 됨 . pi = 3.141592 π = 3.141592 . pi . 3.141592 . π . 3.141592 . &#44611;&#54728;&#48652; &#45936;&#49828;&#53356;&#53457;&#50640;&#49436; &#50724;&#47448;&#44032; &#45228;&#45716;&#45936; &#47784;&#47476;&#44192;&#45796;. gg --&gt; &#54644;&#44208; &#50756;&#47308; . - 삭제하고 다시 처음부터 시작했다. . &#49688;&#49885;&#51012; &#47691;&#51080;&#44172; &#54364;&#54788;&#54616;&#44256; &#49910;&#45796;&#47732;?? . - $수식$ 꼴로 나타낸다. . - y = x^2 + 1 . - $y = x^2 +1$ . &#48145; &#52392;&#51088; &#54364;&#54788; . - $수식_밑첨자$ . - x_1 + x_2 = x_3 . - $x_1 + x_2 = x_3$ . $ sum$ &#54364;&#54788; . - limits 옵션을 통해 $ sum$의 시작과 끝의 위치를 $ sum$의 바로 위와 아래로 지정가능 . - $ sum_{n=1}^{ infty} frac{1}{n^2}$ . - $ sum limits_{n=1}^{ infty} frac{1}{n^2}$ . &#48177;&#53552; &#54364;&#54788; . - 벡터 표현하기: 화살표, 볼드체 . - $X$는 변수 . - $ boldsymbol{X}, ; vec{X}$는 벡터 . &#50948;&#47196; &#51473;&#44292;&#54840; &#54364;&#54788; . - overbrace를 통해 위로 중괄호를 표현함 . - $x+x+x+ dots+x+x, ;x$를 $n$번 더함 . - $ overbrace{x + cdots + x}^{n rm times}$ . &#51216;&#52237;&#44592; . - s 제외하면 점 하나만 찍힘, s 포함하면 점 세개 찍힌다 . - dots &gt; $ dots$ . - cdots &gt; $ cdots$ . - ddots &gt; $ ddots$ . &#50976;&#50857;&#54620; latex . boldsymbol . - applies to nearly all symbols, not just letters and numbers . - ex) $ boldsymbol{A} ,A$ . bf . - Used to turn on boldface; affects uppercase and lowercase letters, and digits . - ex) ${ bf 123} ,{123}$ . therefore . - therefore를 통해 삼각형 모양 점3개를 만듦 . - $ therefore 1+1= text{힘든 삶}$ . &#47588;&#50864; &#50976;&#50857;&#54620; &#47560;&#53356;&#45796;&#50868; &#49324;&#51060;&#53944; . - &lt;Jupyter 노트북에서 Markdown 및 LaTeX를 작성하는 방법 알아보기&gt; --&gt; https://ichi.pro/ko/jupyter-noteubug-eseo-markdown-mich-latexleul-jagseonghaneun-bangbeob-al-abogi-18246612521469 . - latex command 총 정리 --&gt; https://www.tutorialspoint.com/tex_commands/percentage.htm .",
            "url": "https://gkswotn12345.github.io/green/python/github/markdown/jupyter/2021/06/24/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4.html",
            "relUrl": "/python/github/markdown/jupyter/2021/06/24/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4.html",
            "date": " • Jun 24, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "백준 문제풀기",
            "content": ". &#48177;&#51456; &#54616;&#47732;&#49436; &#50508;&#50500;&#45240; &#51216; . 같은 언어, 같은 코드여도 시간이 다를 수 있음 . | 메모리도 다를 수 있음 . | . &#51077;&#52636;&#47141;&#44284; &#49324;&#52825;&#50672;&#49328; . &#46160; &#51088;&#50672;&#49688; A&#50752; B&#44032; &#51452;&#50612;&#51652;&#45796;. &#51060;&#46412;, A+B, A-B, A*B, A/B(&#47787;), A%B(&#45208;&#47672;&#51648;)&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . a, b = map(int, input().split()) print(a+b) print(a-b) print(a*b) print(a//b) print(a%b) . 10 4 21 2 1 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . a, b = map(int, input().split()) print(a+b) . 12 . &#45208;&#47672;&#51648; . (A+B)%C는 ((A%C) + (B%C))%C 와 같을까? . | (A×B)%C는 ((A%C) × (B%C))%C 와 같을까? . | 세 수 A, B, C가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오. . | . A, B, C = map(int, input().split()) print((A+B)%C) print(((A%C) + (B%C))%C) print((A*B)%C) print(((A%C) * (B%C))%C) . 1 1 0 0 . &#44273;&#54616;&#44592; . a = str(input()) b = str(input()) result = ([int(a) * int(b[2-x]) for x in range(3)]) for i in range(3): print(result[i]) print(int(a)*int(b)) . 2360 3776 1416 181720 . &#54217;&#44512;&#51008; &#45336;&#44192;&#51648; . 각 케이스마다 한 줄씩 평균을 넘는 학생들의 비율을 반올림하여 소수점 셋째 자리까지 출력한다. | . C = int(input()) for i in range(C): line = list(map(int, input().split())) mean = sum(line[1:]) / line[0] over_mean = [x for x in range(1, len(line)) if line[x] &gt; mean] over_mean_percent = len(over_mean) * 100 / line[0] print(&#39;{:.3f}%&#39;.format(over_mean_percent)) . 57.143% . &#44256;&#50577;&#51060; &#52636;&#47141; . - 문자열은 &#39; &#39;로 둘러 싸임 . - 를 출력하고 싶으면 . - &#39;을 출력하고 싶으면 &#39; 또는 문자열을 &quot; &quot;로 감싸기 . - 정규표현식의 일종임 --&gt; 정규표현식 공부하기 . print(&#39; &#39;) . File &#34;&lt;ipython-input-28-eaac87876c3b&gt;&#34;, line 1 print(&#39; &#39;) ^ SyntaxError: EOL while scanning string literal . print(&#39; &#39;) . . print(&#39;&#39;&#39;) . File &#34;&lt;ipython-input-33-c6d045ece466&gt;&#34;, line 1 print(&#39;&#39;&#39;) ^ SyntaxError: EOF while scanning triple-quoted string literal . print(&#39; &#39;&#39;) . &#39; . print(&quot;&#39;&quot;) . &#39; . print(&#39; / n ) ( &#39;) n( / ) n (__)|&#39;) . / ) ( &#39;) ( / ) (__)| . &#44053;&#50500;&#51648; . - 문자열에서 &quot; &quot;를 표현하고 싶으면 &#39; &#39;로 감싸기 . - 또는 문자열을 &#39;&#39;&#39; &#39;&#39;&#39;로 감싸는 방법도 있음 . print(&quot;&quot;&quot;) . File &#34;&lt;ipython-input-46-3f29872ceae9&gt;&#34;, line 1 print(&#34;&#34;&#34;) ^ SyntaxError: EOF while scanning triple-quoted string literal . print(&#39;&quot;&#39;) . &#34; . print(&#39;&#39;&#39; | _/| n|q p| /} n( 0 )&quot;&quot;&quot; n|&quot;^&quot;` | n||_/= __| &#39;&#39;&#39;) . | _/| |q p| /} ( 0 )&#34;&#34;&#34; |&#34;^&#34;` | ||_/= __| . - &#39;&#39;&#39; &#39;&#39;&#39;로 감쌀 때 앞의 &#39;&#39;&#39; 앞에 r을 적으면 문자열을 원시 문자열로 처리함 . - 를 표현하기 위해 로 하지 않고 그냥 역슬래시만 해도 가능 . print(&#39;| _/| n|q p| /} n( 0 )&quot;&quot;&quot; n|&quot;^&quot;` | n||_/= __|&#39;) . | _/| |q p| /} ( 0 )&#34;&#34;&#34; |&#34;^&#34;` | ||_/= __| . print(r&#39;&#39;&#39;| _/| |q p| /} ( 0 )&quot;&quot;&quot; |&quot;^&quot;` | ||_/= __|&#39;&#39;&#39;) . | _/| |q p| /} ( 0 )&#34;&#34;&#34; |&#34;^&#34;` | ||_/= __| . . if&#47928; . &#46160; &#51221;&#49688; A&#50752; B&#44032; &#51452;&#50612;&#51276;&#51012; &#46412;, A&#50752; B&#47484; &#48708;&#44368;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . A, B = map(int, input().split()) if A&gt;B: print(&#39;&gt;&#39;) elif A&lt;B: print(&#39;&lt;&#39;) else: print(&#39;==&#39;) . &gt; . &#49884;&#54744; &#51216;&#49688;&#47484; &#51077;&#47141;&#48155;&#50500; 90 ~ 100&#51216;&#51008; A, 80 ~ 89&#51216;&#51008; B, 70 ~ 79&#51216;&#51008; C, 60 ~ 69&#51216;&#51008; D, &#45208;&#47672;&#51648; &#51216;&#49688;&#45716; F&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . def result(grade): if grade &gt;= 90 and grade &lt;= 100: print(&quot;A&quot;) elif grade &gt;= 80 and grade &lt;= 89: print(&quot;B&quot;) elif grade &gt;= 70 and grade &lt;= 79: print(&quot;C&quot;) elif grade &gt;= 60 and grade &lt;= 69: print(&quot;D&quot;) else: print(&quot;F&quot;) grade = int(input()) result(grade) . A . &#50672;&#46020;&#44032; &#51452;&#50612;&#51276;&#51012; &#46412;, &#50980;&#45380;&#51060;&#47732; 1, &#50500;&#45768;&#47732; 0&#51012; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다. . | 예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다. . | . def leap_year(year): if (year%4 ==0 and year%100 != 0) or year%400 == 0: print(1) else: print(0) year = int(input()) leap_year(year) . 1 . &#49324;&#48516;&#47732; &#44256;&#47476;&#44592; . 첫 줄에는 정수 x가 주어진다. (−1000 ≤ x ≤ 1000; x ≠ 0) 다음 줄에는 정수 y가 주어진다. (−1000 ≤ y ≤ 1000; y ≠ 0) . | 점 (x, y)의 사분면 번호(1, 2, 3, 4 중 하나)를 출력한다. . | . def quadrant(a,b): if a&gt;0 and b&gt;0: print(1) elif a&gt;0 and b&lt;0: print(4) elif a&lt;0 and b&gt;0: print(2) elif a&lt;0 and b&lt;0: print(3) x = int(input()) y = int(input()) quadrant(x, y) . 4 . &#50508;&#46988; &#49884;&#44228; . 45분 일찍 알람 설정하기 | . h, m = map(int, input().split()) if m &gt;= 45: print(h, m-45) elif h == 0: print(23, m+15) else: print(h-1, m+15) . 23 40 . . for&#47928; . N&#51012; &#51077;&#47141;&#48155;&#51008; &#46244;, &#44396;&#44396;&#45800; N&#45800;&#51012; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. &#52636;&#47141; &#54805;&#49885;&#50640; &#47582;&#52656;&#49436; &#52636;&#47141;&#54616;&#47732; &#46108;&#45796;. . n = int(input()) for i in range(1,10): print(&#39;%s * %s = %s&#39; % (n, i, n*i)) . 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 첫째 줄에 테스트 케이스의 개수 T가 주어진다. . | 각 테스트 케이스마다 A+B를 출력한다. . | . T = int(input()) for i in range(T): A, B = map(int, input().split()) print(A+B) . 6 . 10 . 75 . n&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, 1&#48512;&#53552; n&#44620;&#51648; &#54633;&#51012; &#44396;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 반복문 있는 버전 | . n = int(input()) sum = 0 for i in range(1, n+1): sum += i print(sum) . 55 . 반복문 없는 버전 | . n = int(input()) print(int(n * (n+1) / 2)) . 55 . sys.stdin.readline() . 본격적으로 for문 문제를 풀기 전에 주의해야 할 점이 있다. . | 입출력 방식이 느리면 여러 줄을 입력받거나 출력할 때 시간초과가 날 수 있다는 점이다. . | Python을 사용하고 있다면 input() 대신 sys.stdin.readline()을 사용할 수 있다. . | 단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에 문자열을 저장하고 싶을 경우 .rstrip()을 추가로 해 주는 것이 좋다. . | . import sys T = int(input()) for i in range(T): A, B = map(int, sys.stdin.readline().split()) print(A+B) . ValueError Traceback (most recent call last) &lt;ipython-input-3-173fe188e1c6&gt; in &lt;module&gt; 2 T = int(input()) 3 for i in range(T): -&gt; 4 A, B = map(int, sys.stdin.readline().split()) 5 print(A+B) ValueError: not enough values to unpack (expected 2, got 0) . - error 왜 뜨지? . - sys.stdin.readline()를 쓸 때마다 에러가 난다. . &#51088;&#50672;&#49688; N&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, 1&#48512;&#53552; N&#44620;&#51648; &#54620; &#51460;&#50640; &#54616;&#45208;&#50473; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . N = int(input()) for i in range(1, N+1): print(i) . 1 2 3 4 5 . &#51088;&#50672;&#49688; N&#51060; &#51452;&#50612;&#51276;&#51012; &#46412;, N&#48512;&#53552; 1&#44620;&#51648; &#54620; &#51460;&#50640; &#54616;&#45208;&#50473; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . N = int(input()) for i in range(1, N+1): print(N-i+1) . 5 4 3 2 1 . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 각 테스트 케이스마다 &quot;Case #x: &quot;를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다. | . import sys T = int(input()) for i in range(1, T+1): A, B = map(int, sys.stdin.readline().split()) print(&#39;Case #%s: %s&#39; % (i, A+B)) . Case #1: 6 . Case #2: 6 . Case #3: 8 . &#48324; &#52237;&#44592; - 1 . 문제 출처: 백준 2438번 | . N = int(input()) for i in range(1, N+1): for j in range(i): print(&#39;*&#39;, end = &#39;&#39;) print(&#39; n&#39;, end = &#39;&#39;) . * ** *** **** ***** . print&#54632;&#49688; &#50857;&#48277; . print(출력할 객체, end = &#39;함수가 종료될 때 실행하는 값&#39;) . | print()함수에서 end값을 따로 지정하지 않으면 끝을 줄바꿈 문자로 한다. . | . print(&#39;안녕&#39;, end = &#39;~~~~&#39;) print(&#39;하세요&#39;) . 안녕~~~~하세요 . N = int(input()) for i in range(N): for j in range(1, N-i): print(&quot; &quot;, end = &quot;&quot;) for k in range(i+1): print(&quot;*&quot;, end = &quot;&quot;) print(&quot; n&quot;, end = &quot;&quot;) . * ** *** **** ***** . &#51221;&#49688; N&#44060;&#47196; &#51060;&#47336;&#50612;&#51652; &#49688;&#50676; A&#50752; &#51221;&#49688; X&#44032; &#51452;&#50612;&#51652;&#45796;. &#51060;&#46412;, A&#50640;&#49436; X&#48372;&#45796; &#51089;&#51008; &#49688;&#47484; &#47784;&#46160; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 첫째 줄에 N과 X가 주어진다. (1 ≤ N, X ≤ 10,000) . | 둘째 줄에 수열 A를 이루는 정수 N개가 주어진다. 주어지는 정수는 모두 1보다 크거나 같고, 10,000보다 작거나 같은 정수이다. . | X보다 작은 수를 입력받은 순서대로 공백으로 구분해 출력한다. X보다 작은 수는 적어도 하나 존재한다. . | . N, X = map(int, input().split()) A = list(map(int, input().split())) for i in range(N): if A[i] &lt; X: print(A[i], end = &quot; &quot;) . 1 0 . . while&#47928; . &#46160; &#51221;&#49688; A&#50752; B&#47484; &#51077;&#47141;&#48155;&#51008; &#45796;&#51020;, A+B&#47484; &#52636;&#47141;&#54616;&#45716; &#54532;&#47196;&#44536;&#47016;&#51012; &#51089;&#49457;&#54616;&#49884;&#50724;. . 입력의 마지막에는 0 두 개가 들어온다. | . while True: A,B = map(int, input().split()) if A==0 and B==0: break else: print(A+B) . 2 . 4 . &#45908;&#54616;&#44592; &#49324;&#51060;&#53364; . 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. . | 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. . | 26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다. . | 위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다. . | N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.(0&lt;=N&lt;=99 인 정수) . | . n = N = int(input()) N_cycle = 0 while True: if N &lt; 10: N = int(2*str(N)) N_cycle += 1 else: N = int(str(N)[-1]+str(int(str(N)[0])+int(str(N)[-1]))[-1]) N_cycle += 1 if N == n: print(N_cycle) break . 60 . . &#54632;&#49688; . N&#44060;&#51032; &#54633; . 정수 n개가 주어졌을 때, n개의 합을 구하는 함수를 작성하시오. | . def solve1(a): sum = 0 for i in range(len(a)): sum += a[i] return(sum) . a=[0,1,2,3,4] solve1(a) . 10 . def solve2(a): return(sum(a)) . a=[0,1,2,3,4] solve2(a) . 10 . &#49472;&#54532; &#45336;&#48260; . 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다. | . z = set(range(1,10001)) - {x+sum([int(a) for a in str(x)]) for x in range(1,10001)} z = list(z) z.sort() for i in range(len(z)): print(z[i]) # 출력이 너무 길어서 출력은 생략 . &#54620;&#49688; . 어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. . | 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. . | N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오. . | . N = int(input()) def solve(a): if a &lt; 100: print(a) else: n = 99 for i in range(100, a+1): if int(str(i)[1]) - int(str(i)[0]) == int(str(i)[2]) - int(str(i)[1]): n += 1 print(n) solve(N) . 129 . . &#51116;&#44480;&#54632;&#49688;(&#51473;&#50836;&#54632; &#50500;&#47560;&#46020; &#44536;&#47532;&#44256; &#54775;&#44040;&#47548;) . - 재귀함수를 구상해보자. . - 재귀함수는 관계가 중요하다. . - 팩토리얼에서는 $fact(x)= x * fact(x-1)$ 관계가 성립한다. . - $fact(0), fact(1)$ 은 1이다. . - x가 0 또는 1일 때는 return을 1로 설정하고 나머지의 경우에는 $fact(x)= x * fact(x-1)$ 을 return한다면 재귀함수가 된다. . - 즉, 기본값 [$fact(0 or 1)=1$] 을 알고 관계식 [$fact(x)= x * fact(x-1)$] 을 안다면 재귀함수로 구현할 수 있다. . &#54057;&#53664;&#47532;&#50620; . 0보다 크거나 같은 정수 N이 주어진다. . | 이때, 재귀함수를 이용하여 N!을 출력하는 프로그램을 작성하시오. . | . N = int(input()) def fact(x): if x == 0 or x == 1: return 1 else: return x*fact(x-1) print(fact(N)) . &#54588;&#48372;&#45208;&#52824; &#49688; 5 . n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오. . | 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. . | 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. . | n은 20보다 작거나 같은 자연수 . | . N = int(input()) def fibo(x): if x == 0: return 0 elif x == 1: return 1 else: return fibo(x-1) + fibo(x-2) print(fibo(N)) . 55 . &#54588;&#48372;&#45208;&#52824; &#49688;&#50676; &#47700;&#47784;&#51060;&#51228;&#51060;&#49496; . 피보나치 재귀 함수의 경우 이미 구한 값을 구하기 위해 반복을 많이 해서 효율성이 떨어진다. . | 재귀 함수가 효율적이지 못하다면 메모이제이션을 사용한다. . | 재귀함수가 한 번 호출될 때마다 결과값을 저장하여 효율성을 높이는 것이 좋다. (메모이제이션) . | . N = int(input()) fibonacci = {0:0, 1:1} ## 메모이제이션을 위한 딕셔러니 선언 def fibo(x): if x in fibonacci: return fibonacci[x] fibonacci[x] = fibo(x-1) + fibo(x-2) return fibonacci[x] print(fibo(N)) . 55 . &#48324; &#52237;&#44592;(Pass) . N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다. . | 크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다. . | N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. . | . print(&#39;&#47928;&#51088;&#50676;&#39;) . $ star$ 과 $ star$ 사이에 빈칸이 있다. 이유는 ,(콤마) 때문이다. | . print(&#39;*&#39;, &#39;*&#39;, end = &quot;&quot;) . * * . ,(콤마)를 없애면 $ star$ 과 $ star$ 사이에 빈칸이 없다. | . print(&#39;*&#39; &#39;*&#39;, end = &quot;&quot;) . ** . def star(x): if x == 3: return print(&#39;*** n* * n***&#39;, end = &quot;&quot;) else: return ## *자리에 star(x/3)대입하면 될 줄 알았는데... . &#54616;&#45432;&#51060; &#53457; &#51060;&#46041; &#49692;&#49436; . 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다. . | 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다. . | 첫째 줄에 옮긴 횟수 K를 출력한다. . | 두 번째 줄부터 수행 과정을 출력한다. . | . N = int(input()) def Hanoi(n,from_pos,to_pos,aux_pos): if n==1: print(from_pos,to_pos) else: Hanoi(n-1,from_pos,aux_pos,to_pos) print(from_pos,to_pos) ## 가장 큰 원반을 목적지로 이동 Hanoi(n-1,aux_pos,to_pos,from_pos) print(2**N-1) Hanoi(N,1,3,2) . 7 1 3 1 2 3 2 1 3 2 1 2 3 1 3 . . &#47928;&#51088;&#50676; . &#49707;&#51088;&#51032; &#54633; . N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오. | . N = int(input()) num_str = str(input()) num_str = num_str.replace(&#39;0&#39;,&quot;&quot;) print(sum([int(num_str[x]) for x in range(len(num_str))])) . 15 . - map 함수 사용 . N = int(input()) num_str = str(input()) print(sum(map(int, num_str))) . 15 . &#45800;&#50612;&#51032; &#44060;&#49688; . 영어 대소문자와 띄어쓰기만으로 이루어진 문자열이 주어진다. . | 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. . | 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다. . | . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] == &#39;&#39;: spaces += 1 if s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 6 . - 어이없는 상황을 맞이함 . - 아래 코드는 틀린 코드임 . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . - input을 a = &#39; Mazatneunde Wae Teullyeoyo&#39; 으로 하게 되면(&#39; &#39;은 빼고) 앞에 띄어쓰기가 있으므로 len(s) - 1 = 3이 출력되야 하는데 4가 출력됨 . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 4 . - 사실 위 코드에 문제가 없는 건 아님 . - 만약 앞 뒤 모두 띄어쓰기가 있다면? . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 4 . - 4가 출력됨?? . string = str(input()) s = string.split(&#39; &#39;) spaces = 0 if s[0] or s[-1] == &#39;&#39;: spaces += 1 print(len(s) - spaces) . 2 . - 웃긴게 뒤에만 띄어쓰기가 있는 경우에는 올바르게 출력함 . &#45800;&#50612; &#44277;&#48512; . 알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. . | 단, 대문자와 소문자를 구분하지 않는다. . | . - 처음에는 for문을 2개 사용해서 같은 원소가 몇 개인지 알아낼려고 했다 . - 그런데 문자열길이가 백만이라 for문을 2번 돌면 2초안에 통과를 못할 것 같았다 . - 그래서 for문을 2개 쓰는 대신 다른 방법을 생각했다 . - 문자열을 대문자로 바꾸고 A~Z까지 원소를 삭제한 후 문자열 길이를 비교해 몇 개가 있는지 파악하기로 했다. . - 나중에 찾아보니 count 함수를 쓰면 더 쉽게 할 수 있다. . alphabet = str(input()) alp = alphabet.upper() alpha_list = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;] lenghts = len(alphabet) max_alpha = [] for i in alpha_list: if i in alp: a_len = len(alp.replace(i, &#39;&#39;)) if a_len &lt; lenghts: lenghts = a_len del max_alpha[:] max_alpha.append(i) elif a_len == lenghts: max_alpha.append(i) if len(max_alpha) &gt; 1: print(&#39;?&#39;) else: print(max_alpha[0]) . ? . &#50500;&#49828;&#53412; &#53076;&#46300; . 알파벳 소문자, 대문자, 숫자 0-9중 하나가 주어졌을 때, 주어진 글자의 아스키 코드값을 출력하는 프로그램을 작성하시오. | . input_ = str(input()) print(ord(input_)) . 48 . &#50508;&#54028;&#48307; &#52286;&#44592; . 알파벳 소문자로만 이루어진 단어 S가 주어진다. . | 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오. . | . S = str(input()) for i in &#39;abcdefghijklmnopqrstuvwxyz&#39;: find_ = S.find(i) print(find_, end = &quot; &quot;) . 1 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 . &#47928;&#51088;&#50676; &#48152;&#48373; . 문자열 S를 입력받은 후에, 각 문자를 R번 반복해 새 문자열 P를 만든 후 출력하는 프로그램을 작성하시오. | . T = int(input()) for i in range(T): R, S = map(str, input().split()) R = int(R) string = &#39;&#39; print(&#39;&#39;.join([string + (S[j] * R) for j in range(len(S))])) . /////HHHHHTTTTTPPPPP . &#49345;&#49688; . 상근이의 동생 상수는 수학을 정말 못한다. 상수는 숫자를 읽는데 문제가 있다. . | 이렇게 수학을 못하는 상수를 위해서 상근이는 수의 크기를 비교하는 문제를 내주었다. . | 상근이는 세 자리 수 두 개를 칠판에 써주었다. 그 다음에 크기가 큰 수를 말해보라고 했다. . | 상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. . | 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다. 두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오. . | . a, b = map(str, input().split()) rev_a = int(a[2] + a[1] + a[0]) rev_b = int(b[2] + b[1] + b[0]) if rev_a &gt; rev_b: print(rev_a) else: print(rev_b) . 437 . &#53356;&#47196;&#50500;&#54000;&#50500; &#50508;&#54028;&#48307; . 문제 출처: https://www.acmicpc.net/problem/2941 | . - 아니 디버깅하고 있었다가 예제 모두 맞춰서 이제 됐나? 싶어서 제출 했더니 정답임.. 근데 왜 맞지?? . - 왜 정답인지 생각해 봤음 . - 내 코드를 보면 ddz=z= 가 입력되면 dz=: 1개, z=: 2개임 . - z= 원래 1개여야 맞지만 dz=에 있는 z=을 z=에 포함시켜 2개임 . - 그래서 total_num이 원래보다 +1이 됐음 . - 정상 출력은 total_num + len(S) - 2 * total_num임 . - 2를 곱한 이유는 알파벳 1개당 길이가 2여서임(&#39;dz=&#39;제외) . - 근데 사실 출력이 잘못됨. 왜냐하면 &#39;dz=&#39;의 길이는 3이기 때문 --&gt; 출력값이 &#39;dz=&#39; 하나당 1씩 부족함 . - 그런데 &#39;dz=&#39; 에 &#39;z=&#39;이 포함돼서 +1이 되어 -1과 +1이 서로 상쇄됨 . - 그래서 정답을 출력함, 노리고 한 건 아니지만 어부지리로 맞춘셈 . S = str(input()) s_len = len(S) total_num = (s_len - len(S.replace(&#39;dz=&#39;,&#39;&#39;))) // 3 for i in [&#39;c=&#39;, &#39;c-&#39;, &#39;d-&#39;, &#39;lj&#39;, &#39;nj&#39;, &#39;s=&#39;, &#39;z=&#39;]: total_num += (s_len - len(S.replace(i, &#39;&#39;))) // 2 print(len(S) - total_num) . 3 . - 아래는 다른 사람이 작성한 코드를 보고 영감을 받아 작성한 코드임 . - 위에서 문제점은 dz=에 z=이 포함된것이다 . - 만약 &#39;dz=&#39;을 없앤다면 괜찮을까? --&gt; 그렇지 않음 . - 만약 ddz=z=이면 &#39;dz=&#39;을 없애도 &#39;dz=&#39;이 남게 된다 . - 만약 &#39;dz=&#39;을 없애는 대신에 다른 문자로 바꾼다면? 예컨데 알파벳이 아닌 다른 문자 . - &#39;dz=&#39;을 * 로 바꾼다면 ddz=z= --&gt; d*z=이 되어 제대로 개수를 셀 수 있음 . - 또 다른 장점은 이제 더 이상 알파벳의 개수를 셀 때 //2 or //3 을 하지 않아도 됨 . - 왜냐하면 크로아티아 알파벳을 한 자리 문자로 바꿨기 때문임 . - 모두 길이가 1이므로 바꾼 후에 최종 문자열의 길이를 출력하면 됨 . S = input() for i in [&#39;c=&#39;, &#39;c-&#39;, &#39;dz=&#39;, &#39;d-&#39;, &#39;lj&#39;, &#39;nj&#39;, &#39;s=&#39;, &#39;z=&#39;]: S = S.replace(i, &#39;*&#39;) print(len(S)) . 3 . . &#48652;&#47336;&#53944; &#54252;&#49828;(brute force) . - 완전탐색 알고리즘으로 가능한 모든 경우의 수를 탐색한다. --&gt; 100%확률로 정답 출력 . &#48660;&#47001;&#51117; . 기존 룰: 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. . | 변형 룰: N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오. . | . N, M = map(int,input().split()) card = list(map(int,input().split())) def blackjack(card,length,Max): card_list=[] for i in range(N): for j in range(N): for k in range(N): if i != j and j != k and i != k: if card[i]+card[j]+card[k] &lt;= Max: card_list.append(card[i]+card[j]+card[k]) print(max(card_list)) blackjack(card,N,M) ## 아쉬운점: for문3번사용 --&gt; O(n^3) . 21 . &#48516;&#54644;&#54633; . 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. . | 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. . | 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. . | 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. . | 반대로, 생성자가 여러 개인 자연수도 있을 수 있다. . | 자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오. . | . N = int(input()) def solve(x): list=[] for i in range(1, x+1): generator = i + sum([int(str(i)[j]) for j in range(len(str(i)))]) if generator == x: list.append(i) if len(list) &gt; 0: return(min(list)) else: return 0 print(solve(N)) . 198 . &#51076;&#51032;&#51032; &#49707;&#51088;&#51032; (&#44033; &#51088;&#47551;&#49688; + &#51088;&#44592; &#51088;&#49888;) . x=12345 sum([int(str(x)[i]) for i in range(len(str(x)))])+x ### 리스트 컴프리헨션 . 12360 . &#48152;&#50732;&#47548; &#50724;&#52264;(&#48177;&#51456; &#47928;&#51228; &#50500;&#45784; + &#47924;&#51312;&#44148; &#51069;&#51004;&#49464;&#50836;) . - 문제를 풀다보면 나누기 연산을 할 때가 있다 . - 만약 나누기연산과 몫 연산의 결과가 같다면 무조건 몫 연산자를 쓰자 &gt; 10 / 5 = 10 // 5 . - 왜???? . - 0.1 + 0.2 = 0.3 일까? &gt; no . - ???? 정말로? . 0.1 + 0.2 . 0.30000000000000004 . - 정말로 0.1 + 0.2 = 0.3이 아님 . 0.1 + 0.2 == 0.3 . False . - 하나 더: 1.2 * 3 = 3.6 일까? &gt; no . 1.2 * 3 . 3.5999999999999996 . 1.2 * 3 == 3.6 . False . - 밑에 문제인 IQ Test도 틀린 이유가 몫 연산자를 쓰지 않고 나누기 연산자를 사용한 것이다 . - 위에서 확인한 봐와 같이 반올림 오차 때문에 float형은 불안정하므로 몫 연산자를 사용하는 것이 무조건 안전하다 . IQ Test(&#48145;&#50640; &#49345;&#54889; &#46412;&#47928;&#50640; &#48152;&#47168; &#52286;&#50500; &#48420;&#51020;) + &#47582;&#45716; &#44163; &#44057;&#51008;&#45936; &#44228;&#49549; &#53952;&#47548;..., &#44536;&#47000;&#49436; &#45796;&#47480; &#49324;&#46988; &#53076;&#46300; &#48420;&#45716;&#45936; &#50780; &#53952;&#47160;&#45716;&#51648; &#47784;&#47476;&#44192;&#51020; + &#50508;&#50500;&#45256;&#45796; . IQ Test의 문제 중에는 공통된 패턴을 찾는 문제가 있다. 수열이 주어졌을 때 다음 수를 찾는 문제이다. . | 예를 들어 1, 2, 3, 4, 5가 주어졌다. 다음 수는 무엇인가? 당연히 답은 6이다. . | 약간 더 어려운 문제를 보면 3, 6, 12, 24, 48이 주어졌을 때 다음 수는 무엇인가? 역시 답은 96이다. . | 이제 제일 어려운 문제를 보자. . | 1, 4, 13, 40이 주어졌을 때 다음 수는 무엇일까? 답은 121이다. . | 그 이유는 항상 다음 수는 앞 수 * 3 + 1이기 때문이다. . | 은진이는 위의 3문제를 모두 풀지 못했으므로 자동으로 풀어주는 프로그램을 작성하기로 했다. . | 항상 모든 답은 구하는 규칙은 앞 수 * a + b이다. 그리고 a와 b는 정수이다. . | 수 N개가 주어졌을 때 규칙에 맞는 다음 수를 구하는 프로그램을 작성하시오. . | . - N은 2여도 1, 1 과 같이 답이 있을 수 있다. . - 일반적으로 N = 2이면 다음 수는 여러개이다, . - $1, 2$ --&gt; 다음 수 $3(a=0, b=1)$ or $-8(a=-10, b=12)$ 등등 . - a, b 둘다 0일 수 도 있음 . - 스파게티 코드 + 틀렸습니다 . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule(x): if len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif len(x) == 2 and x[0] == x[1]: return x[0] if len(x) == 1: return &#39;A&#39; if x[0] == x[1] == x[2] : a = 0 elif x[1] == x[0] and x[1] != x[2]: return &#39;B&#39; else: a = (x[2] - x[1]) / (x[1] - x[0]) b = x[1] - a * x[0] for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; elif x[i+1] == 0: ## 이 부분이 문제였다. x[i+1] == 0이면 그 뒤는 확인 안하고 return 0 실행 return 0 return int(a * x[-1] + b) print(sequence_rule(N_list)) . - 위에 있는 코드를 정리하자 . - 틀렸습니다 . - exit(0) --&gt; python 프로그램 종료 . - exit(0)써서 코드 짤려했는데 복잡하고 틀렸다고 처리돼서 다른 방법을 찾아 떠났음 . - 이 파일을 둘러보다가 예전에 왜 틀렸는지 모르겠던 기억에 맞은 사람 코드랑 비교해봄 . - 내 코드: a = (x[1] - x[2]) / (x[0] - x[1]) . - 맞은 사람 코드: a = (x[1] - x[2]) // (x[0] - x[1]) . - 나누기 연산자 대신에 몫 연산자를 사용했음 &gt; 뭔 차이인데? . - 10/5 = 2.0이지만 10//5 = 2 &gt; 그래서 왜?? &gt; 출력을 보면 소수점이 없어야 함 &gt; 하지만 나는 소수점이 있으므로 틀림 . - 근데 그 이유가 아니었다 &gt; return (int(a * x[-1] + b)) 이므로 int형이다 &gt; 소수점 없다는 의미 &gt; 그럼 왜 나누기 연산자 쓰면 틀리고 몫 연산자 쓰면 맞음?? &gt; 그러게? . - 아마 float형이 불안정해서 그럴 것이다 &gt; 그래서 안전하게 나누기 대신 몫 연산자를 쓰는 것이 좋음 &gt; 결과가 같을때 만: 10 / 5 = 10 // 5 . - 밑에 있는 코드는 17%부근에서 틀렸습니다로 처리됨 + 내 제출들을 보면 런타임에러(NameError)가 많이 있음 &gt; 이유: if len(x) == 1: 에서 return할 때 &#39;A&#39;가 아닌 A라고 했음 . - &#39;A&#39;라고 해도 17%부근에서 틀렸음 . - 하지만 나누기 연산자 대신에 몫 연산자를 쓰고 정답처리 됐음 . 틀린 코드 | . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule2(x): if len(x) == 1: return &#39;A&#39; elif len(x) == 2 and x[0] == x[1]: return x[1] elif len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 else: a = (x[1] - x[2]) / (x[0] - x[1]) b = x[1] - a * x[0] for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; return int(a * x[-1] + b) print(sequence_rule2(N_list)) . 13 . 맞은 코드 | . N = int(input()) N_list = list(map(int, input().split())) def sequence_rule2(x): if len(x) == 1: return &#39;A&#39; elif len(x) == 2 and x[0] == x[1]: return x[1] elif len(x) == 2 and x[0] != x[1]: return &#39;A&#39; elif x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 else: a = (x[2] - x[1]) // (x[1] - x[0]) b = x[1] - a * x[0] for i in range(len(x) - 1): if a * x[i] + b != x[i+1]: return &#39;B&#39; return int(a * x[-1] + b) print(sequence_rule2(N_list)) . 13 . - continue --&gt; 아래 코드를 실행하지 않고 건너뜀 . for i in range(10): # 0부터 99까지 증가하면서 100번 반복 if i % 2 == 0: # i를 2로 나누었을 때 나머지가 0면 짝수 continue # 아래 코드를 실행하지 않고 건너뜀 print(i) . 1 3 5 7 9 . - 맞았습니다(3시간 걸림 힘들다) . - 위에 있는 틀린 코드와 밑의 코드는 무슨 차이일까... &gt; 나누기 연산자와 몫 연산자의 차이 . N = int(input()) x = list(map(int, input().split())) if N == 1: print(&#39;A&#39;) elif N == 2: if x[0] == x[1]: print(x[0]) else: print(&#39;A&#39;) else: if x[0] == x[1]: ## a=1, b=0 or a=0, b=x[0] a = 0 b = x[1] else: a = (x[2] - x[1]) // (x[1] - x[0]) b = x[1] - x[0] * a result = True for i in range(N - 1): if x[i] * a + b == x[i+1]: continue else: result = False if result: print(a * x[-1] + b) else: print(&#39;B&#39;) . 121 . &#50689;&#54868;&#44048;&#46021; &#49676; . 종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. . | 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다. . | 숌이 만든 ($N leq10000$)번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. . | . - $N leq 10000$ --&gt; 계산 결과 영화제목은 최대 7자리 . - 7자리 수까지 666을 포함하는 수를 모두 생성한 후 오름차순으로 정렬 . - 문제점: 666xxx 같은 수를 표현한다고 치자 --&gt; 이때 xxx = 010이라면 자연수가 아니므로 010을 수로 표현할 수 없음 . - 666xxx --&gt; 66600x + 6660xx . - 하지만 좋은 방법이 떠오름 . - 666xxx --&gt; 66yxxx , y = 6이므로 yxxx =&gt; range(6000,7000) . - 위와 같이 표현하면 666010도 표현 가능! . import math result = [666] result.extend([int(str(i) + &#39;666&#39;) for i in range(1, 3000)]) ## x666, xy666, xyy666, 1yyy666, 2yyy666 --&gt; 앞으로 나오는 x는 자연수, y는 0포함 result.extend([int(&#39;66&#39; + str(i)) for i in range(6000,7000)]) ## 666yyy result.extend([int(&#39;66&#39; + str(i)) for i in range(600, 700)]) ## 666yy result.extend([int(&#39;666&#39; + str(i)) for i in range(10)]) ## 666y result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 30) for j in range(600, 700)]) ## x666yy, 1y666yy, 2y666yy result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 100) for j in range(60, 70)]) ## x666y, xy666y result.extend([int(str(i) + &#39;66&#39; + str(j)) for i in range(1, 3) for j in range(6000, 7000)]) ## 1666yyy, 2666yyy result.extend([int(str(i) + &#39;666&#39; + str(j)) for i in range(100, 300) for j in range(10)]) ## 1yy666y, 2yy666y result.extend([int(str(i) + &#39;666&#39;) for i in range(1000, 3000)]) ## 1yyy666, 2yyy666 result = list(set(result)) result.sort() N = int(input()) print(result[N-1]) . 1666 . - 다른 사람 아이디어 보고 만든 코드 --&gt; 내 코드보다 코드 길이가 10배 짧아서 10배 좋다고 생각할라 했는데 시간이 너무 오래 걸리네? --&gt; 내 실수인 걸로 할라 했는데 숏코딩 보니까 다른 사람도 시간이 오래 걸렸다. . - 종말의 수는 $10000$개가 최대이므로 아무거 커도 $3000000$ 이하이다. . - $3000000$까지의 숫자 중 $666$을 포함하면 새로운 리스트에 포함한다. . result = [] result.extend([int(str(i)) for i in range(666,3000000) if str(i).find(&#39;666&#39;) != -1]) N = int(input()) print(result[N-1]) . 1666 . - 숏코딩으로 만들었음(가독성 쓰레기) . print([i for i in range(9**7)if&#39;666&#39;in str(i)][int(input())-1]) . 1666 . &#52404;&#49828;&#54032; &#45796;&#49884; &#52832;&#54616;&#44592; . $8 times8$ 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠한다. | 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오. | . - 밑에 있는 코드 왜 틀림??????????????? . - W로 채워진 8$ times$8 체스판을 input 하면 답이 32가 나와야 하는데 chess1, chess2 = 24, 25가 나온다.(원인 불명) . - 아 왜 틀렸냐고... 안해 다른 거 할 거야 . N, M = map(int, input().split()) data = [] for i in range(N): data.append(list(input())) def chess(n, m): x, y = 0, 7 chess_list = [] while x &lt; n - 7 and y &lt; n: a, b = 0, 7 while a &lt; m - 7 and b &lt; m: chess1, chess2 = 0, 0 for i in range(x, y): for j in range(a, b): if (a + x) % 2 ==0: if (i + j) % 2 == 0: if data[i][j] == &#39;B&#39;: chess1 += 1 else: chess2 += 1 if (i + j) % 2 == 1: if data[i][j] == &#39;B&#39;: chess2 += 1 else: chess1 += 1 else: if (i + j) % 2 == 0: if data[i][j] == &#39;B&#39;: chess2 += 1 else: chess1 += 1 if (i + j) % 2 == 1: if data[i][j] == &#39;B&#39;: chess1 += 1 else: chess2 += 1 chess_list.extend([chess1, chess2]) a += 1 b += 1 x += 1 y += 1 print(chess_list) chess(N, M) . - input . 8, 8 . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . WWWWWWWW . - output . [24, 25] . &#45929;&#52824;(7568&#48264;) . N = int(input()) body = [] for i in range(N): body.append(list(map(int,input().split()))) for i in range(N): rank = 1 for j in range(N): if body[i][0] &lt; body[j][0] and body[i][1] &lt; body[j][1]: rank += 1 print(rank, end = &quot; &quot;) . 2 2 1 2 5 . a=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;] x=&#39; &#39;.join(a) a=1,2,3 print(a) . (1, 2, 3) . . &#49548;&#49688; . &#50500;&#54028;&#53944; &#51076;&#45824;(5615&#48264;) --&gt; &#49884;&#44036; &#52488;&#44284; pass . 아파트 면적은 $2xy+x+y = k$ --&gt; 2k+1 = (2x+1)(2y+1) , $x,y$는 양의 정수 . | 즉, 아파트 면적을 k라 할 때 2k+1은 합성수이다. . | 만약, $2k+1$이 소수라면 잘못된 아파트 면적이다. . | . &#49548;&#49688; &#54032;&#48324; . def Is_prime_number(a): from math import sqrt for i in range(2,int(sqrt(a)+1)): if a%i==0: return True else: return False . from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return False else: return True def apart(n): sum = 0 for i in range(n): x = int(input()) if Is_prime_number(2*x+1) == True: sum +=1 return(sum) N = int(input()) apart(N) . - error: 이렇게 코드를 짜면 N에 어떤 수를 대입해도 if Is_prime_number(2*x+1) == True 부분이 항상 참이여서 sum += 1이 실행된다.(원인불명) . from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return 0 else: return 1 def apart(n): sum = 0 for i in range(n): x = int(input()) if Is_prime_number(2*x+1) == 1: sum += 1 return(sum) N = int(input()) apart(N) . - error: 이렇게 코드를 짜면 N에 어떤 수를 대입해도 if Is_prime_number(2*x+1) == True 부분이 항상 참이여서 sum += 1이 실행된다.(마찬가지로 원인불명) . - 아파트 임대 --&gt; 시간 초과 코드 . import sys from math import sqrt def Is_prime_number(a): for i in range(2, int(sqrt(a))+1): if a % i == 0: return False return True def apart(n): sum = 0 for i in range(n): x = int(sys.stdin.readline()) if Is_prime_number(2*x+1) == 1: sum += 1 return(sum) N = int(input()) apart(N) . 2 . &#49548;&#49688;&#54032;&#51221; &#51032;&#47928;&#51216; . def is_prime_number(x): # 2부터 x의 제곱근까지의 모든 수를 확인하며 for i in range(2, int(sqrt(x)) + 1): # x가 해당 수로 나누어떨어진다면 if x % i == 0: return False # 소수가 아님 return True # 소수임 . - 위에 코드는 문제가 없다.$ ,$ x에 2나 3을 넣어도 잘 작동함. . def is_prime_number(x): # 2부터 x의 제곱근까지의 모든 수를 확인하며 for i in range(2, int(sqrt(x)) + 1): # x가 해당 수로 나누어떨어진다면 if x % i == 0: return False # 소수가 아님 else: return True # 소수임 . - 위에 코드는 문제가 있다. x에 2나 3을 넣으면 return이 없다. . - 아마 2나 3을 넣으면 range(2,1) 이 돼서 그럴 것이다. . &#54028;&#51060;&#50028; &#53076;&#46300; &#49892;&#54665; &#49884;&#44036; &#52769;&#51221; . import time start = time.time() ## 시작 시간 저장 ## --작업 코드-- print(&quot;time :&quot;, time.time() - start) . &#49548;&#49688; &#52286;&#44592;1 . 주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오. | . N = int(input()) def Is_prime_num(x): if x == 1: return False for i in range(2, int(x**0.5) + 1): if x % i == 0: return False return True prime_num = 0 num_list = list(map(int, input().split())) for i in range(N): if Is_prime_num(num_list[i]) == True: prime_num += 1 print(prime_num) . 3 . &#49548;&#49688; &#52286;&#44592;2 . 자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오. . | 만약 N과 M사이에 소수가 없다면 1을 출력하시오. . | . N = int(input()) M = int(input()) def Is_prime_num(x): if x == 1: return False for i in range(2, int(x**0.5)+1): if x % i == 0: return False return True prime_list = [] for j in range(N, M+1): if Is_prime_num(j) == True: prime_list.append(j) if len(prime_list) == 0: print(-1) else: print(sum(prime_list)) print(min(prime_list)) . 620 61 . &#50640;&#46972;&#53664;&#49828;&#53580;&#45348;&#49828;&#51032; &#52404;&#47484; &#53685;&#54620; &#49548;&#49688; &#52286;&#44592;(&#49548;&#49688; &#52286;&#44592;2 &#45796;&#47480; &#54400;&#51060;) . - N과M은 10000이하의 자연수 이므로 미리 에라토스테네스의 체를 통해 소수를 구해놓자 . N = int(input()) M = int(input()) n = 10000 m = int(n**0.5) prime_list = [False, False] + [True] * (n-1) for i in range(2, m+1): if prime_list[i] == True: for j in range(2*i, n+1, i): prime_list[j] = False prime_num_list = [ x for x in range(N, M+1) if prime_list[x] == True] if len(prime_num_list) == 0: print(-1) else: print(sum(prime_num_list)) print(min(prime_num_list)) . 620 61 . if prime_list[i] == True: . - 위 부분은 아래와 같이 해도 됨 . if prime_list[i]: . prime_list[i] 자체가 True or False임 . &#49548;&#51064;&#49688;&#48516;&#54644; . 정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오. | . import sys n = 3164 m = int(n**0.5) prime_nums = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_nums[i] == True: for j in range(2*i, n+1, i): prime_nums[j] = False N = int(input()) M = int(N**0.5) def factorization_into_primes(x): if x == 1: sys.exit(0) stack = 0 mul = 1 for k in range(2, M+1): if prime_nums[k] == False: continue else: l = x/k while l == int(l): print(k) mul *= k stack += 1 l = l/k if stack == 0: print(x) elif mul != N: print(int(x/mul)) . 7 11 13 . &#49548;&#49688; &#44396;&#54616;&#44592; . M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오. | . n = 1000000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False M, N = map(int, input().split()) prime_num = [x for x in range(M, N+1) if prime_num_list[x] == True] for k in range(len(prime_num)): print(prime_num[k]) . 3 5 7 11 13 . &#48288;&#47476;&#53944;&#46993; &#44277;&#51456; . 베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다. . | 예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23) . | 자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오. . | . n = 123456 * 2 m = int(n**0.5) prime_nums = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_nums[i] == True: for j in range(2*i, n+1, i): prime_nums[j] = False def prime_number(num): print(len([x for x in range(num+1, 2*num+1) if prime_nums[x] == True])) while True: n = int(input()) if n == 0: break prime_number(n) . 1 . 4 . 3 . 21 . 135 . 1033 . 8392 . &#44264;&#46300;&#48148;&#55120;&#51032; &#52628;&#52769; . 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다. . | 2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오. . | 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다. . | . - 신기한점 . n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False prime_num = [x for x in range(2, n+1) if prime_num_list[x] == True] ### 여기까지 동일 last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True].reverse() type(last_prime_num) . - 위의 코드에서 type(last_prime_num)의 결과는 Nonetype임 . ### 동일 부분 생략 last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True] last_prime_num.reverse() type(last_prime_num) . - 위의 코드에서 type(last_prime_num)의 결과는 list임 . - 무슨 차이일까? . n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i] == True: for j in range(2*i, n+1, i): prime_num_list[j] = False prime_num = [x for x in range(2, n+1) if prime_num_list[x] == True] last_prime_num = [x for x in range(2, 5000) if prime_num_list[x] == True] last_prime_num.reverse() p = len(prime_num) T = int(input()) for i in range(T): N = int(input()) for j in range(N//2, N+1): if j in prime_num and N - j in prime_num: print(N - j, j) break . 5 7 . - 위의 코드는 시간이 매우 오래 걸리는 쓰레기임 . - 새로 만들었음 . - 시간이 $ frac{1}{4}$ 이 됐다: 2344ms --&gt; 556ms . n = 10000 m = int(n**0.5) prime_num_list = [False, False] + [True]*(n-1) for i in range(2, m+1): if prime_num_list[i]: for j in range(2*i, n+1, i): prime_num_list[j] = False T = int(input()) for i in range(T): N = int(sys.) for j in range(N//2, N+1): if prime_num_list[j] and prime_num_list[N - j]: print(N - j, j) break . 5 7 . - 더 줄이고 싶다 . - 시간이 96ms로 단축됨 . - [$ star star star$] 여러번 반복하여 입력을 받는 경우에는 input() 대신 sys.stdin.readline() 사용 [$ star star star$] . . &#44592;&#48376; &#49688;&#54617;1 (&#49884;&#44036; &#52488;&#44284; &#51452;&#51032;) . &#45804;&#54077;&#51060;&#45716; &#50732;&#46972;&#44032;&#44256; &#49910;&#45796;. . 땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다. . | 달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다. . | 달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오. . | . - 달팽이는 올라가고 싶다 --&gt; 시간 초과 코드(while 반복문 사용) . A, B, V = map(int,input().split()) ### 시간 초과 day = 1 h = 0 while 1: h += A if h &gt;= V: break h -= B day += 1 print(day) . 25 . - 달팽이는 올라가고 싶다 --&gt; 시간 초과 해결한 코드(한 줄 수식) . import math A, B, V = map(int,input().split()) ### 시간 초과 해결 print(math.ceil((V-A)/(A-B))+1) . 25 . &#49552;&#51061;&#48516;&#44592;&#51216; . A는 고정 비용, B는 가변 비용, C는 수익, k는 판매량 . | $C*k &gt; A + B*k$ --&gt; $k &gt; frac{A}{C-B}$ . | . A, B, C = map(int, input().split()) if abs(C-B) &lt; 0.5: ### C == B 여부를 판단 print(-1) elif int(A/(C-B)) &lt; 0: print(-1) else: print(int(A/(C-B)) + 1) . -1 . - 위에 코드보다 더 간결한 코드 . - A에 관계없이 B &gt;= C이면 손익분기점이 없다. . A, B, C = map(int, input().split()) if B &gt;= C: ### C == B 여부를 판단 print(-1) else: print(int(A/(C-B)) + 1) . 11 . Fly me to the Alpha Centauri . 시작할 땐 1만큼 도착할 때도 1만큼 이동 . | k만큼 이동한 후에 k-1 or k or k+1 만큼 이동 가능 . | . - 이동 횟수를 최소화할려면? . - $x지점(출발=0) to{1} to{2} to{3} to dots to{n} to{n-1} to dots to{2} to{1} to{y지점}(도착=0)$ . - $이동 ,거리 = sum_{i=1}^{n}{k} + sum_{i=1}^{n-1}{k} = frac{n(n+1)}{2} + frac{(n-1)n}{2} = n^2$ . - $y-x = n^2$ . - $이동 ,횟수 = 화살표의 ,개수 = n+(n-1)=2n-1$ . - 즉 $n^2$의 거리를 이동하기 위한 최소한의 이동 횟수는 $2n-1$이다. . - 바꿔말하면 $2n-1$번의 이동으로 갈 수 있는 최대 거리는 $n^2$이다. . - 위에 방법에 기반하여 정리를 해봤다. . - 위에서는 이동 거리가 $n^2$에 대해서 고려했다. 하지만 이동 거리가 제곱수가 아닐 수 도 있다. . - 예로 이동 거리가 110이면 이동 횟수는 $ sqrt{100} leq sqrt{110} leq sqrt{121}$ 이므로 10 or 11 or 12이다. . - $n^2 = 1+1+2+2+ dots+(n-1)+(n-1)+n$ 이다. . - 100 과 121의 차이는 21 = 10 + 11 --&gt; 100은 이동 횟수 $2n-1=19$, 101$ sim$110 은 $2n=20$, 111$ sim$121은 $2n+1=21$이다. . T = int(input()) for i in range(T): x, y = map(int, input().split()) n = y - x m = int(n**0.5) if n**0.5 == m: print(2*m - 1) elif n - m**2 &lt;= m: print(2*m) else: print(2*m + 1) . 3 . 3 . 4 . &#49444;&#53461; &#48176;&#45804; . 상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. . | 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다. . | 상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. . | 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 된다. . | 하지만 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다. . | 상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오. . | 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다. . | . - 봉지를 최소화 해야 한다. --&gt; 5kg 봉지를 최대한 많이 써야 한다. . - 설탕의 무게를 5로 나눈다. . - 만약 5로 나눠지면 끝이다. 그러지 않다면 5kg 봉지를 하나씩 줄여나가고 나머지를 3kg 봉지로 담는다. . - 5kg 봉지를 하나씩 줄이다가 0이 됐다면 전부 3kg 봉지를 사용한다. . - 그래도 안된다면 정확하게 Nkg을 만드는 것이 불가능하므로 -1을 출력한다. . N = int(input()) def sugar(n): k = n//5 l = n % 5 if l == 0: return k else: n = n - k*5 if n % 3 ==0: return k + 1 else: n = n - (k-1)*5 if n % 3 ==0: return k - 1 + n//3 else: n = n - (k-2)*5 if n % 3 == 0: return k - 2 + n//3 else: n = n -(k-3)*5 if n % 3 ==0: return k - 3 + n//3 else: ...... if n &lt; 0: return -1 . 이런식으로 전개될 것이다. | . N = int(input()) def sugar(n): k = n // 5 l = n % 5 for i in range(k+1): if l == 0: return k break elif l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 201 . - 코드를 둘러보던 중 위의 코드가 비효율적이라 느껴졌다 . - 왜냐하면 for문에서 if l == 0: 은 처음 한 번 해서 False이면 영원히 False이다 --&gt; else: l += 5 때문 . - 하지만 for문 안에 있어서 k+1번 쓸모없는 행위를 반복해야 한다. . - 그래서 아래와 같이 수정했다 . - 그런데 시간이 64ms 에서 72ms가 됐다??? . N = int(input()) def sugar(n): k = n // 5 l = n % 5 if l == 0: return k for i in range(k+1): if l % 3 == 0: return k + l // 3 break else: l += 5 k -= 1 return -1 print(sugar(N)) . 201 . print &#50752; return &#51032; &#52264;&#51060;(&#44036;&#45800;&#55176;) . - return 은 종료문이다. 함수에서 return을 만나면 함수가 종료된다. . - 그렇기에 return이 여러개여도 하나만 반환된다. . - 여러 값을 반환하고 싶다면 return a,b,c, $ dots$ . - print()는 그렇지 않다. . - 위에 설탕배달 코드에서 return을 print()로 바꾼다면 항상 -1을 출력하지만 . - return이기 때문에 return k or return k + l//3이 실행되지 않을 때만 return -1이 실행된다. . &#48516;&#49688;&#52286;&#44592; . 이와 같이 나열된 분수들을 1/1 -&gt; 1/2 -&gt; 2/1 -&gt; 3/1 -&gt; 2/2 -&gt; … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자. . | X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오. . | . - 분모 + 분자 = n + 1인 분수가 n개 있다. . - 분모 + 분자가 2인 분수가 1개, 3인 분수가 2개, 4인 분수가 3개, $ dots$, n+1인 분수가 n개 . - 분모 + 분자가 $n+1$인 끝점: $1+2+3+ dots+n-2+n-1+n$ . x = int(input()) n = int((x * 2) ** 0.5) k = n * (n + 1) // 2 a = k - x if a &lt; 0: n += 1 k += n a = k - x if n % 2 == 0: print(str(n-a)+&#39;/&#39;+str(1+a)) else: print(str(1+a)+&#39;/&#39;+str(n-a)) . 4 10 4 15 5/1 . &#49688;&#54617;&#51008; &#48708;&#45824;&#47732;&#44053;&#51032;&#51077;&#45768;&#45796;(19532&#48264;) . - 백준은 내부 라이브러리만 사용 가능, numpy는 외부 라이브러리라 사용 불가능 . import numpy as np a, b, c, d, e, f = map(int, input().split()) array1 = np.array([[a, b], [d, e]]) array2 = np.array([c, f]) x, y = np.linalg.inv(array1) @ array2 print(round(x), round(y)) . - 연립 일차 방정식을 행렬을 통해 풀어 보자 . a, b, c, d, e, f = map(int, input().split()) det = a * e - b * d print(round((e * c - f *b ) / det), round((a * f - c * d) / det)) . -1 2 . &#48512;&#45376;&#54924;&#51109;&#51060; &#46112;&#53580;&#50556; . 아파트에 거주를 하려면 조건이 있는데 . | a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다 . | 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다 . | . - a층의 b호 사람 수 = a층의 b-1호 사람 수 + a-1층의 b호 사람 수 . - 기본적으로 생각하면 0층 b호에는 n명이 살고 a층 1호에는 1명이 a층 2호에는 a+2명이 산다. . - 점화식을 알고 있으므로 재귀 함수를 사용했음 . - 호출을 여러 번 해야해서 좋지 않음 . - 시간 초과에 걸림 . def apart(a, b): if a == 0: return b if b == 1: return 1 return apart(a, b - 1) + apart(a - 1, b) T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart(k, n)) . 37442160 . - 이미 구한 층,호수 사람 수는 기록하는 방법 사용(메모이제이션) . - 똑같이 시간 초과 . List = [[0] * 14 for _ in range(15)] List[0] = [x for x in range(1, 15)] for i in range(len(List)): List[i][0] = 1 for j in range(len(List)): List[j][1] = j + 2 def apart(a, b): if List[a][b - 1] != 0: return List[a][b - 1] return apart(a, b - 1) + apart(a - 1, b) T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart(k, n)) . 37442160 . - 난 위의 코드가 메모이제이션인 것 같았다. . - 근데 처음 짠 코드와 다른 게 없었다. 메모이제이션이 아닌 가 보다. . - 수학으로 풀려면 계차수열을 사용해야 하는데 복잡해 보인다. . - 그래서 이번에는 처음부터 아파트를 채워놓고 시작하는 방법을 사용했다. . - 층과 호수를 입력하면 채워진 아파트에서 그 층과 호수에 사는 사람 수를 출력한다. . - 최대 사람수가 사는 14층 14호를 입력하면 첫 번째와 두 번째 코드는 2초 정도 걸렸는데 이 코드는 바로 출력된다. . - 시간 초과 해결 . apart = [[0] * 14 for _ in range(15)] apart[0] = [x for x in range(1, 15)] x = len(apart) for i in range(x): apart[i][0] = 1 for j in range(x): apart[j][1] = j + 2 for i in range(1, x): for j in range(1, x - 1): apart[i][j] = apart[i][j-1] + apart[i - 1][j] T = int(input()) for i in range(T): k = int(input()) n = int(input()) print(apart[k][n - 1]) . 37442160 . . &#44592;&#48376; &#49688;&#54617; 2 -- &#44592;&#54616; . &#53552;&#47131;(&#52280;&#44256;&#54644;&#49436; &#54400;&#50632;&#51020;) . 두 원의 중심과 반지름이 각각 주어졌을 때 교점의 개수를 출력하시오 | . - 두 점에서 만나는 경우 . r1 + r2 &gt; d and abs(r1 - r2) &lt; d . - 두 원의 위치관계 참고 : https://mathbang.net/101 . T = int(input()) for i in range(T): x1, y1, r1, x2, y2, r2 = map(int, input().split()) d = ((x1 - x2)**2 + (y1 - y2)**2)**0.5 if d == 0: if r1 == r2: print(-1) else: print(0) elif r1 + r2 &lt; d: print(0) elif r1 + r2 &gt; d and abs(r1 -r2) &lt; d: print(2) elif r1 + r2 == d: print(1) elif abs(r2 - r1) == d: print(1) elif abs(r2 - r1) &gt; d: print(0) . 2 . 1 . 0 . &#53469;&#49884; &#44592;&#54616;&#54617; . 택시 기하학에서 두 점 $T_1(x_1,y_1)$, $T_2(x_2,y_2)$ 사이의 거리는 다음과 같이 구할 수 있다. . | $D(T_1, T_2) = |x_1 - x_2| + |y_1 - y_2|$ . | 첫째 줄에는 유클리드 기하학에서 반지름이 R인 원의 넓이를, 둘째 줄에는 택시 기하학에서 반지름이 R인 원의 넓이를 출력한다. . | . - 반지름이 $R$일 때 원은 $|x_1 - x_2| + |y_1 - y_2| = R$의 자취임 . - 이를 그려본면 택시 기하학에서 원은 마름모임을 쉽게 알 수 있음 . - 넓이는 $ frac{2R times 2R}{2} = 2R^2$ . import math R = int(input()) π = math.pi print(π*R**2) print(2*R**2) . 1385.4423602330987 882 . . &#51221;&#47148; . &#49688; &#51221;&#47148;&#54616;&#44592; 1 . N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. | . - 선택 정렬 . N = int(input()) List = [] for i in range(N): num = int(input()) List.append(num) n = len(List) for j in range(n): min_idx = j for k in range(j + 1, n): if List[k] &lt; List[min_idx]: min_idx = k List[j], List[min_idx] = List[min_idx], List[j] print(List[j]) . 1 2 3 4 5 . - 내장 함수 ?.sort() . N = int(input()) List = [] for i in range(N): num = int(input()) List.append(num) List.sort() for j in range(len(List)): print(List[j]) . 1 2 3 4 5 . &#49688; &#51221;&#47148;&#54616;&#44592; 2 . N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. | . - 아래의 병합 정렬 코드는 시간초과임 . - 왜냐하면 리스트의 길이가 매우 긴데 재귀 함수를 사용했기 때문 . - 재귀 함수 호출이 매우 많이 일어나서 시간이 오래 걸림 . - 그래서 재귀 함수 없는 코드로 짜봤는데 시간 초과 --&gt; 그냥 파이썬이 느림 . - pop(0)이 문제였음 --&gt; $O(N)$ . - 그래서 pop()를 안쓰고 코드를 구성 . N = int(input()) unsorted_list = [] for i in range(N): unsorted_list.append(int(input())) def merge_sort(x): if len(x) &lt;= 1: return x mid = len(x) // 2 left = x[:mid] right = x[mid:] left1 = merge_sort(left) right1 = merge_sort(right) return merge(left1, right1) def merge(left, right): sorted_list = [] while left and right: if left[0] &lt; right[0]: sorted_list.append(left.pop(0)) else: sorted_list.append(right.pop(0)) while left: sorted_list.append(left.pop(0)) while right: sorted_list.append(right.pop(0)) return sorted_list sort_list = merge_sort(unsorted_list) for i in range(N): print(sort_list[i]) . - python은 시간 초과여서 pypy3로 제출해서 맞춤 . - 위 코드는 pypy3로 제출해도 시간 초과임 . N = int(input()) unsorted_list = [] for i in range(N): unsorted_list.append(int(input())) def mergeSort(x): ## 나누기 n = len(x) if n &lt;= 1: return x mid = n // 2 left = x[:mid] ## mid를 기준으로 왼쪽 right = x[mid:] ## mid를 기준으로 오른쪽 next_left = mergeSort(left) ## 재귀적으로 나누기 next_right = mergeSort(right) ## 재귀적으로 나누기 return merge(next_left, next_right) def merge(left, right): ## 병합하기 i = 0 j = 0 sorted_list = list() while i &lt; len(left) and j &lt; len(right): ## left와 right중 더 작은 값 넣기 if left[i] &lt; right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 ## left와 right 중 남은 값을 넣어주기 while i &lt; len(left): sorted_list.append(left[i]) i += 1 while j &lt; len(right): sorted_list.append(right[j]) j += 1 return sorted_list sort_list = mergeSort(unsorted_list) for i in range(N): print(sort_list[i]) . 1 2 3 4 5 . &#49688; &#51221;&#47148;&#54616;&#44592; 3 . N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오. . | N은 최대 10000000, 10000보다 작거나 같은 자연수 . | 수 정렬하기 2와 다르게 메모리 제한이 있다. . | . - 수 정렬하기 2에서 사용했던 코드는 메모리 제한에 걸림 . - 힌트를 보고 생각했음 . - 그런데 생각해보면 메모리가 8MB 이다 . - N이 최대 10000000이면 short형(2byte, c언어)를 쓰더라도 20000000byte로 20MB이다 --&gt; 메모리 초과 . - 근데 N이 10000000이라고 하면 적어도 어느 자연수 하나는 1000번 이상 등장함(비둘기집 원리) . - 그러면 1~10000까지 번호를 새긴 깡통을 만들어두고 input으로 등장한 숫자와 같은 번호의 깡통에 투표를 하는 매커니즘으로 생각하면 어떨까 . - [0]*10001인 리스트를 만듦. 등장한 숫자가 i라면 list의 i번째 요소의 값을 1씩 증가시킴 . - 최종적으로 리스트의 처음 인덱스부터 끝까지 value만큼 출력한다 . - 10000000크기의 list를 만드는 대신에 10000크기의 list를 만듦 --&gt; 메모리 소비 줄임 . - input() 대신 sys.stdin.readline() 사용, 근데 왜 나는 sys.stdin.readline()가 error가 날까... --&gt; 그래서 사용을 안하는 버릇생김 . - Test는 input()으로 해도 제출은 sys.stdin.readline()로 하는 습관 가지기 . 이 코드는 메모리 초과임 | . - arr[i] = 0이어도 뒤에 for문을 실행한다 . - arr[i] = 0이면 pass 하도록 아래와 같이 코드를 바꿨다 . import sys arr = [0] * 10001 N = int(input()) for i in range(N): arr[int(sys.stdin.readline())] += 1 for i in range(1, 10001): for j in range(arr[i]): print(i) . 1 2 4 5 5 . - 문제를 보니 카운팅 정렬로 해결하는 문제였다 --&gt; 카운팅 정렬 공부해야지 . &#53685;&#44228;&#54617; . 수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자. . | 산술평균 : N개의 수들의 합을 N으로 나눈 값 . | 중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값 . | 최빈값 : N개의 수들 중 가장 많이 나타나는 값 . | 범위 : N개의 수들 중 최댓값과 최솟값의 차이 . | N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오. . | . - 이 코드는 잘못된 코드임. while문에서 빠져나오지 못함 . - 처음에는 while문만 보다가 while문은 이상한점이 없어서 처음부터 다시 봤음 . - 처음에 입력을 받는 부분이 잘못됨. 양수와 음수를 구별하는 if-else코드가 for문안에 들어가야 한다 . - 그렇지 않으면 입력을 받아 저장하는 x가 counting되지 않음 . - 또 문제가 있음 while문에서 k+1을 쓰면 무한loop에 빠지고 4001을 써야함(이유는 자고 일어나서..) . - 이유를 찾았다 . for k in range(neg_nums[i]): val_sum -= i . - for문에 변수로 k를 사용해서 k값이 4000에서 다른값으로 변한 것 --&gt; 변수명 안겹치게 하기 . - 또 문제가 있다 . - 중앙값이 제대로 출력되지 않음. 입력으로 1, 3, 8, -2, 2를 주어졌을 때 중앙값으로 8이 출력됨 . - while문에서 num &lt; mid일 때만 수행하라고 했는데 왜지?? num이 mid보다 커져도 for문이 계속 작동하여 median = 8을 store함 . - 이유를 알고보니까 이런 거임. 내가 일을 시키는 입장인데 내가 주는 업무를 수행하는데 12시간 넘으면 쉬라고 명령함 . - 근데 업무로 일 40시간 하기를 시킴.. . - while문에서는 num &lt; mid이면 탈출하라고 했음. True일 동안 for i in range(4001)을 수행해야 함 . - 근데 시킨 업무가 range(4001)여서 i가 0 부터 4000이 될동안 num도 mid보다 커지지만 일단 시킨 업무가 for i in range(4001)이라 멈출 수 없고 다 끝낸 뒤 num &gt;= min여서 while문 탈출 . - 또 문제가 있음... . - 파이썬 round()를 하면 대부분 잘 작동함 근데 -1.5, -3.5같이 -?.5 (?은 홀수)의 경우에 제대로 값을 반환하지 않음 . - 또 2.5, 4.5 같이 ?.5(?은 짝수)의 경우 제대로 값을 반환하지 않음 . - -1.5를 반올림하면 -1이 맞지만 round(-1.5)는 -2를 return한다. 또 2.5를 반올림하면 2가 맞지만 round(2.5)는 2를 return한다 . - 파이썬에서는 반올림 자리가 5인 경우, 앞자리가 홀수면 올림, 짝수면 버림을 한다. 이를 고려해주어야 한다 . - 진짜 마지막으로 에러가 하나 있었다 . - 범위를 구하는 곳에서 오류가 있었는데 입력으로 0, 0, 0, -1, -2 가 주어지면 2가 출력되야 하지만 1이 출력됐다 . - 왜냐하면 양수로 0이 입력됐지만 max_pos = 0이기 때문 . - 그래서 양수는 입력되지 않았다고 판단하여 -1 - (-2) = 1을 범위로 output함 . N = int(input()) k = 4000 pos_nums = [0] * (k+1) neg_nums = [0] * (k+1) for _ in range(N): x = int(input()) if x &gt;= 0: pos_nums[x] += 1 else: neg_nums[-x] += 1 val_sum = 0 min_pos = 0 max_neg = 0 max_pos = 0 min_neg = 0 for i in range(k+1): if pos_nums[i] != 0: max_pos = i if min_pos == 0: min_pos += i for j in range(pos_nums[i]): val_sum += i for i in range(k+1): if neg_nums[i] != 0: min_neg = -i if max_neg == 0: max_neg -= i for k in range(neg_nums[i]): val_sum -= i mean = val_sum / N num_pos = sum(pos_nums) num_neg = sum(neg_nums) mid = (N + 1) // 2 num = 0 if num_pos &gt;= num_neg: mid -= num_neg while num &lt; mid: for i in range(k+1): if pos_nums[i] != 0: for j in range(pos_nums[i]): num += 1 median = i else: mid -= num_pos while num &lt; mid: for i in range(k+1): if neg_nums[i] != 0: for j in range(neg_nums[i]): num += 1 median = -i range_ = 0 if max_pos != 0 and min_neg != 0: range_ = max_pos - min_neg elif max_pos == 0: range_ = max_neg - min_neg elif min_neg == 0: range_ = max_pos - min_pos mode = [] freq = max(pos_nums + neg_nums) for i in range(k+1): if pos_nums[i] == freq: mode.append(i) if neg_nums[i] == freq: mode.append(-i) if mode: mode.remove(min(mode)) mode_ = min(mode) else: mode_ = min(mode) print(mean) print(median) print(mode) print(range_) . - 위에서 잘못된 부분을 디버깅한 코드 . - 디버깅은 print()를 사용했는데 나중에 이에 대해 다뤄보자 . - 시간 초과 --&gt; input() 말고 sys.stdin.readline()써야함 . - 입력구문을 바꾸니 맞았다 . - 디버깅하느라 힘들었음 . N = int(input()) k = 4000 pos_nums = [0] * (k+1) neg_nums = [0] * (k+1) for _ in range(N): x = int(input()) if x &gt;= 0: pos_nums[x] += 1 else: neg_nums[-x] += 1 val_sum = 0 min_pos = [] max_neg = 0 max_pos = 0 min_neg = 0 for i in range(k+1): if pos_nums[i] != 0: max_pos = i if len(min_pos) &lt; 1: min_pos.append(i) for j in range(pos_nums[i]): val_sum += i for i in range(1, k+1): if neg_nums[i] != 0: min_neg = -i if max_neg == 0: max_neg -= i for m in range(neg_nums[i]): val_sum -= i ## 산술평균 def round2(number): if number &gt;= 0: if number - int(number) &gt;= 0.5: a = 1 else: a = 0 return int(number) + a else: if int(number) - number &gt; 0.5: a = -1 else: a = 0 return int(number) + a mean = round2(val_sum / N) ## 중앙값 num_pos = sum(pos_nums) num_neg = sum(neg_nums) mid = (N + 1) // 2 num = 0 if num_pos &gt;= num_neg: mid -= num_neg for i in range(k+1): if pos_nums[i] != 0: for j in range(pos_nums[i]): num += 1 median = i if num &gt;= mid: break else: mid -= num_pos for i in range(k+1): if neg_nums[i] != 0: for j in range(neg_nums[i]): num += 1 median = -i if num &gt;= mid: break ## 범위 range_ = 0 if min_pos and min_neg != 0: range_ = max_pos - min_neg elif len(min_pos) &lt; 1: range_ = max_neg - min_neg elif min_neg == 0: range_ = max_pos - min_pos[0] ## 최빈값 mode = [] freq = max(pos_nums + neg_nums) for i in range(4001): if pos_nums[i] == freq: mode.append(i) if neg_nums[i] == freq: mode.append(-i) if len(mode) &gt; 1: mode.remove(min(mode)) mode_ = min(mode) else: mode_ = min(mode) print(mean) print(median) print(mode_) print(range_) . 2 2 1 10 . . &#44536;&#47532;&#46356; &#50508;&#44256;&#47532;&#51608; . &#46041;&#51204; 0 . 준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다. . | 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. . | 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오. . | 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수) . | . N , K = map(int, input().split()) coins = [] for i in range(N): coins.append(int(input())) num = [K] for j in range(N - 1): val = coins[j+1] / coins[j] replace = num[j] // val num[j] -= replace * val num.append(replace) print(int(sum(num))) . 12 . &#51075;&#50612;&#48260;&#47536; &#44292;&#54840; . 세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들고 난 후 괄호를 모두 지웠다. . | 그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다. . | . - 한번만 minus 기호가 나오면 그 뒤에 수는 모두 빼기로 만들 수 있음 . - 50 - 70 + 80 + 90 --&gt; 50 - (70 + 80 + 90) . - join(), split(), replace(), map() 함수 사용 . string = str(input()) s1 = string.split(&#39;-&#39;) s2 = s1[0] s2 = s2.split(&#39;+&#39;) s2 = list(map(int, s2)) s3 = s1[1:] if len(s3) &gt; 0: s3 = &#39;-&#39;.join(s3) s3 = s3.replace(&#39;-&#39;, &#39;+&#39;) s3 = s3.split(&#39;+&#39;) s3 = list(map(int, s3)) print(sum(s2) - sum(s3)) else: print(sum(s2)) . 0 . ATM . 문제 출처: 백준 11399번 . | 인하은행에는 ATM이 1대밖에 없다. . | 줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 $P_i$가 주어졌다. . | 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오. . | . - times를 sort()함수를 통해 오름차순으로 정렬 . - 최소값 $=$ 첫 번째 원소 $ times$ N $+$ 두 번째 원소 $ times$ (N-1) $+ dots +$ 마지막 원소 $ times$ 1 . N = int(input()) times = list(map(int, input().split())) times.sort() print(sum([times[i] * (N - i) for i in range(N)])) . 32 . &#51452;&#50976;&#49548; . 설명이 길어서 링크를 남긴다. . | 문제 출처: 백준 13305번](https://www.acmicpc.net/problem/13305 . | . - 현재 주유소 가격보다 더 싼 주유소가 있는 곳 까지의 거리만큼만 구매하여 더 싼 주유소까지 감 . - 정확히는 현재 주유소 가격보다 더 싼 주유소 중 가장 거리가 가까운 주유소 . - 더 싼 주유소 까지 갔으면 그 주유소보다 더 싼 주유소가 있는 곳 까지의 거리만큼만 구매하여 더 싼 주유소까지 감 . - 만약 더 싼 곳이 없으면 목표지점까지 남은 거리 만큼 기름을 구매 . - 이를 도착할 때 까지 반복함 . - 백준 문제 예시를 보자 . 기름 가격이 현재 5원 보다 더 싼 곳은 2원이므로 5원에서 2원까지 거리인 2km를 갈 수 있을 정도만 기름을 구매함(2L 구매) . | 현재 2원 보다 더 싼 곳은 1원이므로 2원에서 1원까지 거리인 4km를 갈 수 있을 정도만 기름을 구매함(4L 구매) . | 목표 지점에 도착했으므로 끝 . | N = int(input()) lengths = list(map(int, input().split())) oils = list(map(int, input().split())) idx = 0 costs = 0 for i in range(1, len(oils)): if oils[i] &lt;= oils[idx]: costs += oils[idx] * lengths[i - 1] idx = i else: costs += oils[idx] * lengths[i - 1] print(costs) . 10 . - 아래는 더 간결한 코드(중복 부분 제거) . N = int(input()) lengths = list(map(int, input().split())) oils = list(map(int, input().split())) idx = 0 costs = 0 for i in range(1, len(oils)): costs += oils[idx] * lengths[i - 1] if oils[i] &lt;= oils[idx]: idx = i print(costs) . 10 . &#51452;&#50976;&#49548; &#47928;&#51228; &#46356;&#48260;&#44613; . - 아래는 잘못된 코드임 . N = int(input()) lengths = list(map(int, input().split())) oils = list(map(int, input().split())) idx = 0 costs = 0 for i in range(1, len(oils)): if oils[i] &lt;= oils[idx]: costs += oils[idx] * lengths[idx] idx = i else: costs += oils[idx] * lengths[i - 1] print(costs) . - 아래 코드가 잘못됨 . costs += oils[idx] * lengths[idx] . - 아래 코드로 수정해야함 . lengths[idx] --&gt; lengths[i - 1] . - 디버깅 하면서 느낀점 : 다양한 상황을 고려하고 [$ star$]종이에 쓰면서[$ star$] 어떻게 흘러가는지 분석하자 . &#54924;&#51032;&#49892; &#48176;&#51221; . 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. . | 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. . | 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. . | 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다. . | . - 가장 빨리 끝나는 회의를 배정하는 것이 best임, 시작 시간과 종료 시간이 같은 것이 있을 수 있으므로 종료 시간이 같다면 먼저 시작하는 것을 앞에 배정함 . - 그 회의를 마치고 다음 회의를 고를 때 마찬가지로 가장 빨리 끝나는 회의를 배정함 . - 이를 반복하면 된다 . - [1, 1]과 [0, 1]이 있다면 [0, 1]을 배정하고 [1, 1]을 해야한다. 순서를 바꾸면 1개가 최대임 . - 처음에는 종료 시간만 고려해서 틀림 --&gt; 디버깅을 합시다 . - 그래서 생각한 것이 &quot;아!, 시작 시간과 종료 시간 간격이 짧은 것이 더 좋겠지([5, 8]보단 [6, 8]더 좋을 거야)&quot;라고 했음 . - 그래서 종료 시간 기준으로 오름차순 정렬한 후 시작 시간 기준으로 내림차순 정렬을 했다. 하지만 위에서 다룬 [1, 1]과 [0, 1]의 상황에 의해 틀림 . - 종료 시간기준으로 오름차순 정렬한 후 이를 시작 시간 기준으로 오름차순 정렬해야 함 --&gt; 맞았습니다 . meeting_time = [] N = int(input()) for i in range(N): meeting_time.append(list(map(int, input().split()))) meeting_num = 1 meeting_time.sort(key = lambda finish_time: (finish_time[1], finish_time[0])) ## 종료 시간을 기준으로 오름차순 정렬한 것을 시작 시간을 기준으로 오름차순 정렬 fir_meeting = meeting_time[0] for i in range(1, N): if meeting_time[i][0] &gt;= fir_meeting[1]: meeting_num += 1 fir_meeting = meeting_time[i] print(meeting_num) . 4 . . &#51221;&#49688;&#47200; &#48143; &#51312;&#54633;&#47200; . &#51060;&#54637; &#44228;&#49688; 2 . 자연수 N과 정수 K가 주어졌을 때 이항 계수 $ binom{N}{K}$를 10,007로 나눈 나머지를 구하는 프로그램을 작성하시오. | . - $ _{n} rm C_{k} ;= ; _{n-1} rm C_{k-1} ;+ ;_{n-1} rm C_{k}$ . - n명 중 k명을 선택하는 방법 = 일단 나를 k명에 포함하고 나머지 n-1명 중 k-1명을 선택하는 방법 + 나를 k명에서 제외하고 나머지 n-1명 중 k명을 선택하는 방법 . - 메모이제이션 활용 . - 아래 코드는 수를 곱하고 나누고 하는 과정에서 오차가 발생함(이유 알 것 같음) . N, K = map(int, input().split()) if K &gt; N - K: K = N - K def binom(n, k): frac = 1 if k == 0: return frac for i in range(k): frac *= (n - i) frac /= (k - i) return frac print(binom(N, K)) . 270288240945436736896419468186285475891156693372573153808127299354545159392842888344379470775469423606583114895222426893312341135200171386904964166401328583914403638232447354301148995510201690344719626632436541851159067180652764129719441081806265387434048424366211327146525860903129335008845962936320 . - 아래코드는 메모이제이션으로 구현했다 . - 계산해보면 알겠지만 $_{1000} rm C_{500}$은 매우$ times 100$ 큰 수이다. 300자리임 . - 그래서 $_{1000} rm C_{500}$를 계산할 때 위와같이 구하면 곱하고 나누는 과정에서 소수점 오차가 발생하고 이는 결과적으로 밑의 코드와 다른 값을 출력하게 된다 . - 메모이제이션을 안 쓴 코드와 쓴 코드로 구한 $_{1000} rm C_{500}$ 값을 비교하면 다른 것을 알 수 있다 . - 아래 코드는 오류 발생(만약 위의 코드가 오차없이 답을 구한다면 똑같이 오류 발생) --&gt; 재귀 깊이에 관한 오류 . - 백준에서 정한 파이썬 재귀 깊이는 1000이다. 즉, 같은 함수를 1000번 이상 호출하면 오류가 난다 . - 그래서 오류가 나지 않으려면 재귀 깊이를 sys.setrecursionlimit()를 통해 바꾸던가 해야함 . - 오류가 발생한 이유를 알았으니 아래 코드를 다시 수정함 . import sys sys.setrecursionlimit(10**6) N, K = map(int, input().split()) if K &gt; N - K: K = N - K binom_list = [[-1] * 501 for _ in range(1001)] def binom(n, k): if binom_list[n][k] != -1: return binom_list[n][k] elif n &lt; k: return 0 elif k == 0: return 1 elif n == 1: return 1 binom_list[n][k] = binom(n-1, k) + binom(n-1, k-1) return binom_list[n][k] print(binom(N, K)) . 270288240945436569515614693625975275496152008446548287007392875106625428705522193898612483924502370165362606085021546104802209750050679917549894219699518475423665484263751733356162464079737887344364574161119497604571044985756287880514600994219426752366915856603136862602484428109296905863799821216320 . - 사실 재귀함수를 사용하지 않고 첫 번째 코드를 수정하는 것으로도 정답을 맞출 수 있다 . - 문제는 /(나누기) 이다 / 대신 //(몫 구하기)를 사용하면 해결된다 . - /(나누기 연산자)는 큰 값을 계산할 때 오차에 취약하다 . - 그래서 // 를 쓰는 것이 좋다. 물론 /와 // 결과가 같을 때 ex) 10 / 2 = 10 // 2 . - 밑의 코드 결과는 메모이제이션을 사용한 코드와 같은 것을 알 수 있다 . N, K = map(int, input().split()) if K &gt; N - K: K = N - K def binom(n, k): frac = 1 for i in range(k): frac *= (n - i) for i in range(k): frac //= (k - i) return frac print(binom(N, K)) . 270288240945436569515614693625975275496152008446548287007392875106625428705522193898612483924502370165362606085021546104802209750050679917549894219699518475423665484263751733356162464079737887344364574161119497604571044985756287880514600994219426752366915856603136862602484428109296905863799821216320 . . &#46041;&#51201; &#44228;&#54925;&#48277; . &#54588;&#48372;&#45208;&#52824; &#54632;&#49688; . 문제가 길어서 출처를 남김: 백준 피보나치 함수 문제 | . - 직접 0과 1이 몇번 출력되는지 계산해도 된다 . - 근데 규칙을 보면 출력되는 횟수의 합이 피보나치 수열을 따름 . - 그리고 0이 출력되는 횟수가 1이 출력되는 횟수보다 1이 더 작다 (fibo(3) 이상 부터) . - fibo(1) = 5이므로 0은 5 // 2 번 1은 5 - 5 // 2번 출력됨 . T = int(input()) def fibo(n): fir_fibo = 0 sec_fibo = 1 for i in range(n): next_fibo = fir_fibo + sec_fibo fir_fibo = sec_fibo sec_fibo = next_fibo return next_fibo for i in range(T): N = int(input()) if N == 0: print(1, 0) elif N == 1: print(0, 1) elif N &gt; 1: fibo_N = fibo(N) print(fibo_N // 2, fibo_N - (fibo_N // 2)) . - 위의 코드는 틀렸다 . - 계산해보니 0출력 횟수와 1출력 횟수 차이는 1이 아니었음 . - fibo(5)의 경우 0은 3번, 1은 5번 출력함 . - fibo(n)일 떄 0은 fibo(n-1)번 1은 fibo(n)번 출력함 (n &gt; 1) . T = int(input()) def fibo(n): if n &lt;= 1: return n fir_fibo = 0 sec_fibo = 1 for i in range(n-1): next_fibo = fir_fibo + sec_fibo fir_fibo = sec_fibo sec_fibo = next_fibo return next_fibo for i in range(T): N = int(input()) if N == 0: print(1, 0) elif N == 1: print(0, 1) elif N &gt; 1: print(fibo(N-1), fibo(N)) . 1 0 . 0 1 . 1 2 . &#49888;&#45208;&#45716; &#54632;&#49688; &#49892;&#54665; . 문제 출처: 백준 9184번 | . w_dict = {(0,0,0):1} def w(a, b, c): if (a, b, c) in w_dict: return w_dict[(a, b, c)] if a &lt;= 0 or b &lt;= 0 or c &lt;= 0: return 1 elif a &gt; 20 or b &gt; 20 or c &gt; 20: return w(20, 20, 20) elif a &lt; b and b &lt; c: w_dict[(a, b, c)] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c) else: w_dict[(a, b, c)] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1) return w_dict[(a, b, c)] while True: A, B, C = map(int, input().split()) if A == B == C == -1: break print(&#39;w(%s, %s, %s) = %s&#39; % (A, B, C, w(A, B, C))) . w(1, 1, 1) = 2 . w(2, 2, 2) = 4 . w(10, 4, 6) = 523 . w(50, 50, 50) = 1048576 . w(-1, 7, 18) = 1 . &#54028;&#46020;&#48152; &#49688;&#50676; . 문제 출처: 백준 9461번 | . - 점화식: $f(n) = f(n-2)+f(n-3)$ . padoban_sequence_dict = {1:1, 2:1, 3:1} def padoban_sequence(n): if n in padoban_sequence_dict: return padoban_sequence_dict[n] padoban_sequence_dict[n] = padoban_sequence(n-3) + padoban_sequence(n-2) return padoban_sequence_dict[n] T = int(input()) for _ in range(T): N = int(input()) print(padoban_sequence(N)) . 3 . 16 . 01&#53440;&#51068; . 문제 출처: 백준 1904번 | . - 점화식 노가다로 구했음 --&gt; 만약 노가다로 찾을 수 없는 문제를 해결해야 한다면... . - 피보나치 수열의 점화식과 동일함 . - 점화식: $f(n) = f(n-1) + f(n-2)$ . 이 코드는 재귀함수를 사용해 top-down으로 구현함 | . - RecursionError 발생 --&gt; 재귀 깊이 초과 . - 그래서 재귀 깊이를 크게 하려고 했는데 조건을 보니 N이 최대 $10^6$ 이다 . - 그래서 그냥 bottom-up방식으로 코드를 짜기로 함 . - 재귀 깊이를 크게 했더니 --&gt; 시간 초과 . top-down 코드 | . tile_dict = {1:1, 2:2} def tile(n): if n in tile_dict: return tile_dict[n] tile_dict[n] = tile(n-1) + tile(n-2) return tile_dict[n] N = int(input()) print((tile(N) % 15746)) . 5 . bottom-up 코드 | . - 메모리 초과 --&gt; 왜? 이유 모름 . N = int(input()) x = 10**6 tile_list = [1, 1, 2] + [0]*(x-2) for i in range(3, N+1): tile_list[i] = tile_list[i-1] + tile_list[i-2] print((tile_list[N] % 15746)) . 5 . - 그래서 다른 방법으로 코드 구현했음 . - 시간 초과(0.75초) --&gt; 왜? . N = int(input()) if N &lt;= 2: print(N) else: fir = 1 sec = 2 for i in range(N-2): next_ = fir + sec fir = sec sec = next_ print(next_ % 15746) . 5 . - 참고: https://m.blog.naver.com/hankrah/221863365092 . - map()함수 사용 . - 메모리 초과 --&gt; append() 때문인 듯 . N = int(input()) def fibonacci(n): fibo = [1, 2] [*map(lambda _: fibo.append(sum(fibo[-2:])), range(2, n))] ## tuple unpacking return fibo[n-1] print(fibonacci(N) % 15746) . 5 . - 아래 코드는 정답임 . - 일단 재귀 함수로 구현한 top-down방식은 시간이 오래걸린다 . - 그러므로 bottom-up 방식을 사용했다 . - 근데 메모리초과가 발생했다 --&gt; 이유가 뭐지?? . - 처음엔 몰랐는데 생각해보니 나는 숫자를 다 계산한 다음에 15746으로 나눈 나머지를 구했다 . - N = 1000000 이라면 백만번째 피보나치 항의 값을 구하는 것인데 수가 얼마나 크나면 겁나 큼 --&gt; 수가 너무 커서 메모리 터짐 . - 그래서 N 번째 피보나치 수열을 구한 뒤에 15746으로 나누지 않고 15746으로 나눈 값들을 더해나갔다 --&gt; 이게 왜 성립함?? . - 편의를 위해 15746대신 7000을 쓰자 . - 다음은 피보나치 수열의 점화식과 같은 형태임 . - 10000 + 20000 = 30000, 20000 + 30000 = 50000 . - 일단 최종 결과인 50000을 7000으로 나눈 나머지는 1000 이다 . - 30000을 7000으로 나눈 나머지는 2000이다. 그러면 20000 + 30000 에서 30000 대신 2000을 써도 식이 성립할까? . - 20000 + 2000 = 22000, 22000을 7000으로 나눈 나머지는 1000 이다 --&gt; 식이 성립함 . - 왜 성립하냐면 50000을 7000으로 나눌 것인데 50000을 20000과 30000으로 쪼갤 수 있음 . - (20000 + 30000) % 7000은 20000을 7000으로 나눈 나머지와 30000을 7000으로 나눈 나머지를 더한 것임 --&gt; 근데 더한 값이 7000보다 클 수 도 있으니 더한 값을 7000으로 또 나눠준다 . - 동그란 케잌으로 생각하자 한 번에 7000만큼의 케잌을 조각내어 퍼갈 수 있음(피자 8등분 하듯이 50000중에 7000만큼 조각 케잌 모양으로 퍼감) . - 케잌크기가 50000이라면 7번 퍼가면 1000이 남는다 . - 근데 50000을 20000과 30000으로 나눈뒤에(50000만 크기의 동그란 케잌을 각각 20000, 30000크기인 반원형 케잌으로 cut) 20000에서 7000만큼 퍼가고 30000에서 7000만큼 퍼가도 된다 . - 20000에서 퍼가고 남은 케잌 조각과 30000에서 퍼가고 남은 케잌 조각을 합쳐서 다시 케잌을 만들고 이 케잌에서 7000을 퍼가면 결과적으로 50000에서 7000을 퍼간것과 동일함 . N = int(input()) x = 10**6 tile_list = [0]*(x+1) tile_list[1] = 1 tile_list[2] = 2 for i in range(3, N+1): tile_list[i] = (tile_list[i-1] + tile_list[i-2]) % 15746 print(tile_list[N]) . 5 . RGB&#44144;&#47532; . 문제 출처: 백준 1149번 | . - N = 10이라면 10개를 최소 비용으로 칠하는 방법은 9개까지 칠하는 방법이 여러개 있음(일단 $dp[9]$라고 하자) + 10번째 칠하는 방법은 3가지 . - $dp[9]+P_{10}$의 최소값이 $dp[10]$이 된다 . - 일반화하면 $min(dp[i-1]+P_i) = dp[i]$ --&gt; 아닌듯 . - 위의 논리는 그리디 알고리즘이다. 항상 최소가 되는 비용을 선택하면 전체적으로도 비용이 최소가 되기를 바라는 것이다 --&gt; 하지만 틀렸다 . - $dp[10]$은 10개까지 색칠하는 여러 방법 =&gt; $min(dp[10]+P_{11}) to dp[11]$ . - $dp[11]$은 최소값 -&gt; 100원이라 하자, 다음으로 싼게 110원 . - $dp[11]+P_{12} to dp[12]$ 이미 $dp[11]$이 최소값 --&gt; 100원을 골라서 $dp[12]$는 200원임 다른건 뭐냐? 1원이 있고 1000원, 근데 1원은 이미 고른 색이어서 못 고름 . - $dp[12]$는 200이 아니라 111원임 $dp[11]$이 최소지만 $dp[12]$는 최소가 아니었음 . - 그럼 남음 방법 뭐임?? . - $dp[11]$을 최소값으로 골랐지만 $dp[12]$가 최소가 아닌 이유는 중복되는 색깔을 선택하지 못하기 때문 . - 그러면 $dp[11]$을 전체의 최소값으로 선택하지 말고 색깔마다 최소값을 고르자 --&gt; 11번째 색이 각각 (빨,초,파)인 경우에 최소값을 구하자 --&gt; 총 3가지가 존재함 . - 이제 $dp[12]$는 어떻게 구하냐면 $dp[11]$과 $P_{12}$의 조합이 총 6가지 존재 . - 6개 중에서 12번째 색이 빨, 파, 초가 존재하는데 각각 2개씩 있다 --&gt; 각각 2개 중에서 더 적은 비용을 고른다 . - 그러면 이제 12번째 색이 빨, 파, 초 일때의 전체 비용의 최소값이 존재 --&gt; $dp[12]$는 색깔별로 존재하니까 총 3개 . - 위와 같은 논리로 마지막 N번째까지 최소비용으로 선택하면 된다 . 처음 짠 코드 | . - 이상한 값을 출력함 . - $dp[i+1][0]$의 의미는 i번째 색깔로 0을 선택했다는 의미임 --&gt; 즉 house_prices[i][0] 이어야함 . - 근데 house_prices가 0이 아니라 $dp[i]$의 값을 0으로 선택했음 --&gt; $dp[i][0]$ 이라면 $dp[i+1]$은 1 or 2이다. 0이 아님 . - 틀렸습니다 . N = int(input()) house_prices = [] for _ in range(N): house_prices.append(list(map(int, input().split()))) dp = [[0]*3 for _ in range(1001)] dp[1] = house_prices[0] for i in range(1, N): dp[i+1][0] = min(dp[i][0] + house_prices[i][1], dp[i][0] + house_prices[i][2]) dp[i+1][1] = min(dp[i][1] + house_prices[i][0], dp[i][1] + house_prices[i][2]) dp[i+1][2] = min(dp[i][2] + house_prices[i][0], dp[i][2] + house_prices[i][1]) print(min(dp[N])) . 102 . 디버깅한 코드 | . - 맞았습니다 . N = int(input()) house_prices = [] for _ in range(N): house_prices.append(list(map(int, input().split()))) dp = [[0]*3 for _ in range(1001)] dp[1] = house_prices[0] for i in range(1, N): dp[i+1][0] = min(dp[i][1] + house_prices[i][0], dp[i][2] + house_prices[i][0]) dp[i+1][1] = min(dp[i][0] + house_prices[i][1], dp[i][2] + house_prices[i][1]) dp[i+1][2] = min(dp[i][0] + house_prices[i][2], dp[i][1] + house_prices[i][2]) print(min(dp[N])) . 96 . &#51221;&#49688; &#49340;&#44033;&#54805; . 문제 출처: 백준 1932번 | . - 위의 RGB 문제와 같은 매커니즘이다 . - 그리디 알고리즘으로 접근하면 주어진 조건하에 항상 최대값을 골라야 하지만 항상 최대값을 고른다고 전체가 최대가 되는 것이 아니다(선택에 제약이 있기 때문: 인접한 곳만 선택 가능) . - 현재 n층 i번째에 위치하고 있다면 n+1층으로 내려갈 때 n+1층의 i번째 or i+1번째만 선택 가능 . - N = 4일 때 $dp[4]$는 무엇일까? . - 4층은 칸이 4개가 존재 --&gt; 이를 인덱스로 생각하면 0~3 . - 그러면 4층의 0번째, 4층의 1번째, 4층의 2번째, 4층의 3번째까지 가는 방법이 각각 여러개가 있을 것이다(대각선상에 존재하는 경우는 1개) . - 그러면 각각 그 중에서 최대값을 선택함 --&gt; 4층의 0번째까지 가는 방법 중 최대값, 4층의 1번째까지 가는 방법 중 최대값 ... --&gt; 총 4개 존재함: 인덱스가 4개 이므로 . - 그 4가지 방법 중 최대값이 4층까지 가는 방법 중 가장 큰 값이다 . N = int(input()) triangle = [] for _ in range(N): triangle.append(list(map(int, input().split()))) dp = [[0]*x for x in range(1,501)] dp[0][0] = triangle[0][0] ## 0층 꼭짓점 ## 1층은 왼쪽 대각선과 오른쪽 대각선만 존재하고 대각선 사이에는 데이터가 없어서 따로 처리했음 if N &gt; 1: dp[1][0] = triangle[1][0] + dp[0][0] ## 왼쪽 대각선 dp[1][1] = triangle[1][1] + dp[0][0] ## 오른쪽 대각선 for i in range(1, N-1): for k in range(1, i+1): dp[i+1][0] = dp[i][0] + triangle[i+1][0] ## 왼쪽 대각선 dp[i+1][k] = max(dp[i][k-1]+triangle[i+1][k] , dp[i][k]+triangle[i+1][k]) ## 대각선 사이 dp[i+1][i+1] = dp[i][i] + triangle[i+1][i+1] ## 오른쪽 대각선 print(max(dp[N-1])) . 30 . - 재채점 되어서 확인했더니 틀렸습니다 &gt; N = 1일 때를 고려하지 않아 indexerror 발생 . - N = 1일 때를 고려하도록 수정했음 &gt; 맞았습니다 . &#44228;&#45800; &#50724;&#47476;&#44592; . 문제 출처: 백준 2579번 | . - 계단은 최대 300개, 칸 마다 점수는 10000이하의 자연수 . - 도착 지점은 무조건 밟아야 한다 . - 그래서 출발 지점부터 시작하지말고 도착 지점부터 시작한다고 생각했음 . - $dp[i]$ --&gt; 마지막으로 밟은 지점이 step의 i번째 인덱스일 때 점수가 최대가 되도록 하는 경로 . - $dp[i] = max(step[i] + dp[i-2] , step[i] + dp[i-1])$ --&gt; 아닌듯, 연속해서 3번 밟을 수 없음. $step[i] + dp[i-2]$는 상관없지만 $step[i] + dp[i-1]$는 상관있음 . - $dp[i] = max(step[i] + step[i-1] + dp[i-3]) , max(step[i] + step[i-2] + dp[i-3])$ . - i번째 계단을 밟는데 i-1번째 계단과 i-2번째 계단을 밟았는지 밟지않았는지가 중요하다 . - 만약 i-1번째와 i-2번째 계단을 둘다 밟았다면 i번째 계단을 밟을 수 없다 . - 만약 i-1번째나 i-2번째 계단 중 한 곳만 밟았다면 i번째 계단을 밟을 수 있다 . - 만약 i-1번째나 i-2번째 계단을 둘다 밟지 않았으면 i번째 계단을 밟을 수 없다 . - 하나하나씩 써보자 . - $dp[0]$ = 도착 지점의 점수 . - $dp[1] = step[1]$ (0번쨰 계단 안밟음) , $step[1] + dp[0]$ (0번째 계단 밟음) . - $dp[2] = step[2] + dp[0]$ (1번쨰 계단 안밟음, 0번째 계단 밟음), $step[2] + dp[1] (= step[1])$ (1번째 계단 밟음, 0번째 계단 안밟음) . - $dp[3] = step[3] + dp[2] (= step[2] + dp[0])$ (2번쨰 계단 밟음, 1번째 계단 안밟음), $step[3] + dp[1] (= step[3] + dp[1] = max(step[1], step[1] + dp[0])$ (2번쨰 계단 안밟음, 1번째 계단 밟음) . - 위에 틀린 부분이 있음, 규칙상 0번째 계단(도착 지점)은 무조건 밟아야 하는데 $dp[1](= step[1])$, $dp[2](= step[2] + step[1])$ 은 0번째 계단을 밟지 않았으므로 제외해야 함 . N = int(input()) step = [] for _ in range(N): step.append(int(input())) step.reverse() ## 도착부터 시작할거임 --&gt; 미로찾기할 때 출발부터 시작안하고 도착부터 시작하듯이 dp = [[0] * 2 for _ in range(300)] ## dp[i][0] =&gt; i-1번째를 밟고 i-2번째를 안밟음, dp[i][1] =&gt; i-1번째를 안밟고 i-2번째를 밟음 dp[0][0] = step[0] dp[0][1] = step[0] if N &gt;= 2: dp[1][0] = step[1] + step[0] dp[1][1] = -(3*10**6) ## 0번째 계단은 무조건 밟아야 하는데 dp[1][1]은 0번째 계단을 안 밟음 --&gt; 그래서 의도적으로 dp[1][1]을 경유하면 절대로 최대값이 나오지 안도록 값을 조정함 if N &gt;= 3: dp[2][0] = -(3*10**6) ## dp[1][1]과 마찬가지임 dp[2][1] = step[2] + step[0] for i in range(3, N): dp[i][0] = step[i] + dp[i-1][1] dp[i][1] = step[i] + max(dp[i-2][0], dp[i-2][1]) print(max(dp[N-1][0], dp[N-1][1], dp[N-2][0], dp[N-2][1])) ## 출발지점을 밟는 길과 밟지 않는 길 중에서 점수 획득이 가장 높은 것을 선택 . 75 . 1&#47196; &#47564;&#46308;&#44592; . 문제 출처: 백준 1463번 | . - 일단 내 생각: 3으로 나누는 것이 수를 1로 만드는데 가장 효과적이라 생각했음 . - 그래서 일단 3으로 나눈다 --&gt; 만약 3으로 나눠지지 않는다면?? . - 만약 1을 뺀 값이 3으로 나눠지면 1을 뺀다 --&gt; 그렇지 않다면 2로 나눈다 --&gt; 만약 2로도 나눠지지 않는다면? . - 1을 뺀다 . - 만약 2의 거듭제곱수이면 2로만 나누기 . - 틀렸습니다 . num = N = int(input()) numbers = [0]*(1+10**6) power_of_2 = {} i = 2 j = 1 while i &lt; 10**6: power_of_2[i] = j j += 1 i *= 2 while True: if num &lt; 2: break if num in power_of_2: numbers[1] = numbers[num] + power_of_2[num] break if num % 3 == 0: now_num = num // 3 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif (num-1) % 3 == 0: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif num % 2 == 0: now_num = num // 2 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue else: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num if num &lt; 2: break print(numbers[1]) . - 만약 number가 소인수로 2와 3만을 가지는 시점이 온다면? . - $number = 2^a cdot 3^b$ . - 1까지 만드려면 2로 a번 나누고 3으로 b번 나누면 됨 --&gt; a+b번 필요함 . - 그냥 모든 경우를 고려한다면? . - N이 주어지면 N을 3으로 나누고 2로 나누고 1을 뺀다 . - 각각에 대해서 또 다시 3으로 나누고 2로 나누고 1을 뺀다 . - 이를 1이 될 때까지 반복 . - 음... 어떻게 함? 재귀로? . - 디버깅 중... . - 근데 위와 같이 하면 $N = 10^6$일 때 연산횟수가 커서 시간초과가 발생할 것 같음 . ## 시간초과 ## N = int(input()) numbers = [0]*(1+10**6) def divide3(x): if x == 1: return numbers[1] if x % 3 == 0: if numbers[x // 3] == 0: numbers[x // 3] += (numbers[x] + 1) else: numbers[x // 3] = min(numbers[x] + 1, numbers[x // 3]) x //= 3 divide3(x) if x % 2 == 0: divide2(x) sub1(x) def divide2(y): if y == 1: return numbers[1] if y % 2 == 0: if numbers[y // 2] == 0: numbers[y // 2] += (numbers[y] + 1) else: numbers[y // 2] = min(numbers[y] + 1, numbers[y // 2]) y //= 2 divide2(y) if y % 3 == 0: divide3(y) sub1(y) def sub1(z): if z == 1: return numbers[1] if z &gt; 1: if numbers[z-1] == 0: numbers[z-1] += (numbers[z] + 1) else: numbers[z-1] = min(numbers[z] + 1, numbers[z-1]) z -= 1 if z % 3 == 0: divide3(z) if z % 2 == 0: divide2(z) sub1(z) divide3(N) divide2(N) sub1(N) print(numbers[1]) . - 굳이 1을 빼야할까? . - 2나 3으로 나눠지지 않을 때만 1을 빼는 것이 좋을 것 같음 . - 하지만 10에 경우 위와 같이 하면 10 - 5 - 4 - 2 - 1 . - 정답은 10 - 9 - 3 - 1 . - 만약 1을 뺀 값이 $2^a cdot 3^b$ 꼴이라면 1을 빼자 . 이것도 틀리면 질문검색 볼거임 | . - 5%에서 틀렸습니다.... . num = N = int(input()) numbers = [0]*(1+10**6) mul_2_3 = {} power_of_2 = {} i = 2 j = 1 while i &lt; 10**6: power_of_2[i] = j j += 1 i *= 2 power_of_3 = {} i = 3 j = 1 while i &lt; 10**6: power_of_3[i] = j j += 1 i *= 3 for i in range(1,13): for j in range(1,20): if list(power_of_3.keys())[i-1] * list(power_of_2.keys())[j-1] &lt; 10**6: mul_2_3[list(power_of_3.keys())[i-1] * list(power_of_2.keys())[j-1]] = i+j mul_2_3.update(power_of_2) mul_2_3.update(power_of_3) while True: if num &lt; 2: break if num in mul_2_3: numbers[1] = numbers[num] + mul_2_3[num] break if num % 3 == 0: now_num = num // 3 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif (num-1) in mul_2_3: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue elif num % 2 == 0: now_num = num // 2 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num continue else: now_num = num - 1 if numbers[now_num] == 0: numbers[now_num] += 1 + numbers[num] elif numbers[now_num] &gt; 0: numbers[now_num] = min(numbers[num] + 1, numbers[now_num]) num = now_num if num &lt; 2: break print(numbers[1]) . - 질문검색 보고 옴 &gt; 모든 경우를 탐색해 보자 . - 맞았습니다!!! . - 위에서는 어렵게 생각했는지 모든 경우를 탐색하는 코드를 각각의 경우에 대해서 설계했는데 밑에서는 i의 값을 1씩 줄여나가면서 3가지 경우에 대해 탐색하도록 코드를 구성했음 . i = N = int(input()) dp = [0]*(1+10**6) while i &gt; 1: if i % 3 == 0: if dp[i // 3] == 0: dp[i // 3] += (1 + dp[i]) else: dp[i // 3] = min(dp[i] + 1, dp[i // 3]) if i % 2 == 0: if dp[i // 2] == 0: dp[i // 2] += (1 + dp[i]) else: dp[i // 2] = min(dp[i] + 1, dp[i // 2]) if dp[i-1] == 0: dp[i-1] += (1 + dp[i]) else: dp[i-1] = min(dp[i] + 1, dp[i-1]) i -= 1 print(dp[1]) . 4 . &#49772;&#50868; &#44228;&#45800; &#49688; . 문제 출처: 백준10844번 | . - N = 1일 때 9, N = 2일 때 17 . - N = 3일 때 32이었음(내가 손수 구함) . - 다음과 같은 규칙이 바로 생각났음 &gt; $dp[i+1] = 2 times dp[i] - 2^{i-1}$ . - 위 규칙에 따르면 N = 4일 때 60인데 손수 구할 용기가 안나서 검증없이 바로 코드로 구현함 . - ^^ 틀렸습니다 . - i가 어느 정도 커지면 음수가 된다 . - 규칙을 바꿔봄 &gt; $dp[i+1] = 2 times dp[i] - i$ . - 일단 위의 규칙은 음수가 될 일은 절대 없음 . - 위 규칙에 따르면 N = 4일 때 61인데 손수 구할 용기가 안나서 검증없이 바로 코드로 구현함 . - 틀렸습니다 ^^ . - 이제 N = 4일 때 dp를 구해보자 &gt; 손수 구해보니 N = 4일 때 61임 !!!! &gt; 규칙이 틀렸나? . - 일단 직관적으로 생각하면 $dp[i] = 2^{i-1}*9$ . - 왜냐하면 옆 자릿수와 차이가 1이여야 하므로 +1 or -1임 즉 2가지 경우이므로 2를 계속 곱하고 숫자가 1~9까지 9개이므로 9를 곱합 . - 하지만 9에 경우 -1은 가능하지만 +1은 없음 또 0에 경우 +1은 가능하지만 -1은 존재하지 않는다 &gt; 차이만큼 빼줘야함 . - 위에 기반하면 N = 1: 9 - 0, N = 2: 18 - 1, N = 3: 36 - 4, N = 4: 72 - 11 &gt; 규칙이 보이지 않음 . - 그리고 또 2자리는 1자리에 기반하여 만들고 3자리는 2자리에 기반하여 만듦 ex) 23 --&gt; 232 or 234, 232 --&gt; 2321 or 2323 . - N = 5일 때 118인지 확인할까? . N = int(input()) dp = [0]*101 dp[1] = 9 for i in range(1, 100): dp[i+1] = (2*dp[i] - i) % 1000000000 print(dp[N]) . - 질문검색 보고옴 . - 코드 대충 봐보니 i-1번째에 기반하여 i번째를 만드는 것 같았음 . - 끝자리가 0이나 9인 경우에는 다음 자리에 올 수 있는 숫자가 1개 뿐이므로 이를 고려하여 코드를 구성하자 . - 아니면 끝자리가 0~9 까지 10개이므로 배열을 10칸으로 만들자 . - $dp[i][j]$의 의미는 자릿수가 i인데 끝자리가 j인 경우임 . N = int(input()) dp = [[0]*10 for _ in range(101)] for k in range(1, 10): dp[1][k] = 1 for i in range(1, 100): for j in range(10): if j == 0: dp[i+1][j] = dp[i][j+1] % 1000000000 elif j == 9: dp[i+1][j] = dp[i][j-1] % 1000000000 else: dp[i+1][j] = (dp[i][j+1] + dp[i][j-1]) % 1000000000 print(sum(dp[N]) % 1000000000) . 116 . - 흐음 질문검색에서 아이디어를 가져온거라 정답을 맞춘게 맞춘게 아님 . - 옛날이었으면 풀었을 듯... 요새 안하다보니 감이 떨어짐 . &#54252;&#46020;&#51452; &#49884;&#49885; . 문제 출처: 백준 2156번 | . - 문제를 보자마자 전에 풀었던 계단오르기와 유사하다고 생각이 들었음 . - $dp[i]$는 두 종류가 있음 &gt; i-1번째 와인을 마신 경우와 i-1번째 와인을 마시지 않은 경우 &gt; 두 경우 중 최대값이 $dp[i]$임 . - $dp[i][1] = wines[i] + dp[i-1][0]$ . - $dp[i][0] = max(wines[i] + dp[i-2][0], wines[i] + dp[i-2][1], wines[i] + dp[i-3][1])$ . - $dp[i][0]$은 i-1번째 와인을 마시지 않은 경우 . - $dp[i][1]$는 i-1번째 와인을 마신 경우 . N = int(input()) dp = [[0] * 2 for __ in range(10001)] wines = [0] for _ in range(N): wine = int(input()) wines.append(wine) dp[1][0] = wines[1] dp[1][1] = wines[1] + wines[0] if N &gt; 1: dp[2][0] = wines[2] dp[2][1] = wines[2] + wines[1] for i in range(3, N+1): dp[i][0] = max(wines[i] + dp[i-2][0], wines[i] + dp[i-2][1], wines[i] + dp[i-3][1]) dp[i][1] = wines[i] + dp[i-1][0] print(max(dp[N][0], dp[N][1], dp[N-1][1])) . 33 . &#44032;&#51109; &#44596; &#51613;&#44032;&#54616;&#45716; &#48512;&#48516; &#49688;&#50676; . 문제 출처: 백준 11053번 | . - 모르겠다 공부 ㄱㄱ . - 공부하고 왔음 . - 수열A: 10, 20, 30, 11, 12, 13, 14, 40, 15, 16 이런 수열이 있다고 해보자 . - 위에서 다룬 수열을 A라고 해보자 . - A[6] = 13, dp[6] = 4이다. dp[6] = 4라는 뜻은 A[6]이 마지막 원소이고 만약 수열A가 A[5]까지만 존재했다면 가장 긴 증가하는 부분 수열의 길이는 3이라는 의미이다 . - A[6]을 추가하는데 되도록이면 증가하는 부분 수열의 길이가 크면 좋음 &gt; A[6]이 마지막 원소가 될 수 있는 여러개의 증가하는 부분 수열 중에서 길이가 가장 긴 것에 A[6]을 추가해야 함 . - 즉 dp[1]에서 dp[5]중에서 가장 큰 값에다 A[6]을 추가하여 새로운 dp[6]을 만듦 &gt; dp[i]는 i번째 인덱스 값을 수열의 마지막 원소로 가지는 증가하는 부분 수열 중 가장 길이가 긴 것 . - 가장 긴 증가하는 부분 수열 점화식: $dp[n] = max(dp[i], dp[j], dots, dp[k]) + 1, quad (A[n] &gt; A[i], A[j], dots,A[k]])$ . N = int(input()) dp = [0] * 1001 data = list(map(int, input().split())) arr = [0] + data for i in range(1, N+1): for j in range(i): if arr[i] &gt; arr[j]: dp[i] = max(dp[j] + 1, dp[i]) print(max(dp)) . 5 . &#44032;&#51109; &#44596; &#48148;&#51060;&#53664;&#45769; &#48512;&#48516; &#49688;&#50676; . 문제 출처: 백준 11054번 | . - 질문 검색에서 아이디어 참고함 . - 증가하는 부분 수열 + 감소하는 부분 수열 - 1(겹치는 부분)의 최댓값을 구하자 . - dp_up[n]은 n를 마지막 원소로 가지는 증가하는 부분 수열 중 길이가 가장 긴 것 . - dp_down[n]은 n를 첫번째 원소로 가지는 감소하는 부분 수열 중 길이가 가장 긴 것 . N = int(input()) dp_up = [0] * 1001 dp_down = [1] * 1001 data = list(map(int, input().split())) arr = [0] + data ## 가징 긴 바이토닉 부분 수열 for i in range(1, N+1): for j in range(i): if arr[i] &gt; arr[j]: dp_up[i] = max(dp_up[j] + 1, dp_up[i]) for i in range(N, 0, -1): for j in range(N, i, -1): if arr[i] &gt; arr[j]: dp_down[i] = max(dp_down[j] + 1, dp_down[i]) print(max(list(map(lambda x, y: x+y, dp_up, dp_down)))-1) . 7 . - 위에서 사용한 lambda 함수 간단히 참고 . a = [1, 2, 3, 4, 5] b = [10, 1 ,2, 3, 4] print(max(list(map(lambda x, y: x+y, a, b)))-1) . 10 . - 서로 동일한 index위치에 있는 값을 더한 후 최대값 - 1을 출력 . - 리스트 길이가 다르다면? . a = [1, 2, 3, 4, 5] b = [1 ,2, 10] print(max(list(map(lambda x, y: x+y, a, b)))-1) . 12 . - b는 길이가 3이어서 a의 4와 5 원소는 고려되지 않음 . &#51204;&#44611;&#51460; . 문제 출처: 백준 2565번 | . - A와 B는 연결되어 있으므로 세트임 . - 우선 A, B에 대해 오름차순 정렬을 함(A, B 순서 바뀌어도 ok) &gt; 전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨지므로 . - dp[n]은 n번째 전깃줄이 마지막에 위치하는 LIS임 . - n번째의 전깃줄은 n-1번째 전깃줄에 대해 A, B 각각 숫자가 커야함 . - dp 최대값을 구한 후 N에서 빼면 제거해야 할 전깃줄의 개수임 . N = int(input()) arr = [[0, 0]] dp = [0] * 101 for _ in range(N): arr.append(list(map(int, input().split()))) arr1 = sorted(arr, key = lambda x: (x[0], x[1])) for i in range(1, N+1): for j in range(i): if arr1[i][0] &gt; arr1[j][0] and arr1[i][1]&gt; arr1[j][1]: dp[i] = max(dp[j] + 1, dp[i]) print(N - max(dp)) . 3 . &#54588;&#48372;&#45208;&#52824; &#49688; 2 . 문제 출처: 백준 2748번 | . - n은 90보다 작거나 같은 자연수 . N = int(input()) first_fibo = 0 second_fibo = 1 for i in range(N): next_fibo = first_fibo + second_fibo first_fibo = second_fibo second_fibo = next_fibo print(first_fibo) . 55 . &#54588;&#48372;&#45208;&#52824; &#49688; 3 . 문제 출처: 백준 2749번 | . - n은 1,000,000,000,000,000,000보다 작거나 같은 자연수 . - 아래와 같은 bottom-up 방식은 시간초과임 . N = int(input()) first_fibo = 0 second_fibo = 1 for i in range(N): next_fibo = (first_fibo + second_fibo) % 1000000 first_fibo = second_fibo % 1000000 second_fibo = next_fibo % 1000000 print(first_fibo) . 228875 . - 곰곰이 생각해보니 n이 최대 100경이라 for문 써도 컴퓨터 터지고 배열로 만들어도 컴퓨터 터짐 . - 피보나치 수열의 일반항이 생각나서 검색해봄 . - 근데 n이 너무 커서 overflow 때문에 불가능 . - 위의 방법을 사용하지 않으면 어떻게 푸는지 모르겠어서 질문 검색을 보니 피사노 주기 를 이용하여 푼다고 한다 . - 참고: 피보나치 수를 구하는 여러가지 방법 . - 아무튼 그래서 피사노 주기를 통해서 문제를 해결함 . N = int(input()) m = 10**6 P = 15 * (10**5) M = N % P fibo = {0:0, 1:1} for i in range(M): fibo[i+2] = (fibo[i] % m + fibo[i+1] % m) % m print(fibo[M]) . 228875 . &#54588;&#48372;&#45208;&#52824; &#49688; 4 . 문제 출처: 백준 10826번 | . - n은 10000보다 작거나 같은 자연수 . N = int(input()) dp = [0] * 10001 dp[1] = 1 for i in range(N-1): dp[i+2] = dp[i] + dp[i+1] print(dp[N]) . 55 . LCS . 문제 출처: 백준 9251번 | . &#50672;&#49549;&#54633; . 문제 출처: 백준 1912번 | . &#54217;&#48276;&#54620; &#48176;&#45229; . 문제 출처: 백준 12865번 | .",
            "url": "https://gkswotn12345.github.io/green/python/algorithm/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "relUrl": "/python/algorithm/2021/06/23/%EB%B0%B1%EC%A4%80.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "파이썬 딥러닝",
            "content": "&#53584;&#49436;&#54540;&#47196; . 무지성 코드(예제 그대로 복붙 손으로) | . import tensorflow as tf W = tf.Variable(tf.ones(shape=(2,2)), name = &quot;W&quot;) b = tf.Variable(tf.zeros(shape=(2)), name = &quot;b&quot;) @tf.function def model(x): return W * x + b out_a = model([1,0]) print(out_a) . tf.Tensor( [[1. 0.] [1. 0.]], shape=(2, 2), dtype=float32) . &#52488;&#54217;&#47732;(&#44036;&#45800;&#55176;) . - 평면의 단면은 직선, 부피의 단면은 평면, 그 이상은??? . - 직선($ax + by + c = 0$)은 2차원의 초평면, 평면($ax + by + cz + d = 0$)은 3차원의 초평면 . - $a_1x_1 + a_2x_2 + a_3x_3 + a_4x_4 + c = 0$ 는 뭐라고 불러야 돼??? --&gt; 4차원 공간에 그려짐 . - 평면을 일반화하여 초평면을 만듦 . - n차원의 그려진 초평면 --&gt; n-1차원 공간 . - 초평면은 공간을 분할하는 역할 --&gt; 직선은 평면을 분할, 평면은 공간을 분할 . - [$ ast$] n차원의 초평면은 n차원을 분할 [$ ast$] . &#54140;&#49481;&#53944;&#47200; .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/23/%EB%94%A5%EB%9F%AC%EB%8B%9D.html",
            "relUrl": "/python/2021/06/23/%EB%94%A5%EB%9F%AC%EB%8B%9D.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "map 함수",
            "content": "map &#54632;&#49688; &#53945;&#51669; . - 여러 개의 데이터를 한 번에 다른 형태로 변화하기 위해 사용한다. . - map 함수는 원본 리스트를 변경하지 않고 새 리스트를 생성한다. . - map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환해야 한다. . - map 함수는 리스트의 요소를 지정된 함수로 처리한다. . x=list(range(5)) x . [0, 1, 2, 3, 4] . def two_times(x): return x*2 . y=two_times(x) y . [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] . z=list(map(two_times, x)) z . [0, 2, 4, 6, 8] . map &#54632;&#49688; &#49324;&#50857;&#48277; . - map(함수, 반복가능한 객체) . x = [1.1, 2.1, 3.1, 4.1] y = map(int, x) print(y) . &lt;map object at 0x0000023B6D93D040&gt; . - map 함수는 map 타입으로 결과를 리턴하기 때문에 리스트나 튜플 등으로 변환한다. $ rightarrow [ star$] 변환하지 않으면 위와 같은 결과를 출력한다. [$ star$] . - print(y)하지 않고 그냥 y만 입력해도 된다. . x = [1.1, 2.1, 3.1, 4.1] y = list(map(int, x)) y . [1, 2, 3, 4] . def minus(a): return a - 0.1 . list(map(minus, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . - minus 함수는 map 함수를 위해 한 번 쓰고 버려질 운명이다. 만드는게 귀찮음... . map &#54632;&#49688;&#50640; &#46988;&#45796; &#49885; &#49324;&#50857; . x = [1.1, 2.1, 3.1, 4.1] list(map(lambda a: a - 0.1, x)) . [1.0, 2.0, 3.0, 3.9999999999999996] . input().split()&#44284; map . - input()함수는 c언어의 scanf()함수와 비슷하다. . z = input() . z . &#39;hello&#39; . - input()으로 입력받은 값은 문자열이다. . n = input() . type(n) . str . - input()함수에서 안내문구를 추가할 수 도 있다. . Q = input(&#39;숫자 하나를 입력하세요:&#39;) . Q . &#39;26&#39; . - input()함수의 출력값을 문자열이 아닌 다른 자료형으로 바꾸고 싶다면? . w = int(input(&#39;숫자 하나를 입력하세요:&#39;)) . type(w) . int . - input().split(&quot;기준문자열&quot;)을 사용하면 입력값을 변수 여러 개에 저장할 수 있다. . - split()에서 &quot;기준문자열&quot;이 없는 즉 default는 공백이다. . a, b = input().split() # 입력받은 값을 공백(스페이스, 탭, 엔터 등)을 기준으로 분리 . a, b . (&#39;10&#39;, &#39;20&#39;) . c = a, b type(c) . tuple . - a와b가 문자열이다. . - int형으로 바꾸고 싶다면? . a, b = int(input().split()) . TypeError Traceback (most recent call last) &lt;ipython-input-17-0de5d52cb787&gt; in &lt;module&gt; -&gt; 1 a, b = int(input().split()) TypeError: int() argument must be a string, a bytes-like object or a number, not &#39;list&#39; . - int()함수를 쓰면 될 것 같았는데 오류가 나온다 . - error메시지를 읽어보니 int()함수는 무조건 a string, a bytes-like object or a number 여야 한다.(not &#39;list&#39;) . - a, b는 tuple인 것 같다. . - 그러면 어떻게 하지? $ longrightarrow$ map()함수를 쓰면 된다. . a, b = map(int, input().split()) # 입력받은 값을 정수로 변환 . a, b . (10, 20) . type(a) . int . type(b) . int . - a, b = map(int, input().split())을 풀어서 쓰면 다음과 같은 코드이다. . x = input().split() # input().split()의 결과는 문자열 리스트 m = map(int, x) # 리스트의 요소를 int형으로 변환, 결과는 맵 객체 a, b = m # 맵 객체는 변수 여러 개에 저장 가능 . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#54620; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . L = list(map(int, input().split())) L . [10, 8, 7, 1, 0, 3, 5, 2] . map()&#54632;&#49688; &#51060;&#50857;&#54644; &#50668;&#47084; &#51460;&#50640; &#50668;&#47084; &#44050; &#51077;&#47141; &#48155;&#44592; . data = [] N = int(input()) for i in range(N): data.append(list(map(int, input().split()))) . data . [[1, 4, 0, 2], [17, 8, 1, 0, 4, 6], [1, 0], [0, 4, 5], [0, 0, 10]] .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "relUrl": "/python/2021/06/21/map%ED%95%A8%EC%88%98.html",
            "date": " • Jun 21, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "파이썬 기말시험",
            "content": "import pandas as pd import numpy as np class nexon(): &#39;&#39;&#39; 202016248 통계학과 한재수 파이썬 기말시험 1번 문제에 대한 코드 &#39;&#39;&#39; def __init__(self): self.upgradestate = pd.DataFrame({&#39;day0&#39;:[0]*100}) self.prob = 0.3 self.i = 1 def attempt(self): self.attemptresult = np.random.binomial(n=1, p=self.prob, size=100) def update(self): self.upgradestate[&#39;day%s&#39; % self.i] = np.minimum(self.upgradestate[&#39;day%s&#39; % (self.i-1)] + self.attemptresult, 5) ## +5이후로는 증가하지 않는다 self.ratio = sum(self.upgradestate.loc[:,&#39;day%s&#39; % self.i] == 5) / 100 . #1-(1) test1=nexon() for test1.i in range(1,63): test1.attempt() test1.update() 100*test1.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다 . 100.0 . class nexon2(nexon): &#39;&#39;&#39; 202016248 통계학과 한재수 파이썬 기말시험 2번 문제에 대한 코드 &#39;&#39;&#39; def __init__(self): nexon.__init__(self) self.prob = 0.7 self.failstate = pd.DataFrame({&#39;day0&#39;:[0]*100}) def update(self): nexon.update(self) self.failstate[&#39;day%s&#39; % self.i] = self.failstate[&#39;day%s&#39; % (self.i-1)] + (self.attemptresult==0)*1 for j in range(100): if self.upgradestate.iloc[j,self.i] == 0: self.failstate.iloc[j,self.i] = self.failstate.iloc[j,self.i]-1 ## i-1번째 + 강화시도(0 or 1) = i번째 ## i,i-1번째 강화상태가 0이라는 의미는 i-1째에 시도한 강화가 실패했다는 의미. ## upgradestate가 0이라는 의미는 실패했다는 것이므로 실패횟수가 하나 쌓인다. ## +0에서는 실패횟수가 쌓이지 않으므로 failstate값을 하나 뺀다. if (self.upgradestate.iloc[j,self.i] == 5) and (self.attemptresult[j] == 0): ## i-1번째 + 강화시도(0 or 1) = i번째 ## i번째가 +5강화이면서 i-1번째 시도한 강화가 실패라는 의미는 ## i-1번째가 +5강화였다는 의미이다. 그러므로 i번째 실패횟수가 +1 됐을것이다. ## +5강화에서는 강화를 도전하지 않을 것이다. ## 그러므로 i번째 실패횟수를 1을 감소시킨다. self.failstate.iloc[j,self.i] = self.failstate.iloc[j,self.i]-1 ## +5에서는 강화를 시도하지 않을것이므로 ## 만약 실패했다면 failstate값을 하나 뺀다. def reset(self): for j in range(100): if (self.upgradestate.iloc[j,self.i] &gt;0) and (self.upgradestate.iloc[j,self.i] &lt; 5): if self.failstate.iloc[j,self.i] == 2: self.failstate.iloc[j,self.i] = 0 self.upgradestate.iloc[j,self.i] = 0 ## 실패스택이 2라면 실패스택을 0으로 바꾸고 강화상태를 +0으로 바꾼다 def arrangeprobt(self): if self.ratio &gt;= 0.5: self.prob = 0.9 ## +5강 비율이 50%이상이라면 전체유저의 강화 성공확률을 90%로 바꾼다. . #2-(1) test2=nexon2() for test2.i in range(1,63): test2.attempt() test2.update() test2.reset() 100*test2.ratio ## 62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . #2-(2) test3=nexon2() for test3.i in range(1,32): test3.attempt() test3.update() test3.reset() 100*test3.ratio ## 31일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 99명이였다. . 99.0 . #2-(3) test4=nexon2() for test4.i in range(1,63): test4.attempt() test4.update() test4.reset() test4.arrangeprobt() 100*test4.ratio ## 과반수가 +5강화 일때 성공확률을 0.9로 바꾼다,62일후 100명중 몇명이 +5강화 상태인가? ## 시뮬레이션 결과 100명이였다. . 100.0 . - 다음문장을 잘 읽고 참 거짓을 판단하여라. (10점) . (1) tuple은 원소의 값을 임의로 바꿀 수 있다.=&gt; &#39;거짓&#39; . (2) class 에 정의된 함수(=메서드)는 self 만을 인자로 받을수 있다.=&gt; &#39;거짓&#39; .",
            "url": "https://gkswotn12345.github.io/green/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "relUrl": "/python/2021/06/18/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EC%8B%9C%ED%97%98.html",
            "date": " • Jun 18, 2021"
        }
        
    
  
    
        ,"post20": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://gkswotn12345.github.io/green/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post21": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://gkswotn12345.github.io/green/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "수상 . - 1학년 2학기 때 장학금 10만원… . 학점 . - 1학년 1학기: 4.38 . - 1학년 2학기: 4.50 . - 2학년 1학기: 4.00(희망), 4.42(현실)? . 프로그래밍 언어 . - R . - 파이썬 . - 잘하고 싶다… . 자격증 . - 있을까? . 토익 . - 할거임 . 대외활동 . - 해야지 . 봉사활동 . - .. .",
          "url": "https://gkswotn12345.github.io/green/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://gkswotn12345.github.io/green/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}